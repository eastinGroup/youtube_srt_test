WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.069 --> 00:00:11.290
是的，我是Martin BC。我在雅典基金会工作，我从事研究工作，我是

00:00:11.290 --> 00:00:15.969
我正在徘徊在雅典虚拟机上做很多工作

00:00:15.969 --> 00:00:22.570
我今天要在github上谈论很多想法，因为它们

00:00:22.570 --> 00:00:29.439
没订购，确实是部分订购了，好吧，那会是什么样

00:00:29.439 --> 00:00:33.730
想要在星际操作系统中拥有一名员工

00:00:33.730 --> 00:00:40.809
你知道文件系统，我的意思是为什么不这样做，这也与

00:00:40.809 --> 00:00:45.429
我正在做的工作，是的，我认为这真的很酷，所以让我们从嗯开始

00:00:45.429 --> 00:00:50.589
这是我们今天所处的位置，是的，就像我们可以知道安装ipfs

00:00:50.589 --> 00:00:57.129
哈希um，我们可以在根目录下，我们可以将CD插入任何哈希，

00:00:57.129 --> 00:01:01.379
然后下面是所有文件，这很酷

00:01:01.620 --> 00:01:08.020
所以下一步显然是为我安装的二进制文件运行二进制文件

00:01:08.020 --> 00:01:14.320
文件夹，因此我应该能够将我的bin目录添加到CD中，

00:01:14.320 --> 00:01:18.939
哈希并运行一个程序，现在还不能正常工作，我想也许

00:01:18.939 --> 00:01:23.770
由于限制，这是一个保险丝，但您实际上无法编写程序

00:01:23.770 --> 00:01:32.020
可执行文件，但您知道我敢肯定这只是一个细节，所以接下来

00:01:32.020 --> 00:01:37.659
我们希望能够做的是写入文件，就我而言，我们还无法做到这一点

00:01:37.659 --> 00:01:42.820
知道也许我不知道你们都明白了，但是写作要多一点

00:01:42.820 --> 00:01:47.649
如此复杂-但对于操作系统而言，这非常重要

00:01:47.649 --> 00:01:56.170
能够写入文件，但与IPF的方式不太匹配

00:01:56.170 --> 00:02:00.009
当前无法挂载文件，因此您可以挂载根目录

00:02:00.009 --> 00:02:05.200
激情目录，然后是所有其他文件，因此，如果您更改了

00:02:05.200 --> 00:02:09.340
文件，并且当目录显然在生成新的根哈希时，因此

00:02:09.340 --> 00:02:14.380
该哈希在哪里进行，因此拓扑必须略有不同

00:02:14.380 --> 00:02:20.540
所以也许一种方法是挂载单个文件或单个文件

00:02:20.540 --> 00:02:26.600
散列，例如，也许我可以将散列完全装载到我的音乐文件夹中

00:02:26.600 --> 00:02:32.330
那将包含我所有的音乐，并且我可以将其CD下载

00:02:32.330 --> 00:02:37.430
一些音乐，但我们仍然有一个新的哈希，那里有一个新的根

00:02:37.430 --> 00:02:46.160
更改时的流行方式，因此我们需要您了解UNIX和Linux具有的一些实用程序

00:02:46.160 --> 00:02:52.250
您知道工作目录实际上是在您的shell中实现的lisatime，它是

00:02:52.250 --> 00:02:57.050
不一定实现为用户空间程序，但始终是基于

00:02:57.050 --> 00:03:01.910
您知道POSIX C函数会获得当前工作目录或存在

00:03:01.910 --> 00:03:07.750
目录，因此理想情况下，我们可能会使用诸如打印工作哈希之类的东西

00:03:07.750 --> 00:03:14.330
您知道要获取当前rip哈希的工作目录哈希，并且需要

00:03:14.330 --> 00:03:19.850
是某种类似于POSIX C函数的东西，我们可以在其中构建

00:03:19.850 --> 00:03:25.660
用户空间程序现在就可以执行此操作，而不必为q s-

00:03:25.660 --> 00:03:32.720
函数，它可能是RPC调用之类的东西，但我们需要在其中

00:03:32.720 --> 00:03:38.600
我们可以像我想的那样构建用户空间工具，我们也应该能够

00:03:38.600 --> 00:03:43.580
对IP和s做同样的事情，例如，如果我挂载IP和s目录，这是

00:03:43.580 --> 00:03:48.650
我认为这真的很酷，就像如果我只有一个公共密钥就可以挂载它

00:03:48.650 --> 00:03:53.900
并获取所有更新，以便我可以将Moxa的音乐文件模拟到我的音乐中

00:03:53.900 --> 00:04:01.430
目录并获取所有新音乐得到他放在那里的所有新音乐

00:04:01.430 --> 00:04:06.920
但是如果我有应该不仅可读而且应该挂载的私钥

00:04:06.920 --> 00:04:12.700
可写，然后每当我写入该目录或将其更改为新目录时

00:04:12.700 --> 00:04:19.910
状态根被抛光，所以我们应该能够拥有细粒度的任何东西

00:04:19.910 --> 00:04:26.230
像我应该能够看到的共享子图的控件

00:04:26.230 --> 00:04:34.840
将CD中的CD放入我的音乐文件夹，然后创建一个指向它的新想法嵌套链接，以便创建

00:04:34.840 --> 00:04:42.220
新的新的私人-公众保留在这里，我可以将哈希值提供给我所爱的人

00:04:42.220 --> 00:04:46.000
应该能够再次做到这一点，很棒，我应该能够创造另一个

00:04:46.000 --> 00:04:50.920
我应该能够列出我与某个特定链接的不同链接

00:04:50.920 --> 00:04:58.510
文件夹，最后我应该能够撤消它们并删除那些链接，并且

00:04:58.510 --> 00:05:07.330
这使我可以对谁拥有读取权限进行微调控制

00:05:07.330 --> 00:05:13.540
到什么文件夹，我从功能的角度考虑它，我不知道

00:05:13.540 --> 00:05:22.270
您想熟悉功能系统，但可以确定一个人Q3

00:05:22.270 --> 00:05:31.090
很好，但是eh IP嵌套由于读取功能以及撤销它的能力

00:05:31.090 --> 00:05:35.590
显然，该人仍然可以始终读取最后一个哈希

00:05:35.590 --> 00:05:39.750
发布到它，但他们不会得到任何进一步的更新

00:05:39.750 --> 00:05:46.060
所以是的，多个IPS身份就像超级棒，并且能够

00:05:46.060 --> 00:05:54.460
将它们绑定到文件夹，所以一件很酷的事情就像将我所有的链接

00:05:54.460 --> 00:05:59.470
朋友音乐一起放在您知道的本地文件夹中，就像我将这个IP NS哈希链接在一起一样

00:05:59.470 --> 00:06:05.050
给一个朋友弗雷德·弗雷德（Fred），我们可以拥有我所有的笔音乐和我喜欢的全部数据

00:06:05.050 --> 00:06:11.050
音乐，所以我认为它很酷，而操作系统使ipfs不

00:06:11.050 --> 00:06:16.930
遍历IP嵌套，因为这是可变的，但OS系统层

00:06:16.930 --> 00:06:23.350
应该能够遍历IP NS链接和其他任何IP链接

00:06:23.350 --> 00:06:31.270
我们不仅要添加默克尔链接，还需要

00:06:31.270 --> 00:06:37.230
能够轻点，以便我们需要灵活的链接处理程序，因此

00:06:37.230 --> 00:06:45.210
假设我们有一个方案，其中音乐文件夹在ipfs上共享，但是我们

00:06:45.210 --> 00:06:49.470
有一个我们不想共享的子文件夹，所以我们需要一种方法来适应

00:06:49.470 --> 00:06:56.130
因此，可能散列到音乐文件夹中的只是一些符号

00:06:56.130 --> 00:07:05.730
这里提到的是这个东西，但不是默克尔链接，所以我说这是一个

00:07:05.730 --> 00:07:12.330
无序的演讲，这是一个迟钝，所以我要换档，我要做很多工作

00:07:12.330 --> 00:07:17.130
现在用网络符号嗯，我想谈一秒钟

00:07:17.130 --> 00:07:22.500
什么组件是新的便携式大小和加载时间高效的二进制格式，

00:07:22.500 --> 00:07:26.610
旨在通过利用通用硬件以本地速度执行

00:07:26.610 --> 00:07:32.180
我认为它在各种平台上的功能都很棒

00:07:32.180 --> 00:07:39.030
关键要点是快速高效，它的安全沙盒具有工具链

00:07:39.030 --> 00:07:45.210
代码功能，这意味着它可以与LLVM一起使用，因此您可以与LLVM一起使用

00:07:45.210 --> 00:07:50.280
您应该能够在Web程序集虚拟机中运行，因此

00:07:50.280 --> 00:07:59.900
在框内，您知道c c ++会生锈所有这些东西，并且它是可扩展的，很容易

00:07:59.900 --> 00:08:08.220
将其插入其他系统，很容易嵌入，并且具有以下功能

00:08:08.220 --> 00:08:17.100
网络，是的，它已经由Google，Microsoft，Mozilla，Apple等标准化。

00:08:17.100 --> 00:08:24.300
是的，这是历史上所有的大公司，都是出于某种原因

00:08:24.300 --> 00:08:30.420
这些在2012年被称为可扩展Web宣言，以及

00:08:30.420 --> 00:08:36.030
每当添加新的API来扩展

00:08:36.030 --> 00:08:42.630
需要确保的表面积，而不是使用较大的表面积

00:08:42.630 --> 00:08:46.560
区域，如果您构建小的原语，则可以构建新功能，并且

00:08:46.560 --> 00:08:53.879
这些低级原语，是的，另一件事会减少

00:08:53.879 --> 00:08:58.609
复杂性的增长，因此产生了错误和实现，并允许

00:08:58.609 --> 00:09:04.980
浏览器和供应商在发布高级文件之前先对库进行迭代

00:09:04.980 --> 00:09:12.629
api的权利，在这一切中，所有这些都是

00:09:12.629 --> 00:09:18.119
实际上也更适用于区块链

00:09:18.119 --> 00:09:26.309
今天面对的是我们有一个非常大的可信任计算位，所以我们有一个

00:09:26.309 --> 00:09:31.049
虚拟机，我们具有所有这些预编译功能，并且具有类似状态规则的条件

00:09:31.049 --> 00:09:36.749
状态规则就像我们如何更新状态一样，例如从一个移动余额

00:09:36.749 --> 00:09:41.579
指望那里没有，我会说情况变得越来越糟，因为我们有

00:09:41.579 --> 00:09:46.319
还有更多的三个编译器，每次我们添加一个漂亮的编译器时

00:09:46.319 --> 00:09:53.239
我们扩大了信任范围，扩大了竞争基础，这是超级超级

00:09:53.239 --> 00:09:58.619
重要，就像每个实现都实现的区块链一样

00:09:58.619 --> 00:10:02.759
如果您没有正确地达成共识，那么它就更重要

00:10:02.759 --> 00:10:10.829
而不是在浏览器环境中，因此，一个真正值得信赖的庞大计算基础确实

00:10:10.829 --> 00:10:17.339
糟糕的对称计算平台，而对称计算是基础

00:10:17.339 --> 00:10:24.119
苍蝇，我知道所有基于区块链的共识，所以不要建造东西

00:10:24.119 --> 00:10:28.999
首先，我们应该从一个很小的，受信任的社区基础开始，并拥有一个虚拟机

00:10:28.999 --> 00:10:33.869
基岩，然后在其中建立一切，我认为我们应该考虑状态

00:10:33.869 --> 00:10:40.589
由于最终它们处理进程间的关系，因此在内核方面进行更多的规则管理

00:10:40.589 --> 00:10:47.029
合同之间的通信实际上是一个内核，然后像所有

00:10:47.029 --> 00:10:50.730
预编译应该只是每个合约的用户空间

00:10:50.730 --> 00:10:56.730
像其他任何无特权的合同一样，这是

00:10:56.730 --> 00:11:01.440
今天，我正在您的上校中尝试其中的一些想法，

00:11:01.440 --> 00:11:11.010
 II的一部分不是项目，所以现在回过头来谈谈，我们有一个IP LD

00:11:11.010 --> 00:11:16.050
关于较早的翻译，当他说他们是

00:11:16.050 --> 00:11:21.510
考虑使用穆斯林好吗，因为这就是我在说的-所以一个

00:11:21.510 --> 00:11:27.660
译者，所以有一点历史背景-译者和我

00:11:27.660 --> 00:11:35.149
我认为还是我认为与翻译者紧密相关的比赛

00:11:35.149 --> 00:11:42.990
计划9中的翻译，听说我不知道​​是否有人知道有人

00:11:42.990 --> 00:11:49.410
知道九号计划是什么，听到她没事吧，好吧，所以他们的运作

00:11:49.410 --> 00:11:57.529
系统计划9是作为Linux或UNIX的后继产品而开发的

00:11:57.529 --> 00:12:01.980
并没有真正起飞，原因有很多，其中之一是

00:12:01.980 --> 00:12:09.600
车牌同步，听到的声音也一样

00:12:09.600 --> 00:12:14.899
理查德·斯托曼（Richard Stallman）一直以来一直在开发的操作系统

00:12:14.899 --> 00:12:20.639
无论如何，假定翻译器是充当对象服务器的程序

00:12:20.639 --> 00:12:28.199
并参与畜群分布式文件系统，基本上是做什么的

00:12:28.199 --> 00:12:33.420
需要一些说的数据去翻译器并导出一个公共文件

00:12:33.420 --> 00:12:40.519
系统界面和ipfs之类的东西好吗，PL D，您需要输入一些数据

00:12:40.519 --> 00:12:44.910
将其投入解决工作，但我们的翻译在这里和您一起提出了

00:12:44.910 --> 00:12:53.100
普通顶点，所以另一种表达方式是将其复制到畜群之外

00:12:53.100 --> 00:12:58.529
手动通道，它们只是从一种数据表示形式转换而来

00:12:58.529 --> 00:13:05.069
结构成另一种表示形式，非常简单明了，是的，如果您

00:13:05.069 --> 00:13:09.779
编写了IP LD转换器，而且浪费了您不必实现一个转换器

00:13:09.779 --> 00:13:13.130
对于所有人而言，翻译人员本身可以

00:13:13.130 --> 00:13:18.260
由IPS解决，这意味着对实施的依赖性降低而更多

00:13:18.260 --> 00:13:24.920
总体而言，这是很棒的东西，您可以将这些东西实现

00:13:24.920 --> 00:13:31.160
如果只有一个普通的人，可以在用户空间中实现

00:13:31.160 --> 00:13:38.810
知道API，所以我们对即将到来的偶然信件所做的一件事是

00:13:38.810 --> 00:13:43.459
工作非常酷，我会告诉你你为什么要和其他人睡觉

00:13:43.459 --> 00:13:51.769
区块链正在将区块链导入IMS，所以这不是

00:13:51.769 --> 00:13:56.390
实际上，以太坊的结构看起来像是我留下了很多东西

00:13:56.390 --> 00:14:03.769
但这是一个示例，说明您已阻止了

00:14:03.769 --> 00:14:11.269
很重要，您拥有所有不同的帐户地址，然后在旁边

00:14:11.269 --> 00:14:14.870
记下余额和存储的随机数，并确定存储您拥有所有这些

00:14:14.870 --> 00:14:24.350
不同的键，所以有了这些，我们现在有了这个文件结构，如果以太

00:14:24.350 --> 00:14:29.510
合同只是由内容支持的通用操作系统中的程序

00:14:29.510 --> 00:14:38.390
可寻址文件系统有点繁琐，但我觉得非常酷

00:14:38.390 --> 00:14:43.100
我们要从您的空间中得到什么，请充分利用您的空间，我们要知道我们需要

00:14:43.100 --> 00:14:46.880
运行对称计算，所以我从雅典娜开始尝试工作

00:14:46.880 --> 00:14:51.950
向后倒我们想要一个定理，我们拥有内容宁静的文件系统，因此

00:14:51.950 --> 00:14:58.850
让我们尝试向后工作，我们希望我们知道我们需要大量的计算

00:14:58.850 --> 00:15:04.790
确定性默认情况下，需要将其沙盒化，我们希望

00:15:04.790 --> 00:15:09.140
就像我认为重用旧版程序将很重要

00:15:09.140 --> 00:15:17.449
这些都是用C ++编写的，而且还需要非常简单且详细说明

00:15:17.449 --> 00:15:24.490
wasum会默认覆盖其中的几项

00:15:24.490 --> 00:15:30.500
但是我们需要一个通讯层，所以我们不能只使用Linux

00:15:30.500 --> 00:15:34.760
直接，因为它很复杂，有很多细节我们不在乎

00:15:34.760 --> 00:15:40.130
关于显示器，它不是完全确定的，不是沙盒

00:15:40.130 --> 00:15:46.360
尽管有一些有趣的工作与子图和巨大的操作系统进行了默认

00:15:46.360 --> 00:15:50.530
关于沙盒

00:15:51.940 --> 00:15:57.830
好吧，所以再跳一点，我们会回来的，这将是有道理的

00:15:57.830 --> 00:16:04.940
actor模型actor模型真的很酷actor是这些小程序在运行，

00:16:04.940 --> 00:16:08.420
他们在他们的邮箱中收到消息，然后当他们在

00:16:08.420 --> 00:16:12.800
他们响应并处理邮件的邮箱，他们可以旋转其他邮件

00:16:12.800 --> 00:16:20.900
演员，他们可以通过渠道向其他演员发送消息

00:16:20.900 --> 00:16:26.570
因此，我认为每个合同或程序都是在

00:16:26.570 --> 00:16:31.880
好的微内核框架以及您的模型演员的原因。

00:16:31.880 --> 00:16:36.140
在这种环境下，真正的好是因为每个演员都是自然分裂的

00:16:36.140 --> 00:16:44.260
现场建造沙箱周围

00:16:44.920 --> 00:16:53.620
通过图表非常快，这是我想到的所有基础

00:16:53.620 --> 00:17:01.640
因此演员和他们通过交流的渠道将是超级

00:17:01.640 --> 00:17:10.760
左边的图是链接图，Merkle dag结构是一个位置

00:17:10.760 --> 00:17:17.000
这个森林所代表的图形，所以您所需不是很重要

00:17:17.000 --> 00:17:22.640
知道这一点，但就像有一个坚实的数学框架在强调这一点

00:17:22.640 --> 00:17:28.580
我认为最好有一个基岩现实或基岩模型现实

00:17:28.580 --> 00:17:35.950
因此您需要用它来描述更高级别的功能，因此

00:17:35.950 --> 00:17:40.840
是的，这里的森林或地方图是Merc旧蛋，超图是

00:17:40.840 --> 00:17:49.810
程序之间的通讯线路，例如，我们较早时看到

00:17:49.810 --> 00:17:58.510
铈的图形映射到文件夹或袋子结构中

00:17:58.510 --> 00:18:05.140
以超图形式绘制，因此位于顶部，您知道所有帐户和

00:18:05.140 --> 00:18:11.230
那么您在这里有一个帐户，也许是您的TX，就说该帐户

00:18:11.230 --> 00:18:16.540
代码想找出当前块的哈希值或块号为黑色

00:18:16.540 --> 00:18:22.090
困难，它可能想直接与障碍物交谈，因此可能会打开一个通道

00:18:22.090 --> 00:18:32.500
块，所以它是袋结构和角色通道，在一个图形微图中

00:18:32.500 --> 00:18:40.720
卷发微内核历史悠久，有很多，但是

00:18:40.720 --> 00:18:45.280
如果您不熟悉它们，它们只是一个很小的东西

00:18:45.280 --> 00:18:52.540
提供或实施操作系统所需的软件数量，因此

00:18:52.540 --> 00:18:58.330
微内核，我们正在努力或正在考虑的只是提供

00:18:58.330 --> 00:19:03.160
我们的参与者之间的过程间沟通是开放的

00:19:03.160 --> 00:19:10.900
合同，所以这就是我们今天所处的位置，所有这些东西都被压扁了

00:19:10.900 --> 00:19:17.320
集成为一个协议，一个软件栈，共识合同，IPC网络

00:19:17.320 --> 00:19:24.760
有点大商场的泥泞，这是我认为我们应该搬家的地方

00:19:24.760 --> 00:19:28.270
底部，我们有一个文件系统网络可以由您提供

00:19:28.270 --> 00:19:34.750
最重要的是btp，我们有一个微内核的HR程序和合同

00:19:34.750 --> 00:19:41.970
存在的前提是我们可以建立共识协议，例如etherium

00:19:43.060 --> 00:19:50.180
而且您知道随着生态系统的发展和进步，这不是固定的，我们可以采取行动

00:19:50.180 --> 00:19:55.100
越来越多地进入微内核层，并且越来越多

00:19:55.100 --> 00:20:05.240
就像用户空间程序一样，是的，模块化非常重要Conway的

00:20:05.240 --> 00:20:10.760
组织设计的法律制度被限制于生产

00:20:10.760 --> 00:20:14.750
设计是这些通信结构的副本

00:20:14.750 --> 00:20:21.620
基本上，如果您雇用七个团队来设计编译器，您就是

00:20:21.620 --> 00:20:25.370
会想出一个带有七个不同模块或七个不同模块的编译器

00:20:25.370 --> 00:20:35.090
我认为系统必须具有模块化，才能逐步发展

00:20:35.090 --> 00:20:40.520
因为那就像人类为实现目标而编程并努力实现的目标，所以我认为

00:20:40.520 --> 00:20:49.910
将事物分解成模块真的非常重要，所以顶点是的

00:20:49.910 --> 00:20:59.780
顶点是您知道的程序Linux所说的一切都是文件

00:20:59.780 --> 00:21:09.560
而且我们的IP OS一切都很好，可以再次从计划9借用

00:21:09.560 --> 00:21:17.060
您知道他们只有服务器，只有用户空间程序才能实现

00:21:17.060 --> 00:21:24.790
文件服务器，将这些服务器用于其中的一种可能性是合成

00:21:24.790 --> 00:21:31.100
可能基于数据信息根据需要创建顶点或文件

00:21:31.100 --> 00:21:37.190
内核本身内部的结构，所以您可能会有一个问题，并且您将有

00:21:37.190 --> 00:21:47.570
一个代理追随者，它可能会合成进一步的dag，具体取决于

00:21:47.570 --> 00:21:55.549
这个定位树等，所以做这样的事情会很好

00:21:55.940 --> 00:22:00.769
一切都是文件，所以我想做一个小笔记

00:22:00.769 --> 00:22:05.940
顶点与文件略有不同，因为顶点具有值并且

00:22:05.940 --> 00:22:16.799
它有边，如果我们说顶点也是一个程序，那么值就是那些

00:22:16.799 --> 00:22:25.919
边缘是端口，哦，拍摄，所以演员的术语端口是什么

00:22:25.919 --> 00:22:36.509
演员过去经常通过与其他演员交谈，所以我们需要一个系统API，

00:22:36.509 --> 00:22:40.169
应该超级简单，并且需要像您需要的一切一样易于指定

00:22:40.169 --> 00:22:47.459
对这里的计算基础只有很小的信任

00:22:47.459 --> 00:22:54.659
实际上，我们需要做两件事，我们需要与端口进行交互以发送消息

00:22:54.659 --> 00:22:59.909
这样设置并获取端口就可以发送消息了，我们需要存储

00:22:59.909 --> 00:23:09.749
并从文件系统（即Merkle平台）中检索值，因此也是如此

00:23:09.749 --> 00:23:15.529
很抱歉，这是我同时使用Evo的内部

00:23:15.529 --> 00:23:25.709
看到少量的API，我们可以深入了解它，我们需要它的核心

00:23:25.709 --> 00:23:31.739
进程间通信，因此通道是通信端口的线路，

00:23:31.739 --> 00:23:37.499
每个程序具有该端口的通道的内部名称，可以进行双工读取

00:23:37.499 --> 00:23:45.719
只有只读端口具有上限功能，实际上它们有两个

00:23:45.719 --> 00:23:51.929
阅读能力的能力对那些能力进行处理的能力

00:23:51.929 --> 00:23:57.419
一个表，这样您就可以在以后将它们发送到另一个表，这意味着您可以发送端口

00:23:57.419 --> 00:24:02.039
周围很酷，所以实际上这就是我早些时候的例子

00:24:02.039 --> 00:24:07.110
合同与区块对话以确认您实际上必须

00:24:07.110 --> 00:24:14.670
将读取功能发送到默克尔平台层次结构，直到到达

00:24:14.670 --> 00:24:24.450
演员以及默克尔链接是只读功能，如果

00:24:24.450 --> 00:24:28.049
您想更多地了解能力，就可以看到资本或平静，而他

00:24:28.049 --> 00:24:35.910
写出左右消息，这是我们需要原子消息和非原子消息

00:24:35.910 --> 00:24:41.780
不幸的是，我们现在必须支持原子消息

00:24:41.780 --> 00:24:44.910
非原子且信息为定理没有任何概念

00:24:44.910 --> 00:24:50.730
目前还不是原子国家，但如果我们拥有的话，它将永远不会相信崛起

00:24:50.730 --> 00:24:58.049
有制图或任何类型的可伸缩性都需要制图时

00:24:58.049 --> 00:25:05.429
实际上，消息是不可伪造的，它们具有从到的由

00:25:05.429 --> 00:25:11.190
操作系统，并且它们具有可变的有效负载，这就是我正在使用的负载

00:25:11.190 --> 00:25:15.860
消息现在非常简单，我认为这是所有人的链接

00:25:15.860 --> 00:25:27.020
就像我们是你一样，你们都已经看到了道德上的真主草

00:25:27.020 --> 00:25:33.419
计算就像我们是否知道摩尔速度加倍还是不增加

00:25:33.419 --> 00:25:39.299
法律有点像结束了，但我们仍然可以看到您知道这个指数

00:25:39.299 --> 00:25:47.600
技术的增长，我们仍然看到计算能力的真正良好增长

00:25:47.600 --> 00:25:56.610
每瓦特，所以我们正在做更多的计算，而不是更少的能源，并且

00:25:56.610 --> 00:26:03.900
我认为这样做的最终结果将是我们将计算推出

00:26:03.900 --> 00:26:10.200
边缘，或者将其放置在大数据中心中，我们将拥有

00:26:10.200 --> 00:26:12.809
物联网，但越来越多

00:26:12.809 --> 00:26:17.760
我们只会看到计算在我们周围发生，这被称为无处不在

00:26:17.760 --> 00:26:20.489
很好的系统被称为无处不在的系统

00:26:20.489 --> 00:26:25.739
但是现在我称之为物联网

00:26:25.739 --> 00:26:29.969
罗宾·米勒（Robin Miller）会谈论这个问题，并且在90年代您说过这样的系统

00:26:29.969 --> 00:26:34.200
否则其组成特工将具有自我意识，并对其信念有信心

00:26:34.200 --> 00:26:39.690
环境拥有达成目标和首要目标的能力，并能够适应和适应

00:26:39.690 --> 00:26:44.179
在没有人工干预的情况下改变环境

00:26:44.809 --> 00:26:51.089
因此计算可以出现在任何地方，任何时间，任何地方

00:26:51.089 --> 00:26:57.679
所以你知道他们无所不在，他们将计算推向了边缘

00:26:57.679 --> 00:27:05.479
我认为我们将如何与这些无所不在的接口进行交互

00:27:05.479 --> 00:27:10.619
系统是通过同构操作系统进行的，不一定是

00:27:10.619 --> 00:27:17.190
单例好，一个内容可寻址的文件系统确实奠定了

00:27:17.190 --> 00:27:23.429
这样做的基础是因为您不需要中央服务器，所以您可以拥有很多

00:27:23.429 --> 00:27:29.700
边缘节点能够正确检索您的数据，并且您可以从中

00:27:29.700 --> 00:27:35.969
建立一个操作系统，所以我认为这看起来很像我的网站

00:27:35.969 --> 00:27:41.309
具有很多标签的浏览器打开网络浏览器实际上可以完成很多工作

00:27:41.309 --> 00:27:48.599
对，他们有沙盒流程，它们之间有流程间的交流，所以

00:27:48.599 --> 00:27:54.359
网络工作者我们的经纪人他们的模特作者是亚洲模特，还是对不起演员

00:27:54.359 --> 00:28:05.279
模型和网络，您知道它是移动代码，所以我想我认为

00:28:05.279 --> 00:28:09.779
在网络连接网络技术之间存在联系

00:28:09.779 --> 00:28:13.589
分散的技术带给我们，我认为这对于

00:28:13.589 --> 00:28:19.969
与网络技术和庞大的网络社区一起工作

00:28:19.969 --> 00:28:26.669
所以如何做到有实际而不是完美，就像你可以盯着这个一样

00:28:26.669 --> 00:28:32.130
有很多理论，你可以整天盯着这个理论

00:28:32.130 --> 00:28:37.230
对我来说，我认为很多人都喜欢写东西

00:28:37.230 --> 00:28:41.820
在世界上发生了什么，然后回馈并审视理论

00:28:41.820 --> 00:28:47.480
前进是最好的方法，所以不用担心自己会变得完美

00:28:47.480 --> 00:28:53.220
只要尝试实用，它就包含迭代，一切都是原型

00:28:53.220 --> 00:28:58.380
不要被赶上去建造巨大的最终闪亮的东西，这仅仅是一个

00:28:58.380 --> 00:29:06.000
迭代让它停在预告片上，并真正遵循UNIX哲学

00:29:06.000 --> 00:29:12.360
快速笔记播放9很棒，但是Linux确实做到了正确的一件事

00:29:12.360 --> 00:29:20.340
模块化，所以pi9如何处理所有这些酷事，但事实证明

00:29:20.340 --> 00:29:26.549
真正重要的是模块化，而Linux是第一个获得模块化的模块

00:29:26.549 --> 00:29:31.200
拉里·D（Mountor Larry D）倒下了，这就是我无法做到的一个原因

00:29:31.200 --> 00:29:36.990
最后击败它的是自己的核心开发人员，例如，如果看到一个自己的代码，则编写自己的代码

00:29:36.990 --> 00:29:42.510
修复它是您的工作，是的，这就是我要说的

00:29:42.510 --> 00:29:50.799
[掌声]

