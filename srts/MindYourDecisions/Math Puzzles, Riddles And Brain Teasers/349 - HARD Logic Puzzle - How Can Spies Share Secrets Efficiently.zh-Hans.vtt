WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:05.759
嘿，这是n个间谍成功执行任务后的部分Walker

00:00:05.759 --> 00:00:11.400
现在学习一个秘密，每个间谍都需要学习所有

00:00:11.400 --> 00:00:18.960
秘密他们如何通过协议来做到这一点，鄙视通过

00:00:18.960 --> 00:00:25.650
间谍可以同时在两个间谍之间进行一系列电话通话

00:00:25.650 --> 00:00:31.320
分享所有秘密，从先前的电话中学到什么是最低要求

00:00:31.320 --> 00:00:38.129
通话次数，以便所有间谍都能了解所有秘密，从而解决了这个问题

00:00:38.129 --> 00:00:45.210
对于两种不同类型的通信，一种情况是单向调用间谍

00:00:45.210 --> 00:00:51.600
呼叫可以传输信息，另一种情况是双向呼叫

00:00:51.600 --> 00:00:57.719
间谍可以在通话期间交换信息，请尝试一下此问题

00:00:57.719 --> 00:01:04.680
当您准备好继续观看视频时，系统会考虑该解决方案

00:01:04.680 --> 00:01:11.340
单向呼叫一种协议是每个人都一次呼叫一次，然后

00:01:11.340 --> 00:01:18.299
当您有两名间谍时，间谍会打回所有人

00:01:18.299 --> 00:01:24.720
一个回叫，当您有三个间谍时，这需要两个呼叫，另外两个是

00:01:24.720 --> 00:01:31.680
必要的间谍B和C呼叫间谍，他已被充分告知，然后间谍了一次呼叫

00:01:31.680 --> 00:01:39.000
回到B，然后到C，这是四个呼叫，新间谍需要一个呼叫来呼叫一个

00:01:39.000 --> 00:01:43.890
然后一个电话来向每位新间谍学习信息

00:01:43.890 --> 00:01:49.710
接两次电话，当您有n个间谍时，可以将程序通用化

00:01:49.710 --> 00:01:55.409
N减去一个间谍首先呼叫a这是n减去一个间谍，然后呼叫

00:01:55.409 --> 00:02:00.240
返回所有的N个负一个间谍这些是另一个n个负一个间谍

00:02:00.240 --> 00:02:07.259
总共进行两个n减去两个调用，这是一个过程，因此所有

00:02:07.259 --> 00:02:11.160
间谍学习了所有的秘密，但还有另一个可能是有利的

00:02:11.160 --> 00:02:15.510
有时候，这是一个很棒的算法，看起来像

00:02:15.510 --> 00:02:20.550
循环调用模式的优势在于，每个调用共享最多

00:02:20.550 --> 00:02:27.900
秘密的数目，所以想像一下将间谍围成一个圆圈侦探一个电话

00:02:27.900 --> 00:02:34.860
顺时针旋转所有间谍，以便监视一个共享一个秘密B的通话间谍B

00:02:34.860 --> 00:02:42.060
呼叫C，后者共享另一个秘密C呼叫D，依此类推，当我们到达

00:02:42.060 --> 00:02:48.720
在这五个之前的最后一个间谍将学习这最后一个的所有其他秘密

00:02:48.720 --> 00:02:55.290
然后打电话给一个了解所有秘密的人，这第一条电话链

00:02:55.290 --> 00:03:01.380
N个间谍中有一个接听了一个电话，因此现在总共有n个电话

00:03:01.380 --> 00:03:07.049
最后一个间谍和一个间谍a被完全告知，但是现在其他n个负2个间谍需要

00:03:07.049 --> 00:03:13.590
被告知，以便间谍a继续呼叫B的另一个呼叫链

00:03:13.590 --> 00:03:20.760
C，等等，最后一个by and spy a是已经知道所有秘密的2个间谍

00:03:20.760 --> 00:03:25.859
所以这些是2名间谍，不需要接听电话，因此第二条链可以

00:03:25.859 --> 00:03:31.920
在n减去2次调用中完成，我们不需要最后两个调用，这再次使

00:03:31.920 --> 00:03:38.239
总共2 n减去2个电话，所有间谍都了解了所有秘密

00:03:38.239 --> 00:03:44.609
如果有两个间谍，双向呼叫该怎么办，因为您只需要一个呼叫，因为

00:03:44.609 --> 00:03:51.109
当您有三个间谍时，两个间谍都可以在该呼叫中交换信息

00:03:51.109 --> 00:03:57.060
间谍A和B可以打个电话，然后B和C可以打个电话，所以B和C完全

00:03:57.060 --> 00:04:02.340
在这一点上已获悉，但间谍a不知道辛辣的秘密，所以再打一个电话

00:04:02.340 --> 00:04:08.099
是必要的，当您有四个间谍时，总共需要三个呼叫

00:04:08.099 --> 00:04:13.319
有一个非常有效的拨打电话程序，我们在一个

00:04:13.319 --> 00:04:20.430
对平行边上的间谍进行平方然后打电话

00:04:20.430 --> 00:04:26.700
在四个呼叫中，所有这些呼叫都垂直于这些呼叫

00:04:26.700 --> 00:04:30.560
如果我们在一个电话中拨打电话，则会通知四个间谍

00:04:30.560 --> 00:04:35.180
特定顺序的这种信息交换模式

00:04:35.180 --> 00:04:40.849
对于四个间谍来说，这是非常有效的，可以推广到

00:04:40.849 --> 00:04:48.949
n间谍我们将其中四个间谍指定为每个人都称为间谍之一的集线器

00:04:48.949 --> 00:04:55.910
然后，在中心中的四个中心间谍共享秘密，以便使这四个间谍能够

00:04:55.910 --> 00:05:00.139
知道所有的秘密，然后来自中心的人会打电话给其他

00:05:00.139 --> 00:05:06.050
不在集线器后面，所以我们指定了四个间谍，然后在集线器中

00:05:06.050 --> 00:05:10.909
我们有另外n个减去4个间谍，因此他们将呼叫中心中的某人

00:05:10.909 --> 00:05:15.830
在此图中，我只指定了所有呼叫，但其中一些

00:05:15.830 --> 00:05:21.470
呼叫可以传到BC或D，这与另一端无关紧要-只是四个间谍

00:05:21.470 --> 00:05:26.870
需要呼叫集线器中的某个人，因此这n个负四名间谍需要制作一个

00:05:26.870 --> 00:05:33.139
呼叫集线器中的某人，因此第一组呼叫为n-四个呼叫四个

00:05:33.139 --> 00:05:37.820
然后，集线器中的间谍将根据协议交换信息

00:05:37.820 --> 00:05:42.430
对于四个间谍，他们都会学习所有的秘密

00:05:42.430 --> 00:05:48.009
因此，在接下来的四个电话会议中，他们将全部获得通知。

00:05:48.009 --> 00:05:52.639
现在需要将此信息分配给其他n减4

00:05:52.639 --> 00:05:58.639
不在集线器中的间谍，因此集线器中的某人需要回电

00:05:58.639 --> 00:06:03.590
在此图中，其他n个减去四个间谍，我将其描绘为bi正在调用

00:06:03.590 --> 00:06:08.389
每个人都回来了，但可能是BC或D，因为所有这四个间谍都是

00:06:08.389 --> 00:06:13.310
通知，所以这将是另外的n减去四个电话，以便每个不在的人

00:06:13.310 --> 00:06:18.740
集线器已完全收到通知，我们将通话总数加起来，得到n减

00:06:18.740 --> 00:06:23.300
四个电话，当您有n个电话时，您将无法获得比这更有效的服务

00:06:23.300 --> 00:06:29.210
间谍通过双向呼叫共享信息，所以现在让我们比较两种情况

00:06:29.210 --> 00:06:34.580
当我们进行单向呼叫时，我们可以让所有人都呼叫集线器，也可以

00:06:34.580 --> 00:06:40.219
有一个看起来像循环调用模式的贪婪算法，这是一个

00:06:40.219 --> 00:06:45.080
进行双向通话时总共有两个--通话

00:06:45.080 --> 00:06:53.150
该协议涉及针对间谍的通用协议，现在比较

00:06:53.150 --> 00:06:58.340
您可能会想到两个公式，当您进行双向通话时，您将能够

00:06:58.340 --> 00:07:03.349
有呼叫数量，因为每个呼叫可以交换两次信息

00:07:03.349 --> 00:07:09.020
呼叫者和接收者都可以交换信息，我们所拥有的是您

00:07:09.020 --> 00:07:14.840
最多只能收到两个n减去四个电话，而您只能保存两个电话

00:07:14.840 --> 00:07:19.430
当n大于4时进行单向呼叫，这真是令人惊讶

00:07:19.430 --> 00:07:24.440
即使双向通话您也无法分配更多信息

00:07:24.440 --> 00:07:29.629
比呼叫集线器或发出通告的示例更有效

00:07:29.629 --> 00:07:33.379
调用模式，这是一个非常令人惊讶的事情

00:07:33.379 --> 00:07:37.460
即使您有信息，信息也可能是效率低下的过程

00:07:37.460 --> 00:07:43.039
现在在此视频中进行双向通话我声称这是

00:07:43.039 --> 00:07:47.659
这些过程所必需的调用证明了这是双向的

00:07:47.659 --> 00:07:51.620
通话实际上有点复杂，所以我提供了一个证明

00:07:51.620 --> 00:07:56.599
在另一个视频中，您可以检查该链接的视频描述，并且您可以

00:07:56.599 --> 00:08:01.099
观看视频，为什么2 +-4是等待等待的最少通话次数

00:08:01.099 --> 00:08:05.750
来电感谢收看此视频，请订阅我创建的频道

00:08:05.750 --> 00:08:09.710
有关数学和博弈论的视频，您可以在我的博客中关注自己的决定

00:08:09.710 --> 00:08:13.490
您可以在Facebook Google+和patreon上关注，您可以在社交网络上关注我

00:08:13.490 --> 00:08:16.639
媒体在个人储物柜中，如果您喜欢该视频，请查阅我的书

00:08:16.639 --> 00:08:19.659
视频说明中有链接

