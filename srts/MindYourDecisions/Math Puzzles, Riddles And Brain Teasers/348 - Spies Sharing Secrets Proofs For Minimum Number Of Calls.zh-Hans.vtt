WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:06.930
嘿，这是间谍分享秘密谜题中的新鲜清漆，我问这是什么

00:00:06.930 --> 00:00:12.870
最少的通话次数，以便所有间谍可以了解所有秘密，如果

00:00:12.870 --> 00:00:16.590
您还没有看过视频，请继续尝试，我介绍了

00:00:16.590 --> 00:00:21.600
解决此问题的方法我在此视频说明中提供了一个链接

00:00:21.600 --> 00:00:28.160
视频我要证明为什么最小数字的公式是正确的

00:00:28.910 --> 00:00:34.140
因此，在单向通话中，我们总共有2 n减去2个通话，而在双向通话中，我们有

00:00:34.140 --> 00:00:39.390
最少有2 n减4的通话，所以让我们证明2 n减2是

00:00:39.390 --> 00:00:44.640
单向通话的最小电话数量请注意，当您有一组n

00:00:44.640 --> 00:00:50.430
间谍至少需要n减去1个电话，即使1个间谍也要完全

00:00:50.430 --> 00:00:58.109
因此，如果我们删除其中一个电话，我们将被告知所有秘密

00:00:58.109 --> 00:01:06.060
有n减2次呼叫，每个间谍都不可能完全被告知

00:01:06.060 --> 00:01:13.260
但是随后的通话可以完全通知一位间谍，因此我们将需要n次以上的通话

00:01:13.260 --> 00:01:19.680
充分告知最终间谍，这将导致呼叫数量的下限，因为

00:01:19.680 --> 00:01:28.530
n加2加n等于2减去2呼叫集线器的过程和

00:01:28.530 --> 00:01:34.140
贪心算法达到了这个下界，因此我们可以说这是

00:01:34.140 --> 00:01:41.579
以一种方式通知所有间谍所需的最小呼叫数

00:01:41.579 --> 00:01:47.159
双向调用这是一个更困难的证明，所以我们怎么知道2n减去4是

00:01:47.159 --> 00:01:51.840
最小通话次数有多种方法可以证明这一点

00:01:51.840 --> 00:01:56.670
该视频中出现的所有内容都是矛盾的证明，我们假设我们可以

00:01:56.670 --> 00:02:02.490
得到一个较小的数字，因此我们假设最多2 n减去5个电话就足够了

00:02:02.490 --> 00:02:08.970
为了通知某些满足条件，其中n大于4，我们将M设为

00:02:08.970 --> 00:02:13.530
间谍的最小数量，这将是关键一步

00:02:13.530 --> 00:02:20.160
一些矛盾，所以在这样的调用过程中，我们将不得不

00:02:20.160 --> 00:02:25.710
遵循一定的原则，即没有间谍，没人能听到自己的信息

00:02:25.710 --> 00:02:33.990
例如没有间谍，间谍a就永远听不到别人的秘密或间谍B

00:02:33.990 --> 00:02:40.410
永远也听不见别人的间谍B机密，这在我们的2n中是不正确的

00:02:40.410 --> 00:02:45.330
有人将集线器称为N减4的情况下的减4协议

00:02:45.330 --> 00:02:51.000
然后他们发现间谍，然后接到集线器中某人的回电，以便他们听到

00:02:51.000 --> 00:02:55.860
他们在这个证明中的秘密，但是我们说的是你是否可以做点什么

00:02:55.860 --> 00:03:02.100
优于2减4，您将需要没有人能听到的限制

00:03:02.100 --> 00:03:08.100
他们自己的信息，一旦我们知道在这样的条件下必须满足该条件

00:03:08.100 --> 00:03:14.310
更有效的呼叫程序，然后我们通过一系列步骤最终得到

00:03:14.310 --> 00:03:20.640
结果，每个间谍现在必须至少拨打5次电话，这将是

00:03:20.640 --> 00:03:25.230
效率很低，这意味着呼叫总数必须为5

00:03:25.230 --> 00:03:31.920
 M乘以2，即大于2 m，因此大于2 m

00:03:31.920 --> 00:03:36.720
减去5，这将导致一个矛盾，即如果我们假设

00:03:36.720 --> 00:03:41.280
调用过程的编号可能会更有效，我们实际上可以得出结果

00:03:41.280 --> 00:03:45.630
不可能那么有效，所以我们可以得出最小的结论

00:03:45.630 --> 00:03:53.220
通话次数是2 n减去4，所以让我们进入证明的细节，

00:03:53.220 --> 00:03:57.180
我们假设我们可以获得一个更高效的程序

00:03:57.180 --> 00:04:01.769
大多数2 n减去5个电话足以满足一些更大的需求

00:04:01.769 --> 00:04:07.829
这个证明的一个关键部分是4，我们让M为间谍的最小数量

00:04:07.829 --> 00:04:12.299
为此，我们将在足够的电话中说

00:04:12.299 --> 00:04:18.780
没有人可以听到他们自己的信息，所以如果这个原则

00:04:18.780 --> 00:04:24.599
失败，则意味着某些间谍行为会共享信息，然后最终

00:04:24.599 --> 00:04:29.780
听到他自己的秘密，所以在图论中，这意味着

00:04:29.780 --> 00:04:35.270
是一个封闭的呼叫周期X将会向不同的间谍发出一组呼叫

00:04:35.270 --> 00:04:41.630
最终X会听到这个秘密，所以x将这个秘密分享给s1

00:04:41.630 --> 00:04:47.630
一直被共享，一直监视SK，然后与SK共享信息

00:04:47.630 --> 00:04:53.120
X并再次共享X机密，所以这可能是专有技术失败的情况

00:04:53.120 --> 00:04:58.750
通话周期很近，此过程中可能还有其他通话

00:04:58.750 --> 00:05:05.300
比较容易的是在s1和ek之前进行的调用

00:05:05.300 --> 00:05:13.820
在SK之前进行，或者在进行SJ和ek plus 1调用之前进行EJ

00:05:13.820 --> 00:05:20.930
是在SK之后发生的，所以我们有一些图表，其中M间谍被告知

00:05:20.930 --> 00:05:28.820
两个M减去5的电话，而新的High Principal失败了，所以M应该是

00:05:28.820 --> 00:05:34.490
我们可以达到M减去5的最小间谍数量

00:05:34.490 --> 00:05:41.390
我们要做的是使用更少的两个电话通知n减去1个间谍

00:05:41.390 --> 00:05:47.180
这最多是两个括号n减1减5个调用

00:05:47.180 --> 00:05:51.560
与MM的极小值相矛盾的应该是

00:05:51.560 --> 00:05:55.040
我们可以有一个更有效的呼叫程序，但是如果专有技术失败

00:05:55.040 --> 00:05:59.990
我们实际上可以减少间谍的数量，并且仍然可以更有效地进行通话

00:05:59.990 --> 00:06:04.880
程序，所以我们要如何很好地调整此调用程序

00:06:04.880 --> 00:06:10.610
告知n减去1个间谍，因此我们将从等式中删除间谍X，因此我们现在

00:06:10.610 --> 00:06:15.470
有n个负1间谍，所以我们要摆脱哪两个电话

00:06:15.470 --> 00:06:23.210
摆脱X呼叫s 1和X呼叫SK的呼叫，我们现在让所有

00:06:23.210 --> 00:06:27.500
通话保持相同的顺序，但是我们将重新路由它们，因此我们

00:06:27.500 --> 00:06:33.220
让呼叫更容易进入X，让他们进入s 1

00:06:33.220 --> 00:06:39.270
我们将从e1发出的呼叫转到s 1，通常我们将让这些呼叫

00:06:39.270 --> 00:06:44.610
从EJ转到SJ，所以无论发生什么呼叫，我们都会得到X

00:06:44.610 --> 00:06:52.740
相反，它转到另一个间谍ek转到SK，然后ek + 1转到SK，所以

00:06:52.740 --> 00:06:57.480
如果先前的调用程序导致n个间谍学习了所有

00:06:57.480 --> 00:07:03.090
2和负5的秘密这个新的调用过程实际上是

00:07:03.090 --> 00:07:08.970
在2个较少的呼叫中通知所有这些M减去1个间谍，这将

00:07:08.970 --> 00:07:14.370
与M的极小值矛盾，所以这意味着我们不能没有

00:07:14.370 --> 00:07:20.070
夏威夷失败了，如果我们有一个更有效的解决方案，那么这没有hoyt程序必须是正确的

00:07:20.070 --> 00:07:27.330
调用过程，所以现在我们将使用此no hoyp过程来解决问题

00:07:27.330 --> 00:07:32.670
每个间谍必须至少拨打五个电话，所以第一件事不是夏威夷

00:07:32.670 --> 00:07:38.760
这意味着如果两个间谍处于最后通话状态，则必须是

00:07:38.760 --> 00:07:45.450
两位间谍的原因是，如果这是最后一次通话，则两个间谍都会被充分告知

00:07:45.450 --> 00:07:51.930
因此，如果间谍再次打电话给某人说“间谍X”，这就是为什么X是

00:07:51.930 --> 00:07:56.100
会听到他自己的信息，因为

00:07:56.100 --> 00:08:02.130
最后的通话知道了所有秘密，包括间谍X的秘密，所以我们不能

00:08:02.130 --> 00:08:06.060
发生这种情况，因此如果两个间谍处于最后通话状态，则必须进行最后通话

00:08:06.060 --> 00:08:12.180
两者类似，如果两个间谍在彼此初始通话中，则必须是

00:08:12.180 --> 00:08:20.520
两者的初始通话可以推断出类似的矛盾，因此M

00:08:20.520 --> 00:08:26.730
间谍在一起，我们有初始呼叫和最终呼叫，总共占M

00:08:26.730 --> 00:08:32.250
间谍之间进行的通话，因为通话的总数可以是

00:08:32.250 --> 00:08:37.919
最多2个和负5个，最多留下M个负5个呼叫，这可能是

00:08:37.919 --> 00:08:44.540
当我们有M个间谍时，现在不是初始呼叫或最终呼叫的中间呼叫

00:08:44.540 --> 00:08:49.920
它需要M减1的边或n减1的调用才能在

00:08:49.920 --> 00:08:53.420
所有的间谍，所以中间通话图

00:08:53.420 --> 00:08:59.360
具有n个负5个边且负5个呼叫必须至少有5个不相交

00:08:59.360 --> 00:09:06.950
中间调用图中的连接组件很好看一下间谍

00:09:06.950 --> 00:09:12.050
间谍a可以是一个组件的一部分，也可以连接到另外两个组件

00:09:12.050 --> 00:09:17.900
初始调用和最终调用导致的中间调用的数量，这意味着

00:09:17.900 --> 00:09:23.990
间谍a未连接到中间图的至少两个组件

00:09:23.990 --> 00:09:29.450
通话，因此从ace角度来看，这些通话实质上是在浪费，他们没有

00:09:29.450 --> 00:09:34.880
与实际学习的信息的关系，因此我们将其表示为W

00:09:34.880 --> 00:09:43.250
现在，它需要n减去一个侦探a的电话才能获得通知，而另一个n减去

00:09:43.250 --> 00:09:49.610
一个人号召所有香料从一个人那里学到一个秘密，唯一的电话就是

00:09:49.610 --> 00:09:54.800
同时兼顾间谍的学习信息和分享秘密

00:09:54.800 --> 00:10:02.210
涉及间谍a将用P表示这些电话的数量，所以现在让我们

00:10:02.210 --> 00:10:07.490
看一下我们在过程中的总调用数

00:10:07.490 --> 00:10:12.830
负1个通话加上另外n个负1个通话，这些通话共用一个负1个通话

00:10:12.830 --> 00:10:17.840
得到通知加上另外的n减1个电话来共享一个秘密，我们减去

00:10:17.840 --> 00:10:24.560
排除可能同时做的a的相互调用P，然后我们添加了浪费的

00:10:24.560 --> 00:10:31.850
调用，所以我们有M加1加M加1，等于2我减去2我们减去

00:10:31.850 --> 00:10:38.060
排除可能的相互通话，然后我们添加浪费的通话数量，以便

00:10:38.060 --> 00:10:43.430
所有这些，所有这些电话都必须比总数多

00:10:43.430 --> 00:10:50.210
等于M减去5的通话数量，我们可以重新排列这个不等式来获得

00:10:50.210 --> 00:10:54.020
a的调用次数使其大于或等于3加上

00:10:54.020 --> 00:10:58.760
现在，浪费的呼叫数量是非负的，因此

00:10:58.760 --> 00:11:04.769
表示a必须拨打至少3个电话

00:11:04.769 --> 00:11:10.170
一个初始呼叫和一个最终呼叫，因为a至少必须进行三个呼叫

00:11:10.170 --> 00:11:15.089
至少一个中间呼叫，并且类似地，所有间谍必须

00:11:15.089 --> 00:11:20.790
中间调用，这意味着在

00:11:20.790 --> 00:11:25.049
未连接到的中间呼叫必须有呼叫

00:11:25.049 --> 00:11:30.389
这些组件不能只是一个没有连接的图形，所以从一个

00:11:30.389 --> 00:11:36.119
角度来看至少有两个浪费的电话，所以我们将回到我们的

00:11:36.119 --> 00:11:40.739
关于必须进行的呼叫次数不平等，我们将用它代替

00:11:40.739 --> 00:11:44.790
浪费的通话次数必须至少为2，这意味着通话总数

00:11:44.790 --> 00:11:50.759
一个必须至少5个，这对于所有间谍来说都是正确的

00:11:50.759 --> 00:11:55.739
所有间谍的逻辑都是正确的，因此这意味着每个间谍都必须在

00:11:55.739 --> 00:12:01.259
至少有五个电话，当您有位置和间谍时，这意味着总数

00:12:01.259 --> 00:12:05.850
通话次数必须至少是通话次数的五倍除以二，因为

00:12:05.850 --> 00:12:12.179
通话是成对进行的，因此5m除以2大于2m，并且

00:12:12.179 --> 00:12:19.619
大于2m减去5，因此我们假设可以进行少于2m减去4的呼叫，但是

00:12:19.619 --> 00:12:26.339
导致了一个矛盾，说我们必须有更多的电话，因此2

00:12:26.339 --> 00:12:31.290
 n减4是通话次数的下限，我们知道这是最小值

00:12:31.290 --> 00:12:35.519
价值，因为我们在每个调用其中一项的算法中都实现了这一目标

00:12:35.519 --> 00:12:41.970
四个中心间谍感谢您收看此视频，请订阅我的频道I

00:12:41.970 --> 00:12:45.509
制作有关数学和游戏理论的视频，您可以在我的博客上关注我

00:12:45.509 --> 00:12:49.110
您可以在Facebook Google+和patreon上遵循的决定，您可以

00:12:49.110 --> 00:12:52.379
在压力足球比赛中在社交媒体上吸引她，如果您喜欢这个视频，请

00:12:52.379 --> 00:12:56.179
在视频说明中查看我的书那里的链接

