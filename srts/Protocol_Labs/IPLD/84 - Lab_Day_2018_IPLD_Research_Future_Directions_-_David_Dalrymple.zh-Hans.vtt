WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.060 --> 00:00:04.830
我对IPL de的宏伟愿景是去中心化程序设计

00:00:04.830 --> 00:00:07.950
环境，我所说的编程环境是

00:00:07.950 --> 00:00:11.460
Unix意识有些人谈论核心

00:00:11.460 --> 00:00:15.120
UNIX哲学拥有可组合的实用程序，您可以将它们组合在一起

00:00:15.120 --> 00:00:19.350
做得很好，但我认为UNIX哲学的真正核心内容是

00:00:19.350 --> 00:00:25.800
在此引用中更简洁地捕获到文件是字节序列，

00:00:25.800 --> 00:00:29.580
之所以在此之前无法编写程序，是因为人们没有使用

00:00:29.580 --> 00:00:35.370
关于如何将字节实际放入磁盘的相同约定，因此它们

00:00:35.370 --> 00:00:38.340
程序无法共存，因为其中没有环境

00:00:38.340 --> 00:00:42.660
他们可以交换数据而不会互相破坏，因此文件系统

00:00:42.660 --> 00:00:46.410
实际上是所有UNIX哲学其余部分的核心

00:00:46.410 --> 00:00:49.980
建立在现在之上，而我们真正想要做的就是朝着计算迈进

00:00:49.980 --> 00:00:53.010
使用DAG而不是使用我们正在处理的字节序列进行计算

00:00:53.010 --> 00:00:56.969
结构化数据，所以我们需要重新审视，或者至少我认为这是

00:00:56.969 --> 00:01:00.989
重访许多更高阶的计算类型是有利可图的

00:01:00.989 --> 00:01:07.110
文件系统之上的一些想法

00:01:07.110 --> 00:01:11.939
当我们拥有可以被存储的数据时，DAG可以启用结构化数据存储

00:01:11.939 --> 00:01:16.799
以这些结构化方式进行编码，我们可以改善公共子数据的重复数据删除

00:01:16.799 --> 00:01:20.460
元素，并且因为我们知道在何处分块，所以我们不只是分块

00:01:20.460 --> 00:01:25.619
兆字节或我们可以预取的内容，例如

00:01:25.619 --> 00:01:28.590
认为需要我们知道的东西才能成为的视频文件

00:01:28.590 --> 00:01:33.329
能够有效地访问它的其余部分，我们可以对

00:01:33.329 --> 00:01:36.479
文件的不同语义部分

00:01:36.479 --> 00:01:41.250
我们可以执行懒惰的访问模式，在其中可以加载数据结构并拥有它

00:01:41.250 --> 00:01:45.270
像我们在记忆中一样透明地显示，但实际上，当我们跟随时

00:01:45.270 --> 00:01:50.009
我们在后端遵循哈希链接的指针的一些用法

00:01:50.009 --> 00:01:54.270
您可能想要戴上的这类计算过滤器的案例

00:01:54.270 --> 00:01:59.820
IP LD dag的顶部，现在说这是一个新的dag，但这不是实际的

00:01:59.820 --> 00:02:04.799
IP FS，它是对先前某些东西的计算转换

00:02:04.799 --> 00:02:08.039
可能想做例如减压，我们可能想做

00:02:08.039 --> 00:02:12.110
不同格式之间的透明解密转换

00:02:12.110 --> 00:02:17.930
不同类型的视图将镜头切成薄片，以查找索引中的事物，因此您可以

00:02:17.930 --> 00:02:23.060
提供某种标识符以执行查找键和键的表达式

00:02:23.060 --> 00:02:28.390
值块或什至更高级的查询，例如关系代数

00:02:28.390 --> 00:02:32.989
甚至是我想要能够进行的广义数据分析

00:02:32.989 --> 00:02:36.290
复制数据分析，而不是放置分析结果

00:02:36.290 --> 00:02:39.650
在IP FS上说我相信我对此数据进行了分析

00:02:39.650 --> 00:02:43.519
我把实际的代码放在那儿，你回答你可以重新计算它

00:02:43.519 --> 00:02:47.750
您自己也可以从缓存等处获取它，但是我们想要的东西

00:02:47.750 --> 00:02:50.840
这种事情我们需要纯确定性的可复制语义

00:02:50.840 --> 00:02:54.200
因为我们希望能够缓存我们想要某种查询计划器

00:02:54.200 --> 00:02:58.069
可以说哦，此子表达式是您之前曾计算过的

00:02:58.069 --> 00:03:01.129
信任，或者它是以可验证的方式计算的，或者您是通过计算得出的

00:03:01.129 --> 00:03:05.239
昨天是你自己，我把它放在磁盘上，我将从那里取它，或者如果它是

00:03:05.239 --> 00:03:09.680
真正快速计算的东西，它将比获取更快

00:03:09.680 --> 00:03:12.230
或在网络中找到已经完成的人，然后我会做

00:03:12.230 --> 00:03:16.340
我自己，那些您希望能够留给优化的决策

00:03:16.340 --> 00:03:19.060
这意味着您需要对确定性充满信心

00:03:19.060 --> 00:03:23.630
您的计算元素的可重现输出，我们将

00:03:23.630 --> 00:03:27.620
需要一个优雅的故事来进行升级和版本控制，而不仅仅是数据

00:03:27.620 --> 00:03:33.109
这相对容易以git样式进行处理，但也很容易对架构进行处理

00:03:33.109 --> 00:03:36.739
我们表示数据的方式，甚至比

00:03:36.739 --> 00:03:42.560
我们可能会介绍一些新的问题，您可以问有关数据的问题

00:03:42.560 --> 00:03:45.799
伴随着这些新的表示，所以有一些开放的研究

00:03:45.799 --> 00:03:50.989
如何最好地代表这类事情的问题，当然，我们

00:03:50.989 --> 00:03:53.629
希望其核心易于实现，因此我们希望构建尽可能多的

00:03:53.629 --> 00:03:57.230
在其他功能之上的尽可能的功能，以便在底部

00:03:57.230 --> 00:04:01.250
这是非常非常简单的，无类型的lambda演算是最终版本

00:04:01.250 --> 00:04:06.319
为此，我们正在努力尽可能地做到这一点，并提供广泛的平台支持

00:04:06.319 --> 00:04:13.069
利用webassembly，这样我就可以完成剩余的工作

00:04:13.069 --> 00:04:16.430
去中心化过程中的一系列不同步骤需要30秒

00:04:16.430 --> 00:04:19.909
编程环境，因此数据定义是一种静态的价值语言

00:04:19.909 --> 00:04:23.750
文字类型的JSON样式序列化镜头

00:04:23.750 --> 00:04:28.100
您可以在这些架构和各种形式的值中表示值的实际格式

00:04:28.100 --> 00:04:32.030
不同的方式，取决于您的应用程序对选择器的需求还是

00:04:32.030 --> 00:04:37.160
例如地图和过滤器查询，您可以在其中绑定变量以进行递归

00:04:37.160 --> 00:04:41.630
对象模型，用于将此类查询公开为api，使它们具有人工性

00:04:41.630 --> 00:04:46.370
可读的名称和此类数据库样式索引，然后超出不可变数据，请参见

00:04:46.370 --> 00:04:49.670
Rd T的能力参与者，最终将使您了解

00:04:49.670 --> 00:04:54.110
在此分散式中，可验证地进行无限制的计算

00:04:54.110 --> 00:04:57.520
时间不多了，环境非常感谢

00:04:57.520 --> 00:05:01.350
[掌声]

