WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:04.290
谢谢你，谢谢你说我知道这是所有人的最后一幕

00:00:04.290 --> 00:00:09.150
今天我知道你到目前为止一直在享受会议，我知道我有我的

00:00:09.150 --> 00:00:13.860
我叫David我在协议应用程序上工作，在Perko实验室中我们进行研究

00:00:13.860 --> 00:00:19.619
开发和部署新技术以及良好的协议，以使

00:00:19.619 --> 00:00:25.740
今天的网络更好，我想和您谈谈恒星模块管理以及何时

00:00:25.740 --> 00:00:29.670
我说的模块我真的可以像包一样可以指回购

00:00:29.670 --> 00:00:35.969
我指的不是turbo，甚至不是容器，这些逻辑单元

00:00:35.969 --> 00:00:41.640
您通常会创建自己，以便可以重用自己或与他人共享

00:00:41.640 --> 00:00:44.940
我组织演讲的方式，我将从动机开始，

00:00:44.940 --> 00:00:49.140
进行模块管理的挑战以及如何在内部移动代码

00:00:49.140 --> 00:00:53.670
组织，我将参考NPM我们众所周知的软件包管理器

00:00:53.670 --> 00:00:58.550
你们中的人知道J的社区谈论网络，网络的当前状态以及

00:00:58.550 --> 00:01:03.210
ipfs一个新的IP媒体传输我将以某种方式完成本演示文稿

00:01:03.210 --> 00:01:08.070
新功能，您就可以从这个星座开始了，就像ipfs和

00:01:08.070 --> 00:01:12.810
我们可以使用的软件包管理工具，因此当

00:01:12.810 --> 00:01:17.159
我们谈论模块管理非常重要的是要了解实际的内容

00:01:17.159 --> 00:01:21.270
一个模块，这通常会因我们使用的语言而有偏差

00:01:21.270 --> 00:01:26.549
除非我们决定通过网络公开此模块的软件

00:01:26.549 --> 00:01:30.750
连接或通过管道以一种非常独特的方式连接一切之后

00:01:30.750 --> 00:01:34.979
我们创建了这一逻辑，我们希望能够共享它，还有其他

00:01:34.979 --> 00:01:37.799
人们会发现，通常情况下，

00:01:37.799 --> 00:01:42.840
项目或注册表出现，我们仍然必须决定如何运输

00:01:42.840 --> 00:01:47.549
这些模块，并使其到达将要使用的计算机

00:01:47.549 --> 00:01:52.770
我们必须处理更新，尤其是安全补丁

00:01:52.770 --> 00:01:57.360
为此，我们必须确保每次我们推送更新时都不会中断

00:01:57.360 --> 00:02:02.340
所有这些通过破坏用户空间结构的用户应用程序也非常

00:02:02.340 --> 00:02:05.579
我们在处理模块管理时的一个重要问题，因为取决于

00:02:05.579 --> 00:02:10.259
关于结构以及我们如何组织模块，我们可以对其进行调整以提高性能

00:02:10.259 --> 00:02:13.260
节省带宽，节省空间

00:02:13.260 --> 00:02:19.680
和速度以及如何检查我实际正在运行的是我想要的

00:02:19.680 --> 00:02:25.050
排在第一位，甚至像清单上那样，拥有所有权的人

00:02:25.050 --> 00:02:29.790
允许更改它的模块谁可以在哪里运行以及可以做什么

00:02:29.790 --> 00:02:36.120
我们可以到达，这就像一些，但是非常像大多数

00:02:36.120 --> 00:02:40.230
我们去做软件包管理器时必须要提出的重要问题或

00:02:40.230 --> 00:02:45.750
一个模块管理工具，如果这些东西看起来很我不知道

00:02:45.750 --> 00:02:50.130
这些问题似乎有明显的解决方案，这是因为在node.js中

00:02:50.130 --> 00:02:55.290
社区，我们非常宠爱，我们拥有NPM，而NPM就像万灵药一样

00:02:55.290 --> 00:03:02.519
当NPM出现时，模块管理变得非常聪明

00:03:02.519 --> 00:03:07.530
例如20或30年前不可能的设计实现

00:03:07.530 --> 00:03:13.110
如今，它存储便宜，带宽几乎是免费的，而且在早期

00:03:13.110 --> 00:03:16.380
诸如UNIX管道之类的东西出现了，这也是它们出现的原因之一

00:03:16.380 --> 00:03:19.650
是因为他们不能在内存中提出大问题，所以他们创造了

00:03:19.650 --> 00:03:24.900
他们今天可以将它们连接在一起的小型独立程序NPM是

00:03:24.900 --> 00:03:31.319
甚至可以像多次下载模块一样做出决定

00:03:31.319 --> 00:03:36.030
如果他们必须重复相同的下载并创建此依赖关系树，

00:03:36.030 --> 00:03:40.680
就像解决模块管理的许多问题一样，它们确实存在

00:03:40.680 --> 00:03:44.160
平坦的依赖树，但像开始时一样决定下载

00:03:44.160 --> 00:03:48.359
该模块一遍又一遍地解决了所有问题，而且就像

00:03:48.359 --> 00:03:51.780
易于共享，就像NPM发布一样，我们可以将模块推送到

00:03:51.780 --> 00:03:55.769
注册表，很容易发现，也很有趣，我们有一个不错的网页，

00:03:55.769 --> 00:04:00.359
可以寻找别人的代码，就像我说的那样

00:04:00.359 --> 00:04:03.359
依赖度，我们有多自由，模块之间永远不会发生冲突

00:04:03.359 --> 00:04:07.859
版本和pm实际上应该是所有其他软件包的案例研究

00:04:07.859 --> 00:04:11.970
经理甚至几乎说其他语言仍在与之抗争

00:04:11.970 --> 00:04:15.780
他们的模块管理工具已经存在，例如NPM

00:04:15.780 --> 00:04:21.269
证明了它的概念，尽管残局真的很棒而且下午仍然

00:04:21.269 --> 00:04:26.520
生活在网络上，这是我们逐渐依赖和依赖的神经网络

00:04:26.520 --> 00:04:32.099
以及可以在网络上部署新应用和服务的系统

00:04:32.099 --> 00:04:36.629
如果我们输了，拥有像超级大国一样具有新功能的用户非常脆弱

00:04:36.629 --> 00:04:40.460
与骨干网的连接已消失，我们不能再使用它了，

00:04:40.460 --> 00:04:46.139
这样做有几个原因，但大多数原因是

00:04:46.139 --> 00:04:49.530
在网络的开头（即位置）中做出的设计决策

00:04:49.530 --> 00:04:55.169
寻址位置寻址使网络非常简单，我们有一个地址，或者我们

00:04:55.169 --> 00:04:58.409
有一个我们可以解析到该地址的名称，此位置成为我们的地址

00:04:58.409 --> 00:05:02.520
我们正在寻找的文档的中央授权点

00:05:02.520 --> 00:05:06.060
这在网络中翻译是，如果我要查找某些文件，我只需要

00:05:06.060 --> 00:05:10.069
找到它负责的机器，哦，他们负责该文件，

00:05:10.069 --> 00:05:15.990
尽管很简单，但不一定能满足所有用例

00:05:15.990 --> 00:05:23.520
我们今天可以避免在这个房间等我们的处置，如果我或

00:05:23.520 --> 00:05:28.409
这里的某人想要与其他所有人共享一包mojo，

00:05:28.409 --> 00:05:33.240
发布一个下午，然后其他所有人都必须去一个下午并获取此内容

00:05:33.240 --> 00:05:37.380
模块的问题就像如果我们失去与NPM的连接会发生什么情况

00:05:37.380 --> 00:05:42.650
到骨干，就像酒店互联网断开连接，

00:05:42.650 --> 00:05:47.849
我们不能再访问该模块了，这很奇怪，因为

00:05:47.849 --> 00:05:50.940
就像模块在同一房间里一样，就像我们无法访问它一样

00:05:50.940 --> 00:05:55.620
我们拥有所有这些机器以及所有这些资源，并且

00:05:55.620 --> 00:05:59.729
功能，但我们并未充分利用它，有几个

00:05:59.729 --> 00:06:03.449
网络中的其他问题情况不连贯

00:06:03.449 --> 00:06:08.520
通过网络大部分被踢的事实来实现带宽永久性安全

00:06:08.520 --> 00:06:13.349
物联网之外，还有控制和审查方面的问题，但

00:06:13.349 --> 00:06:17.430
是的，就像位置地址一样，是造成这些问题的根本原因之一

00:06:17.430 --> 00:06:22.770
所有其他的东西，这就是ipfs伴随而来的ipfs代表

00:06:22.770 --> 00:06:28.050
星际文件系统和名称是对CGC的致敬，其中

00:06:28.050 --> 00:06:33.539
设计思想和工作确实激发了他们最初的互联网，这些互联网的名称

00:06:33.539 --> 00:06:39.100
趋向于星际网络，你真的会感觉像发射

00:06:39.100 --> 00:06:44.860
当有人设定建立星际的目标时的原始项目

00:06:44.860 --> 00:06:49.900
网络，我们决定建造星际飞船，因为它确实磨损了

00:06:49.900 --> 00:06:55.420
以及像IP上的网络文件系统一样的想法

00:06:55.420 --> 00:06:59.380
FS是一种协议，可用于升级Web以使其正常工作以使其更智能

00:06:59.380 --> 00:07:03.190
使它分发以使其永久化，从而使其更安全，并且

00:07:03.190 --> 00:07:08.560
特别是如果我们不加快网络速度，它将永远看不到

00:07:08.560 --> 00:07:13.210
最后我们需要实际产生影响和ipfs的采用

00:07:13.210 --> 00:07:17.740
确实是一些非常好的想法的集合，这些想法在系统中可用

00:07:17.740 --> 00:07:21.820
今天我们知道像BitTorrent一样，我猜想FS和来自学院的其他人一样

00:07:21.820 --> 00:07:26.470
并且每个DS都将所有这些想法真正地融合在一起，并创建了一个系统，

00:07:26.470 --> 00:07:31.930
将它部署到网络上，这是ipfs堆栈，也是查看它的另一种方式

00:07:31.930 --> 00:07:37.810
我们当然有使用IP FS的用户并正在创建应用程序吗？

00:07:37.810 --> 00:07:41.860
拥有基于David Mystery's York的命名系统，并具有自我认证

00:07:41.860 --> 00:07:45.250
文件系统，我们有默克尔平台，默克尔平台是

00:07:45.250 --> 00:07:48.910
ipfs Merkabah reg使我们能够与众不同

00:07:48.910 --> 00:07:53.770
在网络上不可变且可变的链接之间，使我们能够创建

00:07:53.770 --> 00:07:58.360
更好的缓存策略，并抢先在网络上移动内容

00:07:58.360 --> 00:08:01.870
然后我们有一个Wii对等网络，这是我们的网络堆栈，现在我们

00:08:01.870 --> 00:08:05.590
连接并发现其他同龄人，这是奇迹般的一天，就像

00:08:05.590 --> 00:08:12.730
第一个问题就像默克尔的名字在哪里来自默克尔·迈克尔

00:08:12.730 --> 00:08:18.580
甲板意味着我们有一个图在那里实际上直接执行图，我们

00:08:18.580 --> 00:08:23.920
在该图中有链接，并且这些链接是不可变的，例如，如果我想要

00:08:23.920 --> 00:08:28.210
连接这两个数据，我只需要灰

00:08:28.210 --> 00:08:33.430
第一部分，将这些灰烬添加到第二部分中，现在我有了一个不可变的

00:08:33.430 --> 00:08:38.680
链接，我总是有一种方法可以随时告诉我所指的是哪一个

00:08:38.680 --> 00:08:43.150
我们将其称为Merkel链接，因为最初的想法来自Ralph C

00:08:43.150 --> 00:08:46.420
默克尔与奇迹树，但这

00:08:46.420 --> 00:08:49.900
意识到我们不是第一个进行可视化的人，就像我们拥有所有

00:08:49.900 --> 00:08:54.480
我们每天使用的系统也使用默克尔链接或默克尔

00:08:54.480 --> 00:08:58.680
眼睛数据结构类似于get是其中之一，但get是一个奇迹树，

00:08:58.680 --> 00:09:01.829
如果使用相同的策略，则闪耀是标记数据结构的标记，并且

00:09:01.829 --> 00:09:07.019
还有其他的权利，像这样的默克尔树和

00:09:07.019 --> 00:09:14.430
无论谁说，这些几种实现方式都可以由我们使用

00:09:14.430 --> 00:09:21.180
就像金钱不会在树上生长，我没想到比特币会出现

00:09:21.180 --> 00:09:27.389
ipfs ipfs就像默克尔森林一样，这里是所有奇迹的地方

00:09:27.389 --> 00:09:33.480
树木可以一种有凝聚力的方式快乐地生活，并且只是为了解释和

00:09:33.480 --> 00:09:38.579
说明默克尔链接的强大功能让我喜欢带来

00:09:38.579 --> 00:09:46.019
SV的CB SS V n与给猫的行为有关，因此请记住，

00:09:46.019 --> 00:09:52.709
将代码传送到CBS和sv n如果网络中断，我们将无法工作

00:09:52.709 --> 00:09:56.129
就像我们无法再提交代码一样，然后我保留服务器，但是我

00:09:56.129 --> 00:10:00.420
倒下或被摧毁，我们所有的工作也将简单地消失，

00:10:00.420 --> 00:10:04.379
然后我喜欢它的出现并基本上完全改变了它的范式

00:10:04.379 --> 00:10:08.129
说，让我们把所有参与这些交易的实体

00:10:08.129 --> 00:10:11.970
说相同的协议并全面实施意味着什么

00:10:11.970 --> 00:10:16.559
就像我们可以切断连接，并且它仍然可以正常工作一样，我们可以

00:10:16.559 --> 00:10:22.889
销毁服务器，并且用户仍然可以使用其他方式来传输数据，如果

00:10:22.889 --> 00:10:26.970
这是我的电子邮件或USB或类似局域网，没关系，它仍然会

00:10:26.970 --> 00:10:30.959
工作，我们仍然可以改善我们的产品，继续开展我们的项目

00:10:30.959 --> 00:10:37.769
而ipfs基本上是针对整个网络执行此操作，因此请再次在ipfs器官

00:10:37.769 --> 00:10:43.980
ipfs数据中的merkel包形成了一个套牌，再次称为奇迹日

00:10:43.980 --> 00:10:47.699
因为链接是加密的灰烬，任何数据结构都可以

00:10:47.699 --> 00:10:54.120
表示为UNIX文件和目录中的一盘广告

00:10:54.120 --> 00:10:59.069
商店，甚至有人在IP FS之上的SQL数据库上工作，

00:10:59.069 --> 00:11:02.790
与我们今天拥有的网络相比，它具有不可思议的优势

00:11:02.790 --> 00:11:04.990
我们已经习惯了这个主意，哦，老兄

00:11:04.990 --> 00:11:09.520
解析到我们喜欢FSU的位置，其名称可以解析为Content

00:11:09.520 --> 00:11:13.660
灰，以便我们可以链接到我们在第一个中寻找的内容

00:11:13.660 --> 00:11:18.760
再来一次是因为我们有这样的想法，就像我们正在寻找

00:11:18.760 --> 00:11:24.280
某些服务器和ipfs中的资源意味着像我正在通过以下方式查找内容

00:11:24.280 --> 00:11:27.910
灰烬，所以我喜欢从已经完成所有这些工作的其他同伴那里获取

00:11:27.910 --> 00:11:32.140
内容或类似内容，请确保如果我已经完成所有内容，

00:11:32.140 --> 00:11:36.970
可以通过检查灰烬来验证我的本地计算机中是否包含内容

00:11:36.970 --> 00:11:44.050
这是我们可以用来创建不可变数据并用于

00:11:44.050 --> 00:11:47.050
非常有效地在网络中移动它，但是新的

00:11:47.050 --> 00:11:50.890
就像我们可以使用DNS来实现可变性一样，

00:11:50.890 --> 00:11:54.760
在这些域记录上使用磷灰石的指针，但是我们必须输入是否必须

00:11:54.760 --> 00:11:59.050
真的非常快，所以我们在中间添加了一层

00:11:59.050 --> 00:12:03.010
称为IP NS，因此不仅可以为网络构建文件系统，而且还可以

00:12:03.010 --> 00:12:09.670
Web和IP NS的命名系统基本上是中间的一层

00:12:09.670 --> 00:12:13.930
是一个可变的指针，而我创建该可变指针的方式

00:12:13.930 --> 00:12:19.600
公钥和私钥对的密钥，我得到了我创建的公钥的灰烬

00:12:19.600 --> 00:12:24.670
一条记录，我用我要指向的灰烬创建一条记录，然后对此签名

00:12:24.670 --> 00:12:28.510
用我的私钥录制并将其部署到网络，以便在其他对等方时

00:12:28.510 --> 00:12:32.170
正在寻找这种公钥的灰烬，他们不仅可以卸载

00:12:32.170 --> 00:12:36.430
从网络记录但也验证签名并具有相同的

00:12:36.430 --> 00:12:43.920
那种信任，你会把权力放在一个中心点，所以是的，所以我们

00:12:43.920 --> 00:12:50.290
知道如何做不可变的文件，知道如何构造类似的目录和

00:12:50.290 --> 00:12:54.880
通过奇迹袋在ipfs里面的文件，我们有可变的指针

00:12:54.880 --> 00:13:00.460
我们可以在网络本身和网络上找到所有这些文件的所有这些数据吗？

00:13:00.460 --> 00:13:05.560
秘密是HTS分布式哈希表，这些就像

00:13:05.560 --> 00:13:09.040
点对点网络以及我教这些工作的方式，我只是想

00:13:09.040 --> 00:13:14.140
给出katene概述，就像您在网络上为每个节点（如HP）一样

00:13:14.140 --> 00:13:18.000
一个ID，您就拥有这样的一个维度

00:13:18.000 --> 00:13:21.900
想法，每次您想将文件设置到网络上时，您只需要简单地执行操作即可

00:13:21.900 --> 00:13:26.160
该文件获取其ID，并在上面放一些指针，例如在上面撒一些指针

00:13:26.160 --> 00:13:30.660
那些具有更接近于我文件概念的ID的节点，所以当有人

00:13:30.660 --> 00:13:35.700
在该文件之后，它将联系再次接近该ID的节点

00:13:35.700 --> 00:13:42.960
并查看指针，并查看文件所在节点的位置，这样

00:13:42.960 --> 00:13:48.420
是一个非常快速的概述，我们当然可以在谈话后进行更深入的探讨，但是

00:13:48.420 --> 00:13:52.170
你们会发现IPFS到IP NS的发现，您会得到完整性

00:13:52.170 --> 00:13:55.470
通过加密散列，您可以获得活动，因为在对等网络中

00:13:55.470 --> 00:13:59.070
您遇到Universe缩放问题的网络中，下载的人越多

00:13:59.070 --> 00:14:03.660
归档您服务的人越多，因此比所有的人都多

00:14:03.660 --> 00:14:06.900
您具有结构性，因为自从您只需要下载一次内容即可

00:14:06.900 --> 00:14:10.770
可以通过您的骨灰验证您已有的联系人

00:14:10.770 --> 00:14:14.670
您可以同时从多个同伴获得极限的运输

00:14:14.670 --> 00:14:17.300
只需同步更改即可移情，您便拥有所有权的想法

00:14:17.300 --> 00:14:22.110
因为像IP NS记录地址一样是由私钥签名的，这些是

00:14:22.110 --> 00:14:27.270
这样的功能列表非常相似，基本上可以匹配所有

00:14:27.270 --> 00:14:35.450
包管理的需求，所以只需要一个天文台的序言就可以了

00:14:35.450 --> 00:14:40.860
应用于PM，如果我们使用它，我们可以从这样的系统中得到什么

00:14:40.860 --> 00:14:45.780
作为运输我们的npm模块的运输工具，为此，我有一个

00:14:45.780 --> 00:14:51.470
演示给你看，就像我一样

00:14:56.350 --> 00:15:04.010
你是我的否认，好吧，每个人都可以看到

00:15:04.010 --> 00:15:08.210
所以我要做的第一件事就是启动ipfs恶魔

00:15:08.210 --> 00:15:16.520
首先需要它，我想从头开始，我必须启动我的PFS恶魔，所以

00:15:16.520 --> 00:15:26.960
我是网络的一部分，然后我们创建了一个名为

00:15:26.960 --> 00:15:38.030
注册表镜像，我要告诉-注册表镜像，我想要一个代理

00:15:38.030 --> 00:15:43.880
我想在本地以及有人请求模块使用时模拟NPM API

00:15:43.880 --> 00:15:47.870
 ipfs为我下载该模块，如果我要再次选择端口

00:15:47.870 --> 00:15:54.260
-只是为了方便起见，我必须说我想将其作为一个文件来运行

00:15:54.260 --> 00:16:02.690
守护程序是真的，所以现在注册表镜像正在运行什么

00:16:02.690 --> 00:16:08.090
如果他在做的话就像是从BFS网络中获取最新状态

00:16:08.090 --> 00:16:16.930
注册表似乎我遇到了一些网络问题，但是我已经做好了准备

00:16:16.930 --> 00:16:21.580
录制视频只是确保我

00:16:21.850 --> 00:16:28.310
所以是的，我不喜欢测试它的功能，所以喜欢演示该演示

00:16:28.310 --> 00:16:32.330
正确的，所以当我展示我们需要恶魔时

00:16:32.330 --> 00:16:37.970
我们运行ipfs恶魔，然后启动恶魔，然后连接到网络。

00:16:37.970 --> 00:16:47.330
这个注册表镜像的东西，我们说我们要在端口上使用ipfs启动它

00:16:47.330 --> 00:16:53.300
连接网络会像NPM的最新状态一样获取列表，例如

00:16:53.300 --> 00:16:58.970
灰烬列表，这些灰烬纠正了模块的所有模块版本的形式

00:16:58.970 --> 00:17:06.260
及其所有版本，然后我说我想使用

00:17:06.260 --> 00:17:10.860
这个本地注册表这个本地代理，它并没有停止，所以就像我们

00:17:10.860 --> 00:17:17.850
通过桥接从NPM安装NPM中的模块

00:17:17.850 --> 00:17:21.300
ipfs，但真正酷的部分就像我们一直喜欢的，我已经从

00:17:21.300 --> 00:17:24.840
NPM是正确的，所以真正很酷的部分就像当我进入断开连接时一样

00:17:24.840 --> 00:17:29.820
环境如果我想在飞机上工作，在网络中的情况下怎么办

00:17:29.820 --> 00:17:34.950
带宽很低，而且我与骨干网之间没有很好的连接，因此

00:17:34.950 --> 00:17:41.670
那就是ifs的美丽，就像在这里展示给我一样，这就是

00:17:41.670 --> 00:17:46.680
我刚更改为正在互联网上使用其他虚拟机的虚拟机

00:17:46.680 --> 00:17:52.130
接口和另一辆无线车，我在这里连接到同一路由器

00:17:52.130 --> 00:18:04.830
这样我就可以选择两台单独的机器执行相同的过程，然后我

00:18:04.830 --> 00:18:13.170
就像开始粉红色一样，等待，不，不，哦，天哪，所以我只想玩

00:18:13.170 --> 00:18:17.700
好吧，所以我刚刚开始ping以表明我已经连接好了，现在

00:18:17.700 --> 00:18:20.490
我要做的就像是您永远不想做的事

00:18:20.490 --> 00:18:29.280
互联网，我的天哪，数据在哪里，现在为什么呢？

00:18:29.280 --> 00:18:34.470
认为您会发生，并且我想尝试安装任何相同的方法

00:18:34.470 --> 00:18:40.050
墙会做一些相同局域网的另一台机器，我会

00:18:40.050 --> 00:18:50.910
说鼓，它就安装了，所以这里发生的事情是我们设法找到了

00:18:50.910 --> 00:18:55.350
所以我觉得两个ipfs恶魔都在局域网中找到了彼此，

00:18:55.350 --> 00:18:57.930
刚刚宣布彼此哦，我有你正在寻找的模块

00:18:57.930 --> 00:19:03.990
从我这里获取它就像节省大量带宽一样

00:19:03.990 --> 00:19:13.620
网络，所以是的，这是我的演示，可以继续继续我的演讲

00:19:13.620 --> 00:19:19.100
我们可以分发此点对点

00:19:20.250 --> 00:19:23.190
注册表仍然是注册表，我们继续拥有这个

00:19:23.190 --> 00:19:27.480
一点，我们可以信任来获取我们的模块并发现这些模块，但是

00:19:27.480 --> 00:19:32.430
现在，我们不仅可以从NPM数据服务器中卸载它，还可以

00:19:32.430 --> 00:19:37.050
就像从我们的朋友计算机中获取它，我们的邻居计算机一样

00:19:37.050 --> 00:19:40.710
每个人都有在其机器和物质上可用的模块的其他任何人

00:19:40.710 --> 00:19:46.230
而2013年2月13日，LX提出了这个想法，现在终于

00:19:46.230 --> 00:19:50.700
就像我们发现可以做到的那样，我们最终可以有一个分布式NPM

00:19:50.700 --> 00:19:57.270
并确保不仅可以使用它来使我们的操作更快，而且

00:19:57.270 --> 00:20:00.990
我们可以将这项技术带到带宽较低的国家/地区

00:20:00.990 --> 00:20:04.380
以及更多断开连接的场景，使他们能够使用我们所使用的模块

00:20:04.380 --> 00:20:11.120
正在提供NPM，我认为这很棒，不像强制性的

00:20:11.900 --> 00:20:18.720
很酷，所以我实际上不知道我的时间，实际上我已经超时了，是的，谢谢

00:20:18.720 --> 00:20:22.970
为了您的关注并留在这里

