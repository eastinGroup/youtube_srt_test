WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.060 --> 00:00:04.470
就像他说的我是马克·夏皮罗（Mark Shapiro）一样，我实际上是在巴黎工作，

00:00:04.470 --> 00:00:07.919
大学理科大学我是那边的阿里·库利

00:00:07.919 --> 00:00:14.690
所以今天我们将和nuno一起告诉您有关您的职责的更多信息，我

00:00:14.690 --> 00:00:18.660
假设你们中的大多数人都读过这些论文，所以我们不会过多地讨论

00:00:18.660 --> 00:00:25.230
什么是合作DG的细节，但更多关于设计理念和内容

00:00:25.230 --> 00:00:28.189
我们在过去几年中学到了

00:00:28.429 --> 00:00:32.820
所以我们都知道云计算，我们遇到的问题被称为

00:00:32.820 --> 00:00:37.649
计算，我们有副本，我们有复制的数据库

00:00:37.649 --> 00:00:44.969
不同的数据中心延迟失败等，因此，由于所有这些原因，

00:00:44.969 --> 00:00:49.620
要在不同位置复制数据，请尽可能将数据移近

00:00:49.620 --> 00:00:55.350
用户可以在旁边运行您的应用程序逻辑

00:00:55.350 --> 00:01:02.579
数据库旁边的数据，并且为了具有可用性，您希望能够

00:01:02.579 --> 00:01:07.500
在不同步的情况下接受所有不同副本的读取和更新

00:01:07.500 --> 00:01:14.549
因为同步很昂贵，如果有问题就无法使用

00:01:14.549 --> 00:01:20.790
这是我们的出发点，我们一直在尝试做的是

00:01:20.790 --> 00:01:25.799
让程序员更容易使用，因此您当然可以

00:01:25.799 --> 00:01:31.799
我们都知道键值存储，并且没有续集数据库

00:01:31.799 --> 00:01:36.210
尝试将一个级别提升到更有用的更高级别的抽象

00:01:36.210 --> 00:01:42.119
对用户对开发人员而言，我们要做的另一件事是对

00:01:42.119 --> 00:01:46.140
未来，所以今天也许您会知道周围有数十个数据中心

00:01:46.140 --> 00:01:50.759
世界，但是这种情况正在迅速改变，越来越多的人

00:01:50.759 --> 00:01:55.710
了解5g革命即将到来的数据位置

00:01:55.710 --> 00:02:00.540
很快，电话运营商将在每个基地建立一个数据中心

00:02:00.540 --> 00:02:04.979
站点，因此周围将有成千上万个数据中心

00:02:04.979 --> 00:02:08.610
这个世界，您将不得不将您的复制品放到Harran并进行管理

00:02:08.610 --> 00:02:13.620
并且您希望能够真正将您的应用程序逻辑转移到

00:02:13.620 --> 00:02:16.650
所以他只有你知道几微秒

00:02:16.650 --> 00:02:23.760
您知道从击键到或鼠标移动到到响应以及什么

00:02:23.760 --> 00:02:28.800
我们想要做的是，我们要移动我们今天可能会提供的担保

00:02:28.800 --> 00:02:34.620
在数据中心中，这些副本非常接近，所以您知道我们不在

00:02:34.620 --> 00:02:36.990
显然，但将来的某个时候

00:02:36.990 --> 00:02:44.040
我们将必须能够管理您知道成千上万个副本和

00:02:44.040 --> 00:02:52.950
当然以容错的方式做到这一点，所以我们提出的方法是

00:02:52.950 --> 00:02:57.840
称为无冲突的复制数据类型，请参见我们的职责和

00:02:57.840 --> 00:03:03.270
首先，这里的见解是一种数据类型，因此它被很好地封装并且

00:03:03.270 --> 00:03:08.610
您将丑陋的方面隐藏在一个不错的您知道的界面后面

00:03:08.610 --> 00:03:14.610
用户很熟悉，当然它是在多个节点上复制的，但是方式

00:03:14.610 --> 00:03:20.550
复制的是，为了确保可用性，我们首先

00:03:20.550 --> 00:03:24.450
随时准备接受更新，因此更新可以并发

00:03:24.450 --> 00:03:30.930
并且未同步，但我们仍然保证您的数据最终会

00:03:30.930 --> 00:03:36.540
会聚，并且不只是寄存器可以读取和写入

00:03:36.540 --> 00:03:42.269
它是更高级别的数据类型，例如集合，图形或序列，或者您知道

00:03:42.269 --> 00:03:48.540
复杂的东西对应用程序程序员更有用，我会

00:03:48.540 --> 00:03:53.250
没有详细介绍我们如何证明这一点，但是在您知道的论文中

00:03:53.250 --> 00:03:56.820
您只是遵循一些非常明确的数学性质，但这仅仅是

00:03:56.820 --> 00:04:01.530
确实有一些非常简单的设计规则，您将确保这些事情将

00:04:01.530 --> 00:04:05.790
将会收敛，并且由于这种设计，一切都分散了，

00:04:05.790 --> 00:04:09.930
一切都以非常纯粹的方式发生，所以为什么有人会使用

00:04:09.930 --> 00:04:14.700
这些数据类型首先很好，因为如果它们确保可用性，

00:04:14.700 --> 00:04:19.500
您，如果可用性不是您生活中的主要动机，我的意思是忘记对不起T

00:04:19.500 --> 00:04:23.430
并忘记了并行性，因为您知道并行性也可以按顺序执行，这很多

00:04:23.430 --> 00:04:28.610
更容易，更简单，更熟悉，所以如果您知道

00:04:28.610 --> 00:04:32.750
可用性是您的事，那么也许手术T是您想要的事

00:04:32.750 --> 00:04:41.270
像我说的那样看手术T是更高级别的数据类型，所以如果您不需要的话

00:04:41.270 --> 00:04:44.030
更高级别的数据类型，如果您知道读写的话，就可以了

00:04:44.030 --> 00:04:48.470
注册表键值存储区一定适合您的应用程序

00:04:48.470 --> 00:04:55.580
那但你知道你是否拥有，如果你拥有，就像我不知道一些

00:04:55.580 --> 00:04:59.270
具有高度可变和高度分布的游戏状态的分布式游戏

00:04:59.270 --> 00:05:03.350
超过一万个副本，也许这就是您遇到的方式

00:05:03.350 --> 00:05:06.560
您应该看一下移动计算还有另一个例子

00:05:06.560 --> 00:05:10.760
因为您知道您的移动计算机可能会与计算机完全断开连接

00:05:10.760 --> 00:05:14.900
网络，并且您希望能够进行区域和更新，即使

00:05:14.900 --> 00:05:18.170
您已断开连接，并确保当您重新融合时

00:05:18.170 --> 00:05:24.110
重新连接它还有助于在数据中心内进行侦听以获取更多信息

00:05:24.110 --> 00:05:32.900
数据中心内部的并行性避免了避免同步，因此一些

00:05:32.900 --> 00:05:37.820
这些概念是一些设计思想，因此首先是数据类型

00:05:37.820 --> 00:05:44.210
应该很熟悉，所以酸度应该尽可能地接近

00:05:44.210 --> 00:05:50.080
到您的顺序设置权限，并具有添加和删除的相同操作

00:05:50.080 --> 00:05:55.520
集合和图中的元素应该看起来像图形的cetera，但是

00:05:55.520 --> 00:06:00.830
当然，您知道是否需要并发，那么您必须要做一些

00:06:00.830 --> 00:06:08.050
接受一些您需要降低期望值的方法，但有些奇怪，但是无论如何

00:06:08.050 --> 00:06:13.610
您需要成为顶级位的一种，您需要向后兼容

00:06:13.610 --> 00:06:17.600
具有顺序数据类型，这并没有写到论文中，因此非常明显

00:06:17.600 --> 00:06:24.170
我们从来没有说过，但这实际上是一个非常重要的财产，第二个

00:06:24.170 --> 00:06:28.940
原则是您希望您的操作通勤，因为如果您有

00:06:28.940 --> 00:06:33.590
更新通勤权的操作，那么顺序无关紧要

00:06:33.590 --> 00:06:37.550
他们收到了，所以如果我知道您在这里进行的一些操作，那就是

00:06:37.550 --> 00:06:40.540
这里的其他操作V某人可能会收到您

00:06:40.540 --> 00:06:44.170
跟着V别人可能会收到V跟着你，但是它

00:06:44.170 --> 00:06:47.830
没关系，如果您的操作已经在

00:06:47.830 --> 00:06:52.930
顺序数据类型，您可以自由在家，所以您拥有类似自己所知道的东西

00:06:52.930 --> 00:06:57.340
如果我说的是集合，我可以进行一些操作，例如添加元素II和

00:06:57.340 --> 00:07:01.390
删除集合，换个元素F可以，因为D跟随

00:07:01.390 --> 00:07:06.550
通过删除F，您知道集合中的F不在集合中，即使是这样，也是如此

00:07:06.550 --> 00:07:13.420
如果您很自然地将两者交换并发一个D并删除F应该有

00:07:13.420 --> 00:07:22.420
完全相同的语义，但是如果您的操作无法进行通勤，那么

00:07:22.420 --> 00:07:28.570
您有一个设计选择，您需要做的是确保这两个

00:07:28.570 --> 00:07:32.830
不会按顺序进行通勤的并发操作仍然

00:07:32.830 --> 00:07:38.530
想出一个，例如，我是否收到也没关系

00:07:38.530 --> 00:07:44.740
删除并添加相同的元素对它顺序不是

00:07:44.740 --> 00:07:48.130
如果我使用Ruby，然后再进行DI运算，则可以计算出正确的e值

00:07:48.130 --> 00:07:53.080
集合，但是如果我通过Ruby进行默认设置，我希望我不在集合中，所以我有

00:07:53.080 --> 00:07:59.020
做出一些设计决策的选择，所以它必须是确定性的，以便

00:07:59.020 --> 00:08:02.620
不论它们的顺序如何，所有副本都得出相同的结论

00:08:02.620 --> 00:08:08.590
接受了这些操作，因此必须确定

00:08:08.590 --> 00:08:13.540
破坏悲伤的同意的本质，但它也应该可以解释为

00:08:13.540 --> 00:08:18.730
用户和开发人员，因此您希望它尽可能靠近

00:08:18.730 --> 00:08:22.210
顺序执行，不可能完全一样好吗

00:08:22.210 --> 00:08:27.700
有时异常会显示出来，但您应该知道它应该很近

00:08:27.700 --> 00:08:34.440
足够，可以说没有足够的措施，但是足够接近，所以

00:08:34.440 --> 00:08:40.870
基本上，如果您知道我是否在E上有并发删除Ian，那么您会说得很好

00:08:40.870 --> 00:08:45.850
我将选择这两种解决方案之一，让您知道我会决定的很好

00:08:45.850 --> 00:08:49.630
在那种情况下，at应该赢，或者我会决定remove应该赢，但是它

00:08:49.630 --> 00:08:51.459
没关系，它必须是确定性的

00:08:51.459 --> 00:08:56.390
好的，当然您也不想丢失更新，所以最后一个骑手

00:08:56.390 --> 00:09:01.610
赢得了例如在键值存储中被广泛使用的方法

00:09:01.610 --> 00:09:07.630
他们从这种意义上讲通勤，但它们很丑，因为您丢失了更新

00:09:07.630 --> 00:09:13.089
一会儿我会谈到稳定的前提条件

00:09:13.089 --> 00:09:21.260
因此，联谊会是一个学术概念，于2009年发布，主要

00:09:21.260 --> 00:09:26.870
纸张是2011年，但它们已经被行业所采用，其中一些是

00:09:26.870 --> 00:09:30.709
好公司这些是我们所知道的公司已经宣布

00:09:30.709 --> 00:09:37.130
以某种方式在内部实际使用CRT T，因此我们必须

00:09:37.130 --> 00:09:44.899
在这里做某事，我将谈论其中一个人，我

00:09:44.899 --> 00:09:50.540
房间里可能有bet365的人，他们会纠正我的

00:09:50.540 --> 00:09:54.500
如果我说些愚蠢的话，这就是我从他们的网站中学到的知识，

00:09:54.500 --> 00:09:59.420
您知道他们发布的视频我没有任何特别的见识知识

00:09:59.420 --> 00:10:05.480
好的，但是好的，这些显然是欧洲最大的

00:10:05.480 --> 00:10:09.950
在线博彩运营商，他们有一个非常低的低点，他们有两个，

00:10:09.950 --> 00:10:15.020
在任何时间点都有50万用户

00:10:15.020 --> 00:10:21.709
数据一个TB的工作集中，我不确定该工作集中的内容是什么，但是II

00:10:21.709 --> 00:10:27.079
知道该工作集的很大一部分实际上存储在C中

00:10:27.079 --> 00:10:37.490
最高要求的职责和种类是他们必须

00:10:37.490 --> 00:10:41.930
可用，因此用户必须能够在任何时间下注

00:10:41.930 --> 00:10:48.290
不管他们的足球比赛是什么，即使他们的服务器之一，您也知道

00:10:48.290 --> 00:10:55.220
失败了，他们也希望一些结果是可以理解的

00:10:55.220 --> 00:10:59.240
因此，最终的一致性还不够好，您必须具有某种

00:10:59.240 --> 00:11:04.370
单调，即如果我下注并查看数据库，我应该能够

00:11:04.370 --> 00:11:08.300
看看我的床是否正确或者我是否读过某人的

00:11:08.300 --> 00:11:12.440
你知道有人在一分钟后下注的一些结果，我应该看看

00:11:12.440 --> 00:11:15.769
数据库，仍然在那里找到它，如果您没有得到这些保证，

00:11:15.769 --> 00:11:21.079
您只是要求最终的一致性，而他们想要的是透明度

00:11:21.079 --> 00:11:25.430
希望结果可以向用户解释，所以这也是我认为的原因

00:11:25.430 --> 00:11:30.410
可能是他们选择考虑CEO职责和旧的原因

00:11:30.410 --> 00:11:34.820
几年前，他们使用续集服务器，发现那不是

00:11:34.820 --> 00:11:40.160
根本无法扩展，而当他们失败时，

00:11:40.160 --> 00:11:47.510
姐姐要转换，2013年中他们决定看看反应，这不是

00:11:47.510 --> 00:11:56.450
续集数据库，在可用性方面很好，但是当失败时

00:11:56.450 --> 00:12:02.899
发生了，他们想出了他们有兄弟姐妹的事实，事实确实如此。

00:12:02.899 --> 00:12:08.959
同一数据项有多个值，这使他们很难处理

00:12:08.959 --> 00:12:13.760
手动操作，所以他们决定在某些时候考虑首席执行官的职责，

00:12:13.760 --> 00:12:18.410
他们已经将近一年的时间了，实际上他们一直在生产中使用策略

00:12:18.410 --> 00:12:25.430
他们使用的是观察者移除集，该观察者由

00:12:25.430 --> 00:12:34.459
罗素（Russell）做出反应，我不知道他们如何使用它的细节，但是

00:12:34.459 --> 00:12:38.630
基本上，他们只是将这些下注放在下注盘中，在某些时候，他们会看

00:12:38.630 --> 00:12:45.020
这组，看看哪些赌注匹配，他们说这是

00:12:45.020 --> 00:12:50.390
从那时起，他们的开发人员对他们而言确实具有变革性

00:12:50.390 --> 00:12:54.560
可以专注于开发有趣的应用程序，而不是

00:12:54.560 --> 00:12:59.990
专注于调试您知道分布式系统中的异常

00:12:59.990 --> 00:13:04.940
每当发生故障时，它都会很快错误地重新收敛，并且

00:13:04.940 --> 00:13:09.920
我问他们你知道他们将来会想要些什么

00:13:09.920 --> 00:13:15.380
愿望清单，这样愿望清单就更具有相同的权利，因此他们会

00:13:15.380 --> 00:13:18.550
就像您知道可用性一样，所有

00:13:18.550 --> 00:13:23.500
但你知道更多关于你的保证，知道我可能想要

00:13:23.500 --> 00:13:33.760
一次更新两件事，而不仅仅是一次更新，所以我已经讲过

00:13:33.760 --> 00:13:40.750
关于这一点，我可以跳过这张幻灯片，所以设置有点像你所知道的

00:13:40.750 --> 00:13:44.260
荒诞的海报孩子，这是每个人都在寻找的东西

00:13:44.260 --> 00:13:48.990
在，但我不想让它变得太无聊，所以让我们发明一个新的数据类型

00:13:48.990 --> 00:13:56.470
好吧，新的意甲DT对吧，所以您开始了

00:13:56.470 --> 00:14:00.579
创业公司，您将要为自己管理婚礼清单，因为认识的人

00:14:00.579 --> 00:14:05.560
已婚，每个人都将在他们的iPhone上拥有他们的婚礼清单的副本

00:14:05.560 --> 00:14:10.690
好吧，这是我的婚礼清单，它让您知道我想要一台电视，我想要和

00:14:10.690 --> 00:14:15.579
我想知道您在威尼斯度蜜月的情况，这是电视的订购清单

00:14:15.579 --> 00:14:18.910
而且您知道，购买电视对我来说比去看电视更重要

00:14:18.910 --> 00:14:25.060
威尼斯，然后我当然会知道吗，所以我会指出一个

00:14:25.060 --> 00:14:28.329
列表中的项目，我会说好，我要添加一些正确的内容

00:14:28.329 --> 00:14:34.899
经过这一步之后，接下来去威尼斯做些看起来不那么重要的事

00:14:34.899 --> 00:14:39.160
都知道也许我不想去威尼斯，所以我将删除针对性的威尼斯

00:14:39.160 --> 00:14:50.020
然后说删除权，那么你知道我的配偶也会在她的副本上

00:14:50.020 --> 00:14:53.170
指出威尼斯，她不知道我删除了威尼斯，因为我们正在工作

00:14:53.170 --> 00:14:57.160
独立地和在不同的复制品上，所以她指着威尼斯说的很好

00:14:57.160 --> 00:15:01.930
你知道我也想去滑雪旅行，但是你知道那仍然

00:15:01.930 --> 00:15:07.690
对我来说更重要，然后在某些时候您知道数据将是

00:15:07.690 --> 00:15:12.820
交流，我们会聚，现在您看到威尼斯走对了，

00:15:12.820 --> 00:15:16.360
我添加的所有东西都在里面，它们在右边

00:15:16.360 --> 00:15:23.110
订购好吧，是的，所以你知道这是我想要的规格

00:15:23.110 --> 00:15:27.640
能够查找我的愿望清单中的内容，我希望能够添加一个

00:15:27.640 --> 00:15:32.470
希望进入我的列表，我想删除您，我很容易从列表中了解一些信息

00:15:32.470 --> 00:15:38.320
足够，所以我怎么能很好地实现它，基本上你知道这是一个链表

00:15:38.320 --> 00:15:44.890
对，我要向顺序链表中添加和删除元素，

00:15:44.890 --> 00:15:48.100
起始标记和结束标记，每次我想添加一些标记时

00:15:48.100 --> 00:15:52.750
只会说在此位置之后添加，所以让我们开始了解

00:15:52.750 --> 00:15:57.250
包含电视和威尼斯的列表，然后我将添加笔记本电脑，您知道

00:15:57.250 --> 00:16:02.140
在执行通常的链表操作时，我替换了您所知道的下一个指针

00:16:02.140 --> 00:16:07.360
在威尼斯笔记中，指向笔记本电脑的指针而不是指向

00:16:07.360 --> 00:16:11.260
终端和笔记本电脑指向终端，你知道你们都知道如何做链接

00:16:11.260 --> 00:16:16.660
清单，然后我可以做同样的事情，我会插入书籍，然后也许

00:16:16.660 --> 00:16:23.350
同时你知道哦，不，然后我要删除威尼斯，所以我要删除

00:16:23.350 --> 00:16:28.060
不允许立即将威尼斯从清单中删除，因为我的配偶

00:16:28.060 --> 00:16:32.800
可能是在威尼斯之后添加了一些东西，这正是发生在威尼斯的事情

00:16:32.800 --> 00:16:39.940
在我向您展示的示例中，我仍然可以在其中插入滑雪旅行

00:16:39.940 --> 00:16:49.740
在正确的位置好吧，如果我们在两个副本中插入两个副本，会发生什么情况

00:16:49.740 --> 00:16:55.480
两件事在同一位置，所以我想购买苹果公司的这款新无人机

00:16:55.480 --> 00:17:01.899
刚出来，你知道我的配偶比我不那么物欲飞扬，

00:17:01.899 --> 00:17:11.589
她希望世界和平，所以我们必须以任何方式解决这个问题

00:17:11.589 --> 00:17:14.949
只要确定性的权利就可以解决它，所以让我们

00:17:14.949 --> 00:17:20.110
按字母顺序解决它，我们已经完成，您可以在这里找到他们

00:17:20.110 --> 00:17:23.949
链表所需的数据类型，所以我作弊了

00:17:23.949 --> 00:17:29.770
真正发明了这就是所谓的RGA，它曾经是其中之一

00:17:29.770 --> 00:17:35.799
DT出版物，但可以放心一点，所以也许我们可以改善这一点

00:17:35.799 --> 00:17:43.929
是的，嗯，不，这看起来不对。我的意思是，世界和平绝对不可能

00:17:43.929 --> 00:17:49.860
比购买无人驾驶飞机重要的是，我想将世界和平提升到最高点

00:17:49.860 --> 00:17:55.779
是的，但同时我的配偶说世界和平

00:17:55.779 --> 00:18:02.139
这是没有任何意义的，你知道世界和平是无法实现的，所以

00:18:02.139 --> 00:18:06.509
不属于列表的顶部，我将其移至右下角，

00:18:06.509 --> 00:18:13.779
好吧，我们现在最终获得了世界和平，当然可以重复一遍，所以有些事情

00:18:13.779 --> 00:18:20.559
出问题了，好吧，这是您知道的我要提出的要求

00:18:20.559 --> 00:18:24.759
是的，我问这隐含的意思是这个东西不能在两个地方

00:18:24.759 --> 00:18:29.860
如果我在同一时间把它同时放在两个地方的话

00:18:29.860 --> 00:18:33.789
我的链表，但您知道那只是一个技术问题

00:18:33.789 --> 00:18:41.679
因此，实际上我刚刚添加了您，您知道了世界和平的两份副本，以及

00:18:41.679 --> 00:18:46.509
删除了单个的，所以我没有得到我想要的东西，另一件事是

00:18:46.509 --> 00:18:50.919
我想做的当然是您现在知道我有我的婚礼清单的人

00:18:50.919 --> 00:18:56.289
会给我买我的礼物，所以我父亲会说好吧，我标记我

00:18:56.289 --> 00:19:05.919
无人机，因为您知道我要购买AI无人机，然后再购买Russell

00:19:05.919 --> 00:19:10.779
真的很喜欢我的伴侣也说哦，我要给你买九头蛇，我们

00:19:10.779 --> 00:19:15.279
最终得到了两架“我”无人机的权利，这又不是我们想要的

00:19:15.279 --> 00:19:24.129
所以这里发生了什么，所以删除之间的区别是什么

00:19:24.129 --> 00:19:29.889
标记的东西正在被删除，并提供这也是这个标记的东西是

00:19:29.889 --> 00:19:35.950
被提供好吧，有很大的不同，所以我在这里写一个

00:19:35.950 --> 00:19:40.269
规格的妓女三重风格，所以在这里我有一个操作

00:19:40.269 --> 00:19:44.110
删除，然后向左是必须要做的事情的前提

00:19:44.110 --> 00:19:48.909
在执行此操作之前为true，因此有权对条件进行过帐

00:19:48.909 --> 00:19:54.309
事后应该是对的，所以当我删除时，我希望

00:19:54.309 --> 00:19:57.010
我已移除以标记为坟墓的东西

00:19:57.010 --> 00:20:02.080
好的，但是状态是什么也没关系，即使它是一个

00:20:02.080 --> 00:20:07.480
墓碑在没事之前就没事了，所以没有真正的先决条件，但是

00:20:07.480 --> 00:20:12.370
树皮在这里是正确的，而在移动情况或要约情况下，我要

00:20:12.370 --> 00:20:20.830
确保该项目是唯一的权利，因此该项目的不变性

00:20:20.830 --> 00:20:26.380
仅在此先决条件正确出现后，权利才出现，因此在

00:20:26.380 --> 00:20:31.779
如果要提供顺序执行，请确保没有

00:20:31.779 --> 00:20:36.190
之前被提供过，所以我有这个前提，还没有提供，我

00:20:36.190 --> 00:20:41.590
提供它，因此之后它将在提供的状态中，但是现在您

00:20:41.590 --> 00:20:46.600
看到只是看这个，你会看到如果我有两个同时执行的要约

00:20:46.600 --> 00:20:50.679
这些提议之一将违反另一个条件还可以的先决条件

00:20:50.679 --> 00:20:57.700
所以这就是为什么要约或要约无法正常工作的原因，我正在尝试

00:20:57.700 --> 00:21:02.110
保持不变，为了保持不变，我需要一个I

00:21:02.110 --> 00:21:06.549
需要一个前提条件，但并发操作违反了该前提条件

00:21:06.549 --> 00:21:13.380
所以我要说前提是不稳定的，来我们这里的人

00:21:13.380 --> 00:21:17.590
昨天的教程中，我们更详细地解释了这一点，但基本上

00:21:17.590 --> 00:21:23.169
有证据表明，如果所有不变量都对不起，如果所有

00:21:23.169 --> 00:21:27.850
前提条件在所有并发更新下都是稳定的，那么反转是

00:21:27.850 --> 00:21:35.740
保证，但是如果不是所有的赌注都没有，那么在我通过

00:21:35.740 --> 00:21:41.080
您知道的麦克风，因此，如果您需要可用性，则必须接受

00:21:41.080 --> 00:21:46.659
并发更新，您知道会有不良影响，但是您经常可以

00:21:46.659 --> 00:21:51.399
掩盖那些不变的不良影响，例如，如果我添加

00:21:51.399 --> 00:21:56.440
两次相同的事情还可以，我可以接受它们，

00:21:56.440 --> 00:22:05.860
隐藏第二种我想向后兼容的东西，如果有的话

00:22:05.860 --> 00:22:09.210
任何秘密，如果有人在其中使用我的CDT

00:22:09.210 --> 00:22:15.690
普通顺序程序，其效果应与

00:22:15.690 --> 00:22:22.860
顺序数据类型，如果两个操作通勤，那么我希望并发

00:22:22.860 --> 00:22:25.980
语义是相同的，但否则我必须选择一些

00:22:25.980 --> 00:22:30.030
再次确定性并足够接近，如果我想保持不变

00:22:30.030 --> 00:22:35.040
保持不变性，这是真的很新的东西，如果没有的话

00:22:35.040 --> 00:22:39.720
您想要保持不变，那么您需要确定的东西

00:22:39.720 --> 00:22:48.990
是您的前提条件是稳定的，所以现在我将尽力向您解释

00:22:48.990 --> 00:22:54.210
我们如何保持一些不变性，所以如果您看一下

00:22:54.210 --> 00:22:59.520
操作如此多的应用程序需要对24种形式的不变量

00:22:59.520 --> 00:23:04.920
某些计数器必须大于或等于K，例如，如果我们要计数

00:23:04.920 --> 00:23:10.140
包含一定数量广告的应用程序中的广告展示次数

00:23:10.140 --> 00:23:17.100
进行打印，因此，如果出现以下情况，则留下的印象数必须大于或等于零

00:23:17.100 --> 00:23:23.010
我们继续放置许多afikoman，好吧，我们希望太多以至于大于或等于

00:23:23.010 --> 00:23:29.400
当然是零，如果真的很多，我们也想向银行也希望

00:23:29.400 --> 00:23:33.630
您银行帐户中的资金大于或等于零，因此

00:23:33.630 --> 00:23:41.730
完全一样的问题，那么我们如何才能尝试解决这一问题

00:23:41.730 --> 00:23:46.740
重要的是要了解的是，例如，如果您尝试做

00:23:46.740 --> 00:23:51.960
以便使剩余的印象数大于或等于零

00:23:51.960 --> 00:23:55.380
如果剩下的印象数是一，那么我们就没有问题

00:23:55.380 --> 00:23:58.800
一千或两万或类似的东西

00:23:58.800 --> 00:24:06.930
所以一口火化不会使它降到零以下，所以只有当我们

00:24:06.930 --> 00:24:14.580
接近于零到零，我们会陷入困境，所以尝试

00:24:14.580 --> 00:24:22.760
解决这些数值不变量，我们要做的是尝试看看

00:24:22.760 --> 00:24:27.799
计数器的当前值还可以，因为维权双胞胎的数量为a

00:24:27.799 --> 00:24:33.140
例如，如果X如果我有一个计数器X，则递减，然后从计数器上掉下来

00:24:33.140 --> 00:24:39.799
例如1000，这意味着我拥有1000对双胞胎急性的权利

00:24:39.799 --> 00:24:46.190
递减可以，这1000条执行递减的权利和HIDA街这些

00:24:46.190 --> 00:24:52.370
多个副本的权限还可以，所以每次我等于减量I

00:24:52.370 --> 00:24:57.940
每次急性权利都会消耗，我会增加一个新的权利

00:24:57.940 --> 00:25:06.980
好的，这是强制执行这些数字不变量的关键IDF

00:25:06.980 --> 00:25:12.580
好吧，我们将拥有这项权利，我们将在复制品中分配这些权利

00:25:12.580 --> 00:25:22.880
而且我们不希望消耗比那时更多的权利，那么它存在就可以了，所以

00:25:22.880 --> 00:25:27.530
现在的问题是，我们可以使用中央服务器来执行此操作

00:25:27.530 --> 00:25:31.970
中央服务器看墙有没有问题，但是我们不想做

00:25:31.970 --> 00:25:37.700
好的，我们要做的是将这些分布在多个

00:25:37.700 --> 00:25:44.240
副本，以便每个副本可以独立访问计数器

00:25:44.240 --> 00:25:52.130
就像它是CR DT一样，所以它是副本，它是此对象的副本F

00:25:52.130 --> 00:25:56.960
它的副本在本地执行操作副本将对等同步

00:25:56.960 --> 00:26:03.799
像其他任何理论一样好的，如果有

00:26:03.799 --> 00:26:07.940
卡在有偏见的ER责任上将发出光芒，我们将像任何其他公司一样进行合并

00:26:07.940 --> 00:26:14.919
其他CR DT好的，有一些细微的区别，所以如果我们不希望

00:26:14.919 --> 00:26:20.210
有时当我们在本地使用急性手术时，计数器为负

00:26:20.210 --> 00:26:25.010
操作将不得不归档，所以我将尝试减小和我的副本

00:26:25.010 --> 00:26:29.960
会告诉我好吧，您不能递减，因为如果您递减，我们可能会破产

00:26:29.960 --> 00:26:35.660
不变，好吧，唯一的区别是

00:26:35.660 --> 00:26:41.350
一个普通的城市，您将允许它递减，但您可以去

00:26:41.350 --> 00:26:47.660
否定，所以我们建立了一个现实

00:26:47.660 --> 00:26:51.650
称它为有界计数器DePandi的计数器基本上可以创建

00:26:51.650 --> 00:26:57.950
它计数器您有一个操作来增加一个值，甚至操作到

00:26:57.950 --> 00:27:03.620
递减给定值，您可以在绑定计数器中看到当前值，并且

00:27:03.620 --> 00:27:08.390
您可以将权限从一个副本转移到另一副本，这样我可以给

00:27:08.390 --> 00:27:15.020
拥有另一个副本的权限，现在我将展示它的工作原理，所以这是一个

00:27:15.020 --> 00:27:23.740
有点吓人好吧，所以基本上我们假设我们有3个CR dt

00:27:23.740 --> 00:27:30.260
复制品可以作为矩阵，每行对应于每列复制品

00:27:30.260 --> 00:27:35.210
对应一个副本好吧，现在我将展示如何更新此矩阵

00:27:35.210 --> 00:27:43.010
因此，我们从全零开始，这意味着基拉是计数器，是零，并且

00:27:43.010 --> 00:27:47.030
现在，当我在第一个副本中递增时，我可以在第一个副本中递增

00:27:47.030 --> 00:27:56.900
复制副本好吧，如果我增加，我会在1 1位置写矩阵

00:27:56.900 --> 00:28:02.840
在第二个副本中，我将使用第二行第二列确定，

00:28:02.840 --> 00:28:07.850
我要递增，第三个副本的内容相同，所以要递增

00:28:07.850 --> 00:28:15.710
而不是非洲减8，我将在第三行第三列使用8，好的

00:28:15.710 --> 00:28:25.250
我将确切解释每一行和每一列的含义，所以现在我们想做

00:28:25.250 --> 00:28:29.810
好的评论，我们已经完成了增量操作，我们总是可以进行增量操作，没问题

00:28:29.810 --> 00:28:34.670
好的，现在我想递减，所以在第一个副本中我想递减15

00:28:34.670 --> 00:28:40.550
我现在不解释，我将检查是否可以减15

00:28:40.550 --> 00:28:45.440
但是我们知道我们不能，因为在那个副本中仅增加了10 I

00:28:45.440 --> 00:28:50.600
没有与副本同步，所以这将失败

00:28:50.600 --> 00:28:56.240
稍后我将解释我真的很了解它需要失败，所以在

00:28:56.240 --> 00:29:00.110
我想将第二个副本递减5好的，我可以

00:29:00.110 --> 00:29:05.870
递减五，我必须点击我想要的记录信息

00:29:05.870 --> 00:29:10.370
递减五，所以我一直这样做，所以我将使用退出列

00:29:10.370 --> 00:29:19.700
说好吧，我想以五点五分的赞美吧，所以我会建议

00:29:19.700 --> 00:29:24.619
转移，所以在副本中，我增加了八，因此

00:29:24.619 --> 00:29:28.340
表示我有八项权利可以做减量

00:29:28.340 --> 00:29:34.009
所以假设现在我想转让其中一些权利来复制一个

00:29:34.009 --> 00:29:39.559
想减少十个以上，所以我想转让复制权

00:29:39.559 --> 00:29:46.669
一个，我该怎么做，我将在矩阵中更新我的信息，好

00:29:46.669 --> 00:29:54.139
基本上，我使用最后一行，因此免费副本将始终使用此行

00:29:54.139 --> 00:29:59.840
好的，我们将在第一栏中记录该信息，表示

00:29:59.840 --> 00:30:12.679
我已将其复制到副本中，这是正确的，是的，因为这是有效的

00:30:12.679 --> 00:30:21.159
最初我已经增加了，这就是我转移的值

00:30:21.159 --> 00:30:27.919
所以这就是我进行增量或转移时更新矩阵的方式，或者

00:30:27.919 --> 00:30:36.559
递减好，这样一路合并，所以在CID T中，当我们进行合并时，我们看到了

00:30:36.559 --> 00:30:41.480
副本中一个副本的状态还可以，并且这些家伙正在合并

00:30:41.480 --> 00:30:47.539
非常简单，这非常简单，因为每个副本仅修改其

00:30:47.539 --> 00:30:54.110
它的行还可以，因此在第一行中仅复制一个触摸

00:30:54.110 --> 00:30:58.039
第二行仅复制两次触摸，第三行仅复制三个

00:30:58.039 --> 00:31:04.310
触及到三月是每一列的最大值，因此合并

00:31:04.310 --> 00:31:08.450
第一个副本与第二个副本只是做最大，我可以这样做

00:31:08.450 --> 00:31:22.600
可以免费复制副本，我可以提供各种副本，所以现在让我们再次来看一下

00:31:22.600 --> 00:31:29.810
我们是如何真正处理评论的，所以现在我们有了这个值

00:31:29.810 --> 00:31:38.150
依赖计数器的这个值，我想通过f12减一

00:31:38.150 --> 00:31:44.060
我怎么知道我是否可以接受12的评论，所以我需要

00:31:44.060 --> 00:31:51.470
检查我是否拥有12个或更多权利来发表评论并执行此操作

00:31:51.470 --> 00:32:02.510
基本上我要做的是，当在

00:32:02.510 --> 00:32:07.100
那些是我增加的值的矩阵

00:32:07.100 --> 00:32:11.690
这些就是我创造的权利

00:32:11.690 --> 00:32:17.300
我将列中的值添加到列中的其他值

00:32:17.300 --> 00:32:23.330
这些是某些复制品转让给我的权利，因此对于

00:32:23.330 --> 00:32:30.530
副本三将版权转让给我，所以我有十四个权利，我

00:32:30.530 --> 00:32:35.480
必须减少我已经转移到其他副本的值，并且

00:32:35.480 --> 00:32:41.390
我已经消耗了这个家伙，到目前为止，我还没有消耗任何其他任何值

00:32:41.390 --> 00:32:47.180
事实上，我拥有十四项权利，因此我可以在当地进行急性抑郁症治疗，

00:32:47.180 --> 00:32:54.620
确保II可以递减，并通过注释来确定

00:32:54.620 --> 00:33:02.840
国家不会消极的，所以哦，当您使用时我们能做什么

00:33:02.840 --> 00:33:11.480
总的来说，保税区刀具基本上在本地执行操作，因此，如果

00:33:11.480 --> 00:33:14.690
没有足够的权限，我们在本地提交

00:33:14.690 --> 00:33:20.330
当然，我们可以在那一刻尝试从其他副本转移权利

00:33:20.330 --> 00:33:27.649
所以我们可以主动重新分配它，好的副本可以是

00:33:27.649 --> 00:33:33.379
在他们之间转让权利，或者当我减少时，他们可以转让

00:33:33.379 --> 00:33:37.580
没有足够的权限，我可以要求其他副本向我转让一些权限

00:33:37.580 --> 00:33:43.879
因此，同步是使用对等同步，因此我们建立了一个

00:33:43.879 --> 00:33:52.190
在react之上的原型我们已经做了一些微基准测试，所以我们

00:33:52.190 --> 00:33:58.580
已经使用三个三个数据中心将其部署在了亚马逊上，我们进行了比较

00:33:58.580 --> 00:34:04.249
基本上是一种解决方案，该方案在自行车中使用强一致性自行车手不一致

00:34:04.249 --> 00:34:09.980
这种方法是拥有一个单一的数据中心，所有更新将

00:34:09.980 --> 00:34:15.230
去那个数据中心好吧，所以延迟是非常微小的

00:34:15.230 --> 00:34:23.690
因为某些更新必须跨到其他数据中心，所以我们

00:34:23.690 --> 00:34:29.829
在使用这种情况下，我们正在使用反应的坚如磐石的方法，所以

00:34:29.829 --> 00:34:36.859
性能并不能很好地扩展到很多方面，我们没有那么多

00:34:36.859 --> 00:34:42.109
键，如果我们有更多的键，它可能会扩展更多，但是对于

00:34:42.109 --> 00:34:48.649
任何苹果与苹果的比较这就是我们所拥有的，如果我们拥有

00:34:48.649 --> 00:34:55.369
我们有一致性吗，这是与react计数器反应好吗，基本上我们

00:34:55.369 --> 00:35:00.950
基本上每个点都有更高的吞吐量和更低的延迟

00:35:00.950 --> 00:35:07.549
这是通过增加客户数量来实现的，因此对于某些给定数量的客户

00:35:07.549 --> 00:35:12.319
客户端，我可以在给定的平均延迟下实现一些吞吐量，所以这是

00:35:12.319 --> 00:35:20.390
这条线是什么意思，所以朝这个方向的一条线集市可以更好地对齐

00:35:20.390 --> 00:35:25.460
就它而言，更糟糕的是，就吞吐量而言，更糟糕，就吞吐量而言，更糟糕

00:35:25.460 --> 00:35:31.270
延迟，所以我们能做的是

00:35:31.270 --> 00:35:40.660
中间，我们不如通过反抗当地的每周意识做出反应

00:35:40.660 --> 00:35:46.539
好的原因之一是我们的对象更大，所以我们必须

00:35:46.539 --> 00:35:53.890
可以存储更多信息，但是我们比典型的要好得多

00:35:53.890 --> 00:36:03.280
强大的一致性好，什么时候我们还拥有什么

00:36:03.280 --> 00:36:11.559
与我们相比，一致性是我们保证不会提供证据

00:36:11.559 --> 00:36:17.079
当您接近平衡点时仅使用弱一致性时会损坏

00:36:17.079 --> 00:36:21.400
通过检查计数器的值是否大于或等于来限制偶数

00:36:21.400 --> 00:36:27.130
如果您有许多同时执行的文档，则将其设置为零

00:36:27.130 --> 00:36:32.140
在不同的数据中心执行时，我们可以执行更多的递减操作，然后

00:36:32.140 --> 00:36:40.390
那么我们可以了，所以这是有界计数器，所以我们还有几张幻灯片

00:36:40.390 --> 00:36:46.829
关于我们已经完成的某些系统的一些事情，斯威夫特认为我会通过

00:36:46.829 --> 00:36:53.619
在这张幻灯片上，但是在一分钟之内，Swift很好，我们已经建立了一个

00:36:53.619 --> 00:36:59.289
数据库中有一篇在线论文，您可以阅读这个想法，就是我们在

00:36:59.289 --> 00:37:09.490
我们拥有的瑞士云，而不只是拥有我们已经迁移的完整数据库

00:37:09.490 --> 00:37:13.720
在客户端计算机中缓存数据库的一部分，可以并允许

00:37:13.720 --> 00:37:20.740
来执行那些客户端计算机的应用程序，我将通过所有

00:37:20.740 --> 00:37:27.430
幻灯片，我只给你一些我认为是的数字

00:37:27.430 --> 00:37:32.589
有趣，所以我们基本上做到了这一点，那就是我们将部分

00:37:32.589 --> 00:37:36.670
数据发送给客户端，然后我们将dota 2客户端的一部分移至

00:37:36.670 --> 00:37:41.210
允许应用访问缓存在

00:37:41.210 --> 00:37:48.829
在这两行中，可以看到粉色和蓝色

00:37:48.829 --> 00:37:54.920
看到延迟的方法几乎为零，因为大多数操作

00:37:54.920 --> 00:38:02.059
该操作在当地非常紧急，因为如果您将数据转为现金，则可以

00:38:02.059 --> 00:38:08.510
使用一种典型的方法将数据中心的重量问题

00:38:08.510 --> 00:38:13.490
更糟糕的是，因为我们有时间将请求发送到数据中心并发送到

00:38:13.490 --> 00:38:22.490
从客户那里得到回复，好吧，但是当那里有那个

00:38:22.490 --> 00:38:27.589
很重要，如果您正在考虑将数据移至客户端

00:38:27.589 --> 00:38:33.140
这是一个重要的信息，我今天要离开这里

00:38:33.140 --> 00:38:38.839
那是您第一次缓存未命中之后，因此您在客户端中

00:38:38.839 --> 00:38:42.470
执行操作，如果您错过了缓存，则必须去缓存

00:38:42.470 --> 00:38:49.670
服务器，或者如果您正在执行复杂的查询，而您没有所有的东西

00:38:49.670 --> 00:38:54.650
您必须立即转到服务器以获取更多数据

00:38:54.650 --> 00:39:00.829
服务器，您遇到两个问题，可以将数据导入

00:39:00.829 --> 00:39:06.770
客户不再那么出色了，因为您可能最终不得不去

00:39:06.770 --> 00:39:11.180
服务器而不是仅运行一次，您最终可能会不止一次地转到

00:39:11.180 --> 00:39:17.900
取回您需要的所有数据，这样一来，如果可以，

00:39:17.900 --> 00:39:23.089
你正在尝试做这样的事情是在第一种时尚是尝试移动

00:39:23.089 --> 00:39:26.480
将您的计算结果保存到服务器，其余的计算结果保存到服务器，以及

00:39:26.480 --> 00:39:34.750
在服务器中获取ezq临时文件，以便总结让我快速总结

00:39:34.750 --> 00:39:41.270
所以我们从自己的经验和他人的经验中学到的东西

00:39:41.270 --> 00:39:46.280
使用CD的原因是应用程序需要多种类型的C奇数，因此

00:39:46.280 --> 00:39:51.799
设置CR DT不能解决所有问题，所以当重要部分是

00:39:51.799 --> 00:39:55.880
当您构建应用程序时，您想要由多个组成

00:39:55.880 --> 00:40:02.449
怪异的事情，所以罗素和其他人正在做的工作

00:40:02.449 --> 00:40:15.709
这是一个技巧地图，还可以，很好，所以显示了标记，所以当您看到

00:40:15.709 --> 00:40:21.969
这必须降低您的期望，以便系统不会像

00:40:21.969 --> 00:40:28.789
一切都是单个服务器，但是您仍然可以执行一些操作

00:40:28.789 --> 00:40:33.019
不变式，您仍然可以做一些有趣的事情，以便您可以做

00:40:33.019 --> 00:40:37.369
多个与爱荷华州保持联系，我们进行的交易

00:40:37.369 --> 00:40:42.949
我大声请你读这篇论文，这样你可能会有第一个因果关系

00:40:42.949 --> 00:40:48.469
好的，这对于某些不变量也有帮助，您可以强制执行存储键

00:40:48.469 --> 00:40:54.229
如我在保税柜台上显示的方差，您可以解决一般问题

00:40:54.229 --> 00:40:59.869
使用正确的一致性来保持不变，这就是标记的工作

00:40:59.869 --> 00:41:06.589
之前提到它，所以我结束了我的演讲，我可以

00:41:06.589 --> 00:41:13.369
问题，所以那些是工人，所以工作的一部分一直在针对那些人

00:41:13.369 --> 00:41:17.469
人，那是

00:41:24.350 --> 00:41:31.550
非常感谢，所以问题还好

00:41:38.190 --> 00:41:45.090
当马克在谈论候补名单时，我可以帮忙，但认为可以操作

00:41:45.090 --> 00:41:49.610
转换之间存在某种联系

00:41:52.760 --> 00:41:57.270
关系是运营转型试图采取一些措施

00:41:57.270 --> 00:42:02.070
这是非可交换的，然后将其翻转并使其可交换

00:42:02.070 --> 00:42:05.970
我认为这是错误的做法，这可能会使它通勤

00:42:05.970 --> 00:42:10.370
从设计的角度上谢谢

00:42:12.140 --> 00:42:25.800
我有一个关于边界计数器的问题，是的，我想知道

00:42:25.800 --> 00:42:29.460
您只有一些有趣的指标，例如

00:42:29.460 --> 00:42:33.300
受限制的计数器请求在应该通过时失败，因为权限

00:42:33.300 --> 00:42:41.940
在系统中但不在正确的位置，我们可能会有一些数字

00:42:41.940 --> 00:42:49.560
那，但这通常取决于您是否在

00:42:49.560 --> 00:42:55.680
基本上在我们的原型中进行权利的主动分配与否

00:42:55.680 --> 00:43:02.660
我们要做的是在系统正在运行副本时尝试进行交换

00:43:02.660 --> 00:43:07.980
他们之间的权利，使他们之间或多或少

00:43:07.980 --> 00:43:14.640
这种情况下，当他们真的非常接近极限时

00:43:14.640 --> 00:43:19.140
可能会变成这种情况，因为我实际上没有这些数字

00:43:19.140 --> 00:43:26.100
原型，我们有一种标志，客户可以要求其处于开启状态

00:43:26.100 --> 00:43:40.620
如果他真的想这样做，可以要求转账，也可以用有限柜台来做

00:43:40.620 --> 00:43:47.360
您可以通过试探法确定一个副本何时应转移其某些副本

00:43:47.360 --> 00:43:51.770
决定如何完成转帐

00:43:51.880 --> 00:43:56.710
我们没有任何幻想，过一段时间后我们会定期进行

00:43:56.710 --> 00:44:03.850
只是当我们同步副本时才使用它进行传输，我们使用它来

00:44:03.850 --> 00:44:20.410
升级每个副本的权限级别，以便您获得此强大的图表

00:44:20.410 --> 00:44:39.460
和弱一致性，如果您可以返回到那个或不是，那就是

00:44:39.460 --> 00:44:43.660
一个，其中包含所有数据，所以我从那些薄弱的名字中收集了

00:44:43.660 --> 00:44:51.490
提供的担保不如强，基本上是几周

00:44:51.490 --> 00:44:56.320
很快我可能会超支，我可能会在一周内低于零先生

00:44:56.320 --> 00:45:01.570
超支是的，卑诗省会为您提供与

00:45:01.570 --> 00:45:09.430
强大的BC可以告诉您，您不会超支并且拥有强大的保证

00:45:09.430 --> 00:45:13.450
您将没有回应，坚强的态度将确保您不会超支

00:45:13.450 --> 00:45:19.540
区别在于问题再见罗素再见

00:45:19.540 --> 00:45:26.110
如果你有，如果你有一个坚强的人，当你想减一的时候，你

00:45:26.110 --> 00:45:30.490
仅拥有一项权利，因此可以想象一下，计数器等于您要去的计数器

00:45:30.490 --> 00:45:33.940
服务器中心的中央服务器知道何时可以

00:45:33.940 --> 00:45:38.740
递减，一切都很好，所以当您有引擎盖柜台时，

00:45:38.740 --> 00:45:44.140
例如，如果您只有一项权利，那么该权利可以存在于任何副本中，因此，如果

00:45:44.140 --> 00:45:48.610
您正在减少没有正确权限的副本数据中的数据

00:45:48.610 --> 00:45:54.340
操作可能会失败，因此我们将看到您需要在不同情况之间保持平衡

00:45:54.340 --> 00:45:58.480
复制品和强壮的你不对，因为你只有一个

00:45:58.480 --> 00:46:01.480
用BC再一次复制强大

00:46:01.480 --> 00:46:04.990
复制品，而不是使用正方形和这些点，您应该使用苹果

00:46:04.990 --> 00:46:21.190
和橘子好吧，所以我应该使用Apple nerd，是的，它们为您提供相同的服务

00:46:21.190 --> 00:46:25.540
那里在某些方面具有可比性，但这将有助于阐明

00:46:25.540 --> 00:46:29.950
差异也是降低我们期望值的一部分

00:46:29.950 --> 00:46:34.570
给您的东西非常接近强一致性，但我们也给

00:46:34.570 --> 00:46:44.470
你们还有很多并行性，好吧，我们倾向于使用权衡一词

00:46:44.470 --> 00:46:52.420
顺便说一下，不要降低您的期望，但是我大多数人

00:46:52.420 --> 00:46:58.090
这些神学是细粒度的数据类型，那么，小事就可以了

00:46:58.090 --> 00:47:02.380
做过任何研究，总是在想着它，不管您采取了什么理由

00:47:02.380 --> 00:47:07.410
关于起因的谷物城市，因此，例如，一个图形数据库本身就是CEO的职责

00:47:07.410 --> 00:47:20.830
graph数据库，您是否拥有我们支持的图数据类型？

00:47:20.830 --> 00:47:30.600
非常大的人有几个千兆字节

00:47:31.590 --> 00:47:37.330
所以我的意思是说这很好，因为它们是各个要素

00:47:37.330 --> 00:47:41.740
细粒度，但数据本身非常大，我想您会拥有

00:47:41.740 --> 00:47:46.270
同样，您可能会说图形数据库将非常相似，因为

00:47:46.270 --> 00:47:56.080
单个元素就是您知道一个顶点或a或一个弧，但是

00:47:56.080 --> 00:48:00.400
这里的目标是能够尤其是Swift云能够处理

00:48:00.400 --> 00:48:05.850
非常大的数据库，但只复制您所占的一小部分

00:48:05.850 --> 00:48:10.920
您真的对部分复制很感兴趣，这是一个非常困难的问题

00:48:10.920 --> 00:48:16.070
其实还有更多的问题

00:48:20.760 --> 00:48:29.280
所以回到您的阅读清单示例中，也许我错过了您有的东西

00:48:29.280 --> 00:48:43.980
两个副本之一的操作可以决定是否可以，但是这些是

00:48:43.980 --> 00:48:59.730
实际上发生了，因此您不能更新副本，也不能在更改后对其进行更改。

00:48:59.730 --> 00:49:06.540
我想指出的事实是，如果您想

00:49:06.540 --> 00:49:10.860
保持其不变性就可以保持这些不变性

00:49:10.860 --> 00:49:14.430
前提条件，所以前提是您知道没有人对此出价

00:49:14.430 --> 00:49:22.400
事情还没做，如果您评估自己对本地的了解，那么您可能会

00:49:22.400 --> 00:49:28.200
为您的前提条件读取了错误的值，好吧，因此在这些情况下，我

00:49:28.200 --> 00:49:32.790
意思是这里有一个证明我的意思是重要的是

00:49:32.790 --> 00:49:36.630
凭直觉是的，你了解你知道也许我需要在这里做点什么

00:49:36.630 --> 00:49:43.260
但是我们有证据表明，只有两种选择，要么是

00:49:43.260 --> 00:49:48.330
一个设计选择这是一个只有两个选择的设计选择

00:49:48.330 --> 00:49:52.470
需要同步，它不再是一项职责

00:49:52.470 --> 00:49:58.290
再或者我必须以较低的期望生活，所以我必须与

00:49:58.290 --> 00:50:02.280
两个人可以同时竞标同一件事的事实，所以这是

00:50:02.280 --> 00:50:06.560
我们凭直觉知道的东西，但现在我们有了证明

00:50:08.970 --> 00:50:15.859
好的，还有其他问题，好的，再请演讲者

