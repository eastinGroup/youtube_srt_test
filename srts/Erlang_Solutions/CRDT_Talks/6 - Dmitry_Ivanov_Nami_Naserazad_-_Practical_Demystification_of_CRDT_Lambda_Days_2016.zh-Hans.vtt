WEBVTT
Kind: captions
Language: zh-Hans

00:00:08.680 --> 00:00:13.480
谢谢大家谢谢你们这么大的数目

00:00:13.480 --> 00:00:17.460
在这一站中，我们将对CR DT进行实际的神秘化

00:00:17.460 --> 00:00:22.230
纳米（Nami）的迪米特里（Dimitri）和DDA做出了巨大贡献，但无法加入我们的行列

00:00:22.230 --> 00:00:26.460
第一个免责声明是我们不是刻板的学术专家，也不是刻板的学院车，

00:00:26.460 --> 00:00:30.660
在瑞士体系中不是那么多专家，我们不会仅仅使用一些

00:00:30.660 --> 00:00:37.380
我们在解决现实世界中的问题方面取得了学术成就，我们充满了

00:00:37.380 --> 00:00:41.430
堆栈开发人员，因此我们正在做后端和前端要做的许多事情

00:00:41.430 --> 00:00:44.280
与您交谈时的基础架构我也在后端打电话

00:00:44.280 --> 00:00:49.110
服务，所以如果事情继续下去，我必须迅速做出反应，我们正在努力

00:00:49.110 --> 00:00:53.400
TomTom和我们正在开发一个名为nav cloud sister floud的系统，该系统是

00:00:53.400 --> 00:00:58.560
炖基于云的存储服务，以使用户同步其导航

00:00:58.560 --> 00:01:02.430
信息一段时间，市场上有很多客户，很多设备

00:01:02.430 --> 00:01:06.420
许多汽车与TomTom签有合同，因此大多数汽车正在逐步

00:01:06.420 --> 00:01:12.150
将与nav cloud集成，并且其中许多已经拥有TomTom，因此

00:01:12.150 --> 00:01:15.750
导航类返回了很多请求，流应该是可扩展的并且可用

00:01:15.750 --> 00:01:20.700
并且因为基于位置的信息和信息不是最重要的信息之一

00:01:20.700 --> 00:01:25.470
敏感信息，足够的云应该是真正安全的，并且还应该

00:01:25.470 --> 00:01:29.790
遵守法律要求，并且还足够曾经使用过

00:01:29.790 --> 00:01:33.810
在第三方应用程序和TomTom应用程序中也是如此，因此我们不应该

00:01:33.810 --> 00:01:38.549
降低他们的表现，我们必须做出反应并迅速做出反应，

00:01:38.549 --> 00:01:41.430
尝试使用非常符合我们要求的技术，因此在

00:01:41.430 --> 00:01:44.729
服务器，我们使用学者作为核心语言，并在顶部打上敲门声

00:01:44.729 --> 00:01:48.810
使用RabbitMQ进行推送通知的事件再次出现在存储中，我们

00:01:48.810 --> 00:01:53.460
在Amazon中进行部署，并促进与我们实施的导航云的集成

00:01:53.460 --> 00:01:56.490
不同抽象级别和不同SDK的不同SDK

00:01:56.490 --> 00:02:02.490
不同的技术Android Java C ++等，这样的同步系统和

00:02:02.490 --> 00:02:06.270
还刀没有特别的特点，尤其是最后

00:02:06.270 --> 00:02:10.049
大部分装有SIM卡的导航设备中使用的云

00:02:10.049 --> 00:02:14.280
内置的SIM卡将由连环画公司由TomTom或

00:02:14.280 --> 00:02:19.019
汽车公司，因此它们具有非常低的带宽，尽管当您

00:02:19.019 --> 00:02:23.129
大部分时间都在开车带你去没有互联网的地方

00:02:23.129 --> 00:02:25.889
因为例如您去农场没有覆盖任何东西

00:02:25.889 --> 00:02:29.090
到您要在停车场停车的调谐器，这样您就不必进入

00:02:29.090 --> 00:02:32.390
所以我的特点是连接不稳定

00:02:32.390 --> 00:02:36.890
拥有有限的用户Shh不想等到他获得

00:02:36.890 --> 00:02:40.040
上网并更新他的信息，这不仅是无缝的

00:02:40.040 --> 00:02:44.540
改变了事情，当然是因为这种连接的持续时间很长

00:02:44.540 --> 00:02:49.400
可能会同时更改，并且这些更改可能处于冲突状态，并且

00:02:49.400 --> 00:02:53.540
当然还是不能保证如果我现在更改某些内容，它可能会达到

00:02:53.540 --> 00:02:57.440
一小时后切断服务器，可以同时进行一些其他更改

00:02:57.440 --> 00:03:01.310
用户当然不能接受将会丢失的数据，这是

00:03:01.310 --> 00:03:05.000
违反法律要求，当然数据应转换为

00:03:05.000 --> 00:03:11.120
用户可能必须期望的值，以便您可以首先锁定该如何处理

00:03:11.120 --> 00:03:16.459
编写大量逻辑以尝试涵盖所有极端情况，以花费大量代码

00:03:16.459 --> 00:03:20.840
处理所有我怀疑甚至可能发生的事情，但如果可能的话，它将带来

00:03:20.840 --> 00:03:25.520
您是一个非常易于维护的代码，而精益涡轮增压则表示优秀的开发人员

00:03:25.520 --> 00:03:29.870
始终专注于他们想在数据上解决问题的数据结构

00:03:29.870 --> 00:03:33.680
结构层次，所以他们想从中获得收益，这就是

00:03:33.680 --> 00:03:40.070
我们选择CR DT的原因，所以我们说CFS就像我说的CRT一样，想尝试CR DT

00:03:40.070 --> 00:03:46.310
是数据类型的数据结构，它有它自己的一个家庭

00:03:46.310 --> 00:03:51.320
并且因为如果an是一系列数据数据结构，并且它具有自己的

00:03:51.320 --> 00:03:58.160
代数，它也被复制，因此可以随时分配

00:03:58.160 --> 00:04:03.560
CRT的任何实例都可以具有多个副本，这些副本可以被删除

00:04:03.560 --> 00:04:08.690
同步并且可以不一样是一回事，甚至可以

00:04:08.690 --> 00:04:12.290
冲突状态，您中的大多数人都在使用诸如get之类的源代码控制工具

00:04:12.290 --> 00:04:17.690
有时get使用递归之类的方法为您解决此冲突

00:04:17.690 --> 00:04:21.290
策略，但有时它不能，并且您必须干预用户应该

00:04:21.290 --> 00:04:26.000
应该面试，但C至少不是没有用户干预我知道我有什么

00:04:26.000 --> 00:04:32.900
这样做的好处是，很多好处的主要成分是

00:04:32.900 --> 00:04:38.539
所谓的合并合并是CR DT代数的一部分，什么是合并

00:04:38.539 --> 00:04:42.470
合并是对Ciardi T也具有的二进制操作

00:04:42.470 --> 00:04:47.450
这些特征，因此，如果必须具有关联性，则必须提交合并，并且

00:04:47.450 --> 00:04:55.460
必须很重要，而且很清楚YC ret是什么

00:04:55.460 --> 00:04:59.570
应该具有这种特征，这显然给我们带来了什么

00:04:59.570 --> 00:05:03.860
特征与分布的性质非常匹配

00:05:03.860 --> 00:05:09.080
在分布式系统中，我们无法获得所有保证，因此您可以发送事件

00:05:09.080 --> 00:05:12.350
我什至可以寄给您，但也可以寄给您，但不能保证

00:05:12.350 --> 00:05:16.880
你以什么顺序收到那些，以为我是服务器，我收到了你

00:05:16.880 --> 00:05:20.330
事件，我有一个本地替身，我刚刚合并到本地遗产，合并到

00:05:20.330 --> 00:05:24.950
本地房地产合并了本地房地产，但是我的合并是有承诺的并且具有关联性，因此

00:05:24.950 --> 00:05:29.570
不管我以什么顺序收到那些，它们都将收敛到相同的位置

00:05:29.570 --> 00:05:33.740
这样的价值显然对分布式系统确实好，另一件事是

00:05:33.740 --> 00:05:38.180
在这些服务系统中甚至可以交付不止一次，所以我发送给您

00:05:38.180 --> 00:05:43.310
如果您将我寄回给我一个确认函，可能会丢失我以为您还没有

00:05:43.310 --> 00:05:47.870
收到了，我很讨厌你，但是你收到了两次，但是你又收到了

00:05:47.870 --> 00:05:51.200
合并它，您只需将其合并到当前资产的当前状态即可

00:05:51.200 --> 00:05:55.000
它多次出现，但由于合并是幂等的，因此到达

00:05:55.000 --> 00:06:02.090
相同的价值，但它没有带来的是，您可以

00:06:02.090 --> 00:06:05.240
在本地更改事情，您不需要任何按需

00:06:05.240 --> 00:06:10.790
远程同步，您可以更改内容，也可以在本地更改内容，

00:06:10.790 --> 00:06:15.830
他们将在某个时候到达服务器，并且本地更改能够应用更改

00:06:15.830 --> 00:06:20.690
在我们的飞行模式下实际上带来了很棒的用户体验，因为用户无法

00:06:20.690 --> 00:06:26.630
不需要等到互联网就可以了我说我解释了几对

00:06:26.630 --> 00:06:32.180
关于CRT团队的非常简单的例子首先是G柜台做柜台就是全部

00:06:32.180 --> 00:06:35.540
这些不断增长的柜台总是在增长，例如，您有一个

00:06:35.540 --> 00:06:39.169
您想计算网站发热量的网站，可能

00:06:39.169 --> 00:06:42.620
您的网站真的很成功，您不能仅仅因为赢得了一个网站就算上它

00:06:42.620 --> 00:06:50.090
单机，所以要分配它Li计数加法不是很CR DT

00:06:50.090 --> 00:06:53.690
合规操作，因为想象我有三台不同的机器，每台机器

00:06:53.690 --> 00:06:57.720
他们中的每个都可以收到他们要求的城镇，如果每个城市都有我的电话，

00:06:57.720 --> 00:07:01.230
他们，只是增加他们，我不能合并他们，因为加法不是项目

00:07:01.230 --> 00:07:06.690
如果我发送事件并且接收到两次错误，则计数很有效，因此我必须

00:07:06.690 --> 00:07:11.430
考虑一下适合的数据结构，因此我们定义了一个数组

00:07:11.430 --> 00:07:15.750
有对应于每台机器的元素，所以我这里有三台机器

00:07:15.750 --> 00:07:20.880
所以我有三个元素的数组正好是矢量时点，所以每当我

00:07:20.880 --> 00:07:24.420
收到计数请求只是增加了它们对应的元素

00:07:24.420 --> 00:07:29.700
所以我总是增加第一个元素，而不是他们说话的间隔

00:07:29.700 --> 00:07:33.780
之所以互相传播是因为彼此闲聊传播

00:07:33.780 --> 00:07:39.450
信息，以达到他们的状态，以总财产和闲聊

00:07:39.450 --> 00:07:44.550
示例系列，如果B和a的数组刚刚合并到自己的数组中，怎么办

00:07:44.550 --> 00:07:48.900
它合并它只是选择了相应元素的最大值，所以在这里

00:07:48.900 --> 00:07:53.490
例如，如果C从B接收到，结果将是6 3 9，因为最大值

00:07:53.490 --> 00:07:57.740
每个元素中的每个将是存在的，总价值是其中的一些

00:07:57.740 --> 00:08:01.919
因此，我以这种方式对分布式计数进行计数，并且可以正常工作，而我从不

00:08:01.919 --> 00:08:05.729
算了两次，它永远不会对我说谎，也许会在背后显示一些东西，但是

00:08:05.729 --> 00:08:10.380
会与正确的值保持一致，为什么会起作用，因为我

00:08:10.380 --> 00:08:15.300
在合并中使用max，并且Max是与RTD兼容的max，是关联的

00:08:15.300 --> 00:08:18.830
交换性和高度很重要，这就是为什么它起作用

00:08:18.830 --> 00:08:23.669
另一个例子甚至是一个更简单的例子，G set G set总是

00:08:23.669 --> 00:08:28.560
增长集，您可以将元素添加到集合中。

00:08:28.560 --> 00:08:35.940
实际上是联盟联盟中一个元素集到另一个联盟的联盟，但联盟

00:08:35.940 --> 00:08:42.360
与add不同的是轻松合规，而Ciardi则合规，所以我不需要更改

00:08:42.360 --> 00:08:46.589
我的数据结构每当他们在不同的机器上都有不同的设置

00:08:46.589 --> 00:08:51.150
收到一个值，他们只是更改本地状态，我说本地更新是

00:08:51.150 --> 00:08:58.920
荒谬的nafla的巨大好处，所以每当彼此闲聊时

00:08:58.920 --> 00:09:03.570
他们只是将它们合并在一起，所以Union当然符合CV RTD，因为Union是一个

00:09:03.570 --> 00:09:08.060
关联交换听不见好吗，这个数据结构将如何

00:09:08.060 --> 00:09:10.970
帮助我们足够的云计算富裕度不同的用例之一是

00:09:10.970 --> 00:09:14.690
同步收藏的位置，以便您可以去喜欢的地方

00:09:14.690 --> 00:09:18.020
将其标记为收藏，而不管您使用的是哪个设备，或者是否

00:09:18.020 --> 00:09:22.100
是否有连接，您是否希望此连接无缝传播，并且您想要

00:09:22.100 --> 00:09:27.440
无论您在何处将收藏夹设置为收藏夹，都有收藏夹的列表

00:09:27.440 --> 00:09:31.720
具有不同的属性，例如名称经度，纬度地址等

00:09:31.720 --> 00:09:36.980
天真的方法是，只有最后的权利才能赢得服务器获得的收益，这仅仅是

00:09:36.980 --> 00:09:40.250
直接进入数据库，所以这显然是行不通的，因为

00:09:40.250 --> 00:09:44.660
想象我离线，我发送数据，例如我在停车场

00:09:44.660 --> 00:09:48.650
没有互联网，我想标记他的停车场，因为一个不错的停车场，

00:09:48.650 --> 00:09:52.940
便宜，是我最喜欢的位置，但是我没有互联网，所以我在那点击了

00:09:52.940 --> 00:09:58.090
想象一个小时后它将到达服务器，但与此同时我也可能

00:09:58.090 --> 00:10:04.250
应用一些其他更改，以便它将覆盖我最新的更改

00:10:04.250 --> 00:10:10.100
而且您也可以通过附加时间戳来解决此问题，但是存在哪个时间戳

00:10:10.100 --> 00:10:14.870
没有可靠的设备时钟时钟服务器时钟

00:10:14.870 --> 00:10:18.800
永远不会知道，虽然作为限制，您要解释一下我们将要使用的

00:10:18.800 --> 00:10:22.430
时间戳，但我们将使用一个更简单的版本

00:10:22.430 --> 00:10:28.460
调整它，以便更新的结果将获胜，所以您

00:10:28.460 --> 00:10:34.280
可能有过时的更新会赢得更新，所以让我们尝试看看我们的DT，因为

00:10:34.280 --> 00:10:37.940
奇怪的是显然适合这种环境

00:10:37.940 --> 00:10:42.590
您已经看过这张幻灯片，这是稳定状态下纳夫云的正确性质

00:10:42.590 --> 00:10:46.940
连接良好的CRT表示我不需要按需删除同步

00:10:46.940 --> 00:10:53.030
不能仅以低带宽在本地波瓣上改变事物，我们扩展了

00:10:53.030 --> 00:10:59.360
我们支持另一项行动的责任给我们带来了困难，那是什么呢？

00:10:59.360 --> 00:11:04.070
意味着这意味着无论何时我想将我们发送到服务器上

00:11:04.070 --> 00:11:08.600
发送整个CR DT的过程，我只是感觉到此本地状态之间的差异

00:11:08.600 --> 00:11:12.230
以及我从服务器看到的最后一个状态

00:11:12.230 --> 00:11:17.390
所以我优化了无缝带宽，如果这是天生的

00:11:17.390 --> 00:11:20.550
改变当然可以让您轻而易举地做出改变，但是Ciardi的设计

00:11:20.550 --> 00:11:25.390
理论上说，我知道如何解决它，我们无法保证更新顺序

00:11:25.390 --> 00:11:29.380
小心看到奇特的关联和交换数据丢失，我们永远不会覆盖

00:11:29.380 --> 00:11:33.550
我们始终会合并，因此我们不会丢失数据，并且不会将数据收敛到

00:11:33.550 --> 00:11:40.570
期望值好吧，为什么，因为我们在所有使用的地方都使用此数据结构

00:11:40.570 --> 00:11:44.350
这种数据结构和客户端，我们在服务器甚至是服务器中使用此数据指令

00:11:44.350 --> 00:11:48.160
我们在数据库中使用此数据结构，因此无论采用哪种技术

00:11:48.160 --> 00:11:52.420
我们使用的是C或DT集或C或DT集，无论客户端中

00:11:52.420 --> 00:11:57.010
数据库中的服务器，所有这些服务器都完成所有合并工作

00:11:57.010 --> 00:12:01.930
合并逻辑在任何地方都是一致的，例如我们使用react作为我们的

00:12:01.930 --> 00:12:04.660
数据存储反应具有非常好的功能

00:12:04.660 --> 00:12:07.930
将矢量时钟附加到您输入的条目是键值基础

00:12:07.930 --> 00:12:13.300
数据库，所以每当您阅读时，您都会写一些反应

00:12:13.300 --> 00:12:16.990
附加一个向量时钟，它与

00:12:16.990 --> 00:12:21.100
纯向量时钟的概念和某种版本控制的东西，但是相当

00:12:21.100 --> 00:12:23.320
关闭，因此它附加了一个矢量时钟

00:12:23.320 --> 00:12:27.700
每当您读取该值时，您还可以在需要时读取向量时钟

00:12:27.700 --> 00:12:33.700
马上回来，您必须提供您看到的最后一个矢量时钟，如果

00:12:33.700 --> 00:12:37.209
您提供的向量时钟实际上是最新的

00:12:37.209 --> 00:12:41.620
它与数据库中的那一项完全相同，您的权限将被覆盖

00:12:41.620 --> 00:12:46.570
前一个，但如果您的向量时钟，如果我与此同时，您是

00:12:46.570 --> 00:12:50.650
读取其他人改变了数据库中的向量时钟

00:12:50.650 --> 00:12:55.089
条目将被更改，因此当您回写时，您的权利将是

00:12:55.089 --> 00:13:00.400
被认为是污点权，在这种情况下，如果您配置react，react将会

00:13:00.400 --> 00:13:05.589
为您保留两个版本，这是您的应用程序责任

00:13:05.589 --> 00:13:11.260
起来阅读解决这些冲突的方法，但对我们来说，我们不在乎它会造成兄弟姐妹

00:13:11.260 --> 00:13:15.640
对我们来说，我们在数据库中存储的内容非常棒，请参阅我们阅读的

00:13:15.640 --> 00:13:20.620
CR职责，我们只是将它们合并为两行代码，没有逻辑，我们知道

00:13:20.620 --> 00:13:25.839
此合并将与所有客户端以及所有

00:13:25.839 --> 00:13:32.089
其他我不知道的设备iPhone iPad iPhone一切，所以这实际上是

00:13:32.089 --> 00:13:35.870
一点理论，现在Dimitri将要讨论的细节

00:13:35.870 --> 00:13:39.709
我们如何实施以及我们实际扩展CR DD的概念以使其匹配

00:13:39.709 --> 00:13:46.699
我们的需求很酷，谢谢妈妈，所以有点盐

00:13:46.699 --> 00:13:51.649
搜寻关键概念，我们决定好了，我们需要做功课，所以我们想

00:13:51.649 --> 00:13:58.309
尝试将收藏夹建模为酸度设置，现在我们实际上需要查看

00:13:58.309 --> 00:14:02.540
是CDT SAT的现有实施方案，请选择适合我们的方案

00:14:02.540 --> 00:14:09.680
需求，因此我们已经看到了G set概念，但是它只允许添加

00:14:09.680 --> 00:14:14.209
移除最喜欢的位置，这不是我们必须支持的情况

00:14:14.209 --> 00:14:18.680
更新和删除元素，所以我们看起来有点

00:14:18.680 --> 00:14:24.709
进一步，我们研究了面对集，所以面对集到面对集商店

00:14:24.709 --> 00:14:29.420
有关添加操作和删除操作的信息，因此删除是

00:14:29.420 --> 00:14:35.779
支持，基本上可以使用两个G组来实现

00:14:35.779 --> 00:14:40.579
首先是G集，我们存储加法运算，然后存储在

00:14:40.579 --> 00:14:44.480
第二个删除操作非常简单，对，这就是它的外观

00:14:44.480 --> 00:14:50.420
像在示例中一样，所以我们有两个节点，主节点B都具有加法和

00:14:50.420 --> 00:14:58.040
移除集，那么我们该如何做呢？如何获得该集的总价值

00:14:58.040 --> 00:15:04.129
好吧，我想这很直观，我们只需要计算一下

00:15:04.129 --> 00:15:08.240
添加集和删除集，这些将是尚未删除的元素

00:15:08.240 --> 00:15:15.589
以及我们如何计算合并，所以我们如何将两个集合很好地合并在一起

00:15:15.589 --> 00:15:20.389
只需采取添加集的联合和删除集的联合，我们

00:15:20.389 --> 00:15:25.249
在这里构造新值正是我们在这里所做的，所以这就是结果

00:15:25.249 --> 00:15:32.149
我认为合并和查找的方法非常简单，这是

00:15:32.149 --> 00:15:38.720
像Scala中的一个小实现一样，我们在这里拥有所有通用代码

00:15:38.720 --> 00:15:42.470
发布的内容，我们稍后会给您链接

00:15:42.470 --> 00:15:47.750
尽管它对我们不起作用有两个原因，所以一个原因是，一旦

00:15:47.750 --> 00:15:50.810
元素已从两相集中移除

00:15:50.810 --> 00:15:55.850
好吧，它永远都被移走了，所以我们不能把它抹掉，第二件事是

00:15:55.850 --> 00:16:01.280
甚至更有争议的元素本质上是可变的，所以没有

00:16:01.280 --> 00:16:05.510
当然，您也可以使用可兼容性进行更新，您仍然可以对更新进行建模

00:16:05.510 --> 00:16:10.730
通过只删除元素，然后再次添加更改其值，尽管它

00:16:10.730 --> 00:16:17.120
真的很容易为套装带来更多色调的石头或去除的元素，因此

00:16:17.120 --> 00:16:21.470
删除集的增长非常快，特别是在热元素上

00:16:21.470 --> 00:16:28.370
更新太快了，我们想避免，所以有多个

00:16:28.370 --> 00:16:32.060
至少要尝试解决面对的问题的集合第一个是

00:16:32.060 --> 00:16:36.920
“最后一个获胜者”元素集，是的，“最后一个获胜者”听起来并不很真实

00:16:36.920 --> 00:16:42.200
有前途的我争辩，所以它也存储了一个添加和删除

00:16:42.200 --> 00:16:48.290
再次可以将操作建模为G集，但是这在分布式系统中很常见

00:16:48.290 --> 00:16:53.270
练习一下，如果您想获得一些其他功能，例如您

00:16:53.270 --> 00:16:56.060
具有这种空间上的权衡，您必须引入一些其他方式

00:16:56.060 --> 00:16:59.990
像汤普森（Thompson）一样处理元数据，因此在最后的交易风中

00:16:59.990 --> 00:17:05.660
与每个删除或添加相关的实际时间戳

00:17:05.660 --> 00:17:12.620
操作，每个元素都有一个时间戳，在这种情况下，实际上我们可以

00:17:12.620 --> 00:17:17.510
将元素读取到已删除的集合（仅通过创建即可提供）

00:17:17.510 --> 00:17:21.740
时间戳比存储的时间戳高的加法运算

00:17:21.740 --> 00:17:27.500
在删除集中，所以这又是一个示例两台机器，我们有这对

00:17:27.500 --> 00:17:33.020
该对中的第一个元素实际上是一个时间戳，只是一个长值

00:17:33.020 --> 00:17:39.230
以及值本身，那么我们如何计算集合的查找值呢？

00:17:39.230 --> 00:17:45.080
只需再次分析元素和时间戳的添加集，

00:17:45.080 --> 00:17:50.900
检查元素是否具有对应的状态和移除集

00:17:50.900 --> 00:17:55.580
时间戳较高，如果有10口井，则在我们继续进行时考虑

00:17:55.580 --> 00:18:00.379
不会出现在查找中，并且合并后的合并是完全相同的

00:18:00.379 --> 00:18:04.549
我们只需要合并广告集并删除广告集，这就是我们正在做的

00:18:04.549 --> 00:18:13.820
这样，根据合并结果，我们可以很容易地进行此查找，

00:18:13.820 --> 00:18:17.450
这就是您基本上可以实现基本操作查找和

00:18:17.450 --> 00:18:24.440
如此混乱，如您所见，这些集合的合并几乎相同，但合并却没有

00:18:24.440 --> 00:18:29.989
再次为我们工作的主要原因仍然是我一成不变的要素

00:18:29.989 --> 00:18:34.940
意味着删除集将再次真正快速增长，因此它解决了一个

00:18:34.940 --> 00:18:39.769
带有阅读元素的面对面设置的问题不会使人感到烦躁

00:18:39.769 --> 00:18:45.980
另一个，所以下一个都设置好了，所以所有设置都代表观察到并删除

00:18:45.980 --> 00:18:53.929
再次进行设置，以便存储添加操作和删除操作

00:18:53.929 --> 00:18:59.409
再次单独存储到G个集合中，因此在所有集合的情况下，实际上

00:18:59.409 --> 00:19:05.509
使用提供额外的因果关系和删除的因果关系

00:19:05.509 --> 00:19:11.720
因此，当您向或设置中添加元素时，您将提供唯一的标记，即

00:19:11.720 --> 00:19:16.970
如果要删除集合，则与特定的加法运算关联

00:19:16.970 --> 00:19:24.350
从中删除元素，您必须在中找到较旧的旧对

00:19:24.350 --> 00:19:29.869
G集合中的add集合将所有这些标签放到

00:19:29.869 --> 00:19:34.879
基本上删除集合，当然它支持阅读元素

00:19:34.879 --> 00:19:38.840
使用新的唯一标记创建一个新的加法运算，该标记尚未出现在

00:19:38.840 --> 00:19:44.690
删除集合，以便基于此我们可以想象查找功能将如何

00:19:44.690 --> 00:19:51.619
看起来是或设置是，我们基本上需要再次遍历设置处的添加

00:19:51.619 --> 00:19:57.649
并找到那些标签中尚未包含的元素

00:19:57.649 --> 00:20:02.330
设置，基本上这就是我们在这里所做的

00:20:02.330 --> 00:20:07.309
因此，合并的惊奇与惊奇完全相同，我们只是将

00:20:07.309 --> 00:20:12.830
添加集并删除基本上位于网格上的集

00:20:12.830 --> 00:20:18.019
是的，这就是我们在此处查找的方式，因此我们为

00:20:18.019 --> 00:20:21.889
查找操作基本上会遍历广告集，然后找到

00:20:21.889 --> 00:20:27.620
对应的元素和删除集，是的，并且合并正是

00:20:27.620 --> 00:20:34.580
同样，它也有相同的问题，或者是的，让我们将问题作为

00:20:34.580 --> 00:20:41.419
我要很好地面对不可变的元素，所以这些元素可以使用

00:20:41.419 --> 00:20:45.620
然后我们开始思考可以改善我们的需求

00:20:45.620 --> 00:20:50.539
现有的布景，所以我们说可以，我们可以介绍自己的布景吗？

00:20:50.539 --> 00:20:58.100
设置是好的，顺便说一句，我们称它为我们实际观察到的更新

00:20:58.100 --> 00:21:04.370
更新并删除集，是的，我们通过提供相同的技术

00:21:04.370 --> 00:21:10.100
基本上有助于解决我们需求的其他元数据，因此首先

00:21:10.100 --> 00:21:17.330
我们所说的一切都很好，我们希望能够进行变异，以便更新我们想要的元素

00:21:17.330 --> 00:21:20.330
为了识别元素，所以我们引入了这个标识符

00:21:20.330 --> 00:21:25.159
与每个元素相关联的是一个唯一的标识符，我们使用您的ID

00:21:25.159 --> 00:21:31.820
我们说的第二件事还好，我们也希望有时间戳来工作

00:21:31.820 --> 00:21:38.240
设置与上次右风相同的方式，以便能够对元素进行反应并解决

00:21:38.240 --> 00:21:43.820
冲突的副本，基本上就是原则

00:21:43.820 --> 00:21:47.299
所以我们对元素的标识是不变的

00:21:47.299 --> 00:21:52.879
对，所以一旦元素生成，它就永远坐在那里

00:21:52.879 --> 00:22:00.620
更改了ID，但该值是可变的，因此我们最终采用了这种结构，因此

00:22:00.620 --> 00:22:06.649
我们添加的元数据基本上是作为设置时间戳记的想法，并且这种时髦

00:22:06.649 --> 00:22:11.059
删除标志，所以我们需要什么，我们可以将其建模为

00:22:11.059 --> 00:22:16.549
作为两个单独的集合进行添加和删除，因此我们想解决的问题

00:22:16.549 --> 00:22:21.320
节省一些空间，我们说可以，如果我们集成了该鉴别器

00:22:21.320 --> 00:22:26.179
标记元素已删除或未删除的字段

00:22:26.179 --> 00:22:32.480
是的，实际上效果很好，是的，当然只能包含

00:22:32.480 --> 00:22:40.580
一个具有特定ID的元素，所以这里还是一个例子两台机器

00:22:40.580 --> 00:22:48.769
这四个四个字段，因此UUID时间戳本身就是值，并且是可选的

00:22:48.769 --> 00:22:53.750
删除标志，如果未设置，那么它是错误的，那么我们如何计算

00:22:53.750 --> 00:22:58.039
对我们集合的查找，例如在机器上

00:22:58.039 --> 00:23:03.409
我们只需要遍历所有土地集的下划线集

00:23:03.409 --> 00:23:09.380
元素并找到未删除的元素，这很容易，我们该怎么做

00:23:09.380 --> 00:23:14.179
合并，因此在这种情况下的合并涉及的程度不那么多

00:23:14.179 --> 00:23:19.970
因此，如果您需要合并两台计算机上的值，我们必须将所有

00:23:19.970 --> 00:23:25.250
来自两个基础集合的元素，然后我们按ID将它们分组，我们得到

00:23:25.250 --> 00:23:30.260
每个子元素的这些子组就像是冲突的副本，必须

00:23:30.260 --> 00:23:34.519
必须解决，所以我们需要减少这些人群中的我们

00:23:34.519 --> 00:23:39.679
减少好，我们有一个时间戳记，所以我们可以说好吧，我们根据

00:23:39.679 --> 00:23:46.730
时间戳，如果可能的话，这是我们的合并结果，就像

00:23:46.730 --> 00:23:52.730
因此，这些是获胜者，而查找将仅是两个元素，一个是

00:23:52.730 --> 00:23:58.610
删除了一个非常简单的方法，然后代码示例又如何

00:23:58.610 --> 00:24:05.990
基本上完全按照我所说的关于分组的方式实施，所以一旦我们

00:24:05.990 --> 00:24:11.179
有点确定，我们想走那条路，我们开始建立模型

00:24:11.179 --> 00:24:16.429
使用我们的集合对收藏夹API进行建模

00:24:16.429 --> 00:24:20.779
因此，确切地说，我们具有要同步的一组属性，即

00:24:20.779 --> 00:24:25.639
就像喜欢的数据一样，像名称位置一样，而我们拥有这些

00:24:25.639 --> 00:24:31.669
此最喜欢的州封装的三个附加元数据字段

00:24:31.669 --> 00:24:35.809
元素这些元数据是同步所必需的

00:24:35.809 --> 00:24:42.840
所以我想问一下，如果我们有相等的时间戳，我们该怎么办，所以正如我所说

00:24:42.840 --> 00:24:47.909
在合并中，我们有这些子组，我们可以减少，好吧，我们必须等于x

00:24:47.909 --> 00:24:55.169
乘以4到2倍，正如娜美在这里说的那样，钥匙必须保证

00:24:55.169 --> 00:25:00.809
有收敛的保证，所以无论发生什么事情都必须收敛

00:25:00.809 --> 00:25:05.580
在那种情况下对获胜者采取行动，并减少小组人数，所以如果有时间

00:25:05.580 --> 00:25:09.899
邮票是相同的，我们继续比较，所以我们检查的下一个

00:25:09.899 --> 00:25:16.590
删除标记，并且在城市中存在一个对或删除有偏见的条款

00:25:16.590 --> 00:25:20.100
偏见，所以您可以根据业务需求说可以，我喜欢

00:25:20.100 --> 00:25:25.440
删除或删除添加或删除等，即使删除

00:25:25.440 --> 00:25:30.539
松弛是一样的，我们甚至必须比较所有其余属性

00:25:30.539 --> 00:25:36.840
确定性Lee确定性融合操作正确，即使我们

00:25:36.840 --> 00:25:40.799
必须转到真正的最后一个属性，我们进行词典编排

00:25:40.799 --> 00:25:47.250
顺序比较，因为它是确定性的，所以一旦我们介绍了这些

00:25:47.250 --> 00:25:53.820
从应用程序客户端开始，在我们所有的层上都喜欢C或D T

00:25:53.820 --> 00:25:59.159
应用服务器数据库Nami设置到处都有相同的流程

00:25:59.159 --> 00:26:03.779
基本上在每一层的每个地方都有合并操作

00:26:03.779 --> 00:26:09.090
应用于来自其他层的值，所以

00:26:09.090 --> 00:26:14.490
更新来自UI来自客户端，客户端合并到其本地状态

00:26:14.490 --> 00:26:19.139
如果某些内容来自服务器，则此更新也可以被盲目合并

00:26:19.139 --> 00:26:22.710
到当地州，您不必担心冲突一次

00:26:22.710 --> 00:26:28.110
您已经正确地实现了模型，例如在服务器上，例如

00:26:28.110 --> 00:26:32.820
娜美（Nami）解释了反应情况，例如服务器有点像

00:26:32.820 --> 00:26:38.970
代理，以便服务器从客户端接收到的更新，即它获取的deef

00:26:38.970 --> 00:26:45.210
来自反应的数据解决了冲突，此处未显示，仅此而已

00:26:45.210 --> 00:26:49.000
需要合并这些值，数据库和客户端的值

00:26:49.000 --> 00:26:53.890
是的，推送到数据库，并将解析后的值返回给

00:26:53.890 --> 00:26:59.380
客户端，这很简单，它的编程模型也很简单，因为

00:26:59.380 --> 00:27:04.120
好吧，是的，基本上您不必担心实施所有

00:27:04.120 --> 00:27:07.840
这些冲突解决代码和每个单独的组件特别是

00:27:07.840 --> 00:27:11.440
如果您在我们的情况下拥有一个不同平台，不同客户的动物园

00:27:11.440 --> 00:27:19.630
到目前为止，您必须遵守相同的内容

00:27:19.630 --> 00:27:23.919
像现在这样想，是的，非常好，非常好，没有任何东西

00:27:23.919 --> 00:27:27.549
我们将与您分享的问题为什么我们不开始使用慈善机构大家

00:27:27.549 --> 00:27:31.330
对那种应用程序来说，为什么我们只需要一个

00:27:31.330 --> 00:27:37.210
正常设置的正常数据结构以及考虑在内的考虑因素和

00:27:37.210 --> 00:27:43.659
局限性总是有对的技巧，所以首先我要说的是问题

00:27:43.659 --> 00:27:51.429
慈善机构的一个众所周知的问题是汤姆·斯通（Tom Stone）的成长环境

00:27:51.429 --> 00:27:55.750
每次我们删除元素时，您都会生产此汤姆石，并将其存储

00:27:55.750 --> 00:28:01.809
在删除集中，直观地讲，您在上执行更新的次数越多

00:28:01.809 --> 00:28:07.179
在这个场景上，您会创建更多的Tom石头，并且可能是

00:28:07.179 --> 00:28:12.940
无限的增长，所以例如我们观察到我们刚推出我们的

00:28:12.940 --> 00:28:18.610
API，我们观察到一个betta用户只有五个未删除的收藏夹

00:28:18.610 --> 00:28:22.770
所以在用户界面中，他只看到一小部分信息

00:28:22.770 --> 00:28:26.380
进行同步，但是如果他实际上在对该平台进行严格的测试，那么他

00:28:26.380 --> 00:28:31.150
创建了类似三千个已删除元素的结果，从而导致JSON解压缩

00:28:31.150 --> 00:28:35.320
就像一个兆字节的哇，这太疯狂了，想象它来来往往

00:28:35.320 --> 00:28:42.429
电线，是的，我们可以争辩，好吧，我们希望能够修剪已删除的

00:28:42.429 --> 00:28:48.159
元素最终并没有为我们带来那么多的价值

00:28:48.159 --> 00:28:54.460
问题是什么时候可以这么说，要求可能应该是

00:28:54.460 --> 00:29:01.820
所有客户端必须观察该删除的元素，否则您

00:29:01.820 --> 00:29:05.600
可能会复活，所以想象一下客户端处于脱机状态，我们只是从

00:29:05.600 --> 00:29:08.420
服务器重新联机，看到该服务器

00:29:08.420 --> 00:29:12.110
没有那个值试图到达服务器不知道

00:29:12.110 --> 00:29:16.760
元素被删除了，那回来并不是很好，所以我们开始考虑还可以

00:29:16.760 --> 00:29:21.650
我们如何才能很好地解决这个问题，我们认为好吧，也许我们可以

00:29:21.650 --> 00:29:25.070
引入某种形式的客户意识，因此每个用户都有一套设备

00:29:25.070 --> 00:29:29.780
与该帐户相关联后，一旦我们拥有了

00:29:29.780 --> 00:29:35.390
这些客户的注册，一旦我们神奇地能够确定

00:29:35.390 --> 00:29:38.840
客户端的最后一次同步时间，如果他们都是

00:29:38.840 --> 00:29:44.420
客户已观察到已同步，删除了我们可以删除的收藏夹

00:29:44.420 --> 00:29:48.860
它有一些问题，尽管第一件事就是很好的跟踪

00:29:48.860 --> 00:29:53.570
最后一次同步时间非常棘手，事实证明这很棘手，并且

00:29:53.570 --> 00:29:57.320
第二件事是，是的，这基本上取决于时间

00:29:57.320 --> 00:30:03.530
我们知道正确的时间会发生什么，所以接下来的事情

00:30:03.530 --> 00:30:07.910
我们开始看的是介绍一些离开的时间

00:30:07.910 --> 00:30:12.380
因为汤姆·斯通斯（Tom Stone）有那么一点时间离开，在此之后的一段时间

00:30:12.380 --> 00:30:18.380
删除了汤姆石可以安全地删除的窍门是

00:30:18.380 --> 00:30:23.840
所有客户端和服务器必须应用相同的时间来执行实时规则，并且

00:30:23.840 --> 00:30:29.690
再次，这当然取决于时间，所以可能会有一些时间

00:30:29.690 --> 00:30:39.610
差异，当然您必须正确管理这些TTL规则

00:30:39.910 --> 00:30:45.680
我们要解决的下一件事是优化带宽

00:30:45.680 --> 00:30:52.610
这对我们的平台来说真的很重要，因为Nami设置了经典的

00:30:52.610 --> 00:30:59.240
与我们的CDT类型的数据结构一起工作的是，将所有

00:30:59.240 --> 00:31:03.860
说明这就是为什么它们实际上被称为基于州的Sur责任的原因，因此我们

00:31:03.860 --> 00:31:07.250
想要优化，我们只想对所有更新说def，所以在

00:31:07.250 --> 00:31:12.560
我在幻灯片中显示的示例客户端实际上具有一组元素服务器

00:31:12.560 --> 00:31:15.860
也有一组要修改的元素，这就是为什么

00:31:15.860 --> 00:31:21.500
将此时髦的双引号客户端也以本地状态修改为

00:31:21.500 --> 00:31:28.059
元素，它实际上将其发送到服务器，它只能发送更新的元素

00:31:28.059 --> 00:31:34.070
因为好看的东西并没有改变，我认为这是很直观的

00:31:34.070 --> 00:31:37.700
初始实施时，服务器实际上会做些什么，因此它将合并

00:31:37.700 --> 00:31:40.040
值，然后它将响应客户端

00:31:40.040 --> 00:31:44.690
现在使用完整的合并集来休息api，如果您这样做的话，效果不是很好

00:31:44.690 --> 00:31:49.059
例如有非常大的墓碑，例如很多墓碑

00:31:49.059 --> 00:31:54.110
我们需要注意的一件事是服务器响应

00:31:54.110 --> 00:31:58.610
服务器之前的b，实际上是从

00:31:58.610 --> 00:32:04.700
客户迷路了，所以我们介绍了这种叫做范围小偷的东西

00:32:04.700 --> 00:32:09.169
范围小偷实际上仅在以下情况下服务器才响应某些值：

00:32:09.169 --> 00:32:14.720
这些值实际上是vinny获胜的值，并且服务器假定

00:32:14.720 --> 00:32:19.610
客户端没有看到它们，因此如果客户端的所有更新都包含一个更新

00:32:19.610 --> 00:32:24.740
将是响应中的空集，但客户端并不真正在乎它

00:32:24.740 --> 00:32:28.520
从服务器接收到一些东西，它合并到本地状态后，响应

00:32:28.520 --> 00:32:35.150
从服务器就可以了，所以让我们谈谈时间，是的，有问题

00:32:35.150 --> 00:32:42.440
如果时间安排得当，就没有可靠的时间对，这有点像

00:32:42.440 --> 00:32:46.100
问题，尤其是如果您将时间戳记作为附加条件的话

00:32:46.100 --> 00:32:51.820
冲突Rizzoli的元数据，所以我实际上喜欢来自Janos bionaire的引用

00:32:51.820 --> 00:32:56.630
在他的一份演讲中，他认为实际上是在追踪时间

00:32:56.630 --> 00:33:01.429
当我们跟踪时间时，我们对时间本身不感兴趣

00:33:01.429 --> 00:33:04.820
至少确实需要做，以及分布式系统中我们真正需要的

00:33:04.820 --> 00:33:09.410
是事件的顺序，因此我们需要了解发生了什么事

00:33:09.410 --> 00:33:13.730
在几秒钟之内发生什么类似的事情，所以在这种情况下

00:33:13.730 --> 00:33:20.870
但是最重​​要的是因果关系和有序性，所以我们认为

00:33:20.870 --> 00:33:26.630
时间可能就足够了，但这意味着什么，所以让我们

00:33:26.630 --> 00:33:29.820
看一下两种排序的情况，一种是在场景内排序

00:33:29.820 --> 00:33:35.190
注意听起来很简单，对，这是一个没有分布状态的状态，

00:33:35.190 --> 00:33:39.930
很好，它仍然很棘手，所以例如，我想你们大多数人都知道

00:33:39.930 --> 00:33:45.720
如果您使用的是当前Milly的GVM API系统，则它不是单调的

00:33:45.720 --> 00:33:51.300
无法保证如果您连续两次调用系统电流

00:33:51.300 --> 00:33:55.770
Millis第二个值将保证比第一个值高

00:33:55.770 --> 00:34:00.900
您甚至在本地更新或您的更新可能有点棘手

00:34:00.900 --> 00:34:06.060
您的收藏夹状态，对我们来说，重要的是我们使用时间戳

00:34:06.060 --> 00:34:11.130
是一个逻辑时钟，我们需要保证它单调增长

00:34:11.130 --> 00:34:16.620
例如，我们在客户端上使用了这些+1策略，因此客户端在执行该操作时会做什么

00:34:16.620 --> 00:34:22.500
在设置的小时内对元素的进行更新，因此需要

00:34:22.500 --> 00:34:27.450
像本地时间戳提供商一样追溯时间戳节拍

00:34:27.450 --> 00:34:32.430
如果可能的话，可以根据情况来自服务器

00:34:32.430 --> 00:34:36.990
是否从服务器获取它，但是当它需要保证至少它

00:34:36.990 --> 00:34:42.780
不会低于已经设置的时间戳，这就是为什么

00:34:42.780 --> 00:34:47.760
最糟糕的情况是我们执行+1，这听起来有点为什么，但实际上是的，我们只是

00:34:47.760 --> 00:34:52.230
需要确保此操作将在本地一次获胜

00:34:52.230 --> 00:34:57.000
节点，所以事情来了当我们谈论订购时，事情变得更糟

00:34:57.000 --> 00:35:02.520
来自不同节点的更新确实是一个棘手的话题，所以我们当然

00:35:02.520 --> 00:35:08.460
很幸运，我们的某些设备是P＆D，所以他们有这个GPS GPS时钟

00:35:08.460 --> 00:35:14.010
如果GPS时钟可用，那么您就可以精确计时了

00:35:14.010 --> 00:35:21.090
是它并不总是可用，所以在最坏的情况下，如果我们没有这个

00:35:21.090 --> 00:35:26.580
因此，如果我们至少没有GPS报价时钟，则我们更愿意使用

00:35:26.580 --> 00:35:32.820
服务器时间超过客户端时间，更确切地说，如果我们

00:35:32.820 --> 00:35:37.500
甚至没有一个还可以，至少我们退回到这个加一

00:35:37.500 --> 00:35:41.920
在本地节点上保留更新的策略

00:35:41.920 --> 00:35:46.540
如果您有多个客户端在修改，这当然是最重要的情况

00:35:46.540 --> 00:35:52.630
复制集中的相同元素，并且它们没有可靠的时间

00:35:52.630 --> 00:35:57.099
不知何故，您可能会遇到一些情况，这取决于业务

00:35:57.099 --> 00:36:02.290
它接受或可能不接受金融交易的要求

00:36:02.290 --> 00:36:07.720
真的，所以让我们谈另一个问题，所以我们已经看过那张照片了

00:36:07.720 --> 00:36:11.920
合并到处都是很棒，是的，我们只需要使用

00:36:11.920 --> 00:36:15.520
到处都具有相同的功能，因此可以合并以将其全部统治

00:36:15.520 --> 00:36:21.069
问题很好，问题在于这些合并必须具有相同的行为方式

00:36:21.069 --> 00:36:26.290
给定相同的输入，它必须产生相同的结果，如果不好的话

00:36:26.290 --> 00:36:32.020
差异可能导致无止尽的同步循环，这很漂亮

00:36:32.020 --> 00:36:38.619
对客户不利，这当然不会破坏客户端上的数据

00:36:38.619 --> 00:36:43.180
服务器，但客户端将无法使用特定的客户端，因为它将

00:36:43.180 --> 00:36:46.839
总是合并产生具有不同值的相同内容，然后推动它

00:36:46.839 --> 00:36:49.869
回到服务器，来回来回来回切换，我们有一些机制可以

00:36:49.869 --> 00:36:55.809
真正保护我们免受客户的侵害

00:36:55.809 --> 00:37:02.770
速率限制等，但仍然可能是一个问题，所以那是什么

00:37:02.770 --> 00:37:07.089
指向实际上我们想要显示的内容，有时我们想要显示的很好

00:37:07.089 --> 00:37:12.309
学术性可能并不那么可怕，我知道现在大多数时候我们都处于lambda天

00:37:12.309 --> 00:37:16.930
您实际上喜欢具有相当不错的学术背景，我很确定，但是

00:37:16.930 --> 00:37:21.579
还是喜欢我们的镜像实用程序员，是的，有时候

00:37:21.579 --> 00:37:26.170
开始以CR DT为例，因此我们将打开Wikipedia，然后

00:37:26.170 --> 00:37:31.599
然后您会读到，这是您的职责，它是一个有界的半晶格，

00:37:31.599 --> 00:37:36.130
加入操作好，这是什么意思，然后有很多公式等

00:37:36.130 --> 00:37:39.880
所以您必须花一些时间来解密这些东西，但重点是

00:37:39.880 --> 00:37:45.069
有时候值得，而且其中一些解决方案非常简洁

00:37:45.069 --> 00:37:51.250
在我们的案例中，它被证明比直觉上的某种本土生产的要好得多

00:37:51.250 --> 00:37:56.579
一些本地算法，可能无法在所有

00:37:56.579 --> 00:38:00.599
当然，如我们所示，仍然存在一些局限性，您必须

00:38:00.599 --> 00:38:04.260
了解您的系统的实际使用情况，并不断监控并查看它是否

00:38:04.260 --> 00:38:10.410
仍然符合您的要求，并在需要时进行改进，因此

00:38:10.410 --> 00:38:14.730
关于代码，因此我们发布了两个小型存储库，并提供了示例

00:38:14.730 --> 00:38:19.440
我们展示了不同的CDT集，包括我们的集，代码很漂亮

00:38:19.440 --> 00:38:22.619
小实际上在Scala中有set实现，就像80行

00:38:22.619 --> 00:38:27.210
很好的代码不是因为它是骷髅，而是因为它很

00:38:27.210 --> 00:38:32.849
简单，如果您有一个基于Java Java Java 8的实现，

00:38:32.849 --> 00:38:38.339
有兴趣的人，这是我们好奇心的作业，因此，如果您有兴趣

00:38:38.339 --> 00:38:42.780
有关该主题的一些其他信息，所以实际上第一次讨论是

00:38:42.780 --> 00:38:47.359
激发了我们尝试诺亚的C或DT的能力，我真的很推荐那个演讲

00:38:47.359 --> 00:38:52.730
也是克里斯·迈克尔·约翰（Chris Michael John），他以前来自巴西亚（Barcia）

00:38:52.730 --> 00:38:58.920
阅读有关首席执行官职责的清单第三个是来自首席执行官的论文

00:38:58.920 --> 00:39:03.390
CDT的原始作者创造了术语CDT和强大的最终一致性

00:39:03.390 --> 00:39:09.839
从半实际的角度来看，这是两个更多的链接，所以最后一个也是

00:39:09.839 --> 00:39:15.059
我的折痕使我的作品成为现实Michael John是一种基于Erlang的语言，

00:39:15.059 --> 00:39:19.680
 Erlang的顶部，这里的DTS确实是一流的公民

00:39:19.680 --> 00:39:25.400
那里真的很有趣，还有很多，是的，就像

00:39:25.400 --> 00:39:29.819
您使之使用EITS的某种框架

00:39:29.819 --> 00:39:33.660
为了同步，在该链接中实际上有一个示例

00:39:33.660 --> 00:39:40.049
您可以构建离线广播Web应用程序，是的，非常感谢

00:39:40.049 --> 00:39:42.200
很多

