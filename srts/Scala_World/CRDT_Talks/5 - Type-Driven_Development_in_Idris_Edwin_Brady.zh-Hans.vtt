WEBVTT
Kind: captions
Language: zh-Hans

00:00:26.610 --> 00:00:32.590
好的，女士们，先生们，欢迎我们的演讲，我很高兴

00:00:32.590 --> 00:00:36.100
现在向您介绍埃德温·布雷迪，我想看看

00:00:36.100 --> 00:00:42.550
你知道埃德温·布雷迪（Edwin Brady），他是圣保罗大学的讲师。安德鲁斯我看到一个非常

00:00:42.550 --> 00:00:50.020
我非常热衷于依赖类型系统

00:00:50.020 --> 00:00:54.940
称它为空白确实是那时

00:00:54.940 --> 00:00:58.120
你领先于曲线他也以空白着称，兴趣是

00:00:58.120 --> 00:01:06.610
叫做T mmm-hmm complete nodetráscomplete非常好为什么叫

00:01:06.610 --> 00:01:10.510
参与者完成得很好，我们将介绍哦，不，他们实际上叫Pacman

00:01:10.510 --> 00:01:17.830
完成，但我认为它们是等效的，可能是一个定理，不，不，我有

00:01:17.830 --> 00:01:22.180
我已经有了建设性的证明，可以迈出一步，但我们会看到我们会看到

00:01:22.180 --> 00:01:29.110
那和他最喜欢的啤酒是百威啤酒正确逮捕了那个男人

00:01:29.110 --> 00:01:41.560
好的，女士们，先生们，请热烈的掌声，因为这是我的，是的

00:01:41.560 --> 00:01:45.340
所以非常感谢您的介绍，也非常感谢您

00:01:45.340 --> 00:01:49.960
约翰邀请我，我不知道我不太清楚

00:01:49.960 --> 00:01:56.200
为什么他邀请我，因为说实话我实际上不认识任何学者

00:01:56.200 --> 00:02:00.400
与头骨的链接有点微弱，你们中有些人可能已经看过一对

00:02:00.400 --> 00:02:06.550
多年前，我曾与Mile进行过一次演讲，将Scala与Idris进行了比较，这是一种

00:02:06.550 --> 00:02:11.319
链接的一部分，所以我对Scala的体验是围绕无形的

00:02:11.319 --> 00:02:16.720
有点像在跑步之前跑步，所以我一直在让这些

00:02:16.720 --> 00:02:20.200
有点冲动我试图获得想法，而不是想太多

00:02:20.200 --> 00:02:24.640
关于语法，我从中获得了很多非常有趣的想法

00:02:24.640 --> 00:02:28.360
我见过的上衣，希望您能从中得到一些回报

00:02:28.360 --> 00:02:31.840
重要的是，即使我不这样做，但我并不是真的要把你从

00:02:31.840 --> 00:02:35.260
成为学者计划，成为感兴趣的程序员，我真的在这里，因为我

00:02:35.260 --> 00:02:39.640
希望您能窃取我的想法，以便您能拿出一些想法

00:02:39.640 --> 00:02:42.820
您在礼服中看到您认为自己可以应用于您的程序规模，或者

00:02:42.820 --> 00:02:50.350
然后，请更广泛地讲与该谈话有关的另一件事

00:02:50.350 --> 00:02:53.020
英里实际上是不是这里是是

00:02:53.020 --> 00:02:59.020
所以我们所做的是我写了几个白痴程序，他们

00:02:59.020 --> 00:03:02.770
基本上是挑战，我用完整的程序编写了程序

00:03:02.770 --> 00:03:08.230
在伊卡洛斯（Icarus）的依存类型系统，说好的里程可以做到吗？

00:03:08.230 --> 00:03:13.780
惊讶，我不应该感到惊讶，但令我惊讶的是，他如此讲了

00:03:13.780 --> 00:03:21.210
将是该游戏的下一步，所以我们将看看会发生什么

00:03:21.210 --> 00:03:26.380
接受了极好的挑战，说英里看视频没有得到，

00:03:26.380 --> 00:03:31.570
互联网英里步骤挑战已被接受，因此一些人提出了要求

00:03:31.570 --> 00:03:35.680
我来自圣彼得斯堡的最后几天安德鲁斯，所以现在他在

00:03:35.680 --> 00:03:40.240
苏格兰，您可能会或可能不会了解苏格兰的一件事是

00:03:40.240 --> 00:03:44.890
从某种意义上说，它是函数式编程的精神家园吗？

00:03:44.890 --> 00:03:51.580
 Haskell来自苏格兰毫升，它是苏格兰的一种编程语言，而我们

00:03:51.580 --> 00:03:57.880
现在在苏格兰升旗，以反映国家的这一重要方面

00:03:57.880 --> 00:04:02.260
历史，所以似乎我应该介绍另一个苏格兰人似乎是对的

00:04:02.260 --> 00:04:08.170
可以对苏格兰的函数式编程语言进行编程，好吧，我要

00:04:08.170 --> 00:04:11.620
谈论一件衣服，这是pacman完整的函数式编程语言

00:04:11.620 --> 00:04:15.700
通过吃豆人完成，我基本上是说那里有足够的可用空间

00:04:15.700 --> 00:04:19.359
如果您愿意的话，您可以实施pac-man，所以人们谈论

00:04:19.359 --> 00:04:22.660
你知道一种新的语言是否出现人们认为这是你的人们问的

00:04:22.660 --> 00:04:26.080
如果您的残缺不全，他们可能会担心，如果情况不完全-您的残缺不全，但我

00:04:26.080 --> 00:04:29.920
认为对某件事说那不是真的不是那么有用的话

00:04:29.920 --> 00:04:34.770
例如，宽阔的空间可以完成操纵，但不满足于pac-man的要求

00:04:34.770 --> 00:04:40.060
再一次，也许有人会接受这一挑战来证明这一点，但我认为

00:04:40.060 --> 00:04:43.180
以吃豆人的名义说些话要有用得多，因为

00:04:43.180 --> 00:04:46.870
有能力使用您喜欢的语言并与系统库对话

00:04:46.870 --> 00:04:50.040
并进行系统交互，那么您就有了一些东西

00:04:50.040 --> 00:04:55.380
可能真正有用的嗯，我也一开始就让你知道

00:04:55.380 --> 00:04:59.160
如果有Haskell平台，如何安装东西的说明

00:04:59.160 --> 00:05:01.980
像这样安装在房间上可能具有Haskell平台

00:05:01.980 --> 00:05:06.780
安装也许他们喊了几次，但有二进制文件

00:05:06.780 --> 00:05:09.360
您可以下载并提供所有可用的示例

00:05:09.360 --> 00:05:13.170
在本次演讲中，所有这些都可以在线获得，以供您玩耍，然后尝试

00:05:13.170 --> 00:05:18.540
自己动手吧，所以这将分为两个部分，我不会假设

00:05:18.540 --> 00:05:21.270
任何人对一件衣服一无所知，我知道可能会有几个人

00:05:21.270 --> 00:05:27.150
其实只是为了我自己，我不知道虚荣心是因为

00:05:27.150 --> 00:05:31.200
把手放在任何愿意尝试的人身上，哦，这真是令人惊讶的感谢

00:05:31.200 --> 00:05:37.590
你，所以我要讲一些语法和一些基本的

00:05:37.590 --> 00:05:40.680
的想法，并希望即使您之前已经看过它，

00:05:40.680 --> 00:05:45.140
您会学到一些新东西，但是我想知道的是为什么我认为

00:05:45.140 --> 00:05:49.080
一流的依存类型，因此在语言权利上具有依存类型

00:05:49.080 --> 00:05:53.880
从一开始就已内置到语言中，这是一种有意的功能

00:05:53.880 --> 00:05:58.650
拥有的真正有价值的东西，希望您会在您知道时卖给您

00:05:58.650 --> 00:06:02.670
当您使用类型级别编写花式scala程序时

00:06:02.670 --> 00:06:05.820
扩展程序，您至少会考虑好的，如果我能够的话，这将如何工作

00:06:05.820 --> 00:06:09.300
用一流的类型来表达它，也许可以更好地理解

00:06:09.300 --> 00:06:13.950
下面发生了什么，所以我想向您展示的例子就是那种

00:06:13.950 --> 00:06:18.780
我认为验证很有可能

00:06:18.780 --> 00:06:22.950
在短期内是有用的，所以实际上我们将无法

00:06:22.950 --> 00:06:28.200
可以说在不久的将来我已经编写了程序，它可以进行类型检查并发送

00:06:28.200 --> 00:06:30.390
好的，但是我们将能够坐在那里

00:06:30.390 --> 00:06:33.660
是我们程序的片段，所以我们在网络上工作的地方

00:06:33.660 --> 00:06:37.530
基础架构，或者您知道我们程序的核心组成部分

00:06:37.530 --> 00:06:40.380
真的必须确信我会运行我们想要成为的航空电子软件

00:06:40.380 --> 00:06:44.340
相当确定它在做正确的事情，所以我认为那些核心组件

00:06:44.340 --> 00:06:47.490
在不久的将来，我们有合理的机会能够使用这些种类

00:06:47.490 --> 00:06:52.230
在这些空间中工作的依赖类型技术的介绍我要给你一些

00:06:52.230 --> 00:06:57.630
关于我们如何能够使用诸如地址之类的语言来做到这一点的想法，所以我想

00:06:57.630 --> 00:07:02.100
说一些我认为类型有用的东西，所以我以这个命名

00:07:02.100 --> 00:07:05.780
Idris中的语音类型开发有两个原因

00:07:05.780 --> 00:07:10.850
我后来谈到第二个原因，第一个原因是我看过很多东西

00:07:10.850 --> 00:07:15.950
最后一天左右的类型，很多人都说类型是针对

00:07:15.950 --> 00:07:20.240
如果程序类型为我们，则使我们确信程序是正确的

00:07:20.240 --> 00:07:26.210
检查我们是否知道它可以工作到一定程度，这就是

00:07:26.210 --> 00:07:29.360
太好了，这是绝对正确的事情，您可以做很多事情

00:07:29.360 --> 00:07:35.000
类型，我们应该使用类型，而不仅仅是让机器知道

00:07:35.000 --> 00:07:38.450
当我们做对了事情之后，我们也应该使用类型作为一种手段

00:07:38.450 --> 00:07:42.890
引导我们走向将要运行的程序，因此想起来太容易了

00:07:42.890 --> 00:07:47.360
您编写长程序后，将其提交给您知道的类型检查器

00:07:47.360 --> 00:07:51.230
您将其发送给您的老师进行评分，然后回来并说您知道

00:07:51.230 --> 00:07:55.220
三个类型错误下课后看到我，我们想做的是

00:07:55.220 --> 00:08:00.410
认为类型检查器是您的实验室助手，所以如果您先编写类型

00:08:00.410 --> 00:08:03.080
说好的实验室助理，这就是我们要去的

00:08:03.080 --> 00:08:06.530
让我们每隔一段时间就一起努力工作吧，您也许可以说

00:08:06.530 --> 00:08:10.130
好吧，我不确定该程序如何工作，能给我一个提示而不是

00:08:10.130 --> 00:08:13.880
而不是您知道生成一些代码并进行测试，因为它看起来可能像

00:08:13.880 --> 00:08:17.150
是正确的，看看类型检查器是否接受它，所以我们将看到一些示例

00:08:17.150 --> 00:08:22.820
稍后我们将继续介绍示例，这是怎么回事？

00:08:22.820 --> 00:08:26.419
我开始使用的口头禅，我们将在他的一生中看到

00:08:26.419 --> 00:08:31.400
测试驱动的开发有一个红色绿色重构，我们已经定义了类型

00:08:31.400 --> 00:08:34.610
精炼我很伤心，因为找不到与定义的押韵词有关的单词

00:08:34.610 --> 00:08:38.539
并加以完善，所以如果有人让我知道，那么我们所做的一切就是

00:08:38.539 --> 00:08:44.990
将是正确的或检查器类型定义一个函数，我们可以定义

00:08:44.990 --> 00:08:48.740
可能不完整的功能，我们可以说好吧，我们拥有大部分

00:08:48.740 --> 00:08:51.380
功能，我将为我尚未使用的功能留出一个空洞

00:08:51.380 --> 00:08:54.650
还没写，然后我们可以做的另一件事就是提炼，所以我要说我

00:08:54.650 --> 00:08:57.500
我们将使用很多词“提炼”

00:08:57.500 --> 00:09:01.670
可能不完整并对其进行完善，因此它的定义可能更完整，或者

00:09:01.670 --> 00:09:05.600
信息量稍大一点，基本上我们所做的一切

00:09:05.600 --> 00:09:11.810
进入这三个标题之一，所以每次都一直认为这是一个

00:09:11.810 --> 00:09:16.010
我们定义的类型是我们正在完善，我想我们可以在最后添加重构

00:09:16.010 --> 00:09:18.860
一旦我们有一个工作的专业人士，我们就可以安全地重构，知道如果

00:09:18.860 --> 00:09:24.260
它继续进行类型检查，仍然可以，所以就在我继续之前

00:09:24.260 --> 00:09:27.830
该演示并未对Idris的某些功能进行快速介绍，因为

00:09:27.830 --> 00:09:32.060
这是一种常见问题，人们总是首先问我头等舱

00:09:32.060 --> 00:09:38.290
依赖类型，所以我在这里说头等舱的意思是语法和

00:09:38.290 --> 00:09:43.130
类型级别和值级别的语义相同，因此没有

00:09:43.130 --> 00:09:46.850
没有区别，没有障碍，两者之间没有障碍

00:09:46.850 --> 00:09:49.190
两种语言真的完全一样

00:09:49.190 --> 00:09:52.310
语言，您可以在表达式中编写的任何内容，可以在类型和类型中编写的语言

00:09:52.310 --> 00:09:56.750
反之亦然，只要它键入检查，那么当您引入功能时

00:09:56.750 --> 00:10:00.230
对人们的编程我们经常说功能是一流的，因为它

00:10:00.230 --> 00:10:03.470
意味着我们可以像其他任何价值一样传递他们，我们可以与他们竞争

00:10:03.470 --> 00:10:07.580
就像一流类型系统中的其他任何值一样，我们的类型也是如此

00:10:07.580 --> 00:10:12.410
可以像计算其他任何值一样计算它们的生成量，尽管Haskell

00:10:12.410 --> 00:10:17.000
启发式语法有时我会后悔，因为这意味着人们认为它应该

00:10:17.000 --> 00:10:20.870
像Haskell一样以各种方式工作，而我只是碰巧喜欢

00:10:20.870 --> 00:10:25.160
Haskell语法中有些事情发生了一些变化，但我没有

00:10:25.160 --> 00:10:28.130
就像您知道单身一样：4种类型，而不是双冒号

00:10:28.130 --> 00:10:33.760
这是一种编译语言，有两种

00:10:33.760 --> 00:10:38.630
通过仅运行本机通过C安装它时获得的代码生成器

00:10:38.630 --> 00:10:43.640
通过JavaScript编写的一个代码确实具有可插入的后端系统，因此您可以

00:10:43.640 --> 00:10:47.540
如果您有的话，可以将其导出接口到

00:10:47.540 --> 00:10:51.440
中间语言，所以如果您想要JVM后端，那么一定要继续

00:10:51.440 --> 00:10:58.210
并写下来，我很乐意帮助您拥有精确的类型，这意味着我们可以

00:10:58.210 --> 00:11:02.260
也进行了优化，因此我们可以阅读您的攻击性内联攻击性欧亚

00:11:02.260 --> 00:11:06.680
在我看来，如果编译器对程序了解更多，那

00:11:06.680 --> 00:11:11.330
应该做的程序应该能够在编译时做更多的工作来使

00:11:11.330 --> 00:11:15.320
该程序效率更高，因此可以删除诸如

00:11:15.320 --> 00:11:23.420
不必要的，依此类推嗯，我把我勇敢地像特质那样放在班上

00:11:23.420 --> 00:11:26.740
Scala希望这是正确的

00:11:27.290 --> 00:11:32.590
是正确的整理吗，好吗

00:11:32.700 --> 00:11:37.880
它束缚了群众，本质上是一种定义类型的接口的方式

00:11:37.880 --> 00:11:41.760
指出类型可以做什么的接口

00:11:41.760 --> 00:11:47.190
与Haskell严格评估不同，但如果您想进行懒惰评估，则可以

00:11:47.190 --> 00:11:51.210
懒惰作为一种类型，我们实际上不会在本次演讲中谈到

00:11:51.210 --> 00:11:56.520
因为有人总是要求如此严格的评估，

00:11:56.520 --> 00:11:59.160
点点滴滴做外来功能系统互动

00:11:59.160 --> 00:12:03.540
好的，所以我要做的主要是现场直播

00:12:03.540 --> 00:12:07.560
因为如果我真的向您展示正在发生的事情会更有趣，而且

00:12:07.560 --> 00:12:12.870
如果不是我只做某事，而是大声疾呼有关的问题，那会更有趣

00:12:12.870 --> 00:12:15.990
论坛，如果您这样做或其他人只是为了证明我还没有这样做，该怎么办

00:12:15.990 --> 00:12:20.490
如果您想大声疾呼建议，然后改用其他方法

00:12:20.490 --> 00:12:30.420
方向好吧，那么这个问题的答案是什么好

00:12:30.420 --> 00:12:36.270
继续前进到其他地方，然后嗯，我想我实际上可以只是为了

00:12:36.270 --> 00:12:39.720
向您展示编译和运行的事物，因为我知道您有多熟悉

00:12:39.720 --> 00:12:43.200
依赖类型的理论终点，但有时确实存在

00:12:43.200 --> 00:12:46.290
认为它具有类型检查功能的人，我无需费心测试它，因为我

00:12:46.290 --> 00:12:51.270
已经知道它可以工作，并且在某种程度上是对的，但是我们确实希望

00:12:51.270 --> 00:12:55.470
运送它们并在某些时候出售它们，以便我可以向您出售我的世界程序

00:12:55.470 --> 00:12:59.910
正确，我将其编译为可执行文件，然后我们就开始了

00:12:59.910 --> 00:13:07.140
有一个可以按通常方式工作的批处理编译器，我们还读取了eval打印信息

00:13:07.140 --> 00:13:11.850
如此循环遍历所有您所熟悉的工具

00:13:11.850 --> 00:13:18.210
来自其他语言，所以我想向您展示的第一件事是最简单的

00:13:18.210 --> 00:13:22.130
一流的类型，所以如果您不理解一流的类型，我的意思是

00:13:22.130 --> 00:13:26.310
希望可以使您更清楚地知道区别在哪里

00:13:26.310 --> 00:13:30.450
在类型和值之间没有一个，所以我将从编写一个函数开始

00:13:30.450 --> 00:13:34.710
顺便说一句，这是在文本编辑器的a中，所以我已经开始

00:13:34.710 --> 00:13:39.270
使用亚当文本编辑器，因为我一直在使用vim进行演讲，人们说

00:13:39.270 --> 00:13:43.020
之后对我来说很好，但是我希望我不必使用vim，所以我

00:13:43.020 --> 00:13:45.270
使用亚当，只是您不必使用它

00:13:45.270 --> 00:13:53.880
大概在某个时候让我的手指纠结，所以当我们做的时候，魏斯

00:13:53.880 --> 00:13:56.940
做类型驱动的开发，总是以类型为先，所以我在此方面所拥有的

00:13:56.940 --> 00:14:00.900
文件是几种类型，我们将使用这些类型将我们引向

00:14:00.900 --> 00:14:06.090
程序，所以首先键入此类型，这将是我们

00:14:06.090 --> 00:14:09.870
计算这将是如果布尔值是真的，我们将让它返回

00:14:09.870 --> 00:14:13.980
布尔值表示单例，如果是的话，我们将返回一个单例

00:14:13.980 --> 00:14:17.790
自然数，如果为假，则不是单例，我们将返回列表

00:14:17.790 --> 00:14:23.130
自然数，所以我在阿萨姆邦要做的是，我说好了，我已经给了类型

00:14:23.130 --> 00:14:28.920
我是一个骨架定义，所以这是一个ctrl alt，用于添加定义，它

00:14:28.920 --> 00:14:33.270
给了我一个骨架的定义，所以这东西在这里列出吧，HS这是一个整体

00:14:33.270 --> 00:14:39.480
所以这在语法上是有效的，如果可以加载，我可以将其加载到其中吗

00:14:39.480 --> 00:14:48.210
导入序言0以统一，所以我可以将其加载到repple中，它将

00:14:48.210 --> 00:14:52.110
快乐地加载它，它会说好吧，您有几个孔，嗯，

00:14:52.110 --> 00:14:58.590
颜色清晰，不是真的，我要关闭颜色，那里有一个

00:14:58.590 --> 00:15:01.640
顺便提一下你

00:15:11.130 --> 00:15:18.240
对，嗯，这样我们就可以检查里面这个孔的类型

00:15:18.240 --> 00:15:24.190
在atham内部，所以按Ctrl-t滑到底部，它将为我们带来互动

00:15:24.190 --> 00:15:28.329
告诉我们结果是什么的窗口我们刚才问的东西有

00:15:28.329 --> 00:15:32.680
我们可以在这里做的其他事情，就像我们可以问文件一样，如果我

00:15:32.680 --> 00:15:37.750
将鼠标悬停在网上，然后按Ctrl或D键，它将向我们提供有关该文件的说明

00:15:37.750 --> 00:15:40.660
我们从中得到什么，所以有很多有用的点点滴滴

00:15:40.660 --> 00:15:44.800
允许我们与系统交互这是Idris所做的全部

00:15:44.800 --> 00:15:48.370
顺便说一下，这里的工作是亚当，很薄，有一个很薄的包装纸，

00:15:48.370 --> 00:15:53.800
这意味着您可以轻松地使其适应您喜欢的文本编辑器，并

00:15:53.800 --> 00:16:01.540
有vim和Emacs模式可以，所以我们还可以检查我们在哪里编写程序

00:16:01.540 --> 00:16:06.670
通过检查输入的可能值，以便单调

00:16:06.670 --> 00:16:09.820
这里是单例的可能值，因为实际上是布尔值，我们可以看一下

00:16:09.820 --> 00:16:13.690
在它们是什么的情况下，可能的值是false和true，所以如果我点击

00:16:13.690 --> 00:16:17.529
ctrl alt c4k拆分为单例，它将拆分回两个

00:16:17.529 --> 00:16:22.269
的可能性，如果你还记得我之前说过的话，那不是一个单例

00:16:22.269 --> 00:16:27.070
那将是NAT的列表，如果的确是单例，则是NAT

00:16:27.070 --> 00:16:30.310
那么为什么我们要这样做呢？为什么要编写函数来

00:16:30.310 --> 00:16:36.910
计算类型很好，就是我们要在类型中使用它，以便我们可以做

00:16:36.910 --> 00:16:41.350
让我们根据较早输入的类型来计算较晚输入的类型

00:16:41.350 --> 00:16:44.440
输入，因此我们将运行此函数，因为此函数返回一个

00:16:44.440 --> 00:16:48.399
类型，我们将在它是一种类型的上下文中在上下文中运行它

00:16:48.399 --> 00:16:52.420
是必需的，所以这里的一些清单将汇总事物列表或

00:16:52.420 --> 00:16:56.050
给出一个自然数的值，具体取决于单例和

00:16:56.050 --> 00:17:01.630
下一个输入，因此，如果我查看此孔的类型，将会看到我们输入的

00:17:01.630 --> 00:17:06.400
我们的单例是布尔值，而X是计算出的列表类型

00:17:06.400 --> 00:17:10.390
从那个单身人士的价值来看，所以我真的不能在这里取得任何进展，或者

00:17:10.390 --> 00:17:13.990
我唯一可以做的有趣的事情就是

00:17:13.990 --> 00:17:18.400
检查单例我还不能检查X，因为我不知道它是什么类型

00:17:18.400 --> 00:17:23.550
在运行此功能之前，我不知道它是什么类型，所以我将进行大小写拆分

00:17:23.550 --> 00:17:28.510
单例，如果我现在检查一下，我将查看一些列表的类型RHS

00:17:28.510 --> 00:17:31.840
一个，所以这是已经创建的漏洞之一，我们知道单例是

00:17:31.840 --> 00:17:37.480
假X输入了此类型的单例，抱歉，如果我现在看一下它的类型

00:17:37.480 --> 00:17:41.620
您会看到它改进了X的类型，因为它现在知道

00:17:41.620 --> 00:17:47.230
上下文单例为假X必须是NAT的列表，并且您相应地知道

00:17:47.230 --> 00:17:51.880
如果我进行大小写拆分，它将为我提供列表的大小写，在其他情况下

00:17:51.880 --> 00:17:55.900
如果我进行K分割，它将得到我的情况，所以这里发生了什么

00:17:55.900 --> 00:18:01.030
是机器计算出的一种输入的值的类型中的一种

00:18:01.030 --> 00:18:05.680
下一个输入的值，所以我不会完成此定义，但是

00:18:05.680 --> 00:18:10.270
我将向您展示一个定义，其中发生了这种情况

00:18:10.270 --> 00:18:13.870
示例，如果您曾经使用过任何C编程，就可以看到全部

00:18:13.870 --> 00:18:20.140
当您使用printf时，这个技巧正好如此，因此我还将在此文件中

00:18:20.140 --> 00:18:24.880
告诉你printf的类型，所以printf的类型完全一样

00:18:24.880 --> 00:18:29.770
我们刚刚看到过，所以它需要格式字符串作为输入和返回类型

00:18:29.770 --> 00:18:36.820
是从此格式字符串计算得出的，因此准备好printf的类型降序即可

00:18:36.820 --> 00:18:41.020
说好吧，这是一个字符串到字符串或％F身份好吧，这就是

00:18:41.020 --> 00:18:45.580
行业，因此C编译器必须通过一些编译器hack才能做到这一点

00:18:45.580 --> 00:18:48.490
确保您具有正确的格式化字符串，这只是一个必要的任务，因此，

00:18:48.490 --> 00:18:52.330
您可能会使用一流类型的东西是

00:18:52.330 --> 00:18:57.040
您可能有一些架构描述，而该架构描述

00:18:57.040 --> 00:19:01.810
例如，将计算数据库查询的有效类型，因此

00:19:01.810 --> 00:19:08.590
扩大这个范围，这样您好，世界示例1您好，世界示例2是

00:19:08.590 --> 00:19:15.520
将成为向量，因为它总是向量，我们使用向量的原因

00:19:15.520 --> 00:19:20.650
因此向量是按其长度参数化的列表，这是我们使用向量的原因

00:19:20.650 --> 00:19:25.230
举个例子，因为与printf不同，它们确实有用

00:19:25.230 --> 00:19:30.400
所以我总是一定会在Haskell编写程序，

00:19:30.400 --> 00:19:33.310
假设我拥有的列表是非空的，并且该假设是

00:19:33.310 --> 00:19:37.370
完全对我刚刚编写的程序有效，然后在12个月后

00:19:37.370 --> 00:19:41.390
违反了其他文件中的假设，我崩溃了，那是

00:19:41.390 --> 00:19:45.050
出乎意料，所以这是我很乐意为您提供的东西

00:19:45.050 --> 00:19:48.920
当我编写Haskell程序时直接知道它，那么会发生什么

00:19:48.920 --> 00:19:53.840
一个向量，您是否可以基本上通过提供一个类型构造函数来声明类型

00:19:53.840 --> 00:20:00.020
这说明了如何建立该类型，以及一些数据构造函数来说明如何

00:20:00.020 --> 00:20:03.830
建立那种类型的值，所以nil这是一个零东西的向量，

00:20:03.830 --> 00:20:09.860
缺点是给定事物的向量，K事物来了或事物将具有

00:20:09.860 --> 00:20:15.620
套管的后继者，因此它的K的后继者可以读为1加K

00:20:15.620 --> 00:20:20.660
基本上这样，在本机中，使用构造函数0和1加定义的数据类型

00:20:20.660 --> 00:20:27.050
比那种一旦拥有就可以做的事就更好了

00:20:27.050 --> 00:20:30.560
可以表达您在列表中具有的功能的变体，因此，如果我有一个

00:20:30.560 --> 00:20:36.650
我想将一个函数应用于两个对应的向量的函数，所以这是

00:20:36.650 --> 00:20:40.130
您拥有的拉链宽度功能是否假定您必须拥有一个

00:20:40.130 --> 00:20:43.460
在Scala中等效，您拥有了一切，还有一点点

00:20:43.460 --> 00:20:49.220
叫做zip，是的，所以很好，所以这对应于此

00:20:49.220 --> 00:20:52.700
是一个问题，如果列表的长度不同，该怎么办？

00:20:52.700 --> 00:20:55.940
您可以在这里做一些非常合理的事情，但其他时候却经常这样做

00:20:55.940 --> 00:20:58.520
比我使用此工具时肯定的要多，我假设这些列表

00:20:58.520 --> 00:21:01.490
真的是一样的长度，如果不是，我应该在做，你知道我

00:21:01.490 --> 00:21:04.580
应该事先做一些事情，所以我在这里表达了

00:21:04.580 --> 00:21:09.860
两个向量进入的类型是相同的长度，并且向量

00:21:09.860 --> 00:21:15.980
出去的时间是一样的，时间驱动的奇妙之处

00:21:15.980 --> 00:21:20.210
发展是因为我已经付出了足够的努力

00:21:20.210 --> 00:21:24.350
机器可以告诉我该功能的类型

00:21:24.350 --> 00:21:27.440
或给我一些有关如何编写此函数的提示，那么

00:21:27.440 --> 00:21:31.670
我首先要做的是定义骨架，所以这是对a的控制

00:21:31.670 --> 00:21:35.390
在我可以对可能的输入进行大小写拆分之前做了，所以我会做一个

00:21:35.390 --> 00:21:44.080
大小写在这里的X上，如果我用RHS查看zip的类型-我们将看到

00:21:44.080 --> 00:21:51.260
明智的选择，所以我们得到X是一个空向量

00:21:51.260 --> 00:21:55.820
明智的选择是其中的向量为零，因为X就是

00:21:55.820 --> 00:22:00.530
Weis唯一可以做的就是这样，如果我进行案件拆分，它只会给我一个

00:22:00.530 --> 00:22:03.740
它不会的可能性甚至不会暗示我必须处理非

00:22:03.740 --> 00:22:09.170
空向量，因为它不会键入检查，而有趣的是，如果我

00:22:09.170 --> 00:22:11.900
看看右边的时间，现在您将看到我正在寻找一个向量

00:22:11.900 --> 00:22:15.050
我可以对机器说几件事很有趣

00:22:15.050 --> 00:22:20.180
只是寻找一个可能的解决方案，在这种情况下，它非常简单

00:22:20.180 --> 00:22:25.160
它只有一个空向量，这是空向量，所以我会做一个

00:22:25.160 --> 00:22:29.090
类似的事情在这里我不会打扰我只是打案件听

00:22:29.090 --> 00:22:33.680
表情搜索，我认为这是唯一合理的答案

00:22:33.680 --> 00:22:46.160
老实说，它可以使机器正常工作，谢谢，所以这不是

00:22:46.160 --> 00:22:49.280
不能让您不知道自己在做什么，这对

00:22:49.280 --> 00:22:52.730
查看该函数的结果，并查看其产生的答案

00:22:52.730 --> 00:22:57.230
你以为答案是因为你知道我使用了很多东西

00:22:57.230 --> 00:23:00.350
在实践中，这种表达搜索是很棘手的

00:23:00.350 --> 00:23:05.690
单子水暖，或者如果您有某种F型或某种G型，您知道等您

00:23:05.690 --> 00:23:08.600
B的关系，并且您有从A到B的各种方法，但是您无法确定

00:23:08.600 --> 00:23:12.080
正常情况下，我先从表达式搜索开始，看看机器是否

00:23:12.080 --> 00:23:15.620
可以弄清楚，往往他们可以弄清楚其中的一部分，但不是全部

00:23:15.620 --> 00:23:22.550
这已经是很大的帮助了，所以这是哦，我会做的，我将再举一个例子

00:23:22.550 --> 00:23:26.630
vector我认为这很有趣，因为它确实展示了

00:23:26.630 --> 00:23:32.420
如果我要尝试基本上转置2d 2d列表并尝试

00:23:32.420 --> 00:23:37.970
在没有类型帮助的情况下转置二维链表

00:23:37.970 --> 00:23:43.730
我很棘手，我知道这只是我对数据设置的那种问题

00:23:43.730 --> 00:23:47.240
结构和算法类我给他们那个二维链表

00:23:47.240 --> 00:23:50.240
并让他们换位，他们讨厌我在大学余下的职业生涯

00:23:50.240 --> 00:23:56.920
而且我并没有真正责怪他们，特别是考虑到我们使用Java进行教学

00:23:57.350 --> 00:24:01.650
我在那说的没什么我不应该说的

00:24:01.650 --> 00:24:07.429
互联网上录制的视频顶部将是一个麻烦的人，我读了它

00:24:07.429 --> 00:24:13.890
好吧，换位，我们将做同样的事情，所以我们得到了N

00:24:13.890 --> 00:24:19.980
乘M向量，我们想归还N乘n向量，所以X是一个向量

00:24:19.980 --> 00:24:22.530
我是指目前唯一可以做的合理的事情

00:24:22.530 --> 00:24:29.670
我所拥有的是X，因此我将对它进行大小写拆分，在第一种情况下，如果

00:24:29.670 --> 00:24:34.980
X是一个空向量，因此如果X是，则输入为

00:24:34.980 --> 00:24:40.140
我必须转置为空向量的向量，以便我可以查看类型

00:24:40.140 --> 00:24:43.440
只是为了看看事情的类型，所以我应该说我需要制作一个

00:24:43.440 --> 00:24:48.660
M个空向量的向量，现在我不能被我立即打扰

00:24:48.660 --> 00:24:54.780
会，但我要放空，我要说你是对的，我是

00:24:54.780 --> 00:24:59.100
将重命名这两个空容器并按L的ctrl，这是什么

00:24:59.100 --> 00:25:03.240
它可以提升功能我需要的类型可以提升新的顶层功能

00:25:03.240 --> 00:25:06.450
填补这个空白，我将稍后再讲，然后我将继续

00:25:06.450 --> 00:25:12.990
有趣的情况，所以在有趣的情况下，我得到了什么？

00:25:12.990 --> 00:25:17.460
总是你知道类型定义细化写类型做一些定义吗

00:25:17.460 --> 00:25:21.929
看看是否有其他类型完善定义，所以我已经完成了

00:25:21.929 --> 00:25:25.080
定义的步骤我在这里做了一些细化，所以让我们看一下

00:25:25.080 --> 00:25:28.559
再次输入，所以在您看到自己所要输入的类型之前，不要取得任何进展

00:25:28.559 --> 00:25:34.679
您需要使用的，所以让我们看一下转置的类型

00:25:34.679 --> 00:25:41.210
也是RHS的向量，所以我有n的向量是X的向量，所以这是第一个

00:25:41.210 --> 00:25:46.710
这是第一行，因此实际上您可以重命名，因为我讲了一段时间

00:25:46.710 --> 00:25:50.910
回来，然后有人跟我转身，说他们的谈话很好，但是为什么

00:25:50.910 --> 00:25:55.340
你的功能程序总是很酷的东西X有一个很好的问题

00:25:55.340 --> 00:26:01.770
但是这里显然是连续运行，所以我们称之为行，我们有

00:26:01.770 --> 00:26:05.790
我们有一个向量K乘以任何东西的向量，所以它将更多

00:26:05.790 --> 00:26:09.840
鉴于流氓是n个事物的向量，因此我需要产生一个向量

00:26:09.840 --> 00:26:12.720
如果X是

00:26:12.720 --> 00:26:17.580
加上n个事物的向量现在我们知道如何将n个事物的K变成一个

00:26:17.580 --> 00:26:26.450
N by K的东西，我们进行递归调用，所以我要做的就是

00:26:26.450 --> 00:26:35.370
然后再问同样的问题，所以现在的类型是

00:26:35.370 --> 00:26:38.789
在这里，我有一个N个事物的向量另一个N个事物的向量，我需要

00:26:38.789 --> 00:26:42.270
做一个n个事物的向量，但我告诉你我们在zip中所做的实际上不是

00:26:42.270 --> 00:26:45.900
这周我们取了N个事物的两个向量，我们做了n个事物的向量，但我没有

00:26:45.900 --> 00:26:48.900
我真的很想担心在这里填写细节，所以我只是要

00:26:48.900 --> 00:26:52.679
提升到顶层函数，所以我要编写一个辅助函数，它是

00:26:52.679 --> 00:26:56.730
给我类型，这是很明显的，所以它是它已经被填充

00:26:56.730 --> 00:27:00.809
在我要编写的对该函数的调用中，现在我给了我一个类型和

00:27:00.809 --> 00:27:06.030
在发生骨架定义大小写拆分之前，我可以做平常的事情

00:27:06.030 --> 00:27:16.940
知道我不需要X，所以我要删除它，让我们

00:27:17.470 --> 00:27:22.299
好吧，您也许可以猜到我在这里要做什么

00:27:22.299 --> 00:27:24.730
有点容易，因为我之前已经做过，但是我碰巧知道我所有

00:27:24.730 --> 00:27:40.629
要做的是好吧，分割案例分割搜索，案例分割搜索，那样就可以了

00:27:40.629 --> 00:27:45.250
帮助那里，类似地清空容器，因此您会在这里注意到有一个

00:27:45.250 --> 00:27:49.809
有一个M，其中有一个类型变量M，这很尴尬，因为我

00:27:49.809 --> 00:27:53.889
想要在类型中使用M＆M，但请稍等

00:27:53.889 --> 00:27:58.629
类型是一流的，所以我可以将其归入范围，因为它的类型是

00:27:58.629 --> 00:28:04.019
第一课，我可以将这个值从类型中带入程序中，

00:28:04.019 --> 00:28:09.460
再次在该处放置案例，这将以递归方式建立一个

00:28:09.460 --> 00:28:13.240
空向量的适当长度列表，因此您可能没有关注

00:28:13.240 --> 00:28:16.779
程序中到底发生了什么，主要是因为这台机器只是

00:28:16.779 --> 00:28:19.870
为我们做思考，但如果您在这里看紧身衣，您会发现

00:28:19.870 --> 00:28:23.500
从顶部开始到底发生了什么，您可以看到，如果我们只能

00:28:23.500 --> 00:28:27.460
在这里制作一个转置向量，我的意思是，如果我们尝试

00:28:27.460 --> 00:28:30.820
很难，我们可以制作一个包含错误内容的转置向量，除了我们

00:28:30.820 --> 00:28:34.570
不能，因为我们没有对LM说什么LM只是我们的一种类型

00:28:34.570 --> 00:28:38.080
除了它很厚以外什么都不知道，所以我想我们可能会倒车

00:28:38.080 --> 00:28:40.960
或让他们知道同时使结构混乱

00:28:40.960 --> 00:28:43.690
但实际上我们要做的唯一自然的事情就是移调

00:28:43.690 --> 00:28:47.350
再次，如果您查看类型2，您将看到我们有一行是向量

00:28:47.350 --> 00:28:51.940
n个事物中，我们有一个转置事物，它是n个事物的向量，而您

00:28:51.940 --> 00:28:56.049
如果您斜视一下那种类型，您可以看到很好的n外观

00:28:56.049 --> 00:28:59.230
有一个东西，我有K个东西，我需要做套管的接班人，所以

00:28:59.230 --> 00:29:05.519
基本上在矢量的前面粘贴了道路，所以我

00:29:05.519 --> 00:29:09.549
应该尝试，我的意思是我应该测试，因为我的意思是一种类型

00:29:09.549 --> 00:29:14.559
检查了一下，所以我们知道它会工作，但是我创建了一个主程序，

00:29:14.559 --> 00:29:19.149
采取向量的某些维度发明向量，然后为我们换位

00:29:19.149 --> 00:29:22.110
所以

00:29:22.720 --> 00:29:34.990
这个介绍实际上为什么我们不使用其他代码生成器呢？

00:29:34.990 --> 00:29:45.400
可能会出错哦，所以编译为行和三

00:29:45.400 --> 00:29:50.350
列，所以这是三列的向量哦一二三四有五和

00:29:50.350 --> 00:29:54.880
依此类推，这是对他们的换位，我们相信换位只是为了证明

00:29:54.880 --> 00:30:00.429
那确实是一个PHP程序，完成了一点点的

00:30:00.429 --> 00:30:08.740
适用于企业的PHP，因此，如果您需要它，这实际上是我写的PHP

00:30:08.740 --> 00:30:15.280
后端进行下注，但是如果您碰巧是，您几乎可以真正知道

00:30:15.280 --> 00:30:18.640
写一个WordPress插件，因为我相信你每天都在做，并且你想拥有

00:30:18.640 --> 00:30:21.159
对功能存在某种功能的某种信心

00:30:21.159 --> 00:30:25.030
您对WordPress插件的正确性是希望使用PHP还是使用

00:30:25.030 --> 00:30:28.450
功能语言我不太了解，我知道我宁愿用

00:30:28.450 --> 00:30:35.080
功能语言还不错，对于入门级的东西来说，你好吗？

00:30:35.080 --> 00:30:47.710
时间十分钟十分钟好的，这是几个您好的例子

00:30:47.710 --> 00:30:51.600
我想告诉你的结局是更多的思考

00:30:51.600 --> 00:30:56.740
您可能想做的一件事的现实是写下状态

00:30:56.740 --> 00:31:01.299
机器或状态转换系统，并确保您正确运行

00:31:01.299 --> 00:31:04.299
遵循适当的状态转换，所以这是我最简单的状态转换

00:31:04.299 --> 00:31:09.490
可以想到，这表明了门的打开和关闭状态

00:31:09.490 --> 00:31:16.780
机器，因此门可以处于打开状态或关闭状态，因此我们将

00:31:16.780 --> 00:31:20.679
如果允许关闭的门敲门，则在关闭状态下开始，但

00:31:20.679 --> 00:31:24.159
不会改变状态，如果门关上了，我们就可以打开它

00:31:24.159 --> 00:31:28.150
并改变了门的状态，它打开了您不是的特定门

00:31:28.150 --> 00:31:34.470
如果打开就可以敲门，这是一扇滑动门，所以门消失了

00:31:34.660 --> 00:31:40.880
如果门打开，则允许您将其关闭，所以这看起来像是

00:31:40.880 --> 00:31:44.510
有点熟悉的API，我的意思是像文件处理一样

00:31:44.510 --> 00:31:48.800
因此，您打开文件时可以执行某些操作

00:31:48.800 --> 00:31:52.250
当它打开时，您可以做一些事情来跟随它进入关闭状态，

00:31:52.250 --> 00:31:58.070
它们不一定相同，如果在您的API中可以

00:31:58.070 --> 00:32:01.190
正确表达您被允许做某事时的这种属性

00:32:01.190 --> 00:32:05.960
动作以及这些动作对状态的影响（如果您可以表征状态）

00:32:05.960 --> 00:32:09.590
并以某种抽象的方式对系统进行推理

00:32:09.590 --> 00:32:13.370
那是因为它在做正确的事，所以我不会经历

00:32:13.370 --> 00:32:16.790
有关如何在一件礼服中精确工作的详细信息，我将向您展示

00:32:16.790 --> 00:32:23.030
类型，希望这些类型足够清楚，以至于您会相信

00:32:23.030 --> 00:32:26.990
他们真的在表达这个门系统，为此，我要切换

00:32:26.990 --> 00:32:34.850
回到他们只是为了表明您可以拥有多个编辑器，因为我们

00:32:34.850 --> 00:32:37.130
会看到错误消息，但我还没有弄清楚如何获取错误

00:32:37.130 --> 00:32:41.600
消息字体，他们不应该问他们，但这是一件好事

00:32:41.600 --> 00:32:45.320
类型驱动的方法，通常不会出现很多错误

00:32:45.320 --> 00:32:49.010
信息，因为机器仅在正确的程序以及您何时

00:32:49.010 --> 00:32:52.400
确实会收到错误消息，因为它在

00:32:52.400 --> 00:32:56.660
您刚刚写的一小部分，所以即使发现错误，它也非常有用

00:32:56.660 --> 00:32:59.690
信息，而不是试图盯着看到底是怎么回事

00:32:59.690 --> 00:33:03.290
程序我倾向于从程序中取出一些位，并用孔替换它们，

00:33:03.290 --> 00:33:07.550
看看它是否开始起作用，我发现这是一种非常有用的使用类型来获取类型的方法

00:33:07.550 --> 00:33:12.680
我去正确的程序好吧，所以这是门状态的代表

00:33:12.680 --> 00:33:18.860
机器使用，所以它是一个名为effect的库，它随Idris和F一起分发

00:33:18.860 --> 00:33:25.910
在这里，我将f描述为一种特定于设备的语言，用于构建

00:33:25.910 --> 00:33:32.690
你与F的单子实际上是我在地球上，这是允许的

00:33:32.690 --> 00:33:36.170
它是一个库，可让您组合不同种类的不同位

00:33:36.170 --> 00:33:40.820
有状态系统的不同效果，而无需

00:33:40.820 --> 00:33:45.740
担心单声道变压器的管道问题，它也使您能够

00:33:45.740 --> 00:33:49.049
更改您可以使用的那是特效

00:33:49.049 --> 00:33:53.190
随着系统的进步，在这里我们已经说过

00:33:53.190 --> 00:33:58.769
这是一个有效程序的开门类型，它以一个开始的单位返回

00:33:58.769 --> 00:34:02.850
处于关闭状态的门，并以处于打开状态并关闭的门结束

00:34:02.850 --> 00:34:06.120
门是相反的，然后Nakia说你只能把它跑到

00:34:06.120 --> 00:34:09.659
门在关闭状态，它不会改变，它不会改变状态，所以

00:34:09.659 --> 00:34:16.679
这个门程序这里是正确的类型，因此您知道资源的正确使用

00:34:16.679 --> 00:34:23.280
该门协议的内容，所以如果我做类似敲门的操作，然后关闭

00:34:23.280 --> 00:34:26.639
如果我基本上想在这里做的就是在门关上的时候关上门

00:34:26.639 --> 00:34:32.909
在已经处于封闭状态的国家，它说得很好，它说这是错的

00:34:32.909 --> 00:34:36.240
这里的这句话说它出了错，而这里的下面是那件事

00:34:36.240 --> 00:34:39.450
告诉我们一些有用的信息，使门之间不匹配

00:34:39.450 --> 00:34:50.639
是的，它本来应该是打开的，实际上已经关闭了，所以是的，如果我尝试

00:34:50.639 --> 00:34:54.540
两次打开它，这是一条可读性更强的错误消息，我们有

00:34:54.540 --> 00:34:58.109
权衡一些错误消息有时会更有帮助

00:34:58.109 --> 00:35:01.200
取决于系统是否识别正在发生的事情的结构，所以在这里

00:35:01.200 --> 00:35:05.670
它说好，您做了一些需要关门的事情，

00:35:05.670 --> 00:35:11.310
实际上门是开着的，所以您只能在门关着的时候打开

00:35:11.310 --> 00:35:15.569
现在它再次进行类型检查，因为我正确地遵循了协议，所以

00:35:15.569 --> 00:35:19.079
各种各样的事情，这是很棒的，我们可以遵循

00:35:19.079 --> 00:35:23.190
状态机，但是这里的问题是我们指定了那些状态

00:35:23.190 --> 00:35:26.880
过渡是过去，我们并不总是拥有对世界的控制权

00:35:26.880 --> 00:35:31.260
例如，门可能卡住了，也许门可能有问题

00:35:31.260 --> 00:35:35.490
门可能会吃掉你知道会上油的东西，所以他们不喜欢果酱，所以我

00:35:35.490 --> 00:35:40.550
如果我处于开门状态，不一定知道我什么时候打开门

00:35:40.550 --> 00:35:44.130
与您不一定知道是否打开文件的文件进行比较

00:35:44.130 --> 00:35:47.250
完成后，您将有一个打开的文件，这可能是一个错误

00:35:47.250 --> 00:35:51.540
所以我们真的需要找出一种在类型中表达它的方式

00:35:51.540 --> 00:35:57.260
系统，以便对安全性有一些合理的要求

00:35:57.260 --> 00:36:02.720
所以幸运的是，拥有一流的类型意味着我们把东西放进了

00:36:02.720 --> 00:36:07.700
表示状态转换如何工作的类型，它们只是程序，所以这是

00:36:07.700 --> 00:36:16.010
我很想看到英里，现在我开着的门说好

00:36:16.010 --> 00:36:21.050
我已经开始处于关门状态，而不是继续前进到

00:36:21.050 --> 00:36:26.600
我要返回的门处于打开状态门碰到了

00:36:26.600 --> 00:36:31.760
该卡纸类型的Jambres的功能，我将检查该类型的卡纸

00:36:31.760 --> 00:36:35.330
如果它被卡住而返回，那么如果它被关上，则门是关闭的

00:36:35.330 --> 00:36:41.570
没关系，那么门是开着的，所以在这里，我有一个有效的，如果我想尝试

00:36:41.570 --> 00:36:46.570
这样的事情之前，会说不对不起，你不能那样做

00:36:46.570 --> 00:36:50.570
看起来您的错误消息比我预期的要差一些，但是

00:36:50.570 --> 00:36:56.119
指向要看的东西是我们有一扇敞开的门，这是我们需要的

00:36:56.119 --> 00:37:00.950
有一扇开着的门，而当我们关上它时却没有

00:37:00.950 --> 00:37:07.100
相反，我们要做的就是获取我们将打开门的返回值

00:37:07.100 --> 00:37:12.170
我会在程序的其余部分贴上一个小孔，如果我们

00:37:12.170 --> 00:37:15.530
看看那个孔的类型，所以vim也具有所有交互式编辑小工具

00:37:15.530 --> 00:37:21.320
所以我用反斜杠T来获取类型，所以我有种侧框类型，你会

00:37:21.320 --> 00:37:27.369
看到ok出现在类型中，所以这暗示着可以有所进步

00:37:27.369 --> 00:37:33.859
在这里，如果我们检查运气好的结果，这种类型的运气将精炼为

00:37:33.859 --> 00:37:40.970
我们可以使用的有用的东西，所以让我们这样做，所以我不喜欢写

00:37:40.970 --> 00:37:45.200
箱子现在全部堵住了，所以克里斯为我写了封信，所以我们将检查

00:37:45.200 --> 00:37:51.410
好吧，我将对结果进行案例拆分哦，胸部对结果进行案例提升

00:37:51.410 --> 00:37:59.950
没关系，所以在门被卡住的情况下

00:38:00.050 --> 00:38:06.200
是的，伊德里斯在这里做所有的工作

00:38:06.200 --> 00:38:11.430
对于编辑器插件编写者而言，这是个好消息，因为您真的不想要

00:38:11.430 --> 00:38:14.369
您在编写IDE时，并不需要

00:38:14.369 --> 00:38:17.850
再次重新实现整个类型系统，特别是如果类型系统是

00:38:17.850 --> 00:38:24.360
您也认识一位评估员，是的，在这里发生的是

00:38:24.360 --> 00:38:30.270
我们知道分支，因为案例分析经历了我们知道的卡塞案例

00:38:30.270 --> 00:38:34.380
我们必须计算门被卡住的状态，以便门

00:38:34.380 --> 00:38:38.940
关闭，我们需要按照您注意到的方式处于门关闭状态

00:38:38.940 --> 00:38:44.670
我以为我也站在这里，所以当我们有效果的'fl程序

00:38:44.670 --> 00:38:47.880
我们可以列出可用的效果，这意味着我可以做点什么

00:38:47.880 --> 00:38:55.500
就像你知道某种卡通挣扎的声音，没有别的

00:38:55.500 --> 00:39:00.930
破解它，然后就可以了，所以在好的情况下，如果我们看一下

00:39:00.930 --> 00:39:04.470
在这里输入，我们将看到我们处于开门状态，需要进入

00:39:04.470 --> 00:39:10.530
门关闭状态，因此此程序无法进行类型检查

00:39:10.530 --> 00:39:16.640
除非我们真的关上身后的门，否则我们就不会出生在田野中

00:39:16.640 --> 00:39:23.730
我们将关上我们身后的门，并检查该类型，现在这是有效的

00:39:23.730 --> 00:39:30.600
在以下情况下，正确使用门协议

00:39:30.600 --> 00:39:34.830
在我最后的快速发言之前，门没有正确关闭只是一件事

00:39:34.830 --> 00:39:38.430
我想向您展示的代码快速示例是这种类型的代码

00:39:38.430 --> 00:39:42.510
您正在测试错误并处理错误的事物，并且

00:39:42.510 --> 00:39:46.140
错误案例和成功案例的处理，您可以想象得非常深刻

00:39:46.140 --> 00:39:50.910
嵌套的代码，如果它变得更长，并且您知道您可能会想

00:39:50.910 --> 00:39:54.359
你能抛出一个异常并有一个处理程序，所以我所做的是II

00:39:54.359 --> 00:40:02.750
决定从Perl借用一个功能，我喜欢说这对反应有好处

00:40:03.400 --> 00:40:12.310
因此，任何Perl程序员都知道Perl中的打开文件或die语法

00:40:12.310 --> 00:40:17.170
您知道语法，所以这与您的想法相同

00:40:17.170 --> 00:40:21.760
有一个主要的工作路径，然后这个替代方法就是这个

00:40:21.760 --> 00:40:25.900
只有在开门不匹配的情况下才称呼它，所以我可以

00:40:25.900 --> 00:40:32.339
很高兴有开门和关门的负担，这很好

00:40:32.339 --> 00:40:37.990
对，那么您为什么要执行这种操作？您可能会这样做的原因

00:40:37.990 --> 00:40:44.079
是如果您的系统中存在规则并且这些规则发生了变化

00:40:44.079 --> 00:40:49.570
因此，一些复杂的实际系统是否会根据当前状态决定

00:40:49.570 --> 00:40:57.849
您被允许做的事情，例如“子手”游戏，

00:40:57.849 --> 00:41:03.400
子手的游戏状态是子手相当简单，所以这是

00:41:03.400 --> 00:41:08.079
是的，是的，我尝试解释了hang子手的规则，

00:41:08.079 --> 00:41:11.650
在一些文档中的hangman后面，我做不到，我不得不称它为

00:41:11.650 --> 00:41:16.240
神秘的单词，因为它听起来太脏了，所以这个主意是

00:41:16.240 --> 00:41:19.750
你猜字母，一个字就收到字母，如果你

00:41:19.750 --> 00:41:24.550
猜对了你想不信不letter地猜测，而你不

00:41:24.550 --> 00:41:31.150
想要不做任何猜测，所以我已经捕捉到了可能的状态

00:41:31.150 --> 00:41:36.760
通过说好游戏来执行game子手游戏，或者有些猜测在运行，

00:41:36.760 --> 00:41:40.390
一些字母或它没有运行，所以这有点像我们的门打开或

00:41:40.390 --> 00:41:43.869
关闭，我们有两个不同的州，只是其中一个州有

00:41:43.869 --> 00:41:49.630
其中包含更多信息，因此不必担心太多

00:41:49.630 --> 00:41:53.829
表示方式的确切细节，但重要的是

00:41:53.829 --> 00:42:00.339
在这个系统中的重要功能是，如果我们收到一个字母，则该字母为

00:42:00.339 --> 00:42:03.130
会出现在单词中还是不在单词中，这将改变

00:42:03.130 --> 00:42:07.510
游戏状态取决于我们是否正确，因此猜测不是

00:42:07.510 --> 00:42:12.190
猜测一个字符是一个效果FFEL程序，该程序返回true或false

00:42:12.190 --> 00:42:14.760
只有在我们有一些猜测的情况下才能工作

00:42:14.760 --> 00:42:18.300
它只有在我们还有其他事情要猜测的情况下才能奏效，并且要么会回来

00:42:18.300 --> 00:42:25.470
仍然有客人，信不见了，或者客人不见了，

00:42:25.470 --> 00:42:30.630
相同数量的事物要猜测，最终我们得出结论

00:42:30.630 --> 00:42:35.700
主程序我们进入主程序，我们看到一个hang子手游戏是

00:42:35.700 --> 00:42:39.570
从运行状态开始的一些猜测

00:42:39.570 --> 00:42:44.820
也许有些话，它以不运行状态结束，所以很快就以这种方式

00:42:44.820 --> 00:42:48.420
程序必须要赢得或输掉或

00:42:48.420 --> 00:42:52.830
放弃，没有其他方法可以解决，我们必须要做的是

00:42:52.830 --> 00:42:58.230
顺便说一句，当我第一次写这篇文章时，我给了它一点点

00:42:58.230 --> 00:43:03.090
不同的类型，我给了它这种类型，所以这是一个稍微

00:43:03.090 --> 00:43:07.800
说我们给出的词的前提条件必须不同

00:43:07.800 --> 00:43:11.730
里面至少有一个字母，我的程序中没有地方打扰

00:43:11.730 --> 00:43:15.660
检查我正在阅读的字符串中是否有一个字母，因此机器

00:43:15.660 --> 00:43:19.260
说对不起，你不能休息我以为那实际上很可爱，因为

00:43:19.260 --> 00:43:22.530
这是我一直犯的那种愚蠢的错误，也是那样的事情

00:43:22.530 --> 00:43:24.390
您认为井类型不能帮助您

00:43:24.390 --> 00:43:30.150
好吧，我认为他们可以犯的另一个错误是，鉴于这两件事

00:43:30.150 --> 00:43:34.020
字母的数量和猜测的数量是数字，所以在这里我们有一个

00:43:34.020 --> 00:43:37.260
来宾，如果为true，则打印错误消息，然后

00:43:37.260 --> 00:43:41.730
打印一条消息，这也确实发生了我错了我错了

00:43:41.730 --> 00:43:45.990
变量，因为它们改变了错误的状态，所以很好地告诉了我

00:43:45.990 --> 00:43:49.590
告诉我这出了错，但是如果您将其停留一分钟左右，您可以

00:43:49.590 --> 00:43:54.060
看看到底出了什么问题，实际上应该是我想的，所以我想要一个

00:43:54.060 --> 00:43:57.480
单词列表只是为了表明有一些类型推断可用，所以我

00:43:57.480 --> 00:43:59.480
不能打扰给出这个单词的清单

00:43:59.480 --> 00:44:05.390
我只是在耐心地等待有人向我抱怨，所以

00:44:05.390 --> 00:44:09.840
有一根绳子的长度和手机信号塔的机器你说什么

00:44:09.840 --> 00:44:12.840
到您计算出此列表长度的计算机，因此我发现了问题

00:44:12.840 --> 00:44:18.170
这个单词列表是不是猩红色的

00:44:19.680 --> 00:44:24.789
因此，因为该编译并运行了，所以我们知道我们将得到一个ser来获取此文件

00:44:24.789 --> 00:44:27.999
子手如果在卡尔里纠缠卡尔，真是很有趣

00:44:27.999 --> 00:44:44.130
难过的是，我们不会输掉反抗哦，也许基本的好

00:44:44.130 --> 00:44:49.390
对，所以哦，最后一件事什么都没有

00:44:49.390 --> 00:44:53.619
那个时候我确实想向您展示我对吃豆人完整性的部分证明，

00:44:53.619 --> 00:44:57.400
自从我第一次展示它以来，我还没有进化过

00:44:57.400 --> 00:45:05.949
以前，所以当我这样做时，您会对地址系统的速度有印象

00:45:05.949 --> 00:45:12.069
这不一定是好的方法，所以这是一个使用

00:45:12.069 --> 00:45:16.119
效果库来管理太空侵略者游戏的状态，以便

00:45:16.119 --> 00:45:21.209
外星人是阴暗星空的地方，炸弹就是所有的地方

00:45:21.209 --> 00:45:26.559
顺便说一下，这里的瓶颈是GCC，所以我需要弄清楚如何修复

00:45:26.559 --> 00:45:31.779
在那里，所以我们正在爆炸着天空中的任务分配标志

00:45:31.779 --> 00:45:39.029
在这里，所以肥皂曼迪无论如何都去了那里

00:45:43.339 --> 00:45:48.960
所以我们为什么要注意安全安全是人们经常谈论的话题

00:45:48.960 --> 00:45:52.349
我们关心安全的类型，但我们还有很多可以写的

00:45:52.349 --> 00:45:56.730
表现力的api，我们可以编写通用程序，我们可以使用类型来帮助我们

00:45:56.730 --> 00:46:01.859
进入正确的程序，这是真正的类型，如果您是

00:46:01.859 --> 00:46:06.510
有兴趣了解更多，甚至可以有一个特殊的秘密，也可以了解更多

00:46:06.510 --> 00:46:10.799
密码，如果您想知道39贝迪（Brady）的特殊密码

00:46:10.799 --> 00:46:14.490
那么您可以在此获得折扣，所以如果您想了解更多信息，那就还没准备好

00:46:14.490 --> 00:46:18.000
但是我的意思是只写了两章，但是它将持续进行

00:46:18.000 --> 00:46:21.119
第二年左右，我刚才介绍的所有想法都会引起您的注意

00:46:21.119 --> 00:46:31.770
更深入一点，很好，非常感谢

00:46:31.770 --> 00:46:36.170
没有更多时间提问了，但我要感谢

