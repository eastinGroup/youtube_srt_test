WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.860 --> 00:00:13.620
嗨，我有一个录音带，我想播放，考虑一下分布式寄存器，所以我们

00:00:13.620 --> 00:00:17.039
将具有此分布式寄存器副本a和的两个副本

00:00:17.039 --> 00:00:22.800
复制B，所以我们要做的是可以对该寄存器执行两次操作

00:00:22.800 --> 00:00:27.510
我们可以设置值，也可以检索值，所以在这里我们将设置

00:00:27.510 --> 00:00:30.660
值1，我们将异步将结果发送到

00:00:30.660 --> 00:00:36.180
副本B并想象它正在分布式系统中运行，因此同时我们

00:00:36.180 --> 00:00:40.680
也可以在原始操作完成后将寄存器设置为两个贴花

00:00:40.680 --> 00:00:45.690
完成，然后设置为副本集以在副本B上看到，因此一旦我们交付

00:00:45.690 --> 00:00:50.250
系统中的这些消息我们如何知道该值是正确的

00:00:50.250 --> 00:00:54.690
我们如何知道副本a和副本B将选择相同的值，并且

00:00:54.690 --> 00:00:58.230
从……的角度来看，我们如何知道该价值是什么

00:00:58.230 --> 00:01:06.270
对这个模型进行编程，因此传统上我们在其中使用同步

00:01:06.270 --> 00:01:12.270
系统执行命令，这使我们可以做的是关于

00:01:12.270 --> 00:01:15.659
给定某些输入正确的值，因此考虑到

00:01:15.659 --> 00:01:18.930
我们可以推断出某些行为的结果

00:01:18.930 --> 00:01:25.380
如此有助于简化编程，这也消除了意外情况

00:01:25.380 --> 00:01:28.950
系统中的非确定性，因此，如果您有并发系统，则可以

00:01:28.950 --> 00:01:31.740
具有不同的调度程序交错，并且您没有锁定数据结构

00:01:31.740 --> 00:01:36.450
正确地，您可以在多次执行此操作的子集下获得值

00:01:36.450 --> 00:01:42.390
对于相同的输入，返回的输出值和种类不同

00:01:42.390 --> 00:01:45.689
传统上，我们已经拥有执行此操作的技术，例如锁定互斥锁是

00:01:45.689 --> 00:01:51.000
信号量监视器，并且您知道所有的分布式扩展

00:01:51.000 --> 00:01:55.740
这项工作是正确的，因此同步非常昂贵，因为我们必须花时间

00:01:55.740 --> 00:01:58.770
我们必须花时间订购东西我们必须花时间等待东西

00:01:58.770 --> 00:02:02.610
而且您知道在某些系统中，如果我们在一台计算机上，这很好

00:02:02.610 --> 00:02:06.180
没关系，我的意思是我们希望自己没有它不是很好，但是有一种

00:02:06.180 --> 00:02:10.790
导致此问题的两个新的真正新潮的应用程序类别

00:02:10.790 --> 00:02:15.840
加剧了权利，所以第一个是物联网，所以如果我们认为

00:02:15.840 --> 00:02:18.480
关于物联网真正意味着什么

00:02:18.480 --> 00:02:23.790
我们拥有低功耗的设备，它们的内存有限，无法与

00:02:23.790 --> 00:02:26.400
它们通常具有受限的连接性以及它们受限的原因

00:02:26.400 --> 00:02:30.480
连接性是因为运行电源的成本确实很高

00:02:30.480 --> 00:02:34.890
如果这些设备碰巧在超过

00:02:34.890 --> 00:02:38.250
共享住宿和计算汇总，可以同时进行修改

00:02:38.250 --> 00:02:41.190
共享聚合，然后联机，我们有一个问题

00:02:41.190 --> 00:02:44.250
分歧，我们不知道如何处理正确的权利

00:02:44.250 --> 00:02:49.230
正确的值是并且有理由类似地将这些值合并在一起

00:02:49.230 --> 00:02:54.420
我正在研究的研究小组中的研究伙伴之一是

00:02:54.420 --> 00:02:57.840
Rovio娱乐，因此移动游戏是另一个真正的领域

00:02:57.840 --> 00:03:04.230
很难，例如《愤怒的小鸟》在排行榜上有个人资料，而罗维奥（Rovio）

00:03:04.230 --> 00:03:06.870
希望人们能够在玩游戏的同时继续玩游戏

00:03:06.870 --> 00:03:12.989
离线，例如如果您在飞机上，并且知道何时拥有该飞机

00:03:12.989 --> 00:03:15.989
有了这个，您将像当前的排行榜一样进行修改

00:03:15.989 --> 00:03:19.290
您将要更新的分数，您知道自己的个人资料，也许您

00:03:19.290 --> 00:03:22.980
更改您的照片，也许您更改名称，然后如果有多个

00:03:22.980 --> 00:03:26.220
使用相同帐户玩游戏的人，您会遇到对帐问题

00:03:26.220 --> 00:03:30.299
客户端脱机并与之同时发生的那些并发更改

00:03:30.299 --> 00:03:33.959
像排行榜之类的东西，即使状态只是您知道的

00:03:33.959 --> 00:03:37.440
我们全力以赴的状态也有说

00:03:37.440 --> 00:03:42.870
我如何将其合并到这种全球排行榜集合中，以便

00:03:42.870 --> 00:03:47.069
同步非常昂贵，所以我的意思是我们也想吃点蛋糕

00:03:47.069 --> 00:03:50.340
是的，我们希望系统完全不同步，我确定您已经

00:03:50.340 --> 00:03:53.549
在本次会议上或之前的几年中都看到过很多演讲

00:03:53.549 --> 00:03:56.639
谈论我们要如何减少同步，谁不减少

00:03:56.639 --> 00:04:01.290
协调和彼得·贝利斯（Peter Bayliss）昨天就此发表了精彩演讲，但

00:04:01.290 --> 00:04:04.260
我们也想使用共享状态权限，因为我们喜欢这样，我们希望拥有

00:04:04.260 --> 00:04:06.780
并发编辑，我们不必路由它，我们不想路由所有内容

00:04:06.780 --> 00:04:11.310
通过单一类型的客户端执行更新，因此我们希望获得最佳

00:04:11.310 --> 00:04:19.200
两个世界，所以我们正在努力进行研究的想法正试图

00:04:19.200 --> 00:04:23.550
从零同步的角度出发我们可以从零开始

00:04:23.550 --> 00:04:26.550
在编程模型中完全同步，然后仅应用

00:04:26.550 --> 00:04:31.470
同步在必要的地方，所以您无需知道而不是构建

00:04:31.470 --> 00:04:34.970
围绕强大的应用程序生态系统

00:04:34.970 --> 00:04:39.199
诸如Zookeeper之类的协调系统为什么我们不设计启动的系统

00:04:39.199 --> 00:04:42.139
没有协调，只有在需要时才使用协调机制

00:04:42.139 --> 00:04:47.690
强制某些全局系统不变，因此研究的目标

00:04:47.690 --> 00:04:51.020
在过去三年中我们一直在做的事情

00:04:51.020 --> 00:04:56.300
今年继续到明年是我们想探索极限，如果我们想

00:04:56.300 --> 00:05:02.030
看看我们是否可以设计一个计算模型，使我们能够编写协调

00:05:02.030 --> 00:05:05.810
免费进行计算，并确保这些计算不受限制

00:05:05.810 --> 00:05:09.410
并发异常当我说并发异常时，我的意思是

00:05:09.410 --> 00:05:12.590
Amazon dynamo出现在购物车中，由于我们使用了

00:05:12.590 --> 00:05:19.190
简单的合并工会功能跨越像购物车的不同副本，所以如果我们想要

00:05:19.190 --> 00:05:24.320
看一下我们用于分布式计算的应用空间的种类

00:05:24.320 --> 00:05:28.430
此处的y轴具有强大的共享属性和

00:05:28.430 --> 00:05:33.530
共享财产薄弱，所以我们在

00:05:33.530 --> 00:05:36.979
x轴，我们有一个耦合作为基础设施属性，我们没有

00:05:36.979 --> 00:05:39.680
特别是在谈论数据中心我们在谈论像数据中心

00:05:39.680 --> 00:05:43.760
某种延迟保证向开放Internet的保证随着我们的发展

00:05:43.760 --> 00:05:49.130
当我们向外移动时，诸如MapReduce之类的东西适合弱者

00:05:49.130 --> 00:05:54.680
共享模型和强耦合模型对MapReduce的强对

00:05:54.680 --> 00:05:59.870
有可能在世界各地进行MapReduce，我想您可以做到，但是

00:05:59.870 --> 00:06:02.930
通常您想在数据中心内部运行它，就需要延迟

00:06:02.930 --> 00:06:06.110
要求您需要一种高度一致的协调方式

00:06:06.110 --> 00:06:10.340
您知道的会员服务使MapReduce成为可能，并且通常只有您

00:06:10.340 --> 00:06:16.039
在缩小的相位上共享状态，因此地图令人尴尬地平行于

00:06:16.039 --> 00:06:19.250
在家里学习的条件，我的意思是，这真是超级尴尬

00:06:19.250 --> 00:06:23.450
并行权限，因为我们不共享您与服务部门联系的任何数据

00:06:23.450 --> 00:06:27.349
每隔一段时间检查一下您计算出的一个块，然后将其发送给它

00:06:27.349 --> 00:06:30.830
返回如果人们计算多个块，他们不在乎，因为那只是更多

00:06:30.830 --> 00:06:35.510
信息，所以在家学习就像在耦合方面真的很弱

00:06:35.510 --> 00:06:40.340
财产是这个开放的Internet想法正确，然后，如果我们考虑问题

00:06:40.340 --> 00:06:43.370
我有很强的分享能力，与这种模式有关，就像

00:06:43.370 --> 00:06:47.100
Twitter是对的，所以我不了解Twitter如何实现的细节，但是我

00:06:47.100 --> 00:06:51.870
想象一下，时间轴是为此而奋斗的对象

00:06:51.870 --> 00:06:56.430
我们在您的朋友要发推文的同时执行并发操作，

00:06:56.430 --> 00:06:59.850
它们将出现在您的时间轴中，因此我们将只有一种来源

00:06:59.850 --> 00:07:03.570
这个对象的真实性，我们将同时写入该对象，因此

00:07:03.570 --> 00:07:07.590
这是一个强烈共享的想法，所以在这样的图表中，您会看到

00:07:07.590 --> 00:07:12.180
一场学术演讲，我们想在哪里取得好成绩，我们显然总是想参加

00:07:12.180 --> 00:07:15.630
右上象限，因为那是通常的区域

00:07:15.630 --> 00:07:20.940
从来没有任何东西，所以这是我们必须要弱小的地方

00:07:20.940 --> 00:07:25.260
耦合到我们不依赖特定发行版的基础架构

00:07:25.260 --> 00:07:29.490
模型或延迟要求，我们可以容忍离线状态，

00:07:29.490 --> 00:07:33.150
想要转向强大的共享模型，以便我们可以共享大量数据

00:07:33.150 --> 00:07:39.630
系统中许多不同客户之间的交流，因此我们将简要介绍一下

00:07:39.630 --> 00:07:42.780
关于分布式计算的基础知识，我将简短说明一下，因为

00:07:42.780 --> 00:07:46.650
这里有很多分布式计算的话题，可能会重申很多

00:07:46.650 --> 00:07:51.060
因此，当我们查看并发编程时，并发编程有一个

00:07:51.060 --> 00:07:54.510
一致性权的问题，我们必须对可以通过什么看到的东西进行推理

00:07:54.510 --> 00:07:58.560
系统中的线程以及诸如我们如何维护缓存和事物之类的想法

00:07:58.560 --> 00:08:02.850
像这样，但是当我们转向分布式编程时，我们介绍了

00:08:02.850 --> 00:08:06.060
对部分失败的问题，所以我们要写一堆

00:08:06.060 --> 00:08:09.060
的复制品，其中一些会成功，而某些会失败

00:08:09.060 --> 00:08:14.640
然后我们有点像好吧，如果我要联系我该如何解释

00:08:14.640 --> 00:08:18.240
再次获得系统并获得我编写的值，它将实际存在于其中，因此

00:08:18.240 --> 00:08:23.310
直到现在，要解决部分故障确实很困难。

00:08:23.310 --> 00:08:27.600
时至今日，仍有许多现代数据库在执行此操作。

00:08:27.600 --> 00:08:32.280
假设单个系统错觉的分布式计算，这是

00:08:32.280 --> 00:08:35.130
您在交易中看到的东西正确的交易是一个想法

00:08:35.130 --> 00:08:40.349
解决这个问题，系统的想法是说单个系统映像是

00:08:40.349 --> 00:08:44.430
如果我有一个分布式数据库，并且向其中一个副本中写入了一个值，并且

00:08:44.430 --> 00:08:49.410
然后例如汤姆去读那个值，他会尽快看到

00:08:49.410 --> 00:08:52.530
操作就完成了，有一个想法，我们执行它就像一个

00:08:52.530 --> 00:08:56.040
系统就像寄存器只有一个副本，即使它是

00:08:56.040 --> 00:09:00.829
复制到处都是，所以如果你参加凯蒂的演讲

00:09:00.829 --> 00:09:06.319
昨天她有点谈论一致性模型的想法，所以

00:09:06.319 --> 00:09:10.730
一致性模型是在分布式计算中，

00:09:10.730 --> 00:09:15.559
应用程序开发人员和系统，一致性模型说的是

00:09:15.559 --> 00:09:18.319
嘿，如果您遵循这些规则，我保证您会看到这些事件

00:09:18.319 --> 00:09:21.170
以特定的顺序排列，并且某些一致性模型不能使

00:09:21.170 --> 00:09:24.410
保证他们说我们不知道您何时会看到事件

00:09:24.410 --> 00:09:27.980
最终以公开的顺序看到它们，这是我们最喜欢的一致性

00:09:27.980 --> 00:09:33.259
正确地进行建模，因此这些一致性可以对事物进行建模

00:09:33.259 --> 00:09:35.929
在这个频谱上，这很奇怪，就像您知道图表是

00:09:35.929 --> 00:09:39.230
有点像，如果您知道整个地方，所有这些

00:09:39.230 --> 00:09:42.110
事情，你是金发，你知道快照隔离和非单调

00:09:42.110 --> 00:09:46.309
快照隔离因果关系的交叉和因果关系，而您却拥有所有这些疯狂的东西

00:09:46.309 --> 00:09:50.899
一致性模型，它们全都存在于频谱中

00:09:50.899 --> 00:09:56.569
我猜对了部分排序，并且得到了一个更强大的一致性模型，

00:09:56.569 --> 00:10:01.129
我们朝着更强大的一致性模型迈进，我们需要执行该模型

00:10:01.129 --> 00:10:04.399
通过使用同步权，所以如果我们需要每个人都同意一个

00:10:04.399 --> 00:10:07.939
在非常特定的时间立即获得价值，我们必须使用协调来做

00:10:07.939 --> 00:10:14.899
因此，我们要考虑的是一致性模型类似于

00:10:14.899 --> 00:10:20.089
编程范例，因为如果您想到编程，这就是合同

00:10:20.089 --> 00:10:23.290
像您一样熟悉的范例函数式编程和数据流式编程

00:10:23.290 --> 00:10:26.899
这是一份合同，说可以很好地为您提供程序，而您遵循这些

00:10:26.899 --> 00:10:30.529
特定的规则，您会正确看到这些特定类型的结果，因此

00:10:30.529 --> 00:10:33.980
这就像应用程序开发人员与

00:10:33.980 --> 00:10:37.579
他们正在构建其应用程序的基础系统

00:10:37.579 --> 00:10:42.529
因此，我们有点后退，说好吧，为什么是

00:10:42.529 --> 00:10:47.119
同步是不可取的，所以您不想这样做是很直观的

00:10:47.119 --> 00:10:52.999
这个，但是无论怎样你都知道要经历它，所以我们有这个想法

00:10:52.999 --> 00:10:57.290
像物理时间这样的生活真的很难，所以如果你去约翰·摩尔讲

00:10:57.290 --> 00:11:01.429
昨天他谈到了您知道与计算机同步的问题

00:11:01.429 --> 00:11:06.889
NTP，您知道特定间隔的计算机如何放弃某些计算机，例如

00:11:06.889 --> 00:11:10.360
甚至都不会同步，我们谈到了

00:11:10.360 --> 00:11:14.110
用于删除的时间戳，以及您在其中删除的内容

00:11:14.110 --> 00:11:17.579
未来意味着什么，这听起来像是一个大问题，

00:11:17.579 --> 00:11:21.760
您知道通常只是利用物理时间和应用程序进行介绍

00:11:21.760 --> 00:11:27.450
复杂性是一件很难的事情，所以时间要花三点时间

00:11:27.450 --> 00:11:33.010
计算第一个的表现形式是一种可变状态，

00:11:33.010 --> 00:11:36.610
顺序系统，因此，如果您想到顺序系统并且

00:11:36.610 --> 00:11:40.329
功能和这些功能使用可变状态这些功能将

00:11:40.329 --> 00:11:43.300
随着时间的推移采用不同的值，所以这是一件困难的事情

00:11:43.300 --> 00:11:46.300
想一想，我们没有引用的这些好特性

00:11:46.300 --> 00:11:52.329
透明性以及我们在并发系统中真正喜欢的东西

00:11:52.329 --> 00:11:55.540
再次，我们有不确定性，所以不同的调度器交错在

00:11:55.540 --> 00:12:00.360
您正在执行多线程编程时，我们通常使用锁来强制执行命令

00:12:00.360 --> 00:12:04.089
这样我们就可以考虑系统并知道我们可以执行它

00:12:04.089 --> 00:12:06.940
多次并获得相同的结果，最糟糕的事情是运行

00:12:06.940 --> 00:12:10.720
您知道的计算机程序在两次给定两个值相同的值的情况下

00:12:10.720 --> 00:12:14.050
排行并得到三个不同的答案，但这并不是一项真正的工作

00:12:14.050 --> 00:12:18.459
最后在分布式系统中，我们在网络上遇到了所有这些问题

00:12:18.459 --> 00:12:20.560
正确的等待时间我们如何进行故障检测

00:12:20.560 --> 00:12:24.730
我的意思是故障检测是一个基本问题，因为它非常

00:12:24.730 --> 00:12:29.920
很难以安全的方式做我们如何正确地协调我们如何确保

00:12:29.920 --> 00:12:33.880
我们以特定的顺序看到事件，所以很多事情是我们必须处理时间

00:12:33.880 --> 00:12:39.610
因为邮件通过网络花费时间，但是您知道

00:12:39.610 --> 00:12:42.550
最终，物理时间是不可避免的，因为它有点像真实的东西

00:12:42.550 --> 00:12:47.110
是的，当你坐在电脑旁，你像你一样猛击时

00:12:47.110 --> 00:12:50.079
知道这个数字，你知道如果你有一个分布式的字数统计

00:12:50.079 --> 00:12:53.920
应用程序，您将在其中输入一些数字以了解它们

00:12:53.920 --> 00:12:57.010
您将在特定时间打这些字，然后

00:12:57.010 --> 00:13:00.550
读取在特定时间计数的单词的结果，这样

00:13:00.550 --> 00:13:04.410
身体上的时间是不可避免的，这是必不可少的

00:13:04.410 --> 00:13:10.110
所以我们走一分钟，然后谈论卡片的寓言

00:13:10.110 --> 00:13:14.279
所以我们考虑一下汽车，以及汽车如何沿着高速公路行驶

00:13:14.279 --> 00:13:20.380
因此，当汽车沿着高速公路行驶时，轮胎会紧紧抓住路

00:13:20.380 --> 00:13:22.990
轮胎紧紧抓住道路，从而产生摩擦，使汽车能够

00:13:22.990 --> 00:13:26.920
推动自己前进，这些摩擦点使汽车

00:13:26.920 --> 00:13:30.550
道路上的汽车很小，就像汽车有很大的地面空间

00:13:30.550 --> 00:13:33.790
但是您有这些与汽车接触的很小的接触点

00:13:33.790 --> 00:13:39.790
这种反应发生的道路，但是你知道你是否有车

00:13:39.790 --> 00:13:43.510
而且那辆车上有一个马达，那么马达真的不喜欢摩擦

00:13:43.510 --> 00:13:48.370
您不希望在那辆车附近的任何地方产生摩擦，因此电机真正依靠

00:13:48.370 --> 00:13:52.300
它尽可能地无摩擦，我们都知道，你知道什么时候有

00:13:52.300 --> 00:13:55.300
电动机内有很多摩擦，很多不好的事情会发生，您的系统会变慢

00:13:55.300 --> 00:14:00.070
停机，系统将无法正常运行，而所有这些都是

00:14:00.070 --> 00:14:06.910
导致系统很难使用，因此我们会考虑

00:14:06.910 --> 00:14:10.330
关于物理时间的摩擦权，所以我们无法消除物理时间

00:14:10.330 --> 00:14:14.380
从系统中删除，因为它对问题至关重要，但我们真的不想要

00:14:14.380 --> 00:14:17.050
尽可能减少在我们的计算机程序中使用物理时间

00:14:17.050 --> 00:14:23.080
可能，所以如果我们在此查看此框，则此框是一个数据流图，因此

00:14:23.080 --> 00:14:27.520
试想一下，这是内部发生的一些常规数据流组成计算

00:14:27.520 --> 00:14:32.770
盒子，我们想要做的是我们要把体力时间推给那些

00:14:32.770 --> 00:14:36.310
互动指向正确，就像汽车与现实世界互动一样

00:14:36.310 --> 00:14:39.760
在这些筹资点的这些地方的地面和高速公路，我们希望推动

00:14:39.760 --> 00:14:44.200
超时，我们不想在那个盒子里有时间，我们不想

00:14:44.200 --> 00:14:48.430
盒子里的物理时间，但是有逻辑时间的概念是可以的

00:14:48.430 --> 00:14:51.910
在盒子里，如果您看到约翰的对讲机，我们会一直这样做

00:14:51.910 --> 00:14:55.900
他谈到您知道让兰珀特时钟使用，我们拥有了所有

00:14:55.900 --> 00:15:00.130
这些好的因果追踪机制中，我们可以推断事件的发生方式

00:15:00.130 --> 00:15:03.400
在系统中传播，但我们不会基于

00:15:03.400 --> 00:15:11.260
身体上的时间，所以你可能会问，为什么我在乎盒子里是否有时间

00:15:11.260 --> 00:15:15.700
好吧，我是说您关心的原因是因为您是

00:15:15.700 --> 00:15:20.110
写盒子，那是您不想要的难事

00:15:20.110 --> 00:15:27.460
艰巨的任务，您必须根据时间编写所有这些代码，因此

00:15:27.460 --> 00:15:31.720
回到第二张幻灯片，我们说得很好，我们可以做的事将为零

00:15:31.720 --> 00:15:37.000
如果我们在一台计算机中有一堆计算机，那么同步实际上并不能做太多

00:15:37.000 --> 00:15:39.700
网络和这些计算机实际上并没有互相交谈

00:15:39.700 --> 00:15:43.180
他们知道他们可能不在一起工作，并且他们可能

00:15:43.180 --> 00:15:47.550
只是独立的单个系统，所以如果没有这些功能，我们真的无法做很多事情

00:15:47.550 --> 00:15:52.959
同步，但真正有趣的中间立场是

00:15:52.959 --> 00:15:57.700
我们可以看一下这个特性，即所谓的强最终一致性和

00:15:57.700 --> 00:16:01.180
这是我们熟悉的腹侧一致性模型

00:16:01.180 --> 00:16:05.800
具有但具有很强的收敛性，这说明

00:16:05.800 --> 00:16:11.050
以任何顺序提供相同更新且可以是不同顺序的副本

00:16:11.050 --> 00:16:15.990
在传递这些消息时，任何节点上的状态都将是等效的

00:16:15.990 --> 00:16:20.829
该模型的主要要求是相当弱的，只需要最终

00:16:20.829 --> 00:16:24.370
复制品到复制品的通讯，这仅仅是为了达到目的

00:16:24.370 --> 00:16:28.750
将所有消息传递到系统中的所有节点，这可以是

00:16:28.750 --> 00:16:31.839
正确地进行传递，我们实际上不必让每个节点都与之对话

00:16:31.839 --> 00:16:37.810
每个节点对此的好处是顺序不敏感，因此

00:16:37.810 --> 00:16:42.310
可交换的，我们可以按任何顺序接收更新，并且更新是重复的，

00:16:42.310 --> 00:16:45.990
敏感，我们可以在网络上进行重放，它也具有关联性

00:16:45.990 --> 00:16:51.130
这真的很棒，因为对于不可靠的人来说这是一个很好的匹配

00:16:51.130 --> 00:16:56.020
异步网络是我们最喜欢的网络，因此功能强大

00:16:56.020 --> 00:16:59.860
一致性依赖于单调性，因此我们将简要讨论

00:16:59.860 --> 00:17:03.100
单调性，我们没有时间真正经历你知道我不能拉

00:17:03.100 --> 00:17:07.480
建立维基百科，并尽可能多地与您一起浏览，但您知道

00:17:07.480 --> 00:17:12.490
我们将只是简要说明什么是单调性

00:17:12.490 --> 00:17:16.020
如果我们回到原始示例，您拥有副本，则副本为

00:17:16.020 --> 00:17:21.000
我们执行设置操作，异步传播结果，然后

00:17:21.000 --> 00:17:27.280
然后我们写两个和三个，所以现在我们有一个决定要做，如果我们

00:17:27.280 --> 00:17:31.120
在自然数是有序域的有序域上操作

00:17:31.120 --> 00:17:35.169
假设我们只设置自然数，该域是有序的，那么我们可以有一个

00:17:35.169 --> 00:17:38.110
单调函数，该函数将保留该顺序为

00:17:38.110 --> 00:17:41.290
输入增加输出将增加，这将

00:17:41.290 --> 00:17:45.340
如果我们使用max这样的东西给我们确定性的执行

00:17:45.340 --> 00:17:48.820
自然数上的单调函数，所以在这里我们很好地看到了

00:17:48.820 --> 00:17:51.820
三，因为三是已经看到的最大价值

00:17:51.820 --> 00:17:54.670
我可以做的是，我可以取这张图中的任何节点，我可以完全重新排列

00:17:54.670 --> 00:17:58.810
它和我仍然会得到相同的结果，所以这是有限的意外非

00:17:58.810 --> 00:18:04.270
系统的确定性，所以如果您去之前的CRT T-talk，

00:18:04.270 --> 00:18:07.180
您可能已经了解了最终的强大一致性，所以我

00:18:07.180 --> 00:18:13.840
对内容的任何重复表示歉意，那么我们如何才能成功地进行强大的编程

00:18:13.840 --> 00:18:20.170
最终的一致性，那么怎样定义成功的标准，这是

00:18:20.170 --> 00:18:24.910
将是剩下的演讲的大纲，然后我们将介绍一下

00:18:24.910 --> 00:18:29.860
看一下我们可以用它来构建哪些应用程序，所以从这里开始

00:18:29.860 --> 00:18:33.790
其实很好，首先要消除意外的不确定性

00:18:33.790 --> 00:18:36.730
因此，我们已经看到这些数据结构我刚刚向您展示了这些单调性

00:18:36.730 --> 00:18:40.590
这些功能确实有助于消除意外的不确定性，并且

00:18:40.590 --> 00:18:44.500
我们要做的是，如果我们要使这个将军成为一个将军，我们将不得不

00:18:44.500 --> 00:18:47.530
目的编程模型，我们必须消除，我们必须有能力

00:18:47.530 --> 00:18:52.810
以单调的方式对非单调进行建模，因此，如果您考虑一个集合

00:18:52.810 --> 00:18:56.380
不是单调的，因为您可以从中删除广告，因为随着时间的流逝，

00:18:56.380 --> 00:18:59.140
会有不同，您知道我们是否计算基数

00:18:59.140 --> 00:19:03.790
随着时间的推移而变化，因此我们必须有一种以单调的方式对其进行建模的方法

00:19:03.790 --> 00:19:07.450
因此，我们可以在以下事件的交付中对此进行推理：

00:19:07.450 --> 00:19:11.650
我们想要保留系统的属性

00:19:11.650 --> 00:19:14.560
函数式编程，使我们能够构成那些对象，因为它已经

00:19:14.560 --> 00:19:17.950
表明如果我只需要一个计数器a就不需要收敛的对象

00:19:17.950 --> 00:19:21.310
收敛计数器，我将其推入不会收敛的收敛集中

00:19:21.310 --> 00:19:25.810
正确，所以我们已经看到其中有些事情很难做到，所以我们

00:19:25.810 --> 00:19:29.230
需要有一种进行构图的方法，我们想采取一些行动

00:19:29.230 --> 00:19:33.700
与类似于融合和参照透明的属性一样

00:19:33.700 --> 00:19:38.460
与功能编程特别相关，但对不起，

00:19:38.460 --> 00:19:42.820
最后，我们需要一种分发所有这些东西的方法，我们需要一种在一个文件中运行它的方法。

00:19:42.820 --> 00:19:47.110
容错的运行时，您知道对故障的适应能力和高度的容错能力

00:19:47.110 --> 00:19:50.320
可用的所有东西，使使用某物变得非常实用

00:19:50.320 --> 00:19:54.400
像这样在生产中，所以我们将首先消除意外的非

00:19:54.400 --> 00:19:58.240
确定性，所以您可能听说过CRT T，我想在

00:19:58.240 --> 00:20:02.740
曾经看到的每个奇怪的循环都已经被某人嘲笑了

00:20:02.740 --> 00:20:05.879
今年还有一个，首席执行官的职责是分布式数据

00:20:05.879 --> 00:20:09.960
在以下情况下具有确定性分辨率的结构

00:20:09.960 --> 00:20:14.279
并发性，因此在并发操作下它们将收敛到一个

00:20:14.279 --> 00:20:20.129
特殊的方式，这些类型存在许多不同的属性

00:20:20.129 --> 00:20:23.580
所有这些东西的不同种类，我们都设置了计数器标记，这些标记是

00:20:23.580 --> 00:20:27.869
就像对不起，就像数十亿美元，我们有不同类型的寄存器

00:20:27.869 --> 00:20:32.549
有一个地图，可以组成一个单一的数据结构，还有

00:20:32.549 --> 00:20:37.590
图和这些数据结构尽可能地模仿顺序对应物

00:20:37.590 --> 00:20:41.190
集合的顺序版本尽可能没有

00:20:41.190 --> 00:20:44.940
并发添加/删除同一元素的操作，因此很多这些数据

00:20:44.940 --> 00:20:48.809
他们采取偏见的结构，在添加和删除

00:20:48.809 --> 00:20:52.109
网络中不同节点上的相同项目我们要做的是

00:20:52.109 --> 00:20:57.600
投放广告，因为我们认为您知道用户只会删除那些

00:20:57.600 --> 00:21:00.600
他们已经在场景中看到了，所以如果您再次遵循这些规则，就可以重新决定

00:21:00.600 --> 00:21:05.039
如果您遵守这些规则，则您具有合同权利，您将获得这些保证，并且

00:21:05.039 --> 00:21:09.779
CEO的职责是他们为每个对象提供强大的最终一致性

00:21:09.779 --> 00:21:16.739
这样就不会过度构图，所以我们将通过一个例子

00:21:16.739 --> 00:21:21.570
假设B和C为三个副本，我们将把我们的集合建模为一组

00:21:21.570 --> 00:21:25.649
三连体，所以这是三连体的集合，所以我省略了外花括号

00:21:25.649 --> 00:21:29.129
使它更具可读性，即使它不是超级可读，我们也有一个价值

00:21:29.129 --> 00:21:33.389
我们有一组独特的常数，它们代表像

00:21:33.389 --> 00:21:39.840
随机数，然后我们有一组删除项，所以当我添加两个副本时，一个副本

00:21:39.840 --> 00:21:44.249
a产生这个随机的小写字母，一个常数加一个到这个集合，然后

00:21:44.249 --> 00:21:49.679
如果副本C然后添加一个具有副本的C，则异步传播

00:21:49.679 --> 00:21:52.889
观测天数尚未发布，因为这些消息需要花费时间才能传播

00:21:52.889 --> 00:21:57.600
复制品C将添加唯一的常数B，这将区分这两个

00:21:57.600 --> 00:22:02.629
她现在想删除系统中发生的并发添加

00:22:02.629 --> 00:22:08.100
集合中的一个，因此圈内是集合中用户可查询的值，因此

00:22:08.100 --> 00:22:13.470
如果C想要从集合中删除一个，它将采用添加集合，即

00:22:13.470 --> 00:22:16.880
B，它将与移除集，B和我们

00:22:16.880 --> 00:22:21.140
我们创建了所谓的逻辑删除集和该逻辑删除统计信息

00:22:21.140 --> 00:22:25.430
跟踪网络中项目的清除，因此当我们交付所有

00:22:25.430 --> 00:22:29.960
这些消息最终我们保证我们会收敛到正确的结果，

00:22:29.960 --> 00:22:33.740
我们这样做的方法是成对的，所以实际上被建模为单调的

00:22:33.740 --> 00:22:36.740
联合半格，但它是成对的mur，使其非常

00:22:36.740 --> 00:22:41.120
很简单，您可以考虑在第一个三元组上进行成对合并

00:22:41.120 --> 00:22:47.270
元素通过合并下降来匹配，集合的并集是针对这些集合的，因为

00:22:47.270 --> 00:22:53.990
他们只会增长是单调的，可以确定元素是否在集合中

00:22:53.990 --> 00:22:57.350
我们要做的是利用广告集和删除集之间的差异

00:22:57.350 --> 00:23:01.880
如果不是空集，我们将其删除，因此您可能正在查看

00:23:01.880 --> 00:23:05.690
这句话是神圣的废话，这是您存储大量数据的大量数据

00:23:05.690 --> 00:23:09.650
一次没有任何元素的集合，是的，你是绝对正确的

00:23:09.650 --> 00:23:15.530
这些集合是模型化的，您知道这些是复杂性，是

00:23:15.530 --> 00:23:20.330
操作，但实际上您可以进行非常有效的修改

00:23:20.330 --> 00:23:24.650
将其减小为集合中活动元素的大小

00:23:24.650 --> 00:23:28.940
向量，表示系统中的参与者以及他们执行了多少次

00:23:28.940 --> 00:23:32.300
更新，所以有很多方法可以对此进行优化，但是这些方法是

00:23:32.300 --> 00:23:39.590
两分钟之内很难解释，所以我现在不使用它们了

00:23:39.590 --> 00:23:42.170
如果要保留某种属性，则具有这些数据结构

00:23:42.170 --> 00:23:44.810
像这些融合和引用的思想一样的函数式编程

00:23:44.810 --> 00:23:50.600
透明度，我们需要有一个模型，允许我们采用C或D T

00:23:50.600 --> 00:23:59.810
组成它们并获得具有此收敛属性的CR DT，所以我

00:23:59.810 --> 00:24:02.870
是晶格处理工作的最后一个过程，所以这是我的最后一个过程

00:24:02.870 --> 00:24:05.210
不知道您可能已经听说过这是我一直在做的事情

00:24:05.210 --> 00:24:09.080
过去一年，这是一个分布式确定性数据流变体，用于

00:24:09.080 --> 00:24:14.000
最终一致的程序类型最终一致的程序以及什么

00:24:14.000 --> 00:24:17.750
我们的意思是，如果程序输出为CR DT，则表示

00:24:17.750 --> 00:24:20.570
最终，一旦我交付了所有更新，即使节点得到了

00:24:20.570 --> 00:24:23.930
分开后，一旦我交付了所有

00:24:23.930 --> 00:24:27.470
更新后，我将在该节点上得到实际的相同答案，因此所有节点

00:24:27.470 --> 00:24:33.269
将在CRT T的基础上收敛到我们这样做的正确值，因此

00:24:33.269 --> 00:24:37.379
就像您想到列表和Lisp一样，我们有使用的晶格

00:24:37.379 --> 00:24:40.440
这是我们在此基础上构建所有内容的主要数据抽象

00:24:40.440 --> 00:24:45.570
不要像我们没有普通人一样静音，就像整数一样，所以

00:24:45.570 --> 00:24:52.169
没有整数，我们要做的是有一种做合成的方法，所以

00:24:52.169 --> 00:24:55.259
我说的所有内部元数据都在单调增长

00:24:55.259 --> 00:24:58.950
在上一个示例中向您展示了我们有一种使用功能组合的方法

00:24:58.950 --> 00:25:02.129
并通过映射元数据并建立其他类型的基于Co的职责

00:25:02.129 --> 00:25:08.639
在其他版本上，最后一次是在Erlang中实现的，而Erlang语法有点

00:25:08.639 --> 00:25:12.570
有时值得商so，所以我要做的是

00:25:12.570 --> 00:25:16.019
您在这里看到的伪代码类型是在调用中专门编码的

00:25:16.019 --> 00:25:20.759
因为erlangs类型系统实际上并不允许扩展，而我们

00:25:20.759 --> 00:25:27.389
这里是我们声明的集合，我们称它为s1我们将添加三个

00:25:27.389 --> 00:25:31.799
项目添加到集合中，因此我们将项目一，二和三相加，然后可以声明第二个

00:25:31.799 --> 00:25:36.809
集合，然后我们可以采用第一个集合将函数应用于其中的所有元素

00:25:36.809 --> 00:25:40.470
集合，然后生成一个新集合，因此该s2也将是CR DT，

00:25:40.470 --> 00:25:46.740
它将根据应用此地图的s1不断进行更新，因此最后一个帕劳是

00:25:46.740 --> 00:25:52.110
我们在本文中专门针对集合进行功能和集合理论运算

00:25:52.110 --> 00:25:55.799
专注于集合，但是实现中有一些计数器和寄存器的东西

00:25:55.799 --> 00:25:59.129
之类的东西，但是本文主要关注于设置数据结构

00:25:59.129 --> 00:26:03.779
因为您可以根据它构建很多东西，所以我们让您知道我们拥有

00:26:03.779 --> 00:26:07.619
看起来非常熟悉的产品交集联合过滤器映射的操作

00:26:07.619 --> 00:26:12.779
折叠像这样的东西，这些操作要做的是它们处理元数据

00:26:12.779 --> 00:26:17.279
计算时，它们会转换给定功能的元数据，因此，如果您有地图

00:26:17.279 --> 00:26:20.309
然后您映射到另一个集合中，然后更改它映射的元素的值

00:26:20.309 --> 00:26:25.830
通过确保元数据在另一侧（如果您有一个CR DT）

00:26:25.830 --> 00:26:29.669
折叠，然后将一组计数器折叠成一个计数器，它将执行该元数据

00:26:29.669 --> 00:26:32.970
映射，因此我们有一个想法，我们需要保留所有元数据

00:26:32.970 --> 00:26:36.539
跨这些对象以确保收敛，这就像一种

00:26:36.539 --> 00:26:43.200
标准的CRT T属性，通过强烈的最终一致性表示出来

00:26:43.200 --> 00:26:47.359
上次工作的方式，我们将简要概述一下

00:26:47.359 --> 00:26:51.330
是系统中的每个副本都是状态的单调流

00:26:51.330 --> 00:26:58.320
因此，每个CR dt本身只会不断增长，我们有从中读取的过程

00:26:58.320 --> 00:27:02.519
单调流，然后写出另一个流，对于产品，什么

00:27:02.519 --> 00:27:05.549
我们会做的是，我们将有两套书，我们将阅读它们，因为它们

00:27:05.549 --> 00:27:08.639
进行更改，我们将继续阅读它们，并产生输出，

00:27:08.639 --> 00:27:12.509
该输出也是CR DT，因此除了计算笛卡尔坐标

00:27:12.509 --> 00:27:16.049
集本身的乘积，我们产生

00:27:16.049 --> 00:27:20.129
设置元数据以确保如果我采用其中两个对象，则这些对象都将

00:27:20.129 --> 00:27:23.490
收敛到相同的结果，并记住这是对所有这些网络都可以容忍的

00:27:23.490 --> 00:27:29.940
异常，最后我们有了通货膨胀的念头，还有什么

00:27:29.940 --> 00:27:35.369
通货膨胀的读法是它确保了我们不会在这里详细讨论

00:27:35.369 --> 00:27:39.090
一段不错的对话，林赛·库珀（Lindsey Cooper）的一篇不错的博客文章

00:27:39.090 --> 00:27:43.980
在通货膨胀和单调之间，但它允许我们做的是

00:27:43.980 --> 00:27:47.940
从特定的副本读取数据，我们已经看到了state，然后看到了state

00:27:47.940 --> 00:27:52.799
 s Prime，然后我们的连接断开，我们回到另一个副本

00:27:52.799 --> 00:27:57.480
还没有s Prime更新，但我们保证不会读取任何值

00:27:57.480 --> 00:28:01.139
从那个副本直到更大，所以如果您熟悉分布式

00:28:01.139 --> 00:28:05.820
与会话保证权有关的数据库会话保证

00:28:05.820 --> 00:28:08.789
说，只要我连接到副本，我将永远继续

00:28:08.789 --> 00:28:12.090
如果我转到另一个节点，可能会收到更大的结果，我可能不得不等待

00:28:12.090 --> 00:28:15.149
这些结果可用，但这确保了我们继续前进

00:28:15.149 --> 00:28:20.960
网络故障条件下处理这些转换

00:28:20.960 --> 00:28:24.840
所以我们来看一个简短的例子，这些流看起来像

00:28:24.840 --> 00:28:29.820
演示一下，如果您想象我们在这里有两个客户，我们有一个副本

00:28:29.820 --> 00:28:33.720
所以它们都以空集开始，我们使用的是相同的三元组

00:28:33.720 --> 00:28:38.279
如果之前在添加集中添加了一个符号，那么我们之前就有的符号是

00:28:38.279 --> 00:28:43.200
发送到副本a并同时C 2与B相加并发送副本a

00:28:43.200 --> 00:28:46.289
副本a不选择一个或另一个

00:28:46.289 --> 00:28:50.159
它在接收到它们时将它们合并在一起，所以这是一个重要的区别

00:28:50.159 --> 00:28:53.700
从使用诸如玻璃作家风之类的系统的比赛中

00:28:53.700 --> 00:28:58.190
看看我们将要汲取什么价值，以便在这个系统中始终在增长

00:28:58.190 --> 00:29:02.330
我们一直在前进，然后看到人们可以继续对其应用更新

00:29:02.330 --> 00:29:05.660
本地状态并将其发送到副本a，然后最终它可以获取该状态

00:29:05.660 --> 00:29:10.850
来自rep okay，如果在此示例中喜欢，则副本中的流为

00:29:10.850 --> 00:29:14.810
单调的，随着时间的流逝它总是在增长，实际上是通货膨胀的，因为

00:29:14.810 --> 00:29:21.320
应用了突变，结果状态总是更大，因此，如果

00:29:21.320 --> 00:29:27.020
我们想建立一个系统来组成这些，我们通过

00:29:27.020 --> 00:29:32.660
单调过程的关系，所以我们再次回到使用类似的例子

00:29:32.660 --> 00:29:36.950
复制副本a具有空集，我们有一个将应用地图的过程

00:29:36.950 --> 00:29:40.880
函数，然后ereve的F就是地图的值

00:29:40.880 --> 00:29:45.500
应用于元素，因此我们只是将其用作速记，因此我们从

00:29:45.500 --> 00:29:48.950
说好吧，我是我要针对副本a和最后一个读取的过程

00:29:48.950 --> 00:29:55.610
我看到的值是底部，因此副本a更改并添加一个时的空集

00:29:55.610 --> 00:30:00.560
加上此读取返回到处理一个，并说是的我有一个

00:30:00.560 --> 00:30:03.860
状态大于其最后观察到的状态，并且p1处理

00:30:03.860 --> 00:30:08.420
值，然后将该值传播到另一个CR DT，所以这就是这个F

00:30:08.420 --> 00:30:14.330
 R的R只是输出CR DT不起作用，因此p1将迭代

00:30:14.330 --> 00:30:18.320
再说一次，好的，我要再读一遍，我要给

00:30:18.320 --> 00:30:21.170
您所观察到的最后一个状态，然后读取直到返回

00:30:21.170 --> 00:30:25.940
再次变得更大，我们用状态来执行此操作，您可能会说哇，这真的

00:30:25.940 --> 00:30:29.570
保持效率低下，使整个状态保持不变是的，这确实是正确的

00:30:29.570 --> 00:30:33.020
练习您在语义上知道我们可以在完整状态下执行此操作，但实际上

00:30:33.020 --> 00:30:36.950
我们使用逻辑时钟对此建模，因此您可以使用版本向量来完成此操作

00:30:36.950 --> 00:30:41.870
然后最终状态再次发生变化，将其从集合中删除

00:30:41.870 --> 00:30:44.720
应用的函数和map函数会生成一个集合，其中值是

00:30:44.720 --> 00:30:49.460
已更改，但元素仍被删除，因此此映射转换相当

00:30:49.460 --> 00:30:53.120
琐碎，但您可以想像，像褶皱之类的东西要多得多

00:30:53.120 --> 00:30:56.000
复杂，甚至过滤器也更复杂，因为您不能省略

00:30:56.000 --> 00:30:58.820
元素中的元素，因为现在您回到知道我看到的问题了

00:30:58.820 --> 00:31:01.790
它还是我没有看到它，所以实际上需要使用过滤器

00:31:01.790 --> 00:31:05.780
将元素从活动元素转换为已删除元素，因此其中一些

00:31:05.780 --> 00:31:11.230
转换是不平凡的，如果我们有一个节点可以看到这一点

00:31:11.230 --> 00:31:16.210
执行我们通过这种单调性得到的合流属性是

00:31:16.210 --> 00:31:21.100
别人也可以看到这种执行权，他们只会看到一些

00:31:21.100 --> 00:31:24.519
状态的子集，但只要它们得到最终信息，只要我们

00:31:24.519 --> 00:31:28.029
确保他们俩都看到关于某个状态的最终信息

00:31:28.029 --> 00:31:32.049
我们将看到结果仍然是相同的，所以这真的很好

00:31:32.049 --> 00:31:37.120
因为我们可以减少与这些流程进行通信所需的时间

00:31:37.120 --> 00:31:40.750
服务器，并且一旦我们完成了，计算仍然是正确的

00:31:40.750 --> 00:31:46.630
交付了系统中的所有事件，所以最后我们将简要地讨论一些

00:31:46.630 --> 00:31:50.620
正在进行的工作称为选择性听觉，这是一种流行病广播

00:31:50.620 --> 00:31:53.799
我们已经开发的基于运行时的系统，所以如果您熟悉的话

00:31:53.799 --> 00:31:58.929
八卦协议这是我们在八卦协议上建立的工作八卦

00:31:58.929 --> 00:32:04.510
协议允许非常有效地传播信息，因此非常可靠

00:32:04.510 --> 00:32:08.710
在可以处理大量节点的故障下进行广播

00:32:08.710 --> 00:32:13.289
一些协议在评估中做10 12.5万5千个节点，

00:32:13.289 --> 00:32:18.639
使这种匹配如此出色的原因是广播协议实现了它们的

00:32:18.639 --> 00:32:23.529
通过弱排序提高效率，这就是为什么它不是通用模型

00:32:23.529 --> 00:32:27.519
建立东西，但这很棒，因为我们不在乎消息

00:32:27.519 --> 00:32:31.419
尽管我们的整个计算模型都基于以下事实进行排序：

00:32:31.419 --> 00:32:36.580
可以重新排序，我们保证我们正确收敛，最后

00:32:36.580 --> 00:32:40.059
名称选择性听觉的原因是我们希望节点能够

00:32:40.059 --> 00:32:43.809
有选择地选择加入计算，所以如果我有一个程序

00:32:43.809 --> 00:32:46.929
需要一些可变状态，我知道这些上的可变状态

00:32:46.929 --> 00:32:50.559
五个节点，那么我就可以表达对该变量的兴趣，所以它很

00:32:50.559 --> 00:32:56.860
类似于发布/订阅系统的运行时，所以我已经展示了

00:32:56.860 --> 00:33:00.820
您已向您表明，您可以消除意外的不确定性

00:33:00.820 --> 00:33:05.559
通过CRT豌豆，我们可以找到一种方法来组合这些东西并构建其他CRT

00:33:05.559 --> 00:33:10.450
茶，最后我们可以非常好地有效地分配它们

00:33:10.450 --> 00:33:13.929
运行时效率很高，所以现在的问题是，我们是否可以实际

00:33:13.929 --> 00:33:19.269
建立任何比这更重要的东西，所以我们希望谈论一个

00:33:19.269 --> 00:33:25.149
手机游戏平台，让我们以愤怒的小鸟为例来做广告

00:33:25.149 --> 00:33:30.039
将与游戏中的客户端一起显示，并且将离线

00:33:30.039 --> 00:33:34.359
人们将继续在游戏中看到广告，因此我们希望客户成为

00:33:34.359 --> 00:33:38.019
持续取得进展，仍然记录广告的展示次数，我们要做

00:33:38.019 --> 00:33:41.320
为您完全协调或最大程度地减少协调

00:33:41.320 --> 00:33:44.889
这是可能的，这就是数据流图的样子，我们将逐步介绍

00:33:44.889 --> 00:33:48.249
因此，让我们想象一下，我们在Rovio中有防暴游戏，他们想

00:33:48.249 --> 00:33:52.659
在游戏内做广告，所以他们有一堆广告计数器广告，我们

00:33:52.659 --> 00:33:56.369
就像将它们分组成一个集合，然后将这些集合合并在一起

00:33:56.369 --> 00:34:00.700
因此，让我们想象一下，有一个合同的概念可以使这个例子成为

00:34:00.700 --> 00:34:05.019
难度稍高一点，您知道合同是说广告可以

00:34:05.019 --> 00:34:09.220
在特定时间显示，因此您想要在Ruby on上执行的操作

00:34:09.220 --> 00:34:13.000
您会对自己说的类似的Rails或Web框架

00:34:13.000 --> 00:34:17.019
续集数据库很好，嘿，您知道计算机连接这两个东西的位置

00:34:17.019 --> 00:34:20.799
等价键匹配的地方，所以在数据流中

00:34:20.799 --> 00:34:24.279
可以通过您知道计算笛卡尔积的模型来对此建模

00:34:24.279 --> 00:34:29.049
然后进行过滤，然后仅获取有效的广告，我们可以

00:34:29.049 --> 00:34:32.619
也让这些客户全力以赴，以便我们将这些计数器分发给

00:34:32.619 --> 00:34:36.549
客户客户可以继续增加这些计数器，因此他们有一个

00:34:36.549 --> 00:34:39.399
代表某种全球计数器的计数器，然后它们与之分离

00:34:39.399 --> 00:34:43.240
然后他们定期将计数器发送回数据中心

00:34:43.240 --> 00:34:47.379
然后数据中心运行的流程正在执行其中一种通货膨胀

00:34:47.379 --> 00:34:52.599
读到它说不要让我不要让这个过程继续运行，直到

00:34:52.599 --> 00:34:55.960
广告达到50,000个，因此所有这些客户都在不断合并

00:34:55.960 --> 00:34:59.619
他们停留在柜台上，单调缓慢增长，然后当我们

00:34:59.619 --> 00:35:03.549
达到那个触发值，我们从模型中删除了集合中的项目

00:35:03.549 --> 00:35:06.880
单调地刷新到客户端，这是完全完成的

00:35:06.880 --> 00:35:10.029
我们唯一协调的部分是与服务器同步到

00:35:10.029 --> 00:35:14.259
发送我们的州，所以这很好，广告柜台是完全

00:35:14.259 --> 00:35:17.950
单调性我们可以通过单调性禁用合同和广告

00:35:17.950 --> 00:35:22.480
所有这些都是单调的，柜台本身就是单调的，显然是个女孩子

00:35:22.480 --> 00:35:26.410
计数器，我们可以取该图中的任何节点并将其放在任何位置

00:35:26.410 --> 00:35:29.920
物理机器，因为数据结构正确捕获了

00:35:29.920 --> 00:35:33.609
并发系统中的并发保证可以正确合并，因此我们可以

00:35:33.609 --> 00:35:37.120
随意分发这张图，这真的非常好，让我说一下

00:35:37.120 --> 00:35:41.440
如果需要的话，它们都在同一台机器上，最后，如果我们认为系统是

00:35:41.440 --> 00:35:44.710
如果我们有一个外部观察者可以看到全球

00:35:44.710 --> 00:35:49.420
计数器是什么的真相，我们可以像我们多常测量一次差异

00:35:49.420 --> 00:35:58.240
同步并将我们的结果放入全局结果中，这样您就可以总结一下

00:35:58.240 --> 00:36:02.800
想一想，所以我对我们从零开始建立的这个模型有什么看法

00:36:02.800 --> 00:36:08.290
同步，我们没有建立必须删除协调的系统

00:36:08.290 --> 00:36:11.890
我们做出的权衡是，如果我们希望我们的广告柜台

00:36:11.890 --> 00:36:16.480
更正确，以减少分歧，我们同步更多，但应用程序

00:36:16.480 --> 00:36:20.380
设计在最低层不使用任何协调，这确实非常好

00:36:20.380 --> 00:36:27.390
构建应用程序的方式，所以最后只是谈论下一步

00:36:27.390 --> 00:36:32.320
简短地讲，因为我没时间了，我们已经显示了元数据可能会变得非常大

00:36:32.320 --> 00:36:38.250
我们有减少系统中元数据的机制，我们有效率

00:36:38.250 --> 00:36:42.430
使用向量而不是存储所有向量的集合的表示

00:36:42.430 --> 00:36:47.260
操作，实际上我们的原始附录尚未发布

00:36:47.260 --> 00:36:50.470
这篇论文将我们扩展到了许多其他不同的优化数据类型

00:36:50.470 --> 00:36:57.220
希望不久将在i Function上公开露面不是

00:36:57.220 --> 00:37:01.990
令人惊讶的是，它依赖于应用于fold的二进制函数

00:37:01.990 --> 00:37:05.950
关联交换幂等，并且具有被求逆的能力，所以如果我

00:37:05.950 --> 00:37:10.990
有一套我已删除项目并多次添加的项目

00:37:10.990 --> 00:37:14.380
并将其折叠到柜台上，我需要一种方法来反映

00:37:14.380 --> 00:37:17.050
计数的加法，计数器的增量和计数器的减法

00:37:17.050 --> 00:37:21.490
以某种方式保存我在两个对象之间保留元数据的计数器

00:37:21.490 --> 00:37:27.850
完全，最后我们可以从数据流图中得出什么，所以可以

00:37:27.850 --> 00:37:31.240
我们在做的事情中看到，嘿，您正在此节点上运行此地图，并且

00:37:31.240 --> 00:37:34.210
在这个节点上的这个过滤器中，我们可以将这些东西正确地组合成一个

00:37:34.210 --> 00:37:40.120
折叠，这样我们就可以使用数据流图得出分布了吗？我们可以使用

00:37:40.120 --> 00:37:44.500
最小所需的分布以得出优化的数据流图，因此这是

00:37:44.500 --> 00:37:48.430
我真的很感兴趣但还没有开始考虑的东西，但是

00:37:48.430 --> 00:37:55.390
似乎很激动，所以总结一下我们学到的东西，我们学到的东西

00:37:55.390 --> 00:38:00.760
我们想要消除偶然的不确定性，并且我们了解到我们

00:38:00.760 --> 00:38:06.090
可以通过CRT来做到这一点，这提供了一个非常好的构建基块

00:38:06.090 --> 00:38:11.260
做CRT T的组合，以建立程序来观察这种强大的

00:38:11.260 --> 00:38:17.350
收敛性，一旦我们有一个有效的方法来做到这一点

00:38:17.350 --> 00:38:20.890
因为CRT T依赖

00:38:20.890 --> 00:38:24.550
就像您知道自己必须容忍一些失败，

00:38:24.550 --> 00:38:30.310
根据您的复制方式，我们可以构建一个运行时系统，使我们能够

00:38:30.310 --> 00:38:35.470
对这种编程模型进行非常有效的缩放，以便总结出以下一种

00:38:35.470 --> 00:38:40.630
关键点同步很昂贵，您可能都知道这一点，

00:38:40.630 --> 00:38:43.210
知道您永远不会比锁定的关键部分更快

00:38:43.210 --> 00:38:49.030
这是一种直接的并发编程，其中很多

00:38:49.030 --> 00:38:53.350
应用程序不可能总是同步，所以如果

00:38:53.350 --> 00:38:57.370
您是移动应用程序，客户端偶尔会离线，这很有趣

00:38:57.370 --> 00:39:02.110
我曾经说过一个轶事，你知道你打电话给你的朋友并计算出一个

00:39:02.110 --> 00:39:05.230
一轮共识告诉他们7:00上网，而保罗·布里尔（Paul Brill）则表示

00:39:05.230 --> 00:39:08.940
现在对我很好，您已经通过电话推送了共识问题，

00:39:08.940 --> 00:39:13.780
最后，您知道有些事情需要同步全局不变量原子

00:39:13.780 --> 00:39:21.760
可见性，所以我们有一堆文件，如果您希望我们可以将其签出

00:39:21.760 --> 00:39:25.420
标记了一个发行版0.01，这使我永远花了这个Erling包装的东西

00:39:25.420 --> 00:39:30.130
即使我有很多经验也可以正常工作

00:39:30.130 --> 00:39:33.250
您可以下载此软件包这是一个不全面的实施

00:39:33.250 --> 00:39:36.460
或所有内容都已构建，但完全可执行，您可以运行我们的演示

00:39:36.460 --> 00:39:41.320
程序，这样很好，最后我要感谢欧洲人

00:39:41.320 --> 00:39:45.100
联盟不仅在过去三年中资助了我的大量研究工作

00:39:45.100 --> 00:39:48.910
但他们也向我提供了研究金，因此这将为我提供

00:39:48.910 --> 00:39:53.170
能够在明年进行我的博士研究，所以我非常感谢他们

00:39:53.170 --> 00:39:57.400
我是克里斯·迈克尔·约翰（Chris Michael John）非常感谢您的光临

00:39:57.400 --> 00:39:59.460
你

