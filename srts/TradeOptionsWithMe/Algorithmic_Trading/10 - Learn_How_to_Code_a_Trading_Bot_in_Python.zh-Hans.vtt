WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.160 --> 00:00:04.240
欢迎回到本视频中的另一个视频，我将向您展示如何开发一个

00:00:04.240 --> 00:00:07.040
基于其交易决策的交易算法

00:00:07.040 --> 00:00:11.200
基本因素，例如大小的质量和价值

00:00:11.200 --> 00:00:14.880
给定公司，我将用python编写此算法

00:00:14.880 --> 00:00:17.920
在Quantconnect算法交易平台内部

00:00:17.920 --> 00:00:21.520
我们将使用quantconnect的原因是您可以访问

00:00:21.520 --> 00:00:25.039
所有他们的数据和回测功能都是免费的

00:00:25.039 --> 00:00:29.199
这是python交易机器人系列的第四段视频，我相信

00:00:29.199 --> 00:00:31.519
这将是迄今为止最大的项目

00:00:31.519 --> 00:00:34.960
我将尽我所能尽一切可能解释一切

00:00:34.960 --> 00:00:38.559
尽管如此，我不得不说，我们将使用Quantconnect的更多功能

00:00:38.559 --> 00:00:41.760
高级功能，例如算法框架

00:00:41.760 --> 00:00:44.960
因此，我强烈建议您观看其他一些视频

00:00:44.960 --> 00:00:48.879
在此视频之前，如果您不熟悉quantconnect或python

00:00:48.879 --> 00:00:52.239
那就是说，让我们从分解交易策略开始

00:00:52.239 --> 00:00:55.120
在视频中从概念上实现

00:00:55.120 --> 00:00:57.199
这样做将有望帮助您理解

00:00:57.199 --> 00:01:01.120
正如我之前所说，我们的代码应该做什么

00:01:01.120 --> 00:01:05.040
该算法将根据公司的基本面做出交易决策

00:01:05.040 --> 00:01:07.520
价值观，我们将不会使用任何技术

00:01:07.520 --> 00:01:11.200
交易决策指标，但如果您愿意的话，那肯定是

00:01:11.200 --> 00:01:14.320
您可以添加以潜在改善其性能的内容

00:01:14.320 --> 00:01:18.240
更具体地说，我们将根据公司的质量对股票进行排名

00:01:18.240 --> 00:01:23.439
价值和规模研究表明，从历史上看，小型股票

00:01:23.439 --> 00:01:27.600
似乎跑赢大盘股，这种效应也称为规模

00:01:27.600 --> 00:01:30.560
效果有多种可能的解释

00:01:30.560 --> 00:01:33.520
对于这种行为，但最广泛接受的是

00:01:33.520 --> 00:01:37.280
那些小盘股比大盘股的流动性更差

00:01:37.280 --> 00:01:41.280
这使得它们不适用于机构贸易公司的交易

00:01:41.280 --> 00:01:44.399
此外，小盘股有更多的增长潜力

00:01:44.399 --> 00:01:48.399
并且更加灵活，但必须注意的是，小盘价

00:01:48.399 --> 00:01:51.840
股票也可能比大盘股更具风险

00:01:51.840 --> 00:01:55.759
由于这种规模效应，我们将根据每只股票的规模得分

00:01:55.759 --> 00:01:59.280
研究人员还以类似的方式设定了市值

00:01:59.280 --> 00:02:03.840
发现存在价值效应，这种效应意味着

00:02:03.840 --> 00:02:08.160
相对较高的账面价值比往往要比那些账面价值低的股票要好

00:02:08.160 --> 00:02:11.760
如果您想了解更多有关价格的信息，请与价格相比较

00:02:11.760 --> 00:02:15.360
值和大小因子，您可以查看链接的定量pedia条目

00:02:15.360 --> 00:02:19.760
在下面的说明框中，除了帐面价值外，我们还将使用

00:02:19.760 --> 00:02:22.400
自由现金流量与企业价值之比

00:02:22.400 --> 00:02:26.560
和给每只股票一个价值得分时的最新收益率

00:02:26.560 --> 00:02:29.840
股票的感知价值越高，我们就越有趣

00:02:29.840 --> 00:02:32.879
最后购买它，但同样重要的是我们还给了每个

00:02:32.879 --> 00:02:37.120
为此，我们将使用所谓的质量得分

00:02:37.120 --> 00:02:40.319
首先，我们将获取毛利率

00:02:40.319 --> 00:02:44.160
这是毛利润与收入之比

00:02:44.160 --> 00:02:48.480
接下来，我们将研究速动比率，即流动资产与

00:02:48.480 --> 00:02:51.519
流动负债，这基本上只是衡量

00:02:51.519 --> 00:02:55.840
最后我们还将研究流动资产负债率

00:02:55.840 --> 00:03:00.640
它检查了由债务融资的公司的百分比

00:03:00.640 --> 00:03:04.560
在此排名中，具有高利润率的公司具有良好的流动性

00:03:04.560 --> 00:03:09.680
而且低负债将获得较高的分数，因此我们的算法会优先考虑

00:03:09.680 --> 00:03:13.360
在计算每只股票的大小值和质量得分时

00:03:13.360 --> 00:03:17.280
我们不会使用潜在基本因素的实际价值

00:03:17.280 --> 00:03:20.879
取而代之的是，我们只对股票进行比较

00:03:20.879 --> 00:03:24.159
因此，例如，高的书本价格比

00:03:24.159 --> 00:03:28.159
只要您拥有比其他同类产品更高的比率，就没有那么重要

00:03:28.159 --> 00:03:31.440
实际进行任何交易之前的股票

00:03:31.440 --> 00:03:35.360
决定，我们必须首先结合我们的尺寸值和质量得分

00:03:35.360 --> 00:03:39.840
为此，我们将每个分数乘以给定的权重

00:03:39.840 --> 00:03:44.400
然后将它们全部加起来，我们得到了每只股票的综合得分

00:03:44.400 --> 00:03:47.440
看了这些股票，然后我们将购买

00:03:47.440 --> 00:03:51.280
那些得分最高的股票，除非它们的得分是

00:03:51.280 --> 00:03:54.159
在我们进入定量连接之前已满

00:03:54.159 --> 00:03:59.120
平台并开始编码，让我再回顾一下该策略

00:03:59.120 --> 00:04:02.239
我们的算法将研究一些流动性最高的股票

00:04:02.239 --> 00:04:05.519
对于这些股票中的每一个，它将计算出一个单独的大小

00:04:05.519 --> 00:04:10.480
价值和质量得分，然后将这些得分合并为一个

00:04:10.480 --> 00:04:14.239
基于此的总分，算法将

00:04:14.239 --> 00:04:20.160
买那些得分最高的股票，让我们现在开始量化

00:04:20.160 --> 00:04:23.280
连接此视频的编码部分

00:04:23.280 --> 00:04:27.040
强烈建议您同时进行编码，以便您快速创建

00:04:27.040 --> 00:04:30.000
一个免费的con connect帐户，说明框中有一个链接

00:04:30.000 --> 00:04:33.360
在我们进行实际编码之前

00:04:33.360 --> 00:04:36.479
虽然我想简单地指出我从中汲取了很多灵感

00:04:36.479 --> 00:04:40.639
摘自杰克·西蒙森（Jack simonsen）在他的基本工厂发布的代码

00:04:40.639 --> 00:04:45.360
战略社区的帖子，非常感谢您里面的帖子

00:04:45.360 --> 00:04:49.040
量化连接平台，我们将转到那里的“实验室”选项卡

00:04:49.040 --> 00:04:53.440
我们可以单击“创建新算法”，这将给您概述

00:04:53.440 --> 00:04:56.479
模块以及一些入门示例代码

00:04:56.479 --> 00:05:00.000
就像我在本视频开头所说的那样，我们将使用定量连接

00:05:00.000 --> 00:05:03.759
现在，我们将在几秒钟内进一步了解算法框架

00:05:03.759 --> 00:05:07.120
只想通过单击三个模块来输入它们

00:05:07.120 --> 00:05:11.360
第一个模块是内部加权投资组合构建模型

00:05:11.360 --> 00:05:15.440
我们将使用它为我们自动构建投资组合

00:05:15.440 --> 00:05:19.280
我们将导入的第二个模块是立即执行模型

00:05:19.280 --> 00:05:23.039
如果我们的算法发送

00:05:23.039 --> 00:05:27.360
最后但同样重要的是，我们将输入

00:05:27.360 --> 00:05:31.520
最大跌幅风险模型该模型使我们可以指定一个

00:05:31.520 --> 00:05:35.199
百分比，并且当头寸亏损达到该百分比时

00:05:35.199 --> 00:05:39.520
该模型将自动管理该头寸的退出过程

00:05:39.520 --> 00:05:43.360
输入这三个模块后，该单击创建算法了

00:05:43.360 --> 00:05:47.520
右下角的按钮将创建一个带有以下内容的示例算法

00:05:47.520 --> 00:05:52.400
每次都调用两个预定义方法on data方法

00:05:52.400 --> 00:05:56.080
该算法接收到新数据，但由于我们将使用该算法

00:05:56.080 --> 00:05:59.759
框架，我们不需要它，所以我们可以删除它

00:05:59.759 --> 00:06:03.680
顾名思义，initialize方法用于初始化设置

00:06:03.680 --> 00:06:08.080
算法所需的函数和变量

00:06:08.080 --> 00:06:11.600
在我们开始实际实现initialize方法之前，我想简单地

00:06:11.600 --> 00:06:14.319
向您展示quantconnect的算法框架

00:06:14.319 --> 00:06:18.479
因为这将是该算法的必要工具

00:06:18.479 --> 00:06:21.919
更复杂的交易算法的一般设计模式

00:06:21.919 --> 00:06:26.160
是一个至少分为五到六个独立模块的项目

00:06:26.160 --> 00:06:29.759
如果您想查看这五到六个模型的详细分类

00:06:29.759 --> 00:06:33.440
我强烈建议您观看我的交易算法说明视频

00:06:33.440 --> 00:06:37.199
在此视频下面的描述框中有一个链接，我只会为您提供

00:06:37.199 --> 00:06:41.360
该框架的简要概述该算法框架包括五个

00:06:41.360 --> 00:06:45.120
模块的第一个是所谓的宇宙选择

00:06:45.120 --> 00:06:48.639
建立模型，算法在该模型上确定要考虑的证券

00:06:48.639 --> 00:06:52.080
在这里寻找潜在交易时，您可以考虑以下因素：

00:06:52.080 --> 00:06:57.120
流动性价格行业或我们的算法

00:06:57.120 --> 00:07:00.560
我们将研究具有基本数据的最具流动性的证券

00:07:00.560 --> 00:07:05.520
接下来我们需要可用的我们有alpha模型，这是

00:07:05.520 --> 00:07:09.280
可能是最重要的模型，因为这是您发挥优势的地方

00:07:09.280 --> 00:07:13.840
扮演Alpha模型的角色是发出交易信号，但它不会

00:07:13.840 --> 00:07:16.479
虽然直接发出任何贸易订单

00:07:16.479 --> 00:07:20.160
相反，它只是将交易建议传递给投资组合

00:07:20.160 --> 00:07:23.280
构造模型，然后该模型构造一个

00:07:23.280 --> 00:07:26.800
基于这些交易信号的适当投资组合

00:07:26.800 --> 00:07:30.319
投资组合构建模型的最简单形式之一

00:07:30.319 --> 00:07:33.440
是一个相等加权的模型，它分配您的相等份额

00:07:33.440 --> 00:07:37.280
我们算法的每个头寸的投资组合资本

00:07:37.280 --> 00:07:42.160
将使用内部加权分配，但除此之外

00:07:42.160 --> 00:07:46.319
还有一个交易成本模型可以模拟交易成本

00:07:46.319 --> 00:07:50.240
它这样做是为了确定给定的交易是否值得您花钱

00:07:50.240 --> 00:07:53.280
如果伴随的交易成本太高

00:07:53.280 --> 00:07:56.879
可能不值得，我们不会在我们的系统中实现这样的模型

00:07:56.879 --> 00:08:01.280
算法，虽然接下来是风险模型，例如名称

00:08:01.280 --> 00:08:05.199
暗示风险模型是算法的风险管理单元

00:08:05.199 --> 00:08:08.479
它决定何时获利和何时减少损失

00:08:08.479 --> 00:08:12.400
我们将从使用相对简单的风险模型即最大风险模型开始

00:08:12.400 --> 00:08:15.919
缩水模型该模型会尽快平仓

00:08:15.919 --> 00:08:19.680
它超过一定的预定百分比缩水

00:08:19.680 --> 00:08:23.520
最后但并非最不重要的一点是，我们拥有执行模型，该模型的工作

00:08:23.520 --> 00:08:28.240
发出实际的交易订单，尤其是当您要开仓或平仓时

00:08:28.240 --> 00:08:32.800
您不想只发出一份大交易订单的大头寸

00:08:32.800 --> 00:08:36.240
相反，您可能想将头寸分成许多较小的订单

00:08:36.240 --> 00:08:40.719
并将其作为适当的时间发送，以确定最佳的订单量

00:08:40.719 --> 00:08:45.360
时间就是我们算法的执行模型

00:08:45.360 --> 00:08:49.120
使用非常简单的立即执行模型

00:08:49.120 --> 00:08:53.440
除了关注点分离之外，使用此类算法的巨大优势

00:08:53.440 --> 00:08:55.920
框架是非常容易

00:08:55.920 --> 00:09:00.080
交换您可以基本想到的这些组件的单个组件

00:09:00.080 --> 00:09:03.040
作为交易算法的不同组成部分

00:09:03.040 --> 00:09:06.080
您可以轻松地交换投资组合的构建方式

00:09:06.080 --> 00:09:10.000
或仅通过更改一条或两条线即可如何管理风险

00:09:10.000 --> 00:09:14.640
它非常强大，而且quantconnect实际上提供了广泛的

00:09:14.640 --> 00:09:19.839
在创建算法时预定义模块的范围，我们已经

00:09:19.839 --> 00:09:24.880
导入了投资组合的建设风险和执行模型，所以这三个

00:09:24.880 --> 00:09:29.600
几行代码已经负责管理我们的投资组合及其风险和

00:09:29.600 --> 00:09:33.519
贸易订单管理不仅很棒，还可以

00:09:33.519 --> 00:09:36.320
现在要做的是实现Universe选择

00:09:36.320 --> 00:09:39.519
模型和Alpha模型，我们将从宇宙开始

00:09:39.519 --> 00:09:43.120
实现初始化方法后立即选择模型

00:09:43.120 --> 00:09:46.720
我们将从设置行李测试的开始日期和结束日期开始

00:09:46.720 --> 00:09:50.320
真的不重要，您在这里选择哪个日期，我会过去

00:09:50.320 --> 00:09:52.880
8年

00:09:56.320 --> 00:09:59.680
接下来，我们为反向测试设置启动缓存平衡

00:09:59.680 --> 00:10:03.440
这只是出于回购目的，在实际交易中，这个数字将是

00:10:03.440 --> 00:10:06.320
从您的经纪人平台的帐户余额中提取

00:10:06.320 --> 00:10:10.800
我会将起始现金余额设置为100000

00:10:11.120 --> 00:10:15.040
接下来，我们将执行模型设置为立即执行模型

00:10:15.040 --> 00:10:19.600
该模型一旦收到交易信号，便会发出订单

00:10:19.600 --> 00:10:22.880
之后，我们将投资组合构建模型设置为内部

00:10:22.880 --> 00:10:26.800
加权投资组合构建模型，该模型接收分配权重

00:10:26.800 --> 00:10:29.920
然后从Alpha模型创建基于这些的投资组合

00:10:29.920 --> 00:10:33.360
权重之后，我们将风险模型设置为

00:10:33.360 --> 00:10:37.279
最大跌幅模型该模型采用一个参数，即

00:10:37.279 --> 00:10:40.880
百分比亏损，之后应退出头寸

00:10:40.880 --> 00:10:47.360
我们现在将其设置为10，但可以尝试不同的值

00:10:47.360 --> 00:10:50.640
现在是时候初始化一些我们将用于

00:10:50.640 --> 00:10:54.160
选择宇宙以更好地理解这一点让我快速

00:10:54.160 --> 00:10:58.079
概述我们将如何实现此算法的Universe选择

00:10:58.079 --> 00:11:02.240
我们将使用两个过滤器添加一个Universe，一个更粗略的过程过滤器

00:11:02.240 --> 00:11:06.959
还有一个很好的过滤器，课程过滤器使我们可以过滤掉证券

00:11:06.959 --> 00:11:11.600
根据其价格美元数量以及是否为基本数据

00:11:11.600 --> 00:11:15.120
在这里，我们选择价格超过5美元的那些股票

00:11:15.120 --> 00:11:18.320
足够的流动性和基本数据

00:11:18.320 --> 00:11:22.480
然后，这些证券集合将被传递到精细过滤器中

00:11:22.480 --> 00:11:25.920
在这里，我们会筛选出没有正确价值的证券

00:11:25.920 --> 00:11:29.760
我们需要对股票进行评分的基本因素

00:11:29.760 --> 00:11:33.160
帮助变量，我们将使用self.nom课程和

00:11:33.160 --> 00:11:36.640
self.numfine这些定义了我们看多少证券

00:11:36.640 --> 00:11:41.279
在课程过滤器和精细过滤器中，我们初始化self.numcores

00:11:41.279 --> 00:11:43.920
到200，这意味着我们将过滤掉

00:11:43.920 --> 00:11:48.000
满足其他标准并通过的200种最具流动性的证券

00:11:48.000 --> 00:11:52.399
然后将其过滤到精细过滤器上，然后将20个过滤器过滤掉

00:11:52.399 --> 00:11:55.279
质量值和大小得分最高的股票

00:11:55.279 --> 00:12:00.720
并进行交易，这就是我们将self.numfine初始化为20的原因。

00:12:00.720 --> 00:12:04.720
接下来我们将self.lastmonth初始化为-1

00:12:04.720 --> 00:12:08.240
我们稍后将使用此变量作为标记，以便我们只能重新平衡

00:12:08.240 --> 00:12:12.480
之后，每个月为您输出一次，我们设置分辨率

00:12:12.480 --> 00:12:16.480
宇宙到每日分辨率，这意味着我们每天都在接收数据

00:12:16.480 --> 00:12:19.440
Quantconnect还支持低至每分钟的分辨率

00:12:19.440 --> 00:12:23.279
但我们将使用此视频的每日分辨率

00:12:23.279 --> 00:12:27.440
现在我们只需要使用添加Universe来添加我们的库存Universe

00:12:27.440 --> 00:12:31.680
作为参数，我们在课程中提交两个方法并查找过滤器

00:12:31.680 --> 00:12:42.959
现在将要实现的我们从课程过滤器开始

00:12:48.480 --> 00:12:51.920
我们在课程过滤器中要做的第一件事是检查是否该

00:12:51.920 --> 00:12:54.639
如果不是，请重新平衡

00:12:54.639 --> 00:12:57.839
不变的宇宙

00:13:04.880 --> 00:13:10.560
否则，我们会将self.lastmonth标志更新为当前月份

00:13:11.519 --> 00:13:15.680
然后是时候根据美元数量对所有给定的安全对象进行排序

00:13:15.680 --> 00:13:19.360
但我们只想保存价格大于5美元的商品

00:13:19.360 --> 00:13:35.839
并且有基本数据

00:13:36.160 --> 00:13:40.639
然后，我们将此列表保存到选定的变量

00:13:43.040 --> 00:13:47.519
最后但并非最不重要的一点是，我们返回所选列表的前200个符号

00:13:47.519 --> 00:13:50.639
这由self.nom课程变量指定

00:13:50.639 --> 00:13:53.920
我们之前定义的

00:13:57.120 --> 00:14:03.839
然后，此列表将传递到我们现在将实现的find过滤器

00:14:04.880 --> 00:14:08.800
我们要在精细过滤器中做的所有事情就是过滤掉那些具有

00:14:08.800 --> 00:14:14.079
对于每个基本因素，该值都将大于0

00:14:14.839 --> 00:14:17.839
用

00:14:31.120 --> 00:14:34.880
这些因素包括毛利率速动比率

00:14:34.880 --> 00:14:37.839
资产负债

00:14:39.600 --> 00:14:45.839
每股账面价值

00:14:45.920 --> 00:14:48.720
现金回报

00:14:52.560 --> 00:15:03.120
收益率和市值，我们将

00:15:03.120 --> 00:15:07.440
非空值，因为如果

00:15:07.440 --> 00:15:12.800
算法找不到所有基本因素列表的实际值

00:15:12.800 --> 00:15:15.600
量化连接允许您使用，您可以检查链接

00:15:15.600 --> 00:15:19.839
下方说明框中的文档页面

00:15:19.839 --> 00:15:24.839
现在，在查找过滤器中剩下要做的就是返回此过滤后的文件

00:15:24.839 --> 00:15:29.120
列出我们现在已经成功

00:15:29.120 --> 00:15:32.720
为该算法实现了Universe选择模型

00:15:32.720 --> 00:15:36.399
现在让我们回到initialize方法并开始添加一些变量

00:15:36.399 --> 00:15:40.639
对于此处的Alpha模型，我们将创建几个

00:15:40.639 --> 00:15:44.320
变量，这些变量将是alpha模型的一些参数

00:15:44.320 --> 00:15:48.000
前三个参数是质量值的权重

00:15:48.000 --> 00:15:51.519
和大小得分，如您所愿记住的

00:15:51.519 --> 00:15:54.959
我们的算法为我们的股票世界中的每只股票提供了质量

00:15:54.959 --> 00:15:59.680
值和尺码得分这些得分然后必须通过将每个得分相乘来合并

00:15:59.680 --> 00:16:03.440
用权重得分，然后将它们汇总起来，我们在这里定义

00:16:03.440 --> 00:16:07.279
每个得分的权重，我将给出质量和价值得分

00:16:07.279 --> 00:16:11.040
权重为2，大小得分为权重1。

00:16:11.040 --> 00:16:14.880
请注意，我们将在Alpha模型中将这些分数标准化，因此

00:16:14.880 --> 00:16:17.519
这些权重之间的关系很重要

00:16:17.519 --> 00:16:22.959
不是实际值本身，所以2 2和1等于0.4

00:16:22.959 --> 00:16:29.120
 0.4和0.2的权重意味着质量和价值得分具有

00:16:29.120 --> 00:16:34.480
现在剩下的对总分的影响比总分的影响大

00:16:34.480 --> 00:16:37.440
要做的是添加实际的Alpha模型

00:16:37.440 --> 00:16:42.880
完成自我点添加阿尔法在这里，我将提交一个实例

00:16:42.880 --> 00:16:47.199
基本因子alpha模型作为构造此模型的参数

00:16:47.199 --> 00:16:50.160
我们需要将参数作为参数传递

00:16:50.160 --> 00:16:54.399
在我们实际使用此Alpha模型之前，尽管我们必须实现它

00:16:54.399 --> 00:17:04.640
为此，我将创建一个新文件并将其命名为alphamodel.pi

00:17:04.640 --> 00:17:08.959
在此文件中，我们将实现基本因子alpha模型类

00:17:08.959 --> 00:17:12.240
要使用此类，我们必须将其导入到主文件中

00:17:12.240 --> 00:17:19.839
从Alpha模型导入基本因子Alpha模型

00:17:21.360 --> 00:17:25.520
在alpha模型文件中，我们将从日期时间导入时间增量，因为我们可能会

00:17:25.520 --> 00:17:28.400
以后需要这个

00:17:28.640 --> 00:17:32.000
因为基本因素alpha模型应该是alpha

00:17:32.000 --> 00:17:37.280
模型，我们想将其声明为alpha模型的子类

00:17:39.200 --> 00:17:44.080
就像在主文件中一样，我们将从实现initialize方法开始

00:17:44.080 --> 00:17:47.919
但是，这次我们将使用实际的类构造函数，而不是

00:17:47.919 --> 00:17:52.400
预定义的初始化方法，称为init构造函数的方法

00:17:52.400 --> 00:18:01.840
当我们在main方法中初始化此类的实例时

00:18:04.240 --> 00:18:08.960
在这里，我们将初始化几个辅助变量，例如self。上个月

00:18:08.960 --> 00:18:12.240
和sales.longs，这是一个包含股票代码的列表

00:18:12.240 --> 00:18:17.520
除了要初始化self.numfine以外，我们还想购买

00:18:17.520 --> 00:18:22.799
对于过去的参数，我们还将self.periods设置为时间字母31。

00:18:22.799 --> 00:18:27.360
这指定了我们要保留每个股票头寸的时间范围

00:18:27.360 --> 00:18:31.520
31的时间差意味着我们要保持每个多头头寸至少一个

00:18:31.520 --> 00:18:34.960
除非风险模型告诉我们否则

00:18:34.960 --> 00:18:37.600
接下来我们也要初始化质量

00:18:37.600 --> 00:18:41.679
值和大小权重，但是在我们执行此操作之前，我们首先要

00:18:41.679 --> 00:18:46.240
对其进行归一化，以使它们的总和等于1。

00:18:46.240 --> 00:18:50.000
我们首先将这三个值保存到列表中，然后对该列表进行规范化

00:18:50.000 --> 00:18:57.840
通过将每个值除以该列表中所有值的总和

00:19:03.200 --> 00:19:06.720
之后，我们可以初始化质量值和尺寸权重

00:19:06.720 --> 00:19:11.840
权重列表的第一个第二和第三个元素

00:19:25.679 --> 00:19:28.960
现在我们已经完成了initialize方法，这意味着我们可以

00:19:28.960 --> 00:19:32.559
最终转到该算法最有趣的部分

00:19:32.559 --> 00:19:36.480
为此，让我快速向您解释一下alpha的不同方法

00:19:36.480 --> 00:19:39.600
首先要进行模型工作，因为我们有不安全感

00:19:39.600 --> 00:19:44.480
更改的方法在以下情况下会自动调用此方法

00:19:44.480 --> 00:19:47.760
从我们的算法中添加或删除了安全性

00:19:47.760 --> 00:19:51.760
因此，当Universe选择模型将新证券添加到其Universe中时

00:19:51.760 --> 00:19:54.799
该方法将自动被调用

00:19:54.799 --> 00:20:00.080
然后我们要用这种方法为每个证券分配一个分数

00:20:00.080 --> 00:20:03.440
除此之外，我们还有更新方法

00:20:03.440 --> 00:20:07.600
每当算法接收到新数据时，都会自动调用此函数

00:20:07.600 --> 00:20:11.679
订阅的交易品种，例如，如果有新的价格数据

00:20:11.679 --> 00:20:14.480
可用于给定库存的更新方法

00:20:14.480 --> 00:20:16.960
被称为这是我们要发送的地方

00:20:16.960 --> 00:20:20.640
实际的交易信号，以便投资组合构建模型可以创建

00:20:20.640 --> 00:20:24.400
从他们的投资组合中，我们将首先实施

00:20:24.400 --> 00:20:28.640
不安全性更改方法我们在这里要做的第一件事是创建一个

00:20:28.640 --> 00:20:32.840
称为添加的列表，其中保存了所有已添加的安全性

00:20:32.840 --> 00:20:35.840
对象

00:20:36.240 --> 00:20:40.320
下一步是计算这些产品的质量值和尺寸分数

00:20:40.320 --> 00:20:43.360
证券，我们将以另一种方式进行

00:20:43.360 --> 00:20:49.120
我会打电话给分数，我们将在几秒钟内实现

00:20:49.120 --> 00:20:51.760
首先让我们了解一下这种计分方法

00:20:51.760 --> 00:20:55.039
将被称为我们希望能够计算分数

00:20:55.039 --> 00:21:03.840
质量值和尺寸指标，这就是为什么我们必须保持其通用性

00:21:05.679 --> 00:21:09.360
为此，学校方法需要两个论点

00:21:09.360 --> 00:21:13.360
第一个参数是证券列表，这将被添加

00:21:13.360 --> 00:21:17.840
证券清单

00:21:20.080 --> 00:21:23.280
下一个参数要复杂一点

00:21:23.280 --> 00:21:26.799
这是一个元组列表，每个元组包含三个元素

00:21:26.799 --> 00:21:31.039
第一个元素是lambda函数，该函数将符号映射到基本

00:21:31.039 --> 00:21:35.280
价值，例如毛利率或市值以及第二个要素

00:21:35.280 --> 00:21:38.000
元组是一个布尔值，它指定我们是否

00:21:38.000 --> 00:21:41.600
想要根据基本价值逆转定购证券

00:21:41.600 --> 00:21:46.240
例如，是否不反转资产的深度

00:21:46.240 --> 00:21:50.240
我们更喜欢价格较低的股票，而我们更喜欢价格较高的股票

00:21:50.240 --> 00:21:53.360
毛利润率就是这个布尔值的原因

00:21:53.360 --> 00:21:59.840
保证金是正确的，但债务对资产来说却是正确的

00:22:05.600 --> 00:22:09.840
元组的第三个元素是一个数字，用于指定该元素的权重

00:22:09.840 --> 00:22:13.440
例如，质量得分的基本值

00:22:13.440 --> 00:22:18.240
看一下毛利率快速比率和债务资产比率

00:22:18.240 --> 00:22:22.640
值得到自己的权重，最简单的加权将等于

00:22:22.640 --> 00:22:27.039
一个，但您也可以赋予某些因素比其他因素更多的权重

00:22:27.039 --> 00:22:30.720
提交的权重将在scores方法中进行归一化，这就是为什么

00:22:30.720 --> 00:22:34.559
实际值与不同之间的关系无关紧要

00:22:34.559 --> 00:22:38.320
例如，我们给出的价值得分的权重

00:22:38.320 --> 00:22:42.559
每股账面价值的权重为0.5，另外两个

00:22:42.559 --> 00:22:47.039
权重为0.25，表示每股账面价值

00:22:47.039 --> 00:22:49.520
对价值排名有两倍的影响

00:22:49.520 --> 00:22:55.840
作为现金收益或收益率

00:23:12.640 --> 00:23:16.480
在我们可以实际使用scores方法之前，尽管我们必须实现它

00:23:16.480 --> 00:23:23.760
因此，在继续使用不安全更改的方法之前，请先执行此操作

00:23:23.760 --> 00:23:27.679
就像我刚才说的那样，此方法需要两个参数，首先是证券列表

00:23:27.679 --> 00:23:31.520
它们保存在添加的变量和包含三个元素的元组列表中

00:23:31.520 --> 00:23:35.679
每个此列表都保存到基本列表中

00:23:35.679 --> 00:23:39.919
我们要在此方法中做的第一件事是保存此列表的长度

00:23:39.919 --> 00:23:43.600
到一个辅助变量中，这个列表的长度就是

00:23:43.600 --> 00:23:46.240
我们将考虑的各个基本指标

00:23:46.240 --> 00:23:50.960
对于长度为0的得分，我们没有任何基础知识可看

00:23:50.960 --> 00:23:54.159
这就是为什么我们然后只返回一个空字典的原因

00:23:54.159 --> 00:23:57.919
否则，我们将创建更多我们需要的辅助变量

00:23:57.919 --> 00:24:01.520
分数字典的方法是我们将要使用的方法

00:24:01.520 --> 00:24:04.960
保存每个符号的分数

00:24:04.960 --> 00:24:09.600
我们创建了另外两个列表，我们稍后需要

00:24:14.640 --> 00:24:18.559
接下来，我们将归一化为每个基本要素提交的权重

00:24:18.559 --> 00:24:21.200
指标

00:24:31.679 --> 00:24:36.400
我们将这些归一化的权重保存到权重列表中

00:24:39.120 --> 00:24:43.039
之后，我们要创建一个排序列表，按符号对符号进行排序

00:24:43.039 --> 00:24:47.840
基本价值观

00:24:56.400 --> 00:25:00.320
这将为每个基本值创建一个列表，第一个值是那些

00:25:00.320 --> 00:25:04.400
使用最理想的值，我们将这些列表保存在排序依据中

00:25:04.400 --> 00:25:06.640
列表

00:25:07.200 --> 00:25:10.960
现在，最后一步是为每个证券创建并保存分数

00:25:10.960 --> 00:25:16.159
基于这些排序列表，我们通过对

00:25:16.159 --> 00:25:20.080
基本上按列表排序的第一个列表

00:25:20.080 --> 00:25:29.840
只是给我们这个列表中每个符号的索引

00:25:34.240 --> 00:25:38.240
计算给定证券的得分，我们找出在哪个位置

00:25:38.240 --> 00:25:42.159
排序列表的后面越靠后

00:25:42.159 --> 00:25:44.720
排名是

00:25:50.640 --> 00:25:54.400
然后，我们将每个基本因素的排名乘以他们的排名

00:25:54.400 --> 00:25:57.840
权重以获得分数

00:26:06.720 --> 00:26:11.840
当我们得到这个分数时，我们会将其保存到学校的字典中

00:26:13.120 --> 00:26:17.120
对添加的列表中的每个证券完成此操作后，我们将返回分数

00:26:17.120 --> 00:26:21.279
使用这种方法的字典，我们现在可以轻松地

00:26:21.279 --> 00:26:25.760
计算不同基本因素列表的分数

00:26:25.760 --> 00:26:28.799
如果我们现在回到不安全更改方法

00:26:28.799 --> 00:26:33.360
我们已经有了质量值和尺寸分数

00:26:33.360 --> 00:26:37.200
如果您想使用与我在这里使用的基本因素不同的基本因素

00:26:37.200 --> 00:26:40.640
您可以轻松更改它们，而无需更改分数方法

00:26:40.640 --> 00:26:45.200
或Alpha模型中的任何其他内容来更改

00:26:45.200 --> 00:26:48.559
您可以更改第三个价值的个人基本原则

00:26:48.559 --> 00:26:53.360
在基本面列表的元组中，现在剩下的要做的就是

00:26:53.360 --> 00:26:57.279
不安全更改方法是结合质量值和大小

00:26:57.279 --> 00:27:01.679
得分为总分，我们的做法与

00:27:01.679 --> 00:27:06.640
我们已经在scores方法中进行过操作，首先我们将一个空字典保存到

00:27:06.640 --> 00:27:10.240
分数变量，我们将在其中保存总分

00:27:10.240 --> 00:27:14.320
每个符号，然后我们遍历

00:27:14.320 --> 00:27:21.840
质量得分字典

00:27:24.000 --> 00:27:28.240
然后，我们为质量中的每个符号保存质量值和大小得分

00:27:28.240 --> 00:27:35.840
值和大小等级变量

00:27:39.039 --> 00:27:42.720
最后，我们将质量等级乘以质量权重

00:27:42.720 --> 00:27:46.640
按价值权重划分的价值等级，按价值权重划分的大小等级

00:27:46.640 --> 00:27:49.840
然后将它们全部加起来

00:27:55.840 --> 00:28:01.200
然后将结果保存到每个符号的分数字典中

00:28:01.679 --> 00:28:04.720
现在，我们获得了每个符号的总分

00:28:04.720 --> 00:28:08.000
之后，我们将分数从最低到最高排序

00:28:08.000 --> 00:28:12.399
分数越低，我们就越能保存最好的分类证券

00:28:12.399 --> 00:28:17.840
在已排序的库存清单中最差的

00:28:28.399 --> 00:28:32.240
在排序的符号列表中，然后保存前20个证券

00:28:32.240 --> 00:28:35.919
得分最高的股票

00:28:39.840 --> 00:28:44.159
20是我们在initialize方法中分配给self.numfine的值

00:28:44.159 --> 00:28:47.120
在主文件中

00:28:48.000 --> 00:28:51.279
现在剩下要做的就是将每只股票的代码保存在

00:28:51.279 --> 00:28:55.120
排序的符号列表self.longs列表，我们将使用它

00:28:55.120 --> 00:28:59.840
我们的交易信号

00:29:02.799 --> 00:29:06.320
在继续进行更新方法之前，我们也想登录

00:29:06.320 --> 00:29:09.760
买入名单中的每个符号和分数，以便我们可以实际查看

00:29:09.760 --> 00:29:16.159
在实时交易中分配分数，我们可以做到这一点

00:29:24.840 --> 00:29:27.840
algorithm.log

00:29:33.120 --> 00:29:37.120
这样，我们现在就完成了不安全更改方法

00:29:37.120 --> 00:29:41.600
现在我们只需要实现update方法，然后我们就完成了

00:29:41.600 --> 00:29:46.159
更新方法是发出实际交易信号的地方

00:29:46.159 --> 00:29:50.240
但是我们只希望每月发送一次交易信号

00:29:50.240 --> 00:29:54.320
这就是为什么我们首先使用上个月的变量来测试是否应该发送

00:29:54.320 --> 00:29:57.440
新的贸易信号

00:29:59.440 --> 00:30:04.799
如果需要重新平衡，我们将更新上个月的变量

00:30:07.120 --> 00:30:10.480
然后我们创建一个名为见解的空列表

00:30:10.480 --> 00:30:13.840
这是将保存实际交易信号的列表，称为

00:30:13.840 --> 00:30:19.840
内部对象，update方法必须返回内部对象的列表，以便

00:30:19.840 --> 00:30:24.080
投资组合构建模型可以从中构建投资组合，但是

00:30:24.080 --> 00:30:28.159
进一步了解洞察力如何工作

00:30:28.159 --> 00:30:32.000
在开始开设新仓位之前，我们首先要关闭所有仓位

00:30:32.000 --> 00:30:39.159
渴望实现这一目标的我们一直在迭代

00:30:39.159 --> 00:30:43.679
然后测试每个安全对象的algorithm.portfolio.values

00:30:43.679 --> 00:30:47.840
是投资而不是自我

00:30:49.360 --> 00:30:52.960
如果同时满足这两个条件，我们要发送交易信号

00:30:52.960 --> 00:30:56.480
告诉其他模型我们要平仓

00:30:56.480 --> 00:31:01.440
为此，我们将一个内部对象附加到内部列表中

00:31:01.440 --> 00:31:06.720
为此，让我快速概述一下内部对象的外观

00:31:13.919 --> 00:31:17.600
一个标准的内部对象构造函数需要八个参数

00:31:17.600 --> 00:31:22.399
其中一些具有默认值，第一个参数是安全符号

00:31:22.399 --> 00:31:26.399
以便其他模型了解此洞察力针对的安全性

00:31:26.399 --> 00:31:29.519
下一个参数是时间范围，这样很清楚

00:31:29.519 --> 00:31:32.640
此洞察力在哪个时间范围内有效

00:31:32.640 --> 00:31:36.320
如果没有其他说明，头寸将自动平仓

00:31:36.320 --> 00:31:40.320
时间过去后，我们将使用self.period

00:31:40.320 --> 00:31:45.519
下一次初始化为31天，我们必须指定

00:31:45.519 --> 00:31:48.320
大多数时候您可能需要洞察力

00:31:48.320 --> 00:31:52.399
内部价格，但您也可以提交其他信息的洞察力，例如

00:31:52.399 --> 00:31:56.399
波动性，因为价格洞察力更大

00:31:56.399 --> 00:32:00.679
常见的，也可以使用此方法在内部创建价格

00:32:00.679 --> 00:32:06.559
inside.price，其中包含一些参数，但我们将在此处使用更通用的版本

00:32:06.559 --> 00:32:09.600
第四个论点是内部的方向

00:32:09.600 --> 00:32:14.080
在这里，您可以指定给定安全性的预测方向，因为

00:32:14.080 --> 00:32:16.720
我们想平仓任何潜在的未平仓头寸

00:32:16.720 --> 00:32:22.159
我们将在direction.flat内部使用，接下来的四个参数是可选的，

00:32:22.159 --> 00:32:26.240
具有默认值none的默认值，它们是幅度置信度来源

00:32:26.240 --> 00:32:29.760
内部的型号和重量取决于产品组合

00:32:29.760 --> 00:32:32.559
这些值可以对构造模型产生影响

00:32:32.559 --> 00:32:36.159
构建的投资组合，但由于我们只想关闭一些

00:32:36.159 --> 00:32:40.399
开仓我们不会在这里传递任何值

00:32:40.399 --> 00:32:43.840
现在我们已经成功平仓了所有不需要的未平仓头寸

00:32:43.840 --> 00:32:47.760
这意味着我们现在可以最终提交有关证券的购买见解

00:32:47.760 --> 00:32:53.360
在self.longs列表中这样做，我们首先保存self.longs列表的长度

00:32:53.360 --> 00:32:57.760
到可变长度，然后我们从0迭代到

00:32:57.760 --> 00:33:00.080
长度

00:33:00.320 --> 00:33:03.840
然后，对于每只眼睛，我们在其中附加一个购买项

00:33:03.840 --> 00:33:08.880
长符号列表中的元素到我们的内部列表中

00:33:09.519 --> 00:33:13.039
再一次，我们将使用self.period作为第二个参数

00:33:13.039 --> 00:33:17.039
和inside.price为第三

00:33:17.679 --> 00:33:21.200
由于我们对多头头寸感兴趣，因此我们提交了看涨的见解

00:33:21.200 --> 00:33:27.039
与direction.up不同，之前我们不想传递值

00:33:27.039 --> 00:33:33.279
该算法内部对象的置信度和权重参数

00:33:33.279 --> 00:33:36.720
我们实际上并不需要置信度值，但是如果您选择其他方法

00:33:36.720 --> 00:33:41.840
投资组合构建模型可能对我们需要的有用

00:33:41.840 --> 00:33:44.799
但是是最后一个参数的值

00:33:44.799 --> 00:33:49.200
是main的initialize方法中给定内部的权重

00:33:49.200 --> 00:33:52.399
算法类，我们将投资组合模型设置为内部

00:33:52.399 --> 00:33:56.240
加权投资组合模型

00:33:56.240 --> 00:34:00.000
每个提交的见解的权重参数分配

00:34:00.000 --> 00:34:03.440
因此，与其他见解相比，给定见解的权重更大

00:34:03.440 --> 00:34:06.720
该头寸将获得更多的资本

00:34:06.720 --> 00:34:10.399
由于较长的符号列表是按从最佳到最差的顺序排序

00:34:10.399 --> 00:34:13.919
我们希望为那些得分最高的证券分配更多的资金

00:34:13.919 --> 00:34:18.079
而那些成绩较差的人不希望等待时间有所不同

00:34:18.079 --> 00:34:21.359
线性的，我们将使用一个简单的二次方

00:34:21.359 --> 00:34:26.879
方程来计算重量来完成这一任务，我们简单地减去i

00:34:26.879 --> 00:34:30.000
从长度变量定义为

00:34:30.000 --> 00:34:35.760
这个长长的符号列表，然后我们平方这个值，将

00:34:35.760 --> 00:34:39.919
表示在长符号列表中得分最低的股票将始终

00:34:39.919 --> 00:34:42.879
权重为1，而得分最高的股票

00:34:42.879 --> 00:34:47.440
长度的权重将平方这些值将自动

00:34:47.440 --> 00:34:51.839
在投资组合构建模型中进行归一化

00:34:52.399 --> 00:34:55.679
现在剩下要做的就是返回此见解列表

00:34:55.679 --> 00:34:59.200
我们已经完成了实现Alpha模型的工作

00:34:59.200 --> 00:35:03.200
在我们最终开始测试该算法之前，我有一件非常小的事情

00:35:03.200 --> 00:35:07.599
想要添加到主文件以向您展示如何创建自定义图

00:35:07.599 --> 00:35:10.960
让我们快速创建一种绘制未结头寸数量的方法

00:35:10.960 --> 00:35:14.480
在投资组合中，我们将创建一个名为

00:35:14.480 --> 00:35:17.760
在其中绘图，我们通过调用创建自定义绘图

00:35:17.760 --> 00:35:21.440
self.plot这需要三个参数，第一个是

00:35:21.440 --> 00:35:24.960
要在第二个图表上绘制的图表的名称是实际的名称

00:35:24.960 --> 00:35:31.839
在此图表上绘制，最后是要绘制的数据

00:35:33.440 --> 00:35:37.920
要绘制未平仓头寸的数量，我们使用清单的长度和所有未平仓头寸

00:35:37.920 --> 00:35:40.560
职位

00:35:42.079 --> 00:35:46.000
现在我们要做的就是安排此方法，以便定期调用

00:35:46.000 --> 00:35:49.359
根据我们可以做到这一点，而不是初始化

00:35:49.359 --> 00:35:53.680
self.schedule的帮助下的方法

00:35:54.320 --> 00:35:58.880
self.schedule首先接受三个参数，我们必须指定

00:35:58.880 --> 00:36:04.240
您想安排第二个参数指定日期的日期

00:36:04.240 --> 00:36:06.640
时间

00:36:07.119 --> 00:36:12.640
最后一个参数告诉算法您要安排什么

00:36:12.640 --> 00:36:16.160
我们想将self.plotting安排在上午10点30分

00:36:16.160 --> 00:36:20.800
每个星期一的确切日期和时间并不重要，我们只想要它

00:36:20.800 --> 00:36:25.839
每周冷却一次，现在我们终于可以开始回测

00:36:25.839 --> 00:36:29.119
为此，我们只需单击

00:36:29.119 --> 00:36:32.800
右上角的“返回测试”按钮，则您必须

00:36:32.800 --> 00:36:36.960
等待回测完成，具体取决于时间范围的分辨率

00:36:36.960 --> 00:36:40.800
和算法的效率，这可能需要几秒钟的时间，最高可达20

00:36:40.800 --> 00:36:44.640
分钟甚至更长的时间，但是这种算法不应该花时间

00:36:44.640 --> 00:36:48.800
结束测试后，超过两分钟的时间a

00:36:48.800 --> 00:36:52.880
将会生成带有大量统计数据和图表的性能概览

00:36:52.880 --> 00:36:56.480
在这里，重要的是要了解这些结果是来自

00:36:56.480 --> 00:37:00.800
您选择仅对算法进行回测的确切时间

00:37:00.800 --> 00:37:03.440
因为这些结果在一定时期内都很好

00:37:03.440 --> 00:37:08.240
并不意味着他们会胜过其他交易或真实交易

00:37:08.240 --> 00:37:11.920
在右上角，您可以选择要显示的图表

00:37:11.920 --> 00:37:15.839
持仓图是我们创建的用于绘制未平仓数量的自定义图

00:37:15.839 --> 00:37:19.520
在任何给定时间的头寸，其他图表将自动

00:37:19.520 --> 00:37:23.359
除了看到一些常规性能外，还为您生成了

00:37:23.359 --> 00:37:26.400
顶部的指标，您还可以在下面查看净值图表

00:37:26.400 --> 00:37:29.440
如果您进一步向下滚动，也可以

00:37:29.440 --> 00:37:33.359
查看其他指标最有趣的指标之一是

00:37:33.359 --> 00:37:36.720
尖锐比率，该比率基本上是对

00:37:36.720 --> 00:37:41.599
风险调整收益率，该值越高，效果越好

00:37:41.599 --> 00:37:45.200
我不想花太多时间分析这些结果，因为那不是

00:37:45.200 --> 00:37:48.160
这部影片的重点，但如果您想更详细

00:37:48.160 --> 00:37:50.960
评估交易策略的细目

00:37:50.960 --> 00:37:54.560
确保查看有关该主题的视频

00:37:54.560 --> 00:37:58.079
除了这些指标之外，您还可以选择查看所有订单

00:37:58.079 --> 00:38:01.200
该算法发送或查看该算法的日志

00:38:01.200 --> 00:38:04.400
在这里，当我们单击“日志”选项卡时，我们可以看到

00:38:04.400 --> 00:38:07.920
符号和得分的列表，因为这是我们登录的

00:38:07.920 --> 00:38:11.359
alpha模型的不安全更改方法

00:38:11.359 --> 00:38:15.680
但是现在让我们回到算法，而不是向您展示结果

00:38:15.680 --> 00:38:18.480
在特定的时间范围内还有一些非常有用的

00:38:18.480 --> 00:38:23.200
首先要向您展示的功能我想演示为什么

00:38:23.200 --> 00:38:28.079
算法框架是如此有用，现在该算法的风险模型为

00:38:28.079 --> 00:38:32.320
最大跌幅模型，这意味着如果

00:38:32.320 --> 00:38:36.079
如果我们想将其更改为

00:38:36.079 --> 00:38:40.400
交易止损风险模型而不是固定风险模型，我们可以通过以下方式轻松实现

00:38:40.400 --> 00:38:43.200
更改每个证券的最大回撤百分比

00:38:43.200 --> 00:38:47.839
交易止损风险管理模型这一微小的变化

00:38:47.839 --> 00:38:53.280
除了跟踪止损风险模型外，还可以更改整个风险模型

00:38:53.280 --> 00:38:56.800
也可以选择其他预定义的风险模型之一或创建您的

00:38:56.800 --> 00:38:59.760
拥有您可以为您做完全相同的事情

00:38:59.760 --> 00:39:04.320
投资组合构建模型执行模型或其他模型

00:39:04.320 --> 00:39:08.160
否则可能需要重组整个算法的更改

00:39:08.160 --> 00:39:12.400
现在，使用算法框架时只需更改一行即可完成

00:39:12.400 --> 00:39:15.760
我知道算法框架起初可能会有些混乱

00:39:15.760 --> 00:39:19.520
这也是为什么我建议从不使用的经典算法开始的原因

00:39:19.520 --> 00:39:21.599
它，但是一旦你理解了正常

00:39:21.599 --> 00:39:24.000
算法切换到算法框架

00:39:24.000 --> 00:39:29.520
肯定有它的优点，接下来让我向您展示一个更神奇的东西

00:39:29.520 --> 00:39:32.720
最近添加到Quant Connect平台的功能

00:39:32.720 --> 00:39:37.760
即参数优化，您可能已经注意到这些黄色的虚线

00:39:37.760 --> 00:39:40.640
在我的代码中，这些指示了

00:39:40.640 --> 00:39:46.240
算法可以在您的个人资料设置下打开或关闭此指示

00:39:46.240 --> 00:39:50.800
参数是变量，例如质量值和尺寸权重

00:39:50.800 --> 00:39:54.640
更改值（例如质量权重）可能会对

00:39:54.640 --> 00:39:58.400
您算法的性能为每个算法找到正确的值

00:39:58.400 --> 00:40:03.280
参数是定量交易界的巨大挑战

00:40:03.280 --> 00:40:06.560
一般而言，最好具有相对较少的参数

00:40:06.560 --> 00:40:10.640
而不是拥有太多更多的参数，您将更容易

00:40:10.640 --> 00:40:13.440
将您的算法过度拟合到特定数据集

00:40:13.440 --> 00:40:17.359
这就是为什么通常可以自动适应的动态模型更好的原因

00:40:17.359 --> 00:40:21.599
而不是使用固定数字来最好地了解参数以及如何

00:40:21.599 --> 00:40:24.079
优化它们，让我们看一下止损风险

00:40:24.079 --> 00:40:27.520
一开始我设定了止损风险

00:40:27.520 --> 00:40:32.880
变量0.1或10％，我从没真正给过我一个理由

00:40:32.880 --> 00:40:36.400
做到了，我真的不能给你一个很好的理由，为什么我选择了10

00:40:36.400 --> 00:40:42.480
超过15％或其他一些值来优化参数的一种方法是

00:40:42.480 --> 00:40:45.760
看一堆不同的背部测试，并比较

00:40:45.760 --> 00:40:48.880
参数值不同的算法

00:40:48.880 --> 00:40:52.960
可悲的是，如果您有很多参数，很难可靠地执行此操作

00:40:52.960 --> 00:40:58.480
由于搜索空间变得巨大，因此该解决方案并不完美

00:40:58.480 --> 00:41:02.160
由于它可能导致过度拟合，因此在优化

00:41:02.160 --> 00:41:06.560
算法的参数让我向您展示quantconnect如何允许

00:41:06.560 --> 00:41:09.760
您可以使用停止示例来优化算法的参数

00:41:09.760 --> 00:41:13.520
首先，我们需要正式定义风险参数

00:41:13.520 --> 00:41:19.359
这个变量是一个参数，我们可以使用self.getperimetry

00:41:19.359 --> 00:41:23.200
此方法获取参数的值并将其设置为止损风险

00:41:23.200 --> 00:41:26.800
但是，如果找不到get参数，则该变量

00:41:26.800 --> 00:41:30.640
该参数的值，我们仍然希望算法能够正常工作

00:41:30.640 --> 00:41:34.960
这就是为什么我们测试止损风险是否为零，以及是否将其设置为默认风险的原因

00:41:34.960 --> 00:41:39.440
值，例如10％现在，我们可以通过添加

00:41:39.440 --> 00:41:43.359
将其移至此处左下方的算法栏中

00:41:43.359 --> 00:41:46.720
您只需要输入止损风险，这就是我们在get中指定的名称

00:41:46.720 --> 00:41:50.640
参数方法，接下来我们可以单击编辑符号进行设置

00:41:50.640 --> 00:41:54.800
达到某个值（例如10％）的原因

00:41:54.800 --> 00:41:57.359
有用的是，它允许您更改您的

00:41:57.359 --> 00:42:01.359
参数而不实际编辑算法的源代码

00:42:01.359 --> 00:42:04.400
这是测试和实时交易的绝佳功能

00:42:04.400 --> 00:42:07.760
因为您可能不总是想要编辑实际的代码

00:42:07.760 --> 00:42:11.920
现在我们可以单击“回测”按钮旁边的“优化”按钮

00:42:11.920 --> 00:42:16.560
这会打开一个新标签，使我们可以设置优化条件

00:42:16.560 --> 00:42:20.560
目前，网格搜索是唯一的优化策略，这就是我们

00:42:20.560 --> 00:42:24.000
将使用下一个，您可以选择最大化或

00:42:24.000 --> 00:42:28.079
最小化锐利比率年收益概率锐利比率

00:42:28.079 --> 00:42:32.480
或缩水，我们只会最大化锐利比率

00:42:32.480 --> 00:42:36.079
然后我们单击下一步，这使我们可以选择我们想要的参数

00:42:36.079 --> 00:42:39.280
目前，您只能优化两个

00:42:39.280 --> 00:42:42.560
我们想要优化止损风险的参数

00:42:42.560 --> 00:42:46.079
参数作为最小值，我们选择百分之一

00:42:46.079 --> 00:42:51.280
作为最大值，我们进一步增加了25％，将步长更改为

00:42:51.280 --> 00:42:54.079
百分之一（可选），您还可以添加一些

00:42:54.079 --> 00:42:58.880
锐利比率年收益或缩水的约束在这里我们

00:42:58.880 --> 00:43:04.160
再单击一次之后，暂时不会添加任何约束

00:43:04.160 --> 00:43:07.520
我们可以选择一个计算节点以及允许使用的最大节点数

00:43:07.520 --> 00:43:10.800
同时注意，优化功能当前

00:43:10.800 --> 00:43:14.640
并非免费提供，而是您需要支付几美分的费用才能

00:43:14.640 --> 00:43:19.119
美元，取决于回溯测试的数量和计算复杂性

00:43:19.119 --> 00:43:22.640
如您所见，此优化的预计等待时间

00:43:22.640 --> 00:43:25.839
是5分钟，因子数量是25

00:43:25.839 --> 00:43:30.160
估计成本只有30美分

00:43:30.160 --> 00:43:35.760
现在让我单击“优化”，然后跳到完成时

00:43:38.400 --> 00:43:42.800
欢迎回到这里，您可以查看优化结果页面的概述

00:43:42.800 --> 00:43:46.880
此图显示了具有不同值的反向测试的结果

00:43:46.880 --> 00:43:50.480
您可以看到止损风险参数很大

00:43:50.480 --> 00:43:53.359
不同值的性能差异

00:43:53.359 --> 00:43:57.200
在下面，我们可以看到几个散点图，可以帮助您分析

00:43:57.200 --> 00:43:59.839
参数值与

00:43:59.839 --> 00:44:03.440
其他一些性能指标（如果我们向下滚动到此底部）

00:44:03.440 --> 00:44:06.880
网页上，我们可以看到每个袋子测试的更详细的细分

00:44:06.880 --> 00:44:10.000
在这里，我们可以按概率的尖锐比率对回测进行排序

00:44:10.000 --> 00:44:15.359
净利润比率大幅下降和实际参数值

00:44:15.359 --> 00:44:18.800
我会在这里按最佳的比例对它们进行排序

00:44:18.800 --> 00:44:23.119
10实际上是最佳值，锐利比为0.512

00:44:23.119 --> 00:44:27.040
在此时间段内的净利润超过97

00:44:27.040 --> 00:44:31.280
 12似乎是下一个最佳价值，然后是5

00:44:31.280 --> 00:44:35.040
请注意，如果我们看净利润而不是急剧比率，则为12％

00:44:35.040 --> 00:44:38.720
实际上是最好的值，同样是最好的参数

00:44:38.720 --> 00:44:41.119
如果按以下顺序对反向测试进行排序，则值会更改

00:44:41.119 --> 00:44:45.359
其他指标，例如收益率为百分之一的止损风险值

00:44:45.359 --> 00:44:49.359
最低的27跌幅是有道理的，因为这是一个非常

00:44:49.359 --> 00:44:53.040
严格的止损，但是止损值只有一个

00:44:53.040 --> 00:44:56.960
％的人也只能产生不到50％的净回报

00:44:56.960 --> 00:45:01.680
这意味着该回测的尖锐比率实际上是最差的比率之一

00:45:01.680 --> 00:45:05.119
请注意，这是与跟踪止损风险模型有关，而不是与最大风险模型有关。

00:45:05.119 --> 00:45:09.280
除了此处显示的指标外，回撤风险模型

00:45:09.280 --> 00:45:12.960
也可以单击列以选择其他性能指标以查看和

00:45:12.960 --> 00:45:16.000
除了排序，您还可以过滤

00:45:16.000 --> 00:45:20.160
通过过滤器标签中的其他条件进行回测，这尤其可能

00:45:20.160 --> 00:45:22.480
如果您要分析数百甚至是非常有用的信息

00:45:22.480 --> 00:45:26.720
数以千计的细菌在同一时间，但请注意，如果您查看不同的细菌

00:45:26.720 --> 00:45:29.599
时间范围或更改其他一些参数值

00:45:29.599 --> 00:45:34.640
10％可能实际上不再是最佳值

00:45:34.640 --> 00:45:38.240
有关每个回溯测试的更详细视图，您可以单击回溯测试

00:45:38.240 --> 00:45:40.079
命名，这将带您达到标准

00:45:40.079 --> 00:45:45.280
所选回溯测试的回溯视图，除了止损风险参数外

00:45:45.280 --> 00:45:49.119
也可以将此优化功能用于其他参数，例如

00:45:49.119 --> 00:45:53.200
质量值和尺寸权重只是确保不要过度优化您的

00:45:53.200 --> 00:45:56.079
可用回测数据的算法

00:45:56.079 --> 00:46:01.599
更好的回测结果并不一定总能带来更好的实际性能

00:46:01.599 --> 00:46:05.839
说到实盘交易，我通常会遇到很多关于如何生活的问题

00:46:05.839 --> 00:46:08.560
交易算法，让我快速向您展示如何交易

00:46:08.560 --> 00:46:13.040
通过量子连接实时执行的算法，因此您只需单击

00:46:13.040 --> 00:46:16.000
转到优化按钮旁边的实时按钮

00:46:16.000 --> 00:46:19.680
然后，您可以从当前支持的经纪人平台中进行选择

00:46:19.680 --> 00:46:22.960
通过哪个量化连接可以让您当前进行交易

00:46:22.960 --> 00:46:26.800
互动经纪人可能是最受欢迎的选择，但希望更多

00:46:26.800 --> 00:46:31.680
如果您只是想测试算法，将来会添加经纪人

00:46:31.680 --> 00:46:36.640
通过纸面交易，您也可以通过在此处选择纸面交易来做到这一点

00:46:36.640 --> 00:46:40.319
请注意，实时交易算法需要您始终拥有一台服务器

00:46:40.319 --> 00:46:42.319
结点，以便随时准备

00:46:42.319 --> 00:46:46.400
与关联经纪人进行交流，这就是为什么您需要升级帐户的原因

00:46:46.400 --> 00:46:50.640
通过quantconnect进行实时交易的成本大约为30 a

00:46:50.640 --> 00:46:53.839
我认为这是一个合理的价格

00:46:53.839 --> 00:46:57.680
那说我不一定推荐实时交易这个算法

00:46:57.680 --> 00:47:01.760
该视频和算法的目的是向您展示如何开始开发您的

00:47:01.760 --> 00:47:05.440
自己的交易算法，我并不是说这是一个

00:47:05.440 --> 00:47:10.079
特别好的交易算法该算法的一些问题包括

00:47:10.079 --> 00:47:14.240
与市场高度相关，可能导致交易成本过高

00:47:14.240 --> 00:47:19.280
很多参数，如果您想练习算法，还可以使用更多参数

00:47:19.280 --> 00:47:21.839
您可以使用此项目的开发技能

00:47:21.839 --> 00:47:26.640
作为基础，并在其中添加您自己的变更改进和实验

00:47:26.640 --> 00:47:31.280
可能的练习包括与更多动态模型交换一些参数

00:47:31.280 --> 00:47:35.359
尝试其他评级，包括实际股票得分作为见解权重

00:47:35.359 --> 00:47:38.960
用于投资组合建设，改善评分系统

00:47:38.960 --> 00:47:40.960
自己实现其他一些模型

00:47:40.960 --> 00:47:44.960
甚至向alpha模型添加其他组件，例如动量技术

00:47:44.960 --> 00:47:48.640
基于因素，我在说明框中留下了一个链接

00:47:48.640 --> 00:47:52.480
这样您就可以从该视频中克隆整个代码

00:47:52.480 --> 00:47:55.839
如果您喜欢这部影片，我强烈建议您查看其他一些影片

00:47:55.839 --> 00:47:58.079
视频而不是我的算法交易

00:47:58.079 --> 00:48:01.760
明确表示要确保喜欢的播放列表

00:48:01.760 --> 00:48:04.480
按钮订阅并打开通知铃

00:48:04.480 --> 00:48:08.640
想要更多这样的内容，谢谢

00:48:15.319 --> 00:48:18.319
观看

