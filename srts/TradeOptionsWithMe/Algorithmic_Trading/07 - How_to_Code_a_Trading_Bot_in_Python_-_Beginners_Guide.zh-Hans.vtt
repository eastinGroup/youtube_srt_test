WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.160 --> 00:00:04.080
在我的上一个视频中，我问你是否要看我编写交易算法的代码

00:00:04.080 --> 00:00:07.600
在python中从头开始

00:00:07.600 --> 00:00:10.400
看到我这样做，这正是我要做的

00:00:10.400 --> 00:00:13.280
在此视频中创建此交易算法

00:00:13.280 --> 00:00:16.800
我将使用量子连接平台，这是一种出色的算法

00:00:16.800 --> 00:00:19.920
具有许多强大功能的交易平台

00:00:19.920 --> 00:00:23.519
它是免费使用的，所以如果您想一起编码，请确保

00:00:23.519 --> 00:00:26.640
在观看此视频之前快速创建一个免费帐户

00:00:26.640 --> 00:00:30.320
在下面的说明框中有一个链接，上面写着

00:00:30.320 --> 00:00:33.600
让我们开始创建我们的第一个交易机器人

00:00:33.600 --> 00:00:37.040
但是在开始实际执行算法之前，我们必须先

00:00:37.040 --> 00:00:39.920
在概念层面上制定交易策略

00:00:39.920 --> 00:00:43.920
对于本视频，我们将尝试实施简单的突破策略

00:00:43.920 --> 00:00:47.200
该策略将着眼于给定工具的过去高点

00:00:47.200 --> 00:00:51.280
并在价格成功突破时产生买入信号

00:00:51.280 --> 00:00:54.719
购买证券后的前期高点

00:00:54.719 --> 00:00:58.879
发出跟随价格上涨的交易止损

00:00:58.879 --> 00:01:02.960
随着价格继续上涨，我们的止损也会增加，但

00:01:02.960 --> 00:01:05.840
一旦跌幅超过一定数量

00:01:05.840 --> 00:01:09.119
将关闭此交易止损背后的想法

00:01:09.119 --> 00:01:12.320
是为了缩短我们的失败者，让胜利者奔波

00:01:12.320 --> 00:01:16.400
在开发交易算法时，非常重要的一点是

00:01:16.400 --> 00:01:19.600
您想要确定什么时候价格可观

00:01:19.600 --> 00:01:22.159
发生突破对我们来说可能很容易

00:01:22.159 --> 00:01:26.240
但是对于机器人来说，如果我们看看这个，就不一定很明显

00:01:26.240 --> 00:01:28.799
图表有许多潜在的突破水平

00:01:28.799 --> 00:01:32.320
与人类不同，算法不能仅仅使用其判断来确定哪个

00:01:32.320 --> 00:01:35.439
水平是最好的，因此我们必须指定如何

00:01:35.439 --> 00:01:38.159
突破是为我们的工作策略而定义

00:01:38.159 --> 00:01:41.119
最简单的方法是说，我们看看结局

00:01:41.119 --> 00:01:44.960
最近三个月的价格以及最高价是我们的

00:01:44.960 --> 00:01:48.079
突破水平，但这里出现了一个问题，为什么要做

00:01:48.079 --> 00:01:51.520
我们看三个月，为什么不看一个月或一年或更长时间

00:01:51.520 --> 00:01:54.640
这就是为什么我们不只是想选择

00:01:54.640 --> 00:01:57.119
一些随机数作为我们的回溯长度

00:01:57.119 --> 00:02:00.320
相反，我们希望我们的算法能够动态确定多远

00:02:00.320 --> 00:02:05.119
它会根据证券的波动性回顾突破水平

00:02:05.119 --> 00:02:08.560
如果波动率很高，我们希望比过去更深入地回顾过去

00:02:08.560 --> 00:02:11.920
通过这样做，波动率相对较低

00:02:11.920 --> 00:02:14.959
自动适应波动的变化

00:02:14.959 --> 00:02:18.720
因此，快速回顾一下我们将要实施的策略很简单

00:02:18.720 --> 00:02:21.840
动态改变其回顾的突破策略

00:02:21.840 --> 00:02:25.840
进一步，它使用交易止损来防止潜在

00:02:25.840 --> 00:02:29.040
说了这么多的损失，让我们继续前进

00:02:29.040 --> 00:02:33.599
量化连接平台，实际上开始编写一些代码

00:02:33.599 --> 00:02:37.440
在Quant Connect平台中，我们单击创建新算法，该算法将显示

00:02:37.440 --> 00:02:40.720
一堆模块以及基本的模板算法

00:02:40.720 --> 00:02:44.319
这些模块都是算法框架的一部分，它们使您可以

00:02:44.319 --> 00:02:48.239
使用对某些交易有帮助的预构建代码部分

00:02:48.239 --> 00:02:50.640
策略，如果您想了解更多有关

00:02:50.640 --> 00:02:54.319
算法框架，您可以查看我的视频，了解如何进行交易算法

00:02:54.319 --> 00:02:56.879
在此视频中工作，我们将不会使用任何

00:02:56.879 --> 00:03:00.159
这些模块，因为我们的算法非常简单

00:03:00.159 --> 00:03:03.920
默认情况下，您现在将算法看作是quant的扩展

00:03:03.920 --> 00:03:07.519
进一步连接算法类，您将看到初始化

00:03:07.519 --> 00:03:10.800
并在数据方法（如名称）中暗示了初始化

00:03:10.800 --> 00:03:13.519
存在用于初始化各种参数的方法

00:03:13.519 --> 00:03:17.519
变量和其他设置，例如，这是我们可以初始化的地方

00:03:17.519 --> 00:03:21.760
我们的反向测试的起始资金开始日期和结束日期，但还有更多

00:03:21.760 --> 00:03:25.280
在我们执行其他操作之前的一分钟内，让我们导入

00:03:25.280 --> 00:03:28.080
numpy作为np，因为我们以后将需要numpy来

00:03:28.080 --> 00:03:32.480
计算波动率调整后的回溯长度的标准差

00:03:32.480 --> 00:03:35.920
这样做之后，让我们从初始化方法开始

00:03:35.920 --> 00:03:39.200
让我们清除所有内容并从空白方法开始

00:03:39.200 --> 00:03:43.440
首先，我们将设置初始现金余额，这显然仅是为了

00:03:43.440 --> 00:03:46.159
在实际交易中的测试目的，该数字将是

00:03:46.159 --> 00:03:50.640
从您的经纪人的帐户余额中提取的这个示例中，我们仅使用100 000

00:03:50.640 --> 00:03:54.640
作为下一个起始余额，让我们设置开始和结束日期

00:03:54.640 --> 00:03:57.920
对于现在的背部测试，我们做什么都没关系

00:03:57.920 --> 00:04:01.840
在这里选择，只需确保留有足够的数据，这样您就可以

00:04:01.840 --> 00:04:15.840
一些数据来测试您的算法而不会过度拟合

00:04:19.600 --> 00:04:23.520
现在我们将资产添加到我们的算法中，这将是

00:04:23.520 --> 00:04:27.520
我们实际上将使用交易来执行此操作，我们将使用加法

00:04:27.520 --> 00:04:30.639
权益函数的第一个参数是

00:04:30.639 --> 00:04:33.440
我们要添加的净值，第二个参数是

00:04:33.440 --> 00:04:36.960
我们现在将使用每日数据的数据分辨率

00:04:36.960 --> 00:04:40.320
但也可以使用每小时或每分钟的数据

00:04:40.320 --> 00:04:43.440
至于安全性，我们将使用etf间谍

00:04:43.440 --> 00:04:49.360
可以跟踪sp 500指数，但可以随时使用其他证券

00:04:49.360 --> 00:04:52.639
下一步是初始化我们将回顾的天数

00:04:52.639 --> 00:04:56.240
确定突破点，您希望记住我们

00:04:56.240 --> 00:04:58.880
算法将动态更改此回溯长度

00:04:58.880 --> 00:05:02.800
基于波动率的变化，这就是为什么价值不那么重要的原因

00:05:02.800 --> 00:05:06.320
我们选择这里，尽管我们希望我们的愤怒

00:05:06.320 --> 00:05:10.639
动态更改回溯长度，我们还想添加一些约束条件

00:05:10.639 --> 00:05:14.080
不想回头的长度变得太大或太小

00:05:14.080 --> 00:05:18.560
这就是为什么我现在将增加歌剧和下限的原因，我将选择10天作为

00:05:18.560 --> 00:05:21.520
下限和30天上限

00:05:21.520 --> 00:05:23.680
选择不是真的基于任何东西

00:05:23.680 --> 00:05:27.039
因此，如果您愿意的话，绝对可以尝试使用其他值

00:05:27.039 --> 00:05:30.240
我们要初始化的最后两个变量与我们的交易有关

00:05:30.240 --> 00:05:34.160
止损第一变量自点初始止损

00:05:34.160 --> 00:05:36.880
风险表明我们的第一止损有多接近

00:05:36.880 --> 00:05:41.600
将是证券价格，所以0.98意味着我们的第一站

00:05:41.600 --> 00:05:45.600
损失将导致2损失，然后再击中下一个

00:05:45.600 --> 00:05:48.880
可变的自我交易股票风险表明

00:05:48.880 --> 00:05:51.680
关闭我们的交易止损将跟随资产价格

00:05:51.680 --> 00:05:56.400
在这里，我选择0.9，这意味着它将以10的价格进行交易

00:05:56.400 --> 00:06:00.080
我知道这个房间很大，但是我们想给价格足够的空间

00:06:00.080 --> 00:06:04.000
因为否则我们可能会在每次短期逆转时被阻止

00:06:04.000 --> 00:06:09.280
请注意，值0.98和0.9是相当随意的选择，您可以

00:06:09.280 --> 00:06:13.919
如果您愿意的话，一定要对这些变量使用其他值

00:06:13.919 --> 00:06:18.160
接下来，我们快速讨论on数据方法on数据方法称为

00:06:18.160 --> 00:06:22.240
每当您的算法收到新数据时，该方法就可以决定要处理的内容

00:06:22.240 --> 00:06:25.360
处理数据，是否应采取任何措施

00:06:25.360 --> 00:06:28.000
而不是使用on data方法进行任何交易

00:06:28.000 --> 00:06:32.000
我们将创建自己的方法，因为这将给我们带来更大的自由

00:06:32.000 --> 00:06:35.440
但是我们将使用ondata方法创建价格的图

00:06:35.440 --> 00:06:38.560
我们正在交易的证券，因为这为我们提供了基准

00:06:38.560 --> 00:06:43.280
比较我们算法的性能可以通过self.plot完成

00:06:43.280 --> 00:06:46.560
接受三个参数，第一个是图表的名称，

00:06:46.560 --> 00:06:50.479
我们要创建第二个是此图在此图表上的名称

00:06:50.479 --> 00:06:54.160
最后是图表的实际数据，我们将其称为图表

00:06:54.160 --> 00:06:57.840
数据图表和图表仅是我们安全的象征

00:06:57.840 --> 00:07:01.840
在这种情况下，这将是间谍，最后数据将只是我们的

00:07:01.840 --> 00:07:06.319
证券的收盘价现在让我们创建一种方法

00:07:06.319 --> 00:07:10.560
为我们完成所有交易，自此我们将为每个开放的市场命名

00:07:10.560 --> 00:07:17.840
我们希望在每个市场开放后都可以调用它

00:07:20.560 --> 00:07:24.800
为此，我们将不得不在初始化方法中添加最后一件事

00:07:24.800 --> 00:07:28.960
即具有三个参数的功能时间表

00:07:28.960 --> 00:07:32.080
第一个指定了我们的方法在哪几天被调用

00:07:32.080 --> 00:07:45.840
我们希望在我们的证券交易的每一天都可以调用它

00:07:48.080 --> 00:07:51.199
下一个参数指定何时调用我们的方法

00:07:51.199 --> 00:07:59.840
我们希望在证券市场开放20分钟后将其称为

00:08:04.560 --> 00:08:08.319
最后但并非最不重要的一点是，我们指定调用哪个方法，即

00:08:08.319 --> 00:08:13.840
每种市场开放方式

00:08:18.479 --> 00:08:21.919
如果您不确定某个函数接受多少个参数或该函数的类型

00:08:21.919 --> 00:08:24.840
参数是您可以在左上角搜索它

00:08:24.840 --> 00:08:28.879
在角落处，这将带您到文档页面，该页面说明了如何

00:08:28.879 --> 00:08:33.520
一切正常，并经常提供有用的示例

00:08:37.839 --> 00:08:41.599
现在我们已经初始化了一切，让我们实现我们的每个市场开放

00:08:41.599 --> 00:08:44.320
方法首先我们需要确定回溯

00:08:44.320 --> 00:08:47.920
突破所需的时间，我们将看30天

00:08:47.920 --> 00:08:51.040
今天的波动率并将其与相同的值进行比较

00:08:51.040 --> 00:08:54.000
昨天我们将使用此信息进行调整

00:08:54.000 --> 00:08:57.200
为此我们的回溯窗口的长度

00:08:57.200 --> 00:09:01.440
我们首先需要在过去31天内关闭我们的安全流程

00:09:01.440 --> 00:09:04.560
这可以通过调用history方法来完成

00:09:04.560 --> 00:09:07.680
这将返回一个具有高收盘价的数据帧

00:09:07.680 --> 00:09:11.040
低价和开盘价以及每天的交易量

00:09:11.040 --> 00:09:15.839
在过去的31天里，我们仅对收盘价感兴趣

00:09:15.839 --> 00:09:19.519
为了计算波动率，我们采用收盘价的标准偏差

00:09:19.519 --> 00:09:23.920
过去30天内的处理过程，这是我们使用numpy标准的地方

00:09:23.920 --> 00:09:28.880
偏差函数np.std首先我们在当天进行

00:09:28.880 --> 00:09:37.839
那我们就在前一天做

00:09:42.560 --> 00:09:46.399
那么我们通过减去昨天的

00:09:46.399 --> 00:09:51.839
从今天的价值，然后除以今天的价值

00:09:52.880 --> 00:09:56.080
[音乐]

00:10:04.640 --> 00:10:08.399
现在我们将当前回溯长度乘以delta val加一

00:10:08.399 --> 00:10:12.079
这可以确保波动率增加时，我们的回溯时长也会增加

00:10:12.079 --> 00:10:20.240
反之亦然[音乐]

00:10:20.240 --> 00:10:24.800
由于我们的回溯变量是天数，因此必须为整数

00:10:24.800 --> 00:10:29.440
因此我们将结果四舍五入到最接近的整数

00:10:29.680 --> 00:10:33.360
接下来，我们检查结果回溯长度是否在我们之前的范围内

00:10:33.360 --> 00:10:36.399
定义上限和下限（如果不是）

00:10:36.399 --> 00:10:47.839
确定是，否则我们什么都不做

00:11:00.970 --> 00:11:04.019
[音乐]

00:11:04.079 --> 00:11:07.360
下一个任务是检查是否正在发生突破

00:11:07.360 --> 00:11:10.959
为此，我们再次调用历史记录功能以获取所有每日的列表

00:11:10.959 --> 00:11:15.839
在我们的回顾期间内，该时期的价格高点

00:11:28.399 --> 00:11:32.240
我们将此列表保存在变量self.hi中

00:11:32.240 --> 00:11:36.000
在打开任何仓位之前，我们必须检查两个条件

00:11:36.000 --> 00:11:40.000
第一个是我们目前尚未投资，第二个是

00:11:40.000 --> 00:11:44.000
该突破实际上正在发生，以检查我们是否没有投资我们的

00:11:44.000 --> 00:11:47.360
符号已经可以使用证券投资了

00:11:47.360 --> 00:11:50.639
第二个条件可以通过查看最后一个收盘价和

00:11:50.639 --> 00:11:57.839
检查它是否高于我们self.high变量中的最高点

00:12:09.120 --> 00:12:13.360
请注意，由于我们没有删除self.hi列表的最后一个数据点

00:12:13.360 --> 00:12:18.000
想要比较昨天的高点和昨天的收盘价

00:12:18.000 --> 00:12:22.240
如果满足这两个条件，我们想以市场价格购买间谍

00:12:22.240 --> 00:12:26.560
最简单的方法是使用set holdings方法

00:12:26.560 --> 00:12:30.320
持有资产的第一个参数是我们要交易的证券

00:12:30.320 --> 00:12:33.680
第二个参数是我们投资组合中应占的百分比

00:12:33.680 --> 00:12:37.600
分配给该头寸，因为算法不会进行任何交易

00:12:37.600 --> 00:12:42.480
其他证券，我们会将持股比例设为100％

00:12:42.480 --> 00:12:45.720
在继续之前，我们将突破水平保存到变量

00:12:45.720 --> 00:12:54.320
self.breakout级别此外，我们将设置变量

00:12:54.320 --> 00:12:57.620
最高价格到此突破水平

00:12:57.620 --> 00:13:00.840
[音乐]

00:13:04.959 --> 00:13:08.800
我们将在一分钟内使用此变量进行追踪止损

00:13:08.800 --> 00:13:12.079
现在剩下要做的就是实现追踪止损

00:13:12.079 --> 00:13:16.240
交易止损仅在我们已经有未平仓头寸时才相关

00:13:16.240 --> 00:13:20.079
因此，我们首先必须像检查之前一样检查这种情况

00:13:20.079 --> 00:13:24.480
这与自我证券投资

00:13:33.120 --> 00:13:37.440
接下来我们要发送止损，如果我们还没有这样做的话

00:13:37.440 --> 00:13:41.600
因此我们检查是否有任何订单

00:13:41.720 --> 00:13:44.560
self.transactions.getopenorders返回开放的集合

00:13:44.560 --> 00:13:50.000
如果集合为空，则为我们的安全下达命令

00:13:50.000 --> 00:13:53.120
条件得到满足

00:13:53.360 --> 00:13:57.519
在这种情况下，我们使用自点止损市场订单发送止损订单

00:13:57.519 --> 00:14:03.839
这需要三个参数

00:14:04.100 --> 00:14:10.399
[音乐]

00:14:10.800 --> 00:14:14.000
第一个是我们要交易的证券的象征

00:14:14.000 --> 00:14:18.079
第二个是股数，最后一个参数是止损

00:14:18.079 --> 00:14:21.120
在我们的情况下，我们希望为我们的止损设置价格

00:14:21.120 --> 00:14:24.240
整个头寸，这就是为什么我们使用投资组合点

00:14:24.240 --> 00:14:27.120
数量以找出我们拥有多少股份

00:14:27.120 --> 00:14:31.839
请注意，减号表示卖单

00:14:31.920 --> 00:14:36.160
对于止损价格，我们将突破水平乘以自我点初始止损

00:14:36.160 --> 00:14:39.440
我们较早前初始化为0.98的风险

00:14:39.440 --> 00:14:43.360
这给我们带来了大约2％的风险，但请注意，这个数字是

00:14:43.360 --> 00:14:47.279
相对随意的选择，可以轻松更改

00:14:47.279 --> 00:14:51.199
现在我们已经实现了发送实际止损单的代码

00:14:51.199 --> 00:14:54.880
现在所缺少的只是将止损变成尾随的部分

00:14:54.880 --> 00:14:58.480
止损将其变成交易止损

00:14:58.480 --> 00:15:01.920
将我们的止损保存到可变的self.stop市场门票中

00:15:01.920 --> 00:15:05.519
这样我们以后才能使用

00:15:05.680 --> 00:15:10.079
每当我们的证券达到新高时，我们都希望止损也增加

00:15:10.079 --> 00:15:14.240
如果价格没有创出新高，我们不希望我们的止损位移动

00:15:14.240 --> 00:15:27.839
这就是为什么我们使用此if语句来确定是否创出新高的原因

00:15:31.600 --> 00:15:35.040
此外，我们不希望我们的交易止损跌破我们的初始价

00:15:35.040 --> 00:15:37.680
止损价格，因此我们必须始终对此进行测试

00:15:37.680 --> 00:15:41.839
继续前进之前的状况

00:15:46.770 --> 00:15:49.929
[音乐]

00:16:06.880 --> 00:16:10.480
如果满足这两个条件，我们首先将最高价格设置为最新价格

00:16:10.480 --> 00:16:23.839
收盘价，因为这是新的最高价

00:16:26.240 --> 00:16:29.680
然后，我们创建一个更新订单字段对象，并将其保存到变量中

00:16:29.680 --> 00:16:37.839
更新栏位

00:16:44.639 --> 00:16:48.800
我们将使用该对象来更新我们的止损订单价格，以便

00:16:48.800 --> 00:16:52.880
与证券价格一起上涨

00:16:54.800 --> 00:16:58.480
我们通过乘以追踪止损风险水平来计算新价格

00:16:58.480 --> 00:17:05.839
我们以最新收盘价将其初始化为0.9

00:17:10.079 --> 00:17:17.980
然后我们使用update方法更新我们现有的止损订单

00:17:17.980 --> 00:17:23.949
[音乐]

00:17:25.679 --> 00:17:29.760
最后，我们要将此新的止损价打印到控制台，以便我们可以

00:17:29.760 --> 00:17:32.960
每次更新时检查新订单价格

00:17:32.960 --> 00:17:36.760
在这里，我们不能只使用普通的打印功能，而必须使用

00:17:36.760 --> 00:17:41.919
self.debug，它等同于print的量子连接

00:17:45.760 --> 00:17:49.600
在if条件之外，我们还想绘制我们头寸的止损价

00:17:49.600 --> 00:17:54.160
到我们之前创建的数据图表上，这样我们就可以查看

00:17:54.160 --> 00:17:57.520
我们的止损与证券交易价格进行比较

00:17:57.520 --> 00:18:01.520
我们称此为新的止损价以获得必要的止损

00:18:01.520 --> 00:18:04.400
我们使用的数据

00:18:05.799 --> 00:18:15.840
self.stopmarketticket.getwithorderfield.stoprise作为参数

00:18:20.640 --> 00:18:24.160
现在我们已经做到了，我们已经成功编写了我们的第一笔交易

00:18:24.160 --> 00:18:26.960
算法现在剩下要做的就是构建和

00:18:26.960 --> 00:18:30.880
我们指定了回测时间，请在较早的时间进行回测

00:18:30.880 --> 00:18:35.919
从2017年9月到2020年9月，但可以尝试不同的时间

00:18:35.919 --> 00:18:40.400
如果您想对我们的算法进行回测，我们只需

00:18:40.400 --> 00:18:43.840
单击此处的测试按钮，然后我们必须等待后面的

00:18:43.840 --> 00:18:46.720
测试完成

00:18:46.799 --> 00:18:50.640
当回测完成时，将生成性能概述

00:18:50.640 --> 00:18:54.240
在此报告的顶部，您可以看到一些最相关的统计信息

00:18:54.240 --> 00:18:57.600
例如已实现和未实现的收益退还费用

00:18:57.600 --> 00:19:01.200
还有更多，尽管很高兴看到这里有丰厚的利润

00:19:01.200 --> 00:19:04.880
您不应该根据时间来过多权衡这些结果

00:19:04.880 --> 00:19:09.200
您为背部测试选择的镜架这些数字可能会大不相同

00:19:09.200 --> 00:19:12.720
尽管如此，很高兴看到我们的算法成功产生了利润

00:19:12.720 --> 00:19:16.400
在此栏下方的选定时间范围内，我们可以查看

00:19:16.400 --> 00:19:20.160
投资组合的股本图，这是我们快速进行投资的好方法

00:19:20.160 --> 00:19:26.080
看看我们的收益是如何分配的，否则还有其他一些

00:19:26.080 --> 00:19:29.360
图表和指标，在分析算法的

00:19:29.360 --> 00:19:32.720
在右上角的效果中，您可以选择

00:19:32.720 --> 00:19:35.919
应该显示图表，让我们快速查看数据图表

00:19:35.919 --> 00:19:39.679
这是我们为elgo创建的自定义图表

00:19:39.679 --> 00:19:44.000
如您所见，它既显示了间谍的价格，也显示了我们追踪价格

00:19:44.000 --> 00:19:47.679
我认为停止订单是一个很好的方法

00:19:47.679 --> 00:19:53.120
我们的策略在哪些方面表现良好而哪些方面没有

00:19:53.120 --> 00:19:56.960
否则，您可能还会在右侧注意到此研究指南

00:19:56.960 --> 00:20:00.720
这告诉我们我们多久回测一次算法有多少个参数

00:20:00.720 --> 00:20:03.360
它有，我们花了多少时间

00:20:03.360 --> 00:20:06.960
这些指标可以为您指明算法过度拟合的方式

00:20:06.960 --> 00:20:11.200
总体上讲，潜在的原因是更少的反向测试和参数

00:20:11.200 --> 00:20:14.640
比该算法中的许多示例更好

00:20:14.640 --> 00:20:18.000
参数是我们回溯长度的操作数下限

00:20:18.000 --> 00:20:22.640
或我们的止损的风险百分比，而不是一些任意数字

00:20:22.640 --> 00:20:26.159
您可以采用一种更动态的方法来计算算法

00:20:26.159 --> 00:20:30.080
自己的最优值，例如自适应和动态算法

00:20:30.080 --> 00:20:32.320
通常不太适合过度拟合

00:20:32.320 --> 00:20:35.840
因为它可以适应不断变化的市场条件

00:20:35.840 --> 00:20:39.440
如果您进一步向下滚动，我们还会概述其他一些有用的信息

00:20:39.440 --> 00:20:42.000
指标，我们可以看到我们的算法

00:20:42.000 --> 00:20:46.000
在这三年中有9笔交易的获胜率是50％，但

00:20:46.000 --> 00:20:48.000
平均胜利比平均更大

00:20:48.000 --> 00:20:52.480
损失是一个非常有用的指标，可以用来衡量

00:20:52.480 --> 00:20:54.880
回报与承担的风险相比

00:20:54.880 --> 00:20:59.280
这个比率越高，对我们的算法越好，

00:20:59.280 --> 00:21:03.600
选择的时间范围大约是1，还算不错

00:21:03.600 --> 00:21:07.679
但我想再次强调，所有这些指标仅适用于

00:21:07.679 --> 00:21:12.000
我们选择对它们进行回测的时期可能会大不相同，并且

00:21:12.000 --> 00:21:15.600
在其他时间段内更糟

00:21:15.679 --> 00:21:19.440
最后，您可以点击页面底部的控制台以查看

00:21:19.440 --> 00:21:22.559
如果您还记得我们印制的算法，则印有算法

00:21:22.559 --> 00:21:26.480
每次更新价格时其交易止损的止损价

00:21:26.480 --> 00:21:31.280
如您所见，在进行反向测试时，所有这些价格都可以在此处看到

00:21:31.280 --> 00:21:34.799
似乎太有帮助了，但是在修复错误或进行实时交易时

00:21:34.799 --> 00:21:40.240
有时将某些内容打印到控制台可能非常方便

00:21:41.039 --> 00:21:44.240
在结束本视频之前，我想向您介绍如何成为一名

00:21:44.240 --> 00:21:47.679
算法交易员自己，我真的希望这段视频能给您带来

00:21:47.679 --> 00:21:51.520
很好的算法开发过程概述，但我不期望

00:21:51.520 --> 00:21:54.799
您无需任何帮助即可轻松编写自己的算法

00:21:54.799 --> 00:21:58.720
观看了一个视频后，如果这是您的期望，那么您就可以自己进行设置

00:21:58.720 --> 00:22:01.840
就像编码和其他大多数人一样令人失望

00:22:01.840 --> 00:22:06.960
技巧变得更好的最好方法是自己练习

00:22:06.960 --> 00:22:10.720
在提供出色的免费新手训练营之前，还没有使用过Quantum Connect

00:22:10.720 --> 00:22:13.200
通过一系列其他交易算法指导您

00:22:13.200 --> 00:22:16.640
在我看来，这是一种深入了解算法交易的好方法

00:22:16.640 --> 00:22:21.360
和Quant Connect平台（如果您已经知道如何使用Python进行编码）

00:22:21.360 --> 00:22:24.720
否则，您可以尝试提出非常简单的策略构想

00:22:24.720 --> 00:22:28.400
然后尝试在Quantconnect文档的帮助下实施它们

00:22:28.400 --> 00:22:33.120
社区帖子以及更多（如果需要），甚至可以复制我的算法并尝试

00:22:33.120 --> 00:22:36.000
改善它可以改进的几个方面

00:22:36.000 --> 00:22:39.919
将是添加动态头寸规模，而不是仅仅添加大量股票

00:22:39.919 --> 00:22:43.440
让它变得更加活跃，或者您可以尝试使其更具活力

00:22:43.440 --> 00:22:46.559
通过用其他模型替换参数

00:22:46.559 --> 00:22:49.760
通常，如果您想尝试使用本视频中的算法

00:22:49.760 --> 00:22:53.520
在下面的说明框中有一个链接，可让您复制代码

00:22:53.520 --> 00:22:56.880
我只是不建议使用此算法进行实时交易，因为它是

00:22:56.880 --> 00:22:59.760
没有很好的抛光也没有很好的研究

00:22:59.760 --> 00:23:03.120
该算法的主要目的只是向您介绍

00:23:03.120 --> 00:23:06.799
算法交易和QuantConnect平台

00:23:06.799 --> 00:23:10.400
话虽如此，我真的希望您喜欢这个视频并学到一些东西

00:23:10.400 --> 00:23:12.880
如果您要我在其中创建更多视频，则为新

00:23:12.880 --> 00:23:15.760
我开发并实现了像这样的交易算法

00:23:15.760 --> 00:23:19.679
一定喜欢我的影片并在下方留言，让我知道

00:23:19.679 --> 00:23:23.600
否则，请确保订阅并打开通知铃以获取更多信息

00:23:23.600 --> 00:23:34.000
像这样的内容感谢收看

