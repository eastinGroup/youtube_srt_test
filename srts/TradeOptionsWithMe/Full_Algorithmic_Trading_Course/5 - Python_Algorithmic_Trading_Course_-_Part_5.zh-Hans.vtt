WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.560 --> 00:00:04.160
欢迎观看我的算法交易视频课程的第五个视频，该视频使用

00:00:04.160 --> 00:00:08.320
python和quantconnect平台，如果您是本系列的新手，我建议

00:00:08.320 --> 00:00:12.000
首先观看之前的视频，然后继续此视频

00:00:12.000 --> 00:00:16.320
在今天的视频课中，我们将继续更深入地探索

00:00:16.320 --> 00:00:20.240
更具体地连接api，我们将深入探讨

00:00:20.240 --> 00:00:23.760
处理各种贸易订单以及如何利用

00:00:23.760 --> 00:00:27.119
Quantum Connect提供的调试和日志记录工具

00:00:27.119 --> 00:00:31.279
为此，我们将再次创建一个相对简单的交易机器人

00:00:31.279 --> 00:00:35.280
为了确保您从学习中获得最大收益，请务必进行编码

00:00:35.280 --> 00:00:38.480
如果您尚未创建免费的Quantconnect帐户，则可以这样做

00:00:38.480 --> 00:00:42.719
使用下面描述框中的链接，但在我们进入该操作之前，

00:00:42.719 --> 00:00:46.480
开始实际编码此交易舱，让我们首先探讨quantconnect

00:00:46.480 --> 00:00:49.600
在概念上处理贸易订单

00:00:49.600 --> 00:00:53.199
为此，我们首先来看一下定单的概念

00:00:53.199 --> 00:00:57.760
订单是创建任何类型的订单后获得的对象

00:00:57.760 --> 00:01:01.359
它用于跟踪访问和编辑给定的顺序

00:01:01.359 --> 00:01:05.199
您需要订单凭单对象而不是仅用于对象的原因

00:01:05.199 --> 00:01:08.799
订单本身就是订单是异步的

00:01:08.799 --> 00:01:12.640
意味着首先需要请求任何可能的更新，并且存在

00:01:12.640 --> 00:01:17.200
如果您发送限价单，则不能保证他们会通过

00:01:17.200 --> 00:01:20.640
100股苹果，然后决定要取消

00:01:20.640 --> 00:01:25.280
或几分钟后更新此订单，则只有在该订单尚未更新时，您才能这样做

00:01:25.280 --> 00:01:29.280
尚未填充一些最有趣的属性

00:01:29.280 --> 00:01:34.159
票证对象的状态是其状态订单ID符号

00:01:34.159 --> 00:01:38.320
数量数量填充的平均填充价格和订单类型

00:01:38.320 --> 00:01:42.479
但是，其中的更多内容现在让我们先来看一下如何

00:01:42.479 --> 00:01:46.720
实际下订单，从而首先创建订单凭单

00:01:46.720 --> 00:01:50.799
Quantconnect支持五种不同的订单类型，我们将逐一介绍

00:01:50.799 --> 00:01:53.920
现在第一个最简单的订单类型是

00:01:53.920 --> 00:01:57.680
标准市场订单首先要填写市场订单

00:01:57.680 --> 00:02:02.320
可用价格，并且可以使用self.market订单方法将其发送

00:02:02.320 --> 00:02:06.320
qc算法类save.market的订单

00:02:06.320 --> 00:02:10.479
接受两个必需的参数，第一个是您要发送的符号

00:02:10.479 --> 00:02:14.000
市场订单，第二个是订单数量

00:02:14.000 --> 00:02:18.879
所以50股特斯拉的市价定单看起来像这样

00:02:18.879 --> 00:02:22.239
请注意，此处通常最好使用符号对象而不是

00:02:22.239 --> 00:02:26.000
股票代码，但在大多数情况下两者都可以使用

00:02:26.000 --> 00:02:30.000
由于市场订单通常会立即失效，因此您无法真正更新它们

00:02:30.000 --> 00:02:34.319
在发送它们以使事情变得尽可能逼真之后，quantconnect会这样做

00:02:34.319 --> 00:02:37.680
点差账户，这意味着买单在

00:02:37.680 --> 00:02:42.239
要价和卖单按买入价成交

00:02:42.239 --> 00:02:45.920
默认情况下，市场定单方法是同步的，这意味着您的

00:02:45.920 --> 00:02:50.239
算法将最多等待5秒钟，直到订单字段出现，然后继续操作

00:02:50.239 --> 00:02:54.160
到下一行代码，也可以对此进行自定义

00:02:54.160 --> 00:02:57.360
超时延迟

00:02:58.120 --> 00:03:02.560
self.transactions.marketordefilltimeout作为第三个可选参数，您可以

00:03:02.560 --> 00:03:06.480
还指定是否应异步发送市价单

00:03:06.480 --> 00:03:10.400
在此处传递true表示您的算法不会等到继续

00:03:10.400 --> 00:03:13.680
转到下一行代码，如果您要进行交易，这可能会很有用

00:03:13.680 --> 00:03:18.000
大订单量发送大量订单或在流动性差的市场中交易，并且不要

00:03:18.000 --> 00:03:22.400
希望您的算法始终等待整个市场订单被填满

00:03:22.400 --> 00:03:26.159
该匹配器的市价定单方法或任何其他音频类型方法

00:03:26.159 --> 00:03:30.560
将返回订单凭单对象以保存相应的凭单

00:03:30.560 --> 00:03:35.519
必须将输出保存到变量中，下一个订单类型是限价订单

00:03:35.519 --> 00:03:39.280
它允许您指定要执行的订单价格

00:03:39.280 --> 00:03:42.560
限价订单通常需要更长的时间才能完成

00:03:42.560 --> 00:03:44.480
甚至有时甚至无法满足

00:03:44.480 --> 00:03:48.560
除了反面之外，所有其他功能都使您可以获得比入场和出场价格更好的价格

00:03:48.560 --> 00:03:51.760
市场订单，您可以通过发送限价单

00:03:51.760 --> 00:03:54.879
具有三个参数的self.limit顺序

00:03:54.879 --> 00:03:58.560
前两个是符号和数量，与市场价格相同

00:03:58.560 --> 00:04:00.720
订单和第三个参数是极限

00:04:00.720 --> 00:04:05.360
价格，因为限价订单可能需要更长的时间才能完成，也可能根本无法完成

00:04:05.360 --> 00:04:10.080
可以更新它们，但更多关于更新订单的信息

00:04:10.080 --> 00:04:14.000
接下来还有股市定单，这基本上是一个市场

00:04:14.000 --> 00:04:17.919
达到预定价格后立即发送的订单

00:04:17.919 --> 00:04:21.280
这个价格可以指定为第三个参数

00:04:21.280 --> 00:04:25.919
因此，例如，该股票市场订单将意味着要卖出的市场订单

00:04:25.919 --> 00:04:29.840
间谍的价格将立即发送200股间谍

00:04:29.840 --> 00:04:33.360
假设间谍关闭变量下降10％

00:04:33.360 --> 00:04:38.960
代表买家最新的收盘价，请注意，如果价格波动很大或

00:04:38.960 --> 00:04:42.400
跳空股票市场订单可能会被执行

00:04:42.400 --> 00:04:46.160
价格远低于指定的触发价

00:04:46.160 --> 00:04:49.360
除了止损市场订单，还有止损限价订单

00:04:49.360 --> 00:04:52.560
基本上与止损市场订单的方式相同

00:04:52.560 --> 00:04:57.120
区别在于将发送限价单而不是市价单

00:04:57.120 --> 00:05:01.919
在这里您可以将限制价格指定为第四个参数

00:05:01.919 --> 00:05:06.960
最后但并非最不重要的一点是，规则在未结订单上标记，市场在未结订单上标记

00:05:06.960 --> 00:05:10.720
就像名称所暗示的那样，这些订单以交易价格的开盘价或收盘价成交

00:05:10.720 --> 00:05:14.479
出于安全考虑，至少必须提交这些订单

00:05:14.479 --> 00:05:17.840
分别在打开或关闭前两分钟

00:05:17.840 --> 00:05:22.720
在这里您可以再次只指定一个符号和一个数量

00:05:22.720 --> 00:05:27.199
请注意，如果您使用的是每日数据或其他相对较低的分辨率

00:05:27.199 --> 00:05:30.639
您的市场订单很有可能会转化为市场

00:05:30.639 --> 00:05:34.080
未结订单是这种情况，因为数据是

00:05:34.080 --> 00:05:37.199
在结束时间（通常是在市场期间）提交

00:05:37.199 --> 00:05:41.039
不活动，因此如果您基于此发送任何市场订单

00:05:41.039 --> 00:05:45.199
信息和市场关闭时，它们将自动转换为市场

00:05:45.199 --> 00:05:48.639
在未结订单上，如果您对我的意思感到困惑

00:05:48.639 --> 00:05:50.880
数据在其结束时间提交

00:05:50.880 --> 00:05:54.080
我建议观看本系列的第三个视频，其中涵盖了

00:05:54.080 --> 00:05:56.720
了解时间如何的基本主题

00:05:56.720 --> 00:06:00.000
在精益交易引擎内部处理

00:06:00.000 --> 00:06:03.680
您可能会问自己，为什么没有更复杂的订单类型，例如

00:06:03.680 --> 00:06:06.080
作为交易止损订单或应急

00:06:06.080 --> 00:06:09.919
即使quantconnect没有直接的辅助方法也可以下订单

00:06:09.919 --> 00:06:13.680
对于这些，您仍然可以从上述内容中创建更复杂的订单

00:06:13.680 --> 00:06:16.960
在本视频后面的音频类型中，我将向您展示

00:06:16.960 --> 00:06:21.840
如何创建追踪止损单的示例

00:06:21.840 --> 00:06:26.240
除了订单类型之外，您还可以指定订单的有效时间

00:06:26.240 --> 00:06:30.160
这基本上就是订单保持打开状态的时间长度

00:06:30.160 --> 00:06:33.199
请注意，有效时间只能是

00:06:33.199 --> 00:06:36.880
针对非市场订单进行了调整，因为通常会执行市场订单

00:06:36.880 --> 00:06:40.000
马上有三种不同的设置

00:06:40.000 --> 00:06:44.080
time and force属性的默认值可以取消

00:06:44.080 --> 00:06:47.360
这意味着订单将保持打开状态，直到它被执行为止

00:06:47.360 --> 00:06:51.919
或手动取消的第二个可能值是day

00:06:51.919 --> 00:06:56.160
这意味着该订单将一直有效直到一天结束

00:06:56.160 --> 00:07:00.400
最终的可能值是直到日期，这可以让您指定日期

00:07:00.400 --> 00:07:04.479
直到到达这一天并且订单已经

00:07:04.479 --> 00:07:08.720
尚未填写，它将被取消以更改时间

00:07:08.720 --> 00:07:11.759
订单的力量和力量，您必须设置时间和力量值

00:07:11.759 --> 00:07:14.720
默认订单属性的属性

00:07:14.720 --> 00:07:20.000
例如改变今天的时间和力量会像这样

00:07:20.000 --> 00:07:24.720
接下来，让我们看一下如何更新和取消订单

00:07:24.720 --> 00:07:28.080
就像我之前已经提到的，取决于订单类型的东西

00:07:28.080 --> 00:07:33.280
您可以更新，可以更改所有订单类型，允许您更新该标记属性

00:07:33.280 --> 00:07:36.720
标签可用于标记特定的订单凭单，以供以后参考

00:07:36.720 --> 00:07:41.440
但这对您的交易没有实际影响，此表显示了哪些属性

00:07:41.440 --> 00:07:44.879
您可以更新各种订单类型

00:07:44.879 --> 00:07:49.360
在证券价格上涨时更新止损订单的止损价格

00:07:49.360 --> 00:07:52.479
是创建交易止损单的一种方法

00:07:52.479 --> 00:07:56.960
要实际更新订单，您需要创建一个更新订单字段对象

00:07:56.960 --> 00:08:00.000
然后指定要更新的属性

00:08:00.000 --> 00:08:04.879
然后可以将该对象传递给给定订单上的update方法

00:08:04.879 --> 00:08:08.240
稍后，当我们编写实际代码时，我将以更详细的方式显示此内容。

00:08:08.240 --> 00:08:12.080
交易机器人更新订单会返回订单

00:08:12.080 --> 00:08:14.639
响应对象，您可以使用该对象来确定是否

00:08:14.639 --> 00:08:19.360
更新成功或未取消订单，您只需致电

00:08:19.360 --> 00:08:23.280
但是，给定订单凭单上的取消方法

00:08:23.280 --> 00:08:26.479
您无法对市场订单执行此操作，因为它们通常已被执行

00:08:26.479 --> 00:08:29.199
立即地

00:08:29.599 --> 00:08:33.760
接下来让我们讨论发送交易订单时的头寸调整

00:08:33.760 --> 00:08:37.440
您通常想动态调整其相对于

00:08:37.440 --> 00:08:40.880
例如，您投资组合中的可用资本

00:08:40.880 --> 00:08:44.959
而不是总是发送100股的定单，您可能希望

00:08:44.959 --> 00:08:48.959
幸运地向您的投资组合中的10个发送定单

00:08:48.959 --> 00:08:52.560
Quantconnect具有一些帮助程序功能，也可以使此操作更容易

00:08:52.560 --> 00:08:56.160
第一个也是最常用的辅助函数是我们已经在其中使用的

00:08:56.160 --> 00:08:59.760
最后一个视频，即sets holdings method set

00:08:59.760 --> 00:09:03.440
持股允许您指定要占投资组合的百分比

00:09:03.440 --> 00:09:08.320
分配给给定的证券，然后您的算法会自动

00:09:08.320 --> 00:09:11.839
计算适当的订单大小并发出市场订单以达到

00:09:11.839 --> 00:09:15.920
指定的分配作为可选的第三个参数，您可以

00:09:15.920 --> 00:09:19.839
传递一个布尔值，该值指定是否应清算现有馆藏

00:09:19.839 --> 00:09:23.120
在分配您的投资组合资本之前

00:09:23.120 --> 00:09:27.440
另外，您也可以使用集合持有量将您的持有量按比例放大或缩小到

00:09:27.440 --> 00:09:30.720
为此所需的级别，您需要传递一个列表

00:09:30.720 --> 00:09:35.519
这样的投资组合目标对象将发出市场订单，因此

00:09:35.519 --> 00:09:39.920
您所持间谍的规模将缩小或缩小到80％

00:09:39.920 --> 00:09:44.640
而那些在ibm中购买力达到20的人

00:09:44.640 --> 00:09:48.240
如果您不想使用市场定单进行交易，则不能使用该定单。

00:09:48.240 --> 00:09:52.240
馆藏助手功能，但是还有另一种方法可以智能地

00:09:52.240 --> 00:09:56.240
为此可以计算订单大小，您可以使用self.calculate

00:09:56.240 --> 00:10:01.120
带有两个参数的定单数量，第一个是符号，第二个是

00:10:01.120 --> 00:10:04.160
一个百分比，然后将返回一个整数

00:10:04.160 --> 00:10:07.680
表示将要购买的指定证券的股份数量

00:10:07.680 --> 00:10:11.680
占您可用购买力的指定百分比

00:10:11.680 --> 00:10:15.680
因此，例如，这是您发送分配30的限价单的方式

00:10:15.680 --> 00:10:20.720
以当前市场价格对苹果的购买力

00:10:20.720 --> 00:10:24.320
有时在您的帐户中留有现金缓冲会很有用，这样

00:10:24.320 --> 00:10:26.959
您不会突然用完购买力

00:10:26.959 --> 00:10:31.760
确保您始终有足够的现金储备可以使用

00:10:31.760 --> 00:10:35.920
投资组合价值百分比，并将其设置为您所占投资组合的百分比

00:10:35.920 --> 00:10:41.720
想要保留现金来平仓的简单方法是

00:10:41.720 --> 00:10:45.360
不带任何参数的self.liquidate self.liquidate

00:10:45.360 --> 00:10:49.200
只会使用市价单清算您所有的持仓量

00:10:49.200 --> 00:10:53.360
或者，您可以将特定的符号传递到该位置中仅平仓的位置

00:10:53.360 --> 00:10:57.920
安全性，然后我们才真正进入实际

00:10:57.920 --> 00:11:00.959
编码此视频的一部分，我还想做一些其他事情

00:11:00.959 --> 00:11:05.040
涵盖其中之一是on order事件方法，这是一个事件

00:11:05.040 --> 00:11:08.880
每次订单事件（例如

00:11:08.880 --> 00:11:13.519
发生订单状态更改时，这是检查您的何时

00:11:13.519 --> 00:11:17.040
订单正在执行中，并有可能根据此信息采取行动

00:11:17.040 --> 00:11:21.279
只要有可能，订单状态就包括已提交

00:11:21.279 --> 00:11:24.959
填充部分填充已取消无效，并且

00:11:24.959 --> 00:11:28.000
其他的，我们将在开始时更详细地介绍这一点。

00:11:28.000 --> 00:11:32.560
除了通过订单事件访问订单外，还需要几分钟的时间进行编码

00:11:32.560 --> 00:11:36.000
您也可以通过算法事务管理器来执行此操作

00:11:36.000 --> 00:11:41.120
例如self.transactions.get未结订单允许您获取所有

00:11:41.120 --> 00:11:46.959
您还可以使用指定交易品种的未平仓指令

00:11:47.160 --> 00:11:51.279
self.transactions.getorderbyid通过订单ID获取订单

00:11:51.279 --> 00:11:54.560
事务管理器提供的另一种帮助方法

00:11:54.560 --> 00:11:59.600
是取消未结订单，允许您取消所有未结订单以确保安全

00:11:59.600 --> 00:12:03.040
或整个投资组合，这可能非常有用

00:12:03.040 --> 00:12:07.200
在您想停止所有交易活动的情况下

00:12:07.200 --> 00:12:10.959
最后但并非最不重要的一点是，quantconnect还可以选择

00:12:10.959 --> 00:12:14.160
各种不同的费用和经纪模型来模拟交易成本

00:12:14.160 --> 00:12:18.399
尽可能切合实际，您还可以创建自己的自定义滑点和

00:12:18.399 --> 00:12:22.240
其他交易成本模型，但这是一个更高级的主题

00:12:22.240 --> 00:12:25.839
这是我们在本系列后面的内容

00:12:25.839 --> 00:12:29.600
那就是让我们现在终于开始将这里学到的一些东西放到这里

00:12:29.600 --> 00:12:34.560
像上次一样，通过编写一些代码将其付诸实践

00:12:34.560 --> 00:12:38.160
我们将在理论上实施的交易策略

00:12:38.160 --> 00:12:42.480
我们实际上开始再次编写代码，这是我们将要采取的策略

00:12:42.480 --> 00:12:46.320
实施是一个非常简单的策略，我不建议您进行交易

00:12:46.320 --> 00:12:49.600
用真金白银的主要目的是显示订单

00:12:49.600 --> 00:12:52.320
在量子连接内部处理

00:12:52.320 --> 00:12:56.959
该策略背后的想法是购买并持有给定的股票或etf

00:12:56.959 --> 00:13:00.880
然后，我们创建追踪股票价格的交易止损订单

00:13:00.880 --> 00:13:05.200
比价格低百分之五，这有望使我们保持失败者的地位

00:13:05.200 --> 00:13:08.639
离开获胜者的房间上升时相对较小

00:13:08.639 --> 00:13:12.000
如果止损被击中，我们退出头寸，然后等待

00:13:12.000 --> 00:13:14.800
在我们开始再次投资之前的一个月

00:13:14.800 --> 00:13:18.639
如果我们不等一段时间再进行投资，止损将会

00:13:18.639 --> 00:13:22.240
完全没有用，因为我们将在关闭交易后立即重新购买

00:13:22.240 --> 00:13:26.000
该视频的位置，我们将使用etf

00:13:26.000 --> 00:13:29.200
 qqq进行我们的交易，但随时可以尝试不同的方法

00:13:29.200 --> 00:13:33.200
股票或其他etfs，现在让我们进入

00:13:33.200 --> 00:13:37.200
quantconnect平台并开始实施该策略的代码

00:13:37.200 --> 00:13:40.480
在quantconnect平台内部，我们将创建一个新算法

00:13:40.480 --> 00:13:45.040
在实验室标签中，因为我们不需要strategybuilder，所以我们将退出

00:13:45.040 --> 00:13:48.800
构建器模式并以空白模板算法开始

00:13:48.800 --> 00:13:52.959
像往常一样，我们将从实现initialize方法开始

00:13:52.959 --> 00:13:56.320
这是我们将设置一些回测设置的地方，添加必要的

00:13:56.320 --> 00:13:58.959
数据并定义一些帮助变量

00:13:58.959 --> 00:14:02.880
以后需要先关闭，我们先设置开始

00:14:02.880 --> 00:14:06.399
我们在这里进行回测的结束日期和结束日期，您可以选择任何时间

00:14:06.399 --> 00:14:12.480
你想要我要去的框架直到2021年

00:14:15.279 --> 00:14:18.959
之后，我们为此袋测试设置了初始缓存余额

00:14:18.959 --> 00:14:22.480
请记住，这仅用于实际交易中的回测，这将是

00:14:22.480 --> 00:14:26.720
您的帐户余额之后，我们要添加以下数据

00:14:26.720 --> 00:14:28.959
QQ这是安全的

00:14:28.959 --> 00:14:32.720
算法将为此交易，我们可以使用增加权益

00:14:32.720 --> 00:14:37.279
方法并传递qqq代码符号以及分辨率

00:14:37.279 --> 00:14:41.279
在这里，我们将按小时进行解析，但您也可以每天使用一次

00:14:41.279 --> 00:14:45.760
分辨率，然后将qqq的符号对象保存到

00:14:45.760 --> 00:14:49.519
变量self.qqq，我们将用来引用此变量

00:14:49.519 --> 00:14:53.360
现在我们算法中的安全性

00:14:53.360 --> 00:14:57.680
initialize方法是定义并初始化几个帮助程序变量

00:14:57.680 --> 00:15:01.680
在这里，我们首先创建两个变量，我们将使用这些变量来访问订单

00:15:01.680 --> 00:15:06.399
我们的进出仓单称为第一张可变进场票

00:15:06.399 --> 00:15:10.079
第二张是停市票，我们都将其初始化为

00:15:10.079 --> 00:15:13.440
没有，那么我们再创建两个变量

00:15:13.440 --> 00:15:16.560
跟踪进场和出场定单的现场时间

00:15:16.560 --> 00:15:20.399
这将用于确保我们等待30天才能开始投资

00:15:20.399 --> 00:15:23.680
再次在这里我们称为第一个变量条目

00:15:23.680 --> 00:15:28.320
时间和第二个止损市场填充时间，我们都初始化了

00:15:28.320 --> 00:15:33.440
最早的日期，因为尚未完成任何订单

00:15:33.440 --> 00:15:37.519
最后但并非最不重要的一点是，我们创建了辅助变量self.highest

00:15:37.519 --> 00:15:40.639
毫不意外地跟踪QQ的最高价格

00:15:40.639 --> 00:15:44.079
我们需要这个来保证以后的交易止损

00:15:44.079 --> 00:15:47.360
这样，我们现在就完成了initialize方法，并可以继续进行

00:15:47.360 --> 00:15:50.639
在数据方法上，每次算法时都会调用此方法

00:15:50.639 --> 00:15:53.759
接收新数据，以获取有关如何

00:15:53.759 --> 00:15:56.399
qc算法类内部的数据流

00:15:56.399 --> 00:16:00.320
请务必查看本系列的一些以前的视频

00:16:00.320 --> 00:16:04.320
在编写实际的python代码之前，让我们勾勒出我们想要做的事情

00:16:04.320 --> 00:16:08.000
有一些评论，我们要在数据上做的第一件事

00:16:08.000 --> 00:16:12.639
方法是检查自从我们关闭上一个头寸以来是否已经过去了30天

00:16:12.639 --> 00:16:16.880
那么我们想发送尽可能多的qq份额的入场限价单

00:16:16.880 --> 00:16:19.680
购买，因为我们将使用限价单

00:16:19.680 --> 00:16:22.560
无法保证它们会被填充

00:16:22.560 --> 00:16:26.480
如果在一天之内未完成限价单，我们将上调限价

00:16:26.480 --> 00:16:30.720
这样我们就增加了变得充满的机会

00:16:32.000 --> 00:16:35.920
我们希望在on data方法中要做的最后一件事是提高价格

00:16:35.920 --> 00:16:39.839
尾随止损的数量（如有必要）

00:16:44.320 --> 00:16:48.000
您可能已经注意到我们实际上没有发出任何止损单

00:16:48.000 --> 00:16:51.519
ondata方法中的任何地方，因为我们在on

00:16:51.519 --> 00:16:55.680
订单事件方法在每个订单事件上都会调用此事件处理程序

00:16:55.680 --> 00:16:59.040
这是我们要发送止损单的地方

00:16:59.040 --> 00:17:05.839
但是，我们只想在进入限价单被执行的情况下执行此操作

00:17:09.120 --> 00:17:13.280
最后但并非最不重要的一点是，我们希望保存当前时间，以防我们的止损订单

00:17:13.280 --> 00:17:16.160
失败了，我们需要这样做，所以我们可以正确地停止

00:17:16.160 --> 00:17:20.880
在平仓后30天进行投资

00:17:20.880 --> 00:17:24.559
基本上我们的算法会做的事情，所以现在剩下要做的就是代码

00:17:24.559 --> 00:17:29.600
这样，然后我们就可以开始了，我将从on data方法开始

00:17:29.600 --> 00:17:33.679
一个简单的if语句可以完成30天的等待

00:17:33.679 --> 00:17:36.799
为此，我们只需检查当前时间与

00:17:36.799 --> 00:17:41.360
否则，止损市场订单执行时间少于30天

00:17:41.360 --> 00:17:47.520
有时间再次投资，我们会返回，否则我们将继续进行其余的投资

00:17:47.520 --> 00:17:50.960
方法，我们将需要您的qqq价格，希望您能做到

00:17:50.960 --> 00:17:54.559
记得上一个视频中有多种访问qqq的方法

00:17:54.559 --> 00:17:58.799
价格，我们将只索引self.securities字典并保存

00:17:58.799 --> 00:18:02.799
最新价格到价格变量

00:18:05.760 --> 00:18:11.600
那么我们想发送限价单，但是我们只想这样做

00:18:11.600 --> 00:18:14.400
目前没有投资，也没有其他投资

00:18:14.400 --> 00:18:18.679
QQ仓位的有效订单，我们可以用

00:18:18.679 --> 00:18:23.760
分别投资，投资和交易.getopenorders

00:18:23.760 --> 00:18:28.000
如果没有任何未结订单交易，则getopenorders将是

00:18:28.000 --> 00:18:32.160
空列表，如果出现这种情况，则求值为假

00:18:32.160 --> 00:18:34.720
完成后，我们首先要计算订单

00:18:34.720 --> 00:18:39.840
为此，我们可以使用助手功能计算订单数量

00:18:39.840 --> 00:18:45.919
在这里，我们以self.q作为符号在90处作为投资组合的分配

00:18:45.919 --> 00:18:49.440
然后，它将计算我们需要购买的股票数量才能实现

00:18:49.440 --> 00:18:54.400
将我们的投资组合分配给qqq 90

00:18:54.400 --> 00:19:00.000
这样我们就可以发送带有self.limit order的限价单

00:19:02.400 --> 00:19:06.880
作为可选的第四个参数，我们可以为此顺序传递一个标记

00:19:06.880 --> 00:19:10.000
为了显示这一点，我将用输入标记该订单

00:19:10.000 --> 00:19:14.080
订单，因为我们以后可能想更新此订单

00:19:14.080 --> 00:19:18.400
我们将其订单凭单保存到入口凭单变量中

00:19:18.400 --> 00:19:24.400
此外，我们会将当前时间保存到输入时间变量中

00:19:24.400 --> 00:19:28.000
下一步是在未履行限价单的情况下移动限价

00:19:28.000 --> 00:19:31.200
一天之后，我们首先检查是否更多

00:19:31.200 --> 00:19:33.840
超过一天，然后我们检查限制

00:19:33.840 --> 00:19:39.840
订单是否已成交

00:19:42.480 --> 00:19:45.919
我们可以通过访问门票的status属性来检查

00:19:45.919 --> 00:19:54.320
订购票，如果尚未填写，我们要

00:19:54.320 --> 00:20:07.039
将输入时间更新为当前时间以及更新限价

00:20:07.039 --> 00:20:12.400
要更新限价，我们创建一个更新订单字段对象

00:20:16.080 --> 00:20:19.600
然后将此更新订单字段对象的极限价格设置为

00:20:19.600 --> 00:20:23.200
QQ的当前价格

00:20:28.000 --> 00:20:32.000
最后，我们可以通过传递更新订单字段来更新限价订单

00:20:32.000 --> 00:20:34.880
反对我们的入场券上的更新方法

00:20:34.880 --> 00:20:38.000
订票对象

00:20:38.880 --> 00:20:42.799
现在，在on data方法上剩下要做的就是更新交易止损

00:20:42.799 --> 00:20:47.679
当qqq的价格达到新高时，要达到此价格，我们首先必须

00:20:47.679 --> 00:20:49.919
检查股票票证对象是否不是

00:20:49.919 --> 00:20:53.760
空无一人，我们被投资了

00:20:54.240 --> 00:20:57.440
这可以确保我们当前有一个活跃的股票市场订单

00:20:57.440 --> 00:21:02.880
对于我们的qqq头寸，如果是这种情况，我们要检查

00:21:02.880 --> 00:21:06.559
QQ的最新价格高于我们之前保存的价格

00:21:06.559 --> 00:21:10.480
这种情况下的最高价格，我们首先需要更新

00:21:10.480 --> 00:21:15.440
save.highest价格变量来说明这个新高

00:21:15.600 --> 00:21:20.720
然后我们再次创建一个更新订单字段对象

00:21:27.919 --> 00:21:31.760
但是这次我们将止损价设置为新值

00:21:31.760 --> 00:21:35.679
即比最新价格低5％，该价格应与

00:21:35.679 --> 00:21:39.039
QQ的最高价格

00:21:39.919 --> 00:21:43.520
之后，我们只需要更新股票票，然后我们

00:21:43.520 --> 00:21:47.280
已经使用on data方法完成

00:21:51.120 --> 00:21:54.400
现在剩下要做的就是在上面添加几行代码

00:21:54.400 --> 00:21:58.480
订单事件方法内部的订单事件方法

00:21:58.480 --> 00:22:04.320
我们将首先检查提交的订单事件的状态是否等于字段

00:22:05.280 --> 00:22:08.559
其他可能的状态包括已提交无效

00:22:08.559 --> 00:22:13.360
部分填充，但我们仅对以下情况感兴趣：

00:22:13.360 --> 00:22:17.440
订单已成交，这就是为什么我们返回的原因不是

00:22:17.440 --> 00:22:21.360
在第一种情况之后，我们要

00:22:21.360 --> 00:22:25.760
封面是输入订单已填写的情况

00:22:25.760 --> 00:22:28.960
要检查这一点，我们首先检查进入票证变量

00:22:28.960 --> 00:22:32.720
不为null，并且当前订单事件的订单ID

00:22:32.720 --> 00:22:41.840
实际上等于此入场券对象的订单ID

00:22:45.919 --> 00:22:49.679
在这种情况下，我们知道我们的入场限价单已经完成

00:22:49.679 --> 00:22:53.280
这就是为什么我们现在可以为我们的qqq发送止损市场订单

00:22:53.280 --> 00:22:58.080
我们可以检查入场券的数量

00:22:58.080 --> 00:23:00.320
对象，因为我们想要一个股票市场订单

00:23:00.320 --> 00:23:04.400
整个头寸请注意，我们在此处传递一个负值

00:23:04.400 --> 00:23:07.120
因为这是一个卖单[音乐]

00:23:07.120 --> 00:23:10.400
止损市场定单方法的第三个论点是止损

00:23:10.400 --> 00:23:14.480
价格，我们希望此价格比平均田间价格低5％

00:23:14.480 --> 00:23:17.600
我们的挂单

00:23:18.320 --> 00:23:21.360
在此之后，我们需要处理的唯一其他情况

00:23:21.360 --> 00:23:24.720
止损市场订单已被执行的情况

00:23:24.720 --> 00:23:28.000
要检查这一点，我们再次必须检查股市订单是否

00:23:28.000 --> 00:23:31.280
票证对象是非空的，并且票证的订单ID

00:23:31.280 --> 00:23:37.840
订单事件参数正确

00:23:45.360 --> 00:23:49.279
在这种情况下，我们只想更新止损市场订单执行时间变量

00:23:49.279 --> 00:23:55.039
到目前为止这很重要，因为这可以确保我们等待30

00:23:55.039 --> 00:23:58.000
从现在开始的日子

00:24:03.679 --> 00:24:07.679
最后但并非最不重要的一点是，我们将self.highest价格变量重置为零

00:24:07.679 --> 00:24:12.640
因为我们不知道qqq的价格是否会在一个月后降低

00:24:12.640 --> 00:24:16.960
至此，我们现在已经成功实现了该交易机器人

00:24:16.960 --> 00:24:20.799
现在我们可以点击构建按钮，然后点击后退测试按钮来测试

00:24:20.799 --> 00:24:25.360
在指定的时间段内定位，因为这是一个相对简单的漫游器

00:24:25.360 --> 00:24:28.320
背部测试应该不会花费很长时间

00:24:28.320 --> 00:24:32.559
回溯测试完成后，您将看到类似这样的性能概述

00:24:32.559 --> 00:24:36.000
我不想详细介绍这件事，因为这部影片的重点是

00:24:36.000 --> 00:24:38.880
不要创建性能特别出色的机器人

00:24:38.880 --> 00:24:42.799
我将介绍如何使用此报告来分析策略的绩效

00:24:42.799 --> 00:24:47.600
在本系列的稍后部分，我只想向下滚动到“订单”标签，以便

00:24:47.600 --> 00:24:51.600
我们可以确保这个地方实际上在做应该做的事

00:24:51.600 --> 00:24:55.600
即使是相对简单的机器人，查看订单也会很有帮助

00:24:55.600 --> 00:24:59.360
被发送以更好地了解它在做什么

00:24:59.360 --> 00:25:02.880
当您的机器人正在执行某些不应做的事情时，这可能会特别有用

00:25:02.880 --> 00:25:06.240
要做，而您正在尝试找出为什么在这里

00:25:06.240 --> 00:25:09.360
我们可以看到已发送的所有订单的概述

00:25:09.360 --> 00:25:13.520
如果我们点击订单，我们会看到更详细的细分

00:25:13.520 --> 00:25:17.120
在最右边的列中，您可以看到我们提交的自定义订单代码

00:25:17.120 --> 00:25:21.520
您可以看到这里的第一个订单是入场限价单

00:25:21.520 --> 00:25:27.919
584股qqq的限价单，限价约153.5

00:25:27.919 --> 00:25:31.200
美元这个限价单然后变得很漂亮

00:25:31.200 --> 00:25:34.799
发送限价单后一小时之内

00:25:34.799 --> 00:25:38.880
初始股价接近146美元的止损订单为

00:25:38.880 --> 00:25:42.559
发送出去，我们可以看到一系列的更新

00:25:42.559 --> 00:25:45.360
股票价格，而qqq的价格上涨

00:25:45.360 --> 00:25:50.000
直到2月5日在157点处完成止损单

00:25:50.000 --> 00:25:53.600
下一个挂单首先发送的美元

00:25:53.600 --> 00:25:58.559
在此字段时间之后大约一个月，这正是我们希望的样子

00:25:58.559 --> 00:26:01.760
从这几个命令来看，算法似乎在做它的工作

00:26:01.760 --> 00:26:05.520
除了分析订单以确保

00:26:05.520 --> 00:26:08.720
您完全了解自己的算法，还有其他一些调试和

00:26:08.720 --> 00:26:13.200
quan connect的日志记录工具提供了一种最简单的方法来进行双重检查

00:26:13.200 --> 00:26:18.000
某些事情是通过使用self.debug，这类似于python的打印

00:26:18.000 --> 00:26:21.279
语句，例如，如果您想确保

00:26:21.279 --> 00:26:24.320
交易止损价正在正确更新

00:26:24.320 --> 00:26:28.960
您可以使用sales.debug将更新的止损价打印到控制台

00:26:28.960 --> 00:26:32.400
为此，您将必须重新启动回测并查看值

00:26:32.400 --> 00:26:35.760
打印到页面底部的控制台

00:26:35.760 --> 00:26:40.159
除了safe.debug之外，还有self.error，它向您显示一条红色消息

00:26:40.159 --> 00:26:43.279
控制台请注意，如果正在使用相同的值

00:26:43.279 --> 00:26:46.400
一遍又一遍地打印quantconnect将限制打印

00:26:46.400 --> 00:26:51.440
率，以最终防止浏览器泛滥，您也可以使用self.log来

00:26:51.440 --> 00:26:54.799
锁定某些操作后，当

00:26:54.799 --> 00:26:58.400
回测已在回测报告的底部完成

00:26:58.400 --> 00:27:02.159
这些日志的容量确实有限，因此您无法生成

00:27:02.159 --> 00:27:06.880
每次回溯测试所需的兆字节日志，这是改善日志记录质量的另一种好方法

00:27:06.880 --> 00:27:10.400
通过创建自定义图表和绘图来了解您的算法

00:27:10.400 --> 00:27:13.039
某些价值观，但这是您将学到的东西

00:27:13.039 --> 00:27:17.600
接下来的几部视频之一，如果这一切都不能帮助Quantconnect

00:27:17.600 --> 00:27:21.520
还具有调试模式，您可以通过单击右侧的调试来访问

00:27:21.520 --> 00:27:25.200
您可以像其他想法一样设置代码的一面

00:27:25.200 --> 00:27:29.360
代码左侧的断点以逐步浏览代码

00:27:29.360 --> 00:27:33.200
除了断点，您还可以将变量或其他表达式添加到

00:27:33.200 --> 00:27:37.120
以清单为例，让我快速设置一个断点

00:27:37.120 --> 00:27:41.919
在这种情况下，让我们将self.highest价格添加到监视列表中

00:27:41.919 --> 00:27:45.760
如果我们现在单击回测，则算法每次到达时都会停止

00:27:45.760 --> 00:27:48.720
如果条件进一步，您可以看到

00:27:48.720 --> 00:27:53.360
价格随时间变化的最高值，逐步执行代码

00:27:53.360 --> 00:27:58.159
在查找错误时分析某些变量可能非常有用

00:27:58.159 --> 00:28:01.520
请注意，除了观看简单的变量之外，您还可以跟踪更多

00:28:01.520 --> 00:28:04.240
复杂表达式，例如逻辑表达式

00:28:04.240 --> 00:28:08.080
列表以及更多我认为获得此信息的最佳方法

00:28:08.080 --> 00:28:11.679
熟悉调试模式的方法是尝试一下并在其中玩耍

00:28:11.679 --> 00:28:15.200
据说这已经很长了

00:28:15.200 --> 00:28:18.240
视频，所以我希望它不会太令人压倒，并且您学到了一些东西

00:28:18.240 --> 00:28:20.320
新的，如果您认为一些事情已经过去了

00:28:20.320 --> 00:28:23.440
您不用担心，您可以随时重新观看此视频的某些部分

00:28:23.440 --> 00:28:27.360
甚至下一个视频中的整个内容，我们将看看

00:28:27.360 --> 00:28:30.000
指标工作如何创建自己的指标

00:28:30.000 --> 00:28:34.559
还有更多如果您喜欢这部影片，请务必订阅

00:28:34.559 --> 00:28:37.360
在通知铃上，然后点按“赞”按钮以获取更多信息

00:28:37.360 --> 00:28:45.840
像这样的内容感谢收看

00:28:46.320 --> 00:28:48.399
你

