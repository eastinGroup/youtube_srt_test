WEBVTT
Kind: captions
Language: zh-Hans

00:00:08.879 --> 00:00:13.330
你好，大家非常感谢你早上好，我希望你在做

00:00:13.330 --> 00:00:18.310
好吧，我今天想谈谈冲突

00:00:18.310 --> 00:00:23.859
分布式系统中的分辨率，即如果几个人更改了一些数据

00:00:23.859 --> 00:00:28.060
彼此独立的同时发生了什么我们该如何解决

00:00:28.060 --> 00:00:33.850
那些冲突好吧，我的背景是我是University of University的研究员

00:00:33.850 --> 00:00:38.530
剑桥我以前在很多互联网初创公司中从事过行业，所以我

00:00:38.530 --> 00:00:42.670
例如，在我正在工作的那一刻，在LinkedIn工作了几年

00:00:42.670 --> 00:00:48.460
这个名为“真实数据”的研究项目拼写为T RBE，我们正在努力

00:00:48.460 --> 00:00:52.150
这样做是为了将端到端加密带到更大范围

00:00:52.150 --> 00:00:56.470
应用程序，例如Google Docs，几个人可以

00:00:56.470 --> 00:01:00.790
在线同时编辑文档，而无需信任Google

00:01:00.790 --> 00:01:05.740
服务器，因为我们要做的是能够将数据放置在各种服务器上

00:01:05.740 --> 00:01:09.700
在云中，但不必担心如果它们受到破坏会发生什么情况，或者

00:01:09.700 --> 00:01:15.100
等等，这就是所有这些的背景，我不是在谈论

00:01:15.100 --> 00:01:19.450
加密和安全协议，今天我只关注一点

00:01:19.450 --> 00:01:24.850
整个项目的一部分，如果几个人编辑Beta，会发生什么

00:01:24.850 --> 00:01:29.680
同时，以及如何解决这个问题，所以我想从

00:01:29.680 --> 00:01:34.479
我们可能会熟悉您的情况，您有点忧郁

00:01:34.479 --> 00:01:40.030
简笔图在您的计算机上以及某些时候入侵了某些代码

00:01:40.030 --> 00:01:44.500
您确定此代码已完成，并使用自己喜欢的代码来提交

00:01:44.500 --> 00:01:49.510
版本控制系统我这里仅以git为例，因此在这一点上

00:01:49.510 --> 00:01:53.650
您将代码放入存储库中，然后也许将其推送到某个位置，以便

00:01:53.650 --> 00:01:57.640
其他人也可以看到该代码，因此在得到您的情况下，您可能会

00:01:57.640 --> 00:02:03.490
将其推送到您在github上的存储库中，这就是现在的通信机制

00:02:03.490 --> 00:02:08.920
对您团队中的人来说，所以如果有人说这个红色的小棍子

00:02:08.920 --> 00:02:13.629
弄清楚谁也在入侵代码，那么您可以通过

00:02:13.629 --> 00:02:16.810
中央存储库，这是我们非常熟悉的，这是我们每天要做的

00:02:16.810 --> 00:02:21.400
所以这里的小红人可能会独立

00:02:21.400 --> 00:02:25.810
同时也要在相同的代码库上工作，并且还要进行提交和

00:02:25.810 --> 00:02:30.970
现在，如果这个人现在从github上获取好了，他们将不得不

00:02:30.970 --> 00:02:35.049
如果这是您的工作流程之类，则进行合并或变基

00:02:35.049 --> 00:02:39.010
沿着这些区域，以某种方式将这些更改我不必合并

00:02:39.010 --> 00:02:44.079
在一起，就像人们可能经历的变化一样

00:02:44.079 --> 00:02:47.950
在同一存储库中的文件没问题，它们将被合并

00:02:47.950 --> 00:02:51.879
如果一个人更改了文件的开头而另一个人则干净地

00:02:51.879 --> 00:02:56.049
taejun文件的末尾可能还可以，因为版本

00:02:56.049 --> 00:03:00.099
如果人们更改了相同的控件，控制系统将自动将它们合并

00:03:00.099 --> 00:03:03.280
同一文件的一部分，那么您将必须解决合并冲突

00:03:03.280 --> 00:03:08.650
您自己，所以我们有这些工具可以进行三向合并以复制捕获内容

00:03:08.650 --> 00:03:12.280
从一侧到另一侧，并弄清楚结果应该是什么，所以您已经

00:03:12.280 --> 00:03:16.629
可能必须与这样的事情作斗争，这恰恰是一种问题

00:03:16.629 --> 00:03:20.859
我在谈论，但这个问题不仅发生在软件开发中

00:03:20.859 --> 00:03:26.349
这是一个非常笼统的问题，因此，假设您是一名从事法律工作的律师

00:03:26.349 --> 00:03:31.810
公司，也许正在与您谈判合同，因此有一个客户

00:03:31.810 --> 00:03:36.010
一方面，另一方面，还有另一家和另一家公司的律师事务所

00:03:36.010 --> 00:03:39.639
方面，每个人都来回发送这些版本的合同，

00:03:39.639 --> 00:03:42.940
合同可能是Microsoft Word文档，因为这就是

00:03:42.940 --> 00:03:46.659
律师工作，他们通过电子邮件发送了这些信息，所以您只有一个人

00:03:46.659 --> 00:03:53.349
对这些Word文档进行更改，然后单击“保存”，然后同时进行

00:03:53.349 --> 00:03:57.400
时间也许有人在其他公司也在更新

00:03:57.400 --> 00:04:02.650
相同的文档会对其进行更改，现在您将这些更改通过电子邮件相互发送，如此

00:04:02.650 --> 00:04:06.129
这实际上是几乎相同的数据流，我实际上只是完全重用了

00:04:06.129 --> 00:04:10.419
相同的图表，并更改了电子邮件的标签

00:04:10.419 --> 00:04:14.079
沟通路径，在某些时候，这些变化将是必须的

00:04:14.079 --> 00:04:19.419
合并在一起，现在对于Microsoft Word，我不确定甚至没有

00:04:19.419 --> 00:04:22.780
一种很好的三向合并用户界面，我知道您可以进行比较

00:04:22.780 --> 00:04:27.789
两份文件，但我认为人们后来要做的是手动

00:04:27.789 --> 00:04:31.900
将更改从文档的一个版本复制到另一个版本，如此

00:04:31.900 --> 00:04:35.169
真正手动执行此合并，仅此而已

00:04:35.169 --> 00:04:39.639
这种飞机的情况在这里，所以在这种情况下，最好是

00:04:39.639 --> 00:04:43.539
就像一个非正式的锁，有人说可以，我要编辑

00:04:43.539 --> 00:04:46.900
现在提交文件，第二天请勿更改，我会寄给您，

00:04:46.900 --> 00:04:50.860
然后您可以对其进行编辑，以便人们尝试通过以下方式对他们的更新进行排序

00:04:50.860 --> 00:04:55.449
手动交流在另一个例子中发生了什么让我们来看第三个例子

00:04:55.449 --> 00:05:00.330
虽然让我们看待办事项清单，所以这也许是您说的待办事项清单，

00:05:00.330 --> 00:05:04.719
我和我妻子在一起都有购物清单，我可以在上面添加东西，

00:05:04.719 --> 00:05:08.409
她可以添加东西，然后下一个去商店的人都可以购买这些东西

00:05:08.409 --> 00:05:13.960
这里购买牛奶被添加到待办事项列表中，假设这个待办事项列表是

00:05:13.960 --> 00:05:19.110
现在存储在中央服务器上，这就是允许我们进行通信的原因，所以我

00:05:19.110 --> 00:05:25.659
将我的牛奶添加到“待办事项”列表中，然后按“确定”按钮，因此它会发出类似

00:05:25.659 --> 00:05:29.499
也许通过网络发出的HTTP POST请求值得我们将其存储在此处

00:05:29.499 --> 00:05:33.729
然后回来并说“确定”，它已添加到待办事项列表中，并且与此同时

00:05:33.729 --> 00:05:38.110
也许我妻子去的时候哦，需要给我刚刚记得的植物浇水，所以补充说

00:05:38.110 --> 00:05:43.930
到待办事项列表上也可以将这个帖子发送到服务器上，所以可以，所以

00:05:43.930 --> 00:05:50.349
在这种情况下，实际上发生了什么事，如果该中央服务器存储了

00:05:50.349 --> 00:05:54.189
数据库中的数据，如果它是

00:05:54.189 --> 00:05:59.139
关系数据库说，那么我们实际上正在进行序列化，那就是

00:05:59.139 --> 00:06:03.759
这些更新实际上是按顺序依次应用的

00:06:03.759 --> 00:06:08.919
那是可序列化来自数据库事务的地方，这意味着

00:06:08.919 --> 00:06:12.789
一次应用一次，因此您实际上并没有相同的并发性

00:06:12.789 --> 00:06:17.289
我们在代码编辑和发送Word文档时遇到的问题

00:06:17.289 --> 00:06:21.430
来回移动，因为实际上只有一个数据的主副本，

00:06:21.430 --> 00:06:25.389
驻留在服务器上，并且一次更新一次事务

00:06:25.389 --> 00:06:29.889
按顺序排列，所以在这种情况下，您不会遇到此冲突解决问题，因此

00:06:29.889 --> 00:06:34.120
这看起来不错，但另一方面，您有一个问题，如果

00:06:34.120 --> 00:06:37.659
我现在手机没有信号，或者网络是否正常

00:06:37.659 --> 00:06:42.729
因其他原因而中断，或者我可以按按钮进行保存，然后我将

00:06:42.729 --> 00:06:48.479
只是得到一个旋转的旋转等待指示器，什么都不会发生

00:06:48.479 --> 00:06:52.889
所以在这里，如果您没有

00:06:52.889 --> 00:06:56.550
Internet连接，那么您将无法访问中央服务器，因此无法存储

00:06:56.550 --> 00:07:01.020
任何数据，您都无法以任何方式编辑数据，因此它不能脱机工作，因此这些

00:07:01.020 --> 00:07:04.800
是问题所在，但我们从中央服务器那里获得了优势，

00:07:04.800 --> 00:07:08.430
不必担心这种并发性，这些不同

00:07:08.430 --> 00:07:14.490
编辑同时进行，并且必须将它们合并在一起，但是在

00:07:14.490 --> 00:07:19.949
它的成本仅可在线使用，因此我们现在需要与

00:07:19.949 --> 00:07:24.529
服务器不是很好，特别是如果您在移动设备上做事

00:07:24.529 --> 00:07:30.810
另一个问题是这些请求是同步的，因此当我按保存时

00:07:30.810 --> 00:07:34.830
按钮，我必须等待，直到我从服务器恢复正常，然后才能

00:07:34.830 --> 00:07:39.389
我知道它实际上已经保存了，所以在我还好之前，我不会

00:07:39.389 --> 00:07:43.649
知道网络请求是否确实通过了

00:07:43.649 --> 00:07:49.050
网络不可靠，因此也可能是时间问题，让我们在

00:07:49.050 --> 00:07:53.370
文档编辑案例，例如，对于Google文档，您可以按

00:07:53.370 --> 00:07:57.509
一个字母，然后再过一秒钟，该字母将出现在屏幕上

00:07:57.509 --> 00:08:02.219
另一个正在编辑同一文档的人，因此该编辑

00:08:02.219 --> 00:08:06.089
编辑单元是一个按键，它甚至不像一个提交或类似的东西

00:08:06.089 --> 00:08:11.490
这样就只是一个字母，所以在这种情况下，如果您想发送

00:08:11.490 --> 00:08:15.870
通过中央服务器，那么每次您按下字母时，您都必须先

00:08:15.870 --> 00:08:19.770
发送到服务器，等待将其保存在那里，等待服务器到来

00:08:19.770 --> 00:08:23.999
回到您说的确定，然后您可以在屏幕上显示字母，如此

00:08:23.999 --> 00:08:28.379
您必须等待该网络的每次往返更改

00:08:28.379 --> 00:08:33.269
文档，尤其是在编辑文件时会发生的情况

00:08:33.269 --> 00:08:37.769
通过SSH，因此如果您登录Linux服务器并且使用的是vim或Emacs或

00:08:37.769 --> 00:08:43.289
服务器上的某些内容，然后键入字母，然后该编辑器实际上就存在了

00:08:43.289 --> 00:08:47.100
在服务器上，因此您实际上已经获得了同步往返，因此，如果您已经

00:08:47.100 --> 00:08:50.760
拥有缓慢或不可靠的网络，并且使用SSH非常痛苦

00:08:50.760 --> 00:08:56.579
将所有内容放在中央时可能遇到了最后一个问题

00:08:56.579 --> 00:09:00.180
服务器就是现在有这单一的故障点，人们会取笑

00:09:00.180 --> 00:09:03.940
例如，每次github崩溃时，github都会有人说哦，我们知道了

00:09:03.940 --> 00:09:07.510
不错的分散版本控制系统，我们该怎么做

00:09:07.510 --> 00:09:12.519
集中式服务中的所有功能都不是那么好，所以这件事可以

00:09:12.519 --> 00:09:16.870
如果您担心拒绝服务攻击（例如）或

00:09:16.870 --> 00:09:21.339
担心在某些没有免费服务的国家/地区屏蔽广告

00:09:21.339 --> 00:09:25.180
如果您对当地政权持批评态度，则可以使用互联网

00:09:25.180 --> 00:09:30.610
那么实际上这种阻挡能力是一个很大的问题，所以我们想要

00:09:30.610 --> 00:09:36.970
要做的是找出单中心没有这些问题

00:09:36.970 --> 00:09:43.180
服务器，但同时没有必须要做的所有问题

00:09:43.180 --> 00:09:50.079
手工合并，因此如果我们考虑一下，返回到“待办事项列表”示例

00:09:50.079 --> 00:09:54.519
必须与我们的服务器同步通信，如果服务器位于

00:09:54.519 --> 00:09:58.180
同一镇，但如果在地球另一端的服务器，那么这是

00:09:58.180 --> 00:10:01.839
相当慢，因为光速只是需要一段时间才能完全通过

00:10:01.839 --> 00:10:06.760
绕到世界的另一边再回来，如果我们只放数据怎么办

00:10:06.760 --> 00:10:12.160
集中在几个不同的地方，所以让我们假设蓝色人物添加时

00:10:12.160 --> 00:10:15.970
牛奶到要求的待办事项清单中去只是蓝人的本地人

00:10:15.970 --> 00:10:20.500
数据中心将其称为数据中心一并保存在那里，当红色人

00:10:20.500 --> 00:10:25.180
将水厂添加到待办事项列表中，然后也去本地数据中心

00:10:25.180 --> 00:10:29.380
如果人们位于不同的地方，那是两个不同的本地数据中心

00:10:29.380 --> 00:10:34.540
地点，所以现在可以了，所以每个人都可以从他们的反应中得到回应

00:10:34.540 --> 00:10:41.920
本地数据中心，现在这些更改将异步传播，因此

00:10:41.920 --> 00:10:45.130
绕着地球一路走来的光速仍然和它一样慢

00:10:45.130 --> 00:10:50.140
以前是这样，所以很可能两个人在没有这些更改的情况下进行了

00:10:50.140 --> 00:10:53.199
彼此了解，然后您根本不知道其中哪一个

00:10:53.199 --> 00:10:57.399
实际上是第一位的，因为您知道蓝色的定义不是很明确

00:10:57.399 --> 00:11:02.079
从数据中心的角度来看，先是红色还是红色

00:11:02.079 --> 00:11:05.500
蓝色的出现了，然后红色的出现了，但是从数据的角度来看

00:11:05.500 --> 00:11:11.949
中心-首先是红色，然后是蓝色，所以如果添加一个项目

00:11:11.949 --> 00:11:15.190
将dududu加入待办事项清单意味着将其附加到末尾

00:11:15.190 --> 00:11:19.330
列表中的这些项目现在应该以什么顺序出现，我们突然有了

00:11:19.330 --> 00:11:24.010
担心数据中心可能先购买牛奶这一事实

00:11:24.010 --> 00:11:27.130
然后给工厂浇水，另一个数据中心可能有它们

00:11:27.130 --> 00:11:33.220
以其他顺序翻转哦，是的，即使没有两个数据，我们也可以进一步考虑

00:11:33.220 --> 00:11:37.060
中心，我们可以使其变得非常极端，然后说好，我们什至不去

00:11:37.060 --> 00:11:39.910
与数据中心对话，我们将与我们的本地存储对话

00:11:39.910 --> 00:11:44.350
设备，我将把手机上的存储视为数据

00:11:44.350 --> 00:11:47.740
中心，这是有史以来最好的数据中心，因为我没有网络

00:11:47.740 --> 00:11:52.390
我和手机上的存储之间存在中断，因此此通信是

00:11:52.390 --> 00:11:55.780
总是会工作，所以我可以只在本地存储东西，那会很好

00:11:55.780 --> 00:12:00.580
快速而寄存器可以类似地在本地存储一些东西，然后我们可以

00:12:00.580 --> 00:12:04.870
只是有点类似的等等网络的东西来同步

00:12:04.870 --> 00:12:08.470
改变周围，如果您考虑一下，这与

00:12:08.470 --> 00:12:13.330
与两个数据同时发生的同步抗议

00:12:13.330 --> 00:12:17.920
中心交换数据，它与同步过程完全相同

00:12:17.920 --> 00:12:22.570
发生与github发送的git commit或word文档一起发生

00:12:22.570 --> 00:12:27.070
通过电子邮件发送的消息完全相同，这是您所做的一些更改

00:12:27.070 --> 00:12:31.060
彼此独立且同时发生的事件

00:12:31.060 --> 00:12:35.740
变化是异步传播的，现在当然是在这里

00:12:35.740 --> 00:12:42.190
我们回到了冲突的问题，所以以添加两个项目为例

00:12:42.190 --> 00:12:46.210
做待办事项清单，您可以想象这很容易解决您的问题

00:12:46.210 --> 00:12:50.770
只要确保您以某种方式决定一致的订单，就可以使用一些

00:12:50.770 --> 00:12:55.630
ID或其他一些用户ID，您可以随意订购，但如果

00:12:55.630 --> 00:13:02.940
一个项目是一项，其中一项更改已删除待办事项，另一项已删除

00:13:02.940 --> 00:13:07.720
实际编辑相同的待办事项，因此红色的将购买牛奶更改为

00:13:07.720 --> 00:13:13.720
购买豆浆和蓝色豆浆会删除购买的豆浆项目，而这些

00:13:13.720 --> 00:13:17.670
在没有彼此了解的情况下发生了两次更改，因此我们如何解决这个问题

00:13:17.670 --> 00:13:23.740
因为好吧，如果您说删除操作获胜，那么这个项目是

00:13:23.740 --> 00:13:28.960
删除待办事项列表项已删除，以便通过牛奶设备更改编辑

00:13:28.960 --> 00:13:33.640
牛奶不见了，因为它所指的项目不再存在，而是

00:13:33.640 --> 00:13:38.740
意味着我们已经忘记了在其中添加豆浆的事实

00:13:38.740 --> 00:13:42.430
所以也许这是一个重要的事实，另一方面，我们现在已经迷失了方向

00:13:42.430 --> 00:13:45.430
可以用另一种方式做到这一点我们可以说，尽管豆浆获胜

00:13:45.430 --> 00:13:50.320
但是删除操作已丢失，因此删除操作可能有意义

00:13:50.320 --> 00:13:54.580
我们通常如何解决此类冲突，我们有并发操作

00:13:54.580 --> 00:13:57.220
并发发生并不一定意味着

00:13:57.220 --> 00:14:01.000
在同一时刻，这只是意味着它们发生了而又不了解每个

00:14:01.000 --> 00:14:05.050
其他以及我们需要在每个人都同意的地方实现融合

00:14:05.050 --> 00:14:09.580
最后有相同的数据，所以人们谈论最终的一致性是

00:14:09.580 --> 00:14:14.350
一种数据库术语，通常用于描述这些类型的

00:14:14.350 --> 00:14:18.130
您可以简单地允许同时发生不同事情的系统

00:14:18.130 --> 00:14:22.420
而您只想最后以相同的状态结束问题

00:14:22.420 --> 00:14:27.280
术语“最终一致性”实际上是非常模糊的定义，因此

00:14:27.280 --> 00:14:30.580
人们在谈论它时非常不精确，我想将其分解

00:14:30.580 --> 00:14:36.490
分为三个点，这三个属性要精确一点，所以我要

00:14:36.490 --> 00:14:41.770
首先假设最终交付，那就是我们通过

00:14:41.770 --> 00:14:46.090
网络，我们将假设网络不会永远中断

00:14:46.090 --> 00:14:50.530
因此，我们假设经过一定时间后，您会获得一个网络

00:14:50.530 --> 00:14:54.430
再次连接，因此如果您继续重试，则可以获得消息

00:14:54.430 --> 00:14:58.960
最终您必须做出这样的假设，因为如果您

00:14:58.960 --> 00:15:02.680
假设设备可以永远离线，那么它永远也不会同步

00:15:02.680 --> 00:15:08.140
与其他设备再次按照离线定义，所以我们只是

00:15:08.140 --> 00:15:10.720
会假设最终会有一些消息通过，但我们不会

00:15:10.720 --> 00:15:15.130
对我去冰岛的速度有多快做出任何假设

00:15:15.130 --> 00:15:19.090
没有移动信号，我正在火山顶上的某个地方远足

00:15:19.090 --> 00:15:22.990
两周之后，两周后我将不会收到任何消息，当我回到

00:15:22.990 --> 00:15:26.680
雷克雅未克，当我连接到互联网时，我会收到一些消息

00:15:26.680 --> 00:15:31.960
再次，这意味着我的消息延迟是两个星期，在这种情况下，我们

00:15:31.960 --> 00:15:37.150
只是假设第二步没问题，接下来的第二部分

00:15:37.150 --> 00:15:40.150
一致性是确保每个人最终都处于相同的状态，即

00:15:40.150 --> 00:15:44.140
如果我们假设最终每个人都能得到所有

00:15:44.140 --> 00:15:48.970
消息，然后，如果两个人收到了相同的消息，则他们

00:15:48.970 --> 00:15:52.210
应该处于相同状态，这意味着即使他们收到

00:15:52.210 --> 00:15:55.450
消息以不同的顺序仍然应该以相同的状态结束

00:15:55.450 --> 00:16:01.660
最后，我们想要的是现在不丢失数据，这似乎是一种

00:16:01.660 --> 00:16:06.760
有点荒谬的一点，因为当然没有人愿意丢失数据，但是

00:16:06.760 --> 00:16:10.480
实际上，使它显式显示相当多的数据库非常重要

00:16:10.480 --> 00:16:15.430
用户确实使用了这种模式，即最后一位作家胜出，您说如果两个人

00:16:15.430 --> 00:16:18.280
同时更改数据，我们只选择其中之一

00:16:18.280 --> 00:16:22.660
根据时间戳任意确定为获胜者，其他人则为

00:16:22.660 --> 00:16:27.820
只是要扔掉，所以这就像等效，如果您考虑

00:16:27.820 --> 00:16:31.810
Word文档示例嗯，您有两个人在编辑Word文档，然后

00:16:31.810 --> 00:16:35.530
一个人通过电子邮件将其更改发送给另一个人，而另一个人只是

00:16:35.530 --> 00:16:40.510
说得好我也做了自己的改变，我要声明我的

00:16:40.510 --> 00:16:45.010
更改比您的更改新，所以我将忽略您的更改

00:16:45.010 --> 00:16:49.840
对不起，所以这对人们不是很友好，因为更改丢失了，所以

00:16:49.840 --> 00:16:55.360
让我们要求不要丢失数据，所以这就是我的意思。

00:16:55.360 --> 00:17:00.460
最终的一致性，这就是我们可能要使用的数据结构

00:17:00.460 --> 00:17:05.350
想要应用它，所以我现在将这个待办事项清单作为JSON文档进行移动

00:17:05.350 --> 00:17:11.230
您可以想象这就像一个待办事项清单，就像每个

00:17:11.230 --> 00:17:15.579
待办事项有一个标题和一个完成的标志，无论它是真还是假

00:17:15.579 --> 00:17:21.010
然后可能在侧面也有一些设置和内容，所以

00:17:21.010 --> 00:17:25.660
我们这里的主要数据结构是一个有序列表，即您有一个

00:17:25.660 --> 00:17:30.070
待办事项列表，它们必须以特定顺序出现，并且用户

00:17:30.070 --> 00:17:35.710
指定此顺序，并且您还有地图，因此可能有一个JSON对象

00:17:35.710 --> 00:17:39.730
在另一个JSON对象或类似的对象中现在，一旦我们获得了这些数据

00:17:39.730 --> 00:17:44.050
然后我们可以对它们进行各种更改，以便用户交互

00:17:44.050 --> 00:17:47.650
通过应用程序，他们将进行更改，例如，他们可能会设置

00:17:47.650 --> 00:17:51.610
给植物浇水说实话，所以他们说好了，现在我要检查一下

00:17:51.610 --> 00:17:56.710
我手机上的盒子，然后将其设置为完成标志

00:17:56.710 --> 00:18:00.810
所以这里的操作是change操作，edit操作是

00:18:00.810 --> 00:18:06.490
将值分配给此JSON文档中的特定字段的另一件事是

00:18:06.490 --> 00:18:11.020
可能发生的事情是有人可能会编辑一个字符串，所以将牛奶换成牛奶

00:18:11.020 --> 00:18:16.600
买豆浆，所以在那串子里插入几个字母是另一回事

00:18:16.600 --> 00:18:21.220
人们可能会做的是在两个电话之间插入一个全新的电话妈妈列表项

00:18:21.220 --> 00:18:26.680
买牛奶，在订购浇水植物之前，所以这是编辑订购的

00:18:26.680 --> 00:18:30.730
列出对象以插入新项目人们可能要做的另一件事是

00:18:30.730 --> 00:18:35.980
在此处将此地图添加另一个键，否则他们甚至可能会删除整个条目，因此

00:18:35.980 --> 00:18:39.430
顶级待办事项只是删除整个列表，为什么不这样

00:18:39.430 --> 00:18:43.300
几个列表或类似的东西，所以这些是

00:18:43.300 --> 00:18:47.560
人们可以制作这些文档，而我们想要做的是通过某种方式

00:18:47.560 --> 00:18:51.790
解决这些更改，以便即使人们同时进行这些更改

00:18:51.790 --> 00:18:56.860
彼此之间，我们最终获得了发明的一致性，因此我们可以对此建模

00:18:56.860 --> 00:19:03.040
文档是一棵树，我们可以在上面加一些数据类型注释，例如

00:19:03.040 --> 00:19:07.330
顶级文档是一张地图，在其中，我们在按键下有一个列表

00:19:07.330 --> 00:19:11.860
等等不会涉及太多细节，所以这实际上是我所使用的一种算法

00:19:11.860 --> 00:19:15.130
和一位同事一起开发，我们写了大约几个月的这篇论文

00:19:15.130 --> 00:19:20.080
以前，如果您对此感兴趣，可以在网上找到它，称为

00:19:20.080 --> 00:19:25.180
冲突树复制了Jason数据类型，它说这里有人听说过CRD T

00:19:25.180 --> 00:19:30.640
好的之前，有几个人冷静下来，如果您不知道，这就是CR DT的一个示例

00:19:30.640 --> 00:19:35.740
CR DT是什么，不用担心好吧，本文看起来非常理论化

00:19:35.740 --> 00:19:39.610
在里面看起来像这样，所以我实际上不会经历所有

00:19:39.610 --> 00:19:42.550
今天的操作语义，所以不用担心

00:19:42.550 --> 00:19:46.480
我只是想对算法的工作方式有一个直观的认识

00:19:46.480 --> 00:19:51.580
并只显示其中发生的一些奇怪的边缘情况

00:19:51.580 --> 00:19:55.840
我们在尝试执行此操作时必须考虑的一些内容，但是

00:19:55.840 --> 00:20:00.070
希望该算法将允许人们同时编辑json

00:20:00.070 --> 00:20:06.460
文档并合并这些编辑，最后得到明智的结果，因此

00:20:06.460 --> 00:20:10.150
我们以待办事项清单为例的一个文档例子

00:20:10.150 --> 00:20:14.250
一个人可能只是一个文本文件，所以

00:20:14.970 --> 00:20:21.690
它是一个文本文件，由仅是字符串的文件名组成

00:20:21.690 --> 00:20:26.860
由实际文本的正文字符组成，因此每个人

00:20:26.860 --> 00:20:32.560
角色就像您可以编辑的最小单位，也许有

00:20:32.560 --> 00:20:36.310
格式化设置字体的其他内容，等等，我就离开了

00:20:36.310 --> 00:20:38.470
所有这一切非常有用的另一件事是

00:20:38.470 --> 00:20:42.490
光标位置，例如，如果您使用Google文档，则可以看到

00:20:42.490 --> 00:20:46.450
文档和其他用户现在正在编辑，很方便地看到第三个

00:20:46.450 --> 00:20:50.980
您不会在在线时同时更改同一地点，因此您

00:20:50.980 --> 00:20:55.630
可以想象实现为每个客户的地图都有一个位置

00:20:55.630 --> 00:20:59.260
位置就像文档中的位置，这样您就可以

00:20:59.260 --> 00:21:04.780
跟踪别人的光标，所以我只专注于身体角色

00:21:04.780 --> 00:21:07.900
现在，所以字符的有序列表是

00:21:07.900 --> 00:21:12.790
文档的内容，您可能想知道为什么这就是为什么这是

00:21:12.790 --> 00:21:19.300
字符串而不是字符列表，因此在脚注开始处是字符串列表

00:21:19.300 --> 00:21:25.660
因为在Unicode中，如果您实际上像一个字符一样表示一个或一个

00:21:25.660 --> 00:21:29.920
文档的最小可编辑单位不一定是单个Unicode代码

00:21:29.920 --> 00:21:34.210
点，因为你有像合并标记之类的东西，我认为

00:21:34.210 --> 00:21:38.290
他们被要求重音符号和变音符号以及其他各种东西，或者

00:21:38.290 --> 00:21:43.870
表情符号，我认为肤色注释正在组合标记，所以最终

00:21:43.870 --> 00:21:47.620
由几个Unicode代码点组成的序列，然后构成一个

00:21:47.620 --> 00:21:50.800
如果您对此感兴趣，请从用户角度

00:21:50.800 --> 00:21:55.150
反正Unicode附件编号29和脚注完全无关

00:21:55.150 --> 00:22:01.600
只是想提一提，我也会给我们一些文本编辑器的演示

00:22:01.600 --> 00:22:06.490
之所以实现，是因为让它变得更多一点是一种乐趣

00:22:06.490 --> 00:22:11.760
互动的，所以我在这里是

00:22:11.910 --> 00:22:16.020
不起作用的东西万岁

00:22:19.320 --> 00:22:25.740
抱歉，这一直是演示的问题

00:22:31.410 --> 00:22:36.800
也许它想在Wi-Fi之下好吧，让我们再试一次

00:22:41.530 --> 00:22:49.930
好的，所以这是一个非常基本的文本编辑器，我们使用

00:22:49.930 --> 00:22:54.850
这个数据结构，我们开发的算法，我实际上有两个

00:22:54.850 --> 00:22:58.360
左右两个窗口都是此文本编辑器的实例

00:22:58.360 --> 00:23:07.510
运行，我可以说和，它可以正常工作，所以您可以看到我可以在上面输入内容

00:23:07.510 --> 00:23:11.650
一侧，它出现在另一侧，这两个编辑器实际上是

00:23:11.650 --> 00:23:15.730
通过网络连接进行通信，因此有两个单独的过程

00:23:15.730 --> 00:23:18.850
否则不共享任何东西，因此他们可以轻松地放在两个不同的位置

00:23:18.850 --> 00:23:25.900
世界其他地方的计算机都没问题，我现在能做的是

00:23:25.900 --> 00:23:32.440
杀死服务器，以便他们在此处使用WebSocket服务器进行通信，并且当我

00:23:32.440 --> 00:23:35.830
杀死服务器，我正在模拟的是两者之间的网络交互

00:23:35.830 --> 00:23:39.670
现在两个编辑器都处于离线状态，所以这可能是因为实际上这是一台服务器

00:23:39.670 --> 00:23:43.060
中断或仅仅是因为客户失去了互联网连接

00:23:43.060 --> 00:23:54.100
没什么关系，所以我可以继续离线编辑，所以在这里说

00:23:54.100 --> 00:23:57.010
我要打招呼，大家去柏林，你会发现它没有出现在

00:23:57.010 --> 00:24:06.160
右侧，因为它们处于离线状态，所以我们现在有这两个，所以

00:24:06.160 --> 00:24:09.910
我现在要重新启动服务器，我们想要的是所有这些更改

00:24:09.910 --> 00:24:15.580
保留了鸦片，所以请确保每个人都还在并希望

00:24:15.580 --> 00:24:19.840
你们一切都还不错，所以当我重新启动服务器时，编辑器

00:24:19.840 --> 00:24:24.640
后台继续尝试自动重新连接到服务器并保持

00:24:24.640 --> 00:24:28.450
在后台重试，最终他们将设法连接

00:24:28.450 --> 00:24:32.170
并重新同步，现在您看到的每个人都已经从

00:24:32.170 --> 00:24:35.350
从左到右，我希望你一切都好，已经从

00:24:35.350 --> 00:24:40.390
从右到左，我们没有任何类似的三向合并用户界面

00:24:40.390 --> 00:24:47.140
就像这样，它只是自动执行此操作现在让我们看一下

00:24:47.140 --> 00:24:51.190
算法实际上有效，因为这很有意思，这基本上是

00:24:51.190 --> 00:24:54.800
与Google文档正确执行的操作相同

00:24:54.800 --> 00:24:58.400
Google文档对其离线支持有点挑剔，但是如果您将其强制设置为

00:24:58.400 --> 00:25:04.520
实际上，它实际上执行了相同类型的合并，因此我可以运行

00:25:04.520 --> 00:25:11.870
通过更好地了解Google文档中算法的工作原理，想象一下您有一个

00:25:11.870 --> 00:25:16.880
由字母HDL和O组成的文档，并用

00:25:16.880 --> 00:25:22.280
它是什么位置的索引，所以0 1 3 3在左侧，我们得到了

00:25:22.280 --> 00:25:25.940
右侧的绿色编辑器我们有紫色的编辑器，每个

00:25:25.940 --> 00:25:30.020
编辑器现在对此进行编辑，因此左侧插入第二个L

00:25:30.020 --> 00:25:35.480
字符将其更改为“ hello”，右侧插入感叹号

00:25:35.480 --> 00:25:42.110
标记的最后使其成为基耶洛感叹号，所以现在我们要

00:25:42.110 --> 00:25:45.560
合并同时发生的这两个更改，因此为了

00:25:45.560 --> 00:25:52.700
做到了，我们拥有此服务器-在这种情况下，该服务器由Google和客户端运行

00:25:52.700 --> 00:25:58.460
本质上发送差异或类似操作来记录要更改的内容

00:25:58.460 --> 00:26:02.630
用户进行了更改，并将该操作发送到服务器

00:26:02.630 --> 00:26:09.110
所以左侧说在位置3插入L，所以您看到0 1 2 3 4

00:26:09.110 --> 00:26:14.840
插入L，这样宣誓就从位置3移到了位置4，所以我们

00:26:14.840 --> 00:26:19.070
在那插入L，在这一边，我们有插入感叹号

00:26:19.070 --> 00:26:24.290
在位置4，因此描述了所做的更改，现在

00:26:24.290 --> 00:26:29.210
服务器将这些更改转发给另一个客户端，因此绿色更改

00:26:29.210 --> 00:26:34.250
插入L被服务器转发到此处，在位置3插入L

00:26:34.250 --> 00:26:38.750
位置3在这里是正确的位置，所以您最后会出现一个感叹号

00:26:38.750 --> 00:26:42.950
这是我们想要的，但是如果您考虑其他情况会发生什么

00:26:42.950 --> 00:26:48.860
方向，因此如果我们简单地发送，则在位置4插入感叹号

00:26:48.860 --> 00:26:55.160
通过不变，我们将得到地狱感叹号OH，因为

00:26:55.160 --> 00:27:02.510
在这里我们在位置3插入了字母L，所以O沿着插脚3移动

00:27:02.510 --> 00:27:06.440
到4，所以我们真的需要更改它，以在其中插入感叹号

00:27:06.440 --> 00:27:09.730
位置5，只有这样我们才能获得正确的位置

00:27:09.730 --> 00:27:16.210
带有感叹号的结果，所以这里要发生的是

00:27:16.210 --> 00:27:20.080
该位置需要更改为位置5，因为

00:27:20.080 --> 00:27:25.300
同时在位置3插入一个，因此服务器必须跟踪所有位置

00:27:25.300 --> 00:27:29.260
这些不同的事物同时发生，它必须转变

00:27:29.260 --> 00:27:33.040
重写这三到四条消息的一些转换发生了

00:27:33.040 --> 00:27:36.280
在客户端上也是如此，但是该算法实际上取决于

00:27:36.280 --> 00:27:40.090
服务器也可以做一些工作，并且可以工作，因此将该算法称为

00:27:40.090 --> 00:27:44.410
运营转型已经存在了很长一段时间，所以这是第一个

00:27:44.410 --> 00:27:49.410
在1980年代的学术文献中进行了讨论，尽管第一次

00:27:49.410 --> 00:27:53.920
提出此算法的论文实际上是不正确的，他们在

00:27:53.920 --> 00:27:57.700
他们说他是我们算法失败的案例可以提供帮助

00:27:57.700 --> 00:28:01.090
有人请帮助我们修复它，然后几个人研究人员出现了

00:28:01.090 --> 00:28:06.309
并提出了可行的解决方案，并且有几种不同的解决方案

00:28:06.309 --> 00:28:10.870
那里有许多竞争算法，是大多数现代运算法则

00:28:10.870 --> 00:28:16.840
基于转换的系统是从1995年开始被称为Jupiter的一种继承

00:28:16.840 --> 00:28:21.640
就像Google文档和etherpad基于Google Wave一样

00:28:21.640 --> 00:28:27.220
现在是Apache Wave，他们都使用Jupiter设计，即使用

00:28:27.220 --> 00:28:31.570
进行某些转换的中央服务器，而其他一些则不

00:28:31.570 --> 00:28:34.860
使用中央服务器，而是跟踪某种多维

00:28:34.860 --> 00:28:39.040
他们同时要求同时进行的所有编辑的超立方体

00:28:39.040 --> 00:28:42.880
大量的内存，其中一些算法，这就是为什么不使用它们的原因

00:28:42.880 --> 00:28:48.850
经常在实践中使用，因此对于Google而言，这种工作方式很好，但是

00:28:48.850 --> 00:28:53.500
记住我们想要的是能够使用端到端加密等

00:28:53.500 --> 00:28:56.950
在这种情况下，我们无法让服务器转换我们的消息，因为

00:28:56.950 --> 00:29:00.070
然后，服务器将不得不查看消息的内容，我们想要什么

00:29:00.070 --> 00:29:04.540
我们想要的是，我们要避免使用一台中央服务器，因为那是一台

00:29:04.540 --> 00:29:07.990
故障点，我们希望避免服务器看到我们的内容

00:29:07.990 --> 00:29:12.460
消息，所以我们希望能够转发消息，这就是C

00:29:12.460 --> 00:29:17.380
 Rd T进来，所以C Rd T代表可交换

00:29:17.380 --> 00:29:21.429
不对不起，冲突树复制了数据类型，这有点麻烦

00:29:21.429 --> 00:29:24.030
白人只是说首席执行官的职责，

00:29:24.030 --> 00:29:28.990
本质上，这是一组数据结构，其中几个节点可以

00:29:28.990 --> 00:29:33.850
同时更改数据，它们可以自动合并，因此

00:29:33.850 --> 00:29:37.540
作为合并的数据结构定义的一部分

00:29:37.540 --> 00:29:41.740
函数或允许您以不同顺序应用操作的函数

00:29:41.740 --> 00:29:47.170
并在最后仍然获得相同的结果，如果我们要建模

00:29:47.170 --> 00:29:53.280
就像我在编辑器示例中的文本文档一样，

00:29:53.280 --> 00:29:58.210
有序的字符列表，因此我们想要的数据类型是有序的

00:29:58.210 --> 00:30:02.770
列表，并提出了几种不同的算法，它们是

00:30:02.770 --> 00:30:07.110
直到最近十年，这些事情才出现，

00:30:07.110 --> 00:30:11.710
我现在要描述的内容以及我们基于文本编辑器的内容称为我们的

00:30:11.710 --> 00:30:17.970
GA于2011年从韩国研究小组中复制了可生长阵列

00:30:17.970 --> 00:30:24.340
因此，让我向您展示一下这是如何工作的，简而言之，

00:30:24.340 --> 00:30:29.740
示例文档，这是一个基洛，但是现在不用给每个字母

00:30:29.740 --> 00:30:35.170
只是一个索引0 1 2 3我要给它一个唯一的标识符，每个字母都有一个

00:30:35.170 --> 00:30:41.890
唯一标识符，可能只是0 a 1 a 2 a 3 a，我们现在具有相同的标识符

00:30:41.890 --> 00:30:45.340
如果您插入字母L，则在左侧进行编辑，而在右侧则进行编辑

00:30:45.340 --> 00:30:50.710
手边插入感叹号，每次插入新字母时，

00:30:50.710 --> 00:30:55.300
必须为该字母组成一个新的标识符，我们将有一个

00:30:55.300 --> 00:30:59.440
我们如何创建新标识符的小规则，因此我们必须使用它们

00:30:59.440 --> 00:31:04.540
具有全球唯一性，而且还必须具有一定的订购属性，因此

00:31:04.540 --> 00:31:08.320
我们将按照以下方式构造它们：每个标识符一个数字和一个字母

00:31:08.320 --> 00:31:14.710
对于这个数字，我们选择一个比我们拥有的最大数字大一的数字

00:31:14.710 --> 00:31:19.270
文档，因此文档服务器文件包含0 2 3作为数字，因此

00:31:19.270 --> 00:31:23.920
我们要选择的下一个数字是4，然后我们称之为左边的是节点a

00:31:23.920 --> 00:31:27.760
右边的是节点B，因此这将是我们用于

00:31:27.760 --> 00:31:33.130
标识符，因此，如果我们假设节点的名称是唯一的，那么

00:31:33.130 --> 00:31:35.330
没有其他节点称为a只有一个节点

00:31:35.330 --> 00:31:41.180
他们，此外，我们假设这些数字是通过

00:31:41.180 --> 00:31:45.440
一加一个我们拥有的最大值，因此每个节点的数目将始终是唯一的

00:31:45.440 --> 00:31:49.820
所以这意味着我们在左侧生成a，在右侧生成B

00:31:49.820 --> 00:31:53.570
手侧是相同的，因为它们都在同一开始

00:31:53.570 --> 00:31:57.530
位置，但是它们有两个不同的节点ID，所以我们得到两个不同的

00:31:57.530 --> 00:32:04.370
标识符等，因此可以正常工作，现在我们可以通过我们的服务器或

00:32:04.370 --> 00:32:07.430
甚至不必是通过对等网络访问的服务器，或者

00:32:07.430 --> 00:32:10.370
您还喜欢其他任何东西，为了简单起见，我将在这里使用服务器

00:32:10.370 --> 00:32:16.430
而不是在特定位置插入，我们现在要说插入L

00:32:16.430 --> 00:32:21.050
我们要说的是新生命的新ID，

00:32:21.050 --> 00:32:25.610
要说的是，我们要通过在位置a之后插入来插入它，因此2a是

00:32:25.610 --> 00:32:31.940
第一个L，因此带有a的新L在2a之后插入，另一个在

00:32:31.940 --> 00:32:36.290
侧面，我们在三个三四之后插入感叹号3a是

00:32:36.290 --> 00:32:41.600
字母O，因此在之后插入带有ID的感叹号B

00:32:41.600 --> 00:32:46.250
三个表示在di后面加上感叹号的方法，这样我们现在就可以负担得起

00:32:46.250 --> 00:32:52.070
消息，因此将L插入2a 2a之后，此处仍然表示第一个L，因此

00:32:52.070 --> 00:32:57.050
将第二个L放在正确的位置，并给它一个ID，并在

00:32:57.050 --> 00:33:01.700
另一边，我们可以接受此消息，然后在感叹号中应用该消息

00:33:01.700 --> 00:33:06.950
即使我们插入了字母L，三个a 3a仍然是字母O

00:33:06.950 --> 00:33:12.110
在它没有改变之前，字母O的ID仍然是3a，并且

00:33:12.110 --> 00:33:16.940
所以我们可以在字母O之后的四个字母O后面加上4b的感叹号

00:33:16.940 --> 00:33:19.700
3a，所以我们最终得到相同的文档

00:33:19.700 --> 00:33:23.450
在两个地方都很好，我们现在可以拥有某种网络

00:33:23.450 --> 00:33:27.440
在这两者之间，它不必以任何方式转换消息

00:33:27.440 --> 00:33:30.710
只需确保它不断重试，最终消息就可以了

00:33:30.710 --> 00:33:35.510
通过这些，我们需要在这里加密它们，现在一切都非常好

00:33:35.510 --> 00:33:38.210
该算法仍然存在问题，我想知道是否有人可以

00:33:38.210 --> 00:33:44.300
是的，删除是一件事，是的，我的删除是

00:33:44.300 --> 00:33:48.410
实际上很容易，所以我们要做的删除操作就是为每个

00:33:48.410 --> 00:33:51.980
ID，说如果删除了该ID

00:33:51.980 --> 00:33:56.630
实际上仍然在那里秘密地隐藏着，但是我们要说的是，这个o

00:33:56.630 --> 00:34:01.400
现在不见了，所以不要在称为逻辑删除的用户界面中显示它

00:34:01.400 --> 00:34:06.350
完全有另一个相同的位置，所以两个人同时插入的位置

00:34:06.350 --> 00:34:18.710
位置，让我们有一个更简单的示例文档，是ID为1 a 2 a 3 a的ABC

00:34:18.710 --> 00:34:24.919
现在假设x和y插入到了A和B之间，因此左手

00:34:24.919 --> 00:34:28.879
边插入X和y根据我的规则给他们两个新的ID

00:34:28.879 --> 00:34:37.100
前面指定的是4a和5a，所以这意味着插入X

00:34:37.100 --> 00:34:42.859
在a之后的y之后，在a的右侧插入另一边

00:34:42.859 --> 00:34:48.889
我将插入P和Q，我们将再次使用相同的规则进行分配

00:34:48.889 --> 00:34:54.800
ID，因此它们的ID为4b和5b，它们也出现在a和B之间，

00:34:54.800 --> 00:34:58.640
现在我们需要确保所有这些字母都以某种形式出现

00:34:58.640 --> 00:35:02.300
之后，两个节点上的顺序一致

00:35:02.300 --> 00:35:07.790
操作并将其应用于另一端，因此请插入带有B的新ID的P

00:35:07.790 --> 00:35:14.510
在1 a 1 a之后是第一个字母a，因此我们在其中插入P，然后使用

00:35:14.510 --> 00:35:20.119
在4 B 4 B之后ID为5 B的字母

00:35:20.119 --> 00:35:25.760
插入，以便我们可以输入密钥B的字母P是P

00:35:25.760 --> 00:35:36.920
带5 B的Q跟随4 B，所以我们放了一个PQXYB BC，所以现在可以找到

00:35:36.920 --> 00:35:40.700
到目前为止，我们需要确保另一方面

00:35:40.700 --> 00:35:46.160
以相同的事物结束，因此我们需要确保x在此之后结束

00:35:46.160 --> 00:35:51.350
PQ，但在B之前，因为如果我们将X放在此处，则2将是

00:35:51.350 --> 00:35:56.630
不一致，所以我们现在该怎么做，因为该消息将是

00:35:56.630 --> 00:36:02.240
同样的消息只是将ID为1的X插入X，但是如果

00:36:02.240 --> 00:36:06.220
我们将其放置在1a之后，然后将X移到此处，我们

00:36:06.220 --> 00:36:10.750
有一个不一致的地方，所以我将介绍一个使用

00:36:10.750 --> 00:36:18.040
这些ID，那就是查找传入操作的ID，是的，

00:36:18.040 --> 00:36:21.579
在这种情况下，应用来自不同节点的操作是为了

00:36:21.579 --> 00:36:26.349
a是传入操作，因此我们首先找到位置

00:36:26.349 --> 00:36:31.270
我们要在此处插入一个a，因此我们在a之后开始，然后看一下

00:36:31.270 --> 00:36:38.680
next，该列表中下一个元素的ID，用于B，并且该ID

00:36:38.680 --> 00:36:43.359
这里B大于a的传入元素ID，然后我们将

00:36:43.359 --> 00:36:48.730
跳过它，如果它更大，那么下一个更大，我们将再次

00:36:48.730 --> 00:36:53.440
跳过它，我们一直跳过，直到找到一个更少的元素

00:36:53.440 --> 00:36:59.230
大于输入操作的ID，因此2 a小于4 a，因此按此顺序

00:36:59.230 --> 00:37:03.910
这里我们先看数字，然后是后者，所以这里B大于

00:37:03.910 --> 00:37:08.500
因为B大于5 B肯定大于因为5

00:37:08.500 --> 00:37:13.359
大于4但2小于4，所以我们现在知道必须在

00:37:13.359 --> 00:37:18.549
5 B和a 2 a whoo，然后进行最后的操作是

00:37:18.549 --> 00:37:25.059
其实很容易，所以插入ID为5 a的Y在一段时间之后a就是5

00:37:25.059 --> 00:37:28.930
年龄追赶它，那行得通，如果您想知道在这里跳过

00:37:28.930 --> 00:37:34.630
不适用于此侧，因为此处B的for大于4 a，所以当我们

00:37:34.630 --> 00:37:40.390
在这里为B插入了这个，我们没有跳过a，因为4 B大于4

00:37:40.390 --> 00:37:46.150
所以这实际上是有效的，您有点必须实际证明它

00:37:46.150 --> 00:37:49.630
从数学上说服自己，这确实适用于所有情况，但我们有

00:37:49.630 --> 00:37:54.339
证明了这一点，所以我们实际上相信了这一点，因此Parral现在有了一个

00:37:54.339 --> 00:37:58.750
算法，这将使我们能够同时进行这些更改，而无需进行任何操作

00:37:58.750 --> 00:38:03.190
没有任何协调的转型，只是让我们最终陷入同一困境

00:38:03.190 --> 00:38:09.490
位置，所以我们说我们的文档是大家好，我们认为那不是

00:38:09.490 --> 00:38:12.849
一般性别中立，所以一个人将其更改为嘿

00:38:12.849 --> 00:38:16.330
每个人和另一个人都将改变它以支付给人们

00:38:16.330 --> 00:38:21.430
现在我们的编辑器在这种情况下会做什么，所以我刚才介绍了删除的方式

00:38:21.430 --> 00:38:26.380
起作用，因此删除仅意味着在其上设置一个标志，以便两个人可以

00:38:26.380 --> 00:38:30.610
目前删除相同的字母，他们都删除了男人的G

00:38:30.610 --> 00:38:34.600
一次删除与两次删除相同，不再删除

00:38:34.600 --> 00:38:40.450
通过被删除几次，使这些字母被删除，

00:38:40.450 --> 00:38:45.310
插入停留，因为一个插入并不能替代另一个插入，所以在

00:38:45.310 --> 00:38:50.080
至少要合并的结果是两个插入

00:38:50.080 --> 00:38:55.000
串联起来，这样每个人都会嘿嘿，或者也许每个人都会嘿

00:38:55.000 --> 00:38:59.350
每个人，所以这两个的顺序是任意的，仅取决于

00:38:59.350 --> 00:39:04.090
网络巧合的巧合，您知道

00:39:04.090 --> 00:39:08.260
没有一个命令比另一个命令更好，问题是

00:39:08.260 --> 00:39:11.920
只是我们这里每个人所拥有的不是一个英文单词，所以

00:39:11.920 --> 00:39:15.880
您最终会在文档中出现垃圾，但这实际上是

00:39:15.880 --> 00:39:19.630
Google文档的功能也不错，因此，我现在想说的是，我们会

00:39:19.630 --> 00:39:24.130
告诉用户，这里没有通过拼写检查，而是

00:39:24.130 --> 00:39:27.880
也许我们可以弹出警告说，嘿，几个人在

00:39:27.880 --> 00:39:30.940
实际的Google文档在同一地方甚至都没有这样做，只是警告它

00:39:30.940 --> 00:39:35.170
让人们自己被发现，似乎在实践中起作用，所以我

00:39:35.170 --> 00:39:38.230
认为在这一点上，我们只是说好吧，就足够了，我们将不尝试

00:39:38.230 --> 00:39:41.740
对句子进行语法分析并进行合并

00:39:41.740 --> 00:39:46.000
自动使他们服从英语语法，因为那样就不会

00:39:46.000 --> 00:39:52.620
工作实际上人们已经尝试过了，但是它根本没有用，所以我们得到了这个

00:39:52.620 --> 00:39:56.830
CR DT此数据结构用于有序列表，几个人可以在其中更改

00:39:56.830 --> 00:40:02.110
同时描述了删除操作以及如何删除仍然有很多空白

00:40:02.110 --> 00:40:05.920
问题在那里，所以这里删除的问题是我们实际上需要

00:40:05.920 --> 00:40:11.590
记得很长一段时间之后，太平洋的特定ID是因为

00:40:11.590 --> 00:40:15.730
我们将这些ID用作列表中的位置，例如指针和

00:40:15.730 --> 00:40:20.140
所以我们不能只是删除如果某些内容从文档中删除，我们就无法删除

00:40:20.140 --> 00:40:23.200
然后将其删除，然后完全忘记它，因为然后进行一些操作

00:40:23.200 --> 00:40:29.170
将进入并在503 a之后插入，而我们在503中删除了对不起，我

00:40:29.170 --> 00:40:32.710
在哪里放置插入内容，所以我们必须保留那些被称为

00:40:32.710 --> 00:40:37.630
墓碑也没有谈论过如何撤消，就像您知道控制Zed一样

00:40:37.630 --> 00:40:41.559
键入undo或如何对列表中的元素重新排序，这很有趣

00:40:41.559 --> 00:40:45.010
或如何提高所有这些ID的效率，以免花费太多时间

00:40:45.010 --> 00:40:49.869
存储，所以还有很多悬而未决的问题，我认为基本算法是

00:40:49.869 --> 00:40:52.720
很好，但实际上将其付诸实践仍需要

00:40:52.720 --> 00:40:57.099
有点工作，但实际上我也想谈一些其他的事情，所以我们

00:40:57.099 --> 00:41:02.470
早些时候谈论这些JSON文档，所以发生了有趣的事情

00:41:02.470 --> 00:41:07.660
当前有几个人可以更改仅在以下情况下不会发生的JSON文档

00:41:07.660 --> 00:41:12.430
以文本文档为例，假设我们已经到了这里，这是人为的

00:41:12.430 --> 00:41:18.190
例如，我怕有一张颜色贴图，所以可以想象这是一个实际的

00:41:18.190 --> 00:41:24.549
结构，所以它不像大括号引号c / o et cetera作为文本

00:41:24.549 --> 00:41:29.290
文档，但这实际上是JSON语法树，就在这里，所以一个

00:41:29.290 --> 00:41:34.299
有人在地图中插入了一种新的颜色，即红色，因此您最终选择了

00:41:34.299 --> 00:41:41.230
一张包含蓝色和红色的地图，而另一个人同时决定

00:41:41.230 --> 00:41:44.859
实际上，他们希望清除地图的全部内容，因此将其设置为

00:41:44.859 --> 00:41:52.180
空的地图，然后将绿色添加到地图中，那么我们现在如何全部合并

00:41:52.180 --> 00:41:58.540
这些同时发生的并发变化是怎么回事

00:41:58.540 --> 00:42:02.559
结果在这里什么是正确的行为，我们期望什么？

00:42:02.559 --> 00:42:06.760
我们可以系统地思考它，然后说好吧，蓝色是否包含蓝色

00:42:06.760 --> 00:42:11.890
通过将整个地图设置为空，右侧的蓝色被删除了

00:42:11.890 --> 00:42:16.299
所以我猜蓝色不应该出现在最终结果中，因为它已被删除，

00:42:16.299 --> 00:42:20.410
左手，所以我没碰它，那红，红，红最初并没有

00:42:20.410 --> 00:42:24.369
存在，但已插入到左侧的右侧和右侧

00:42:24.369 --> 00:42:28.900
我没有碰到红色，所以我想我们需要红色才能达到最终结果

00:42:28.900 --> 00:42:33.040
关于绿色绿色插入在右侧，未被触摸

00:42:33.040 --> 00:42:36.549
在左侧，是的，我们希望绿色出现在最终结果中，所以我们

00:42:36.549 --> 00:42:41.589
最终的预期结果是它应该包含红色和绿色，但不能包含蓝色

00:42:41.589 --> 00:42:47.359
这似乎是我的猜测，因此我们可以做到这一点，

00:42:47.359 --> 00:42:51.590
算法做到这一点，这意味着在这里我们必须跟踪什么

00:42:51.590 --> 00:42:58.580
将此地图设置为空意味着，因为如果您只是接受这个并说

00:42:58.580 --> 00:43:04.070
左边的客户首先添加红色，然后进行更改

00:43:04.070 --> 00:43:07.670
是从右侧将地图设置为空的，如果您

00:43:07.670 --> 00:43:11.390
只是天真地套用它，说你已经将他的设置图操作为空

00:43:11.390 --> 00:43:15.650
好吧，您将要擦除红色，因为添加了红色

00:43:15.650 --> 00:43:20.000
同时发生，因此我们必须以某种方式记住地图的状态

00:43:20.000 --> 00:43:25.790
当您将其设置为空时，我们在这里有一个东西被称为

00:43:25.790 --> 00:43:29.960
因果上下文或诸如react之类的数据库中的类似内容具有

00:43:29.960 --> 00:43:35.420
任何使用过的人都会说他们具有这种数据类型功能，很好

00:43:35.420 --> 00:43:39.320
与此类似，您还有一些额外的信息

00:43:39.320 --> 00:43:44.180
在HTTP标头中传递，其目的是跟踪

00:43:44.180 --> 00:43:49.280
什么是状态您看到文件时文件的状态是什么

00:43:49.280 --> 00:43:54.859
这样一来，您以后便知道需要应用哪些更改，因此让我们来看一下

00:43:54.859 --> 00:43:59.690
在另一个示例中，我们再次得到了我们的待办事项列表示例，

00:43:59.690 --> 00:44:04.460
我们已经买了牛奶，但牛奶还没有完成，所以在左侧，

00:44:04.460 --> 00:44:08.960
编辑发生，它只是从列表中删除了购买牛奶，因为它可能是

00:44:08.960 --> 00:44:12.080
做完了，或者我们知道不再需要牛奶或仅仅是牛奶了

00:44:12.080 --> 00:44:17.450
从右侧列表中删除有人将其设置为true，因此点击

00:44:17.450 --> 00:44:22.970
说购买牛奶的按钮确实做到了，如果我们尝试

00:44:22.970 --> 00:44:28.099
合并这两个不同的更新，我们可以像现在一样应用相同的逻辑

00:44:28.099 --> 00:44:33.260
带有嵌套的小睡的颜色，所以带有颜色，我们说的还可以

00:44:33.260 --> 00:44:37.580
它是否包含每个不同的内容，具体取决于谁编辑了

00:44:37.580 --> 00:44:42.020
因此，在左侧购买牛奶的标题已被删除，因为我们

00:44:42.020 --> 00:44:45.890
删除了整个待办事项，所以我猜标题不应该出现在

00:44:45.890 --> 00:44:50.480
右边我们没有碰到标题，所以必须删除

00:44:50.480 --> 00:44:55.820
关于做过的错误做得好的错误在左侧被删除

00:44:55.820 --> 00:44:58.130
写在右边

00:44:58.130 --> 00:45:01.940
正确完成，所以我猜错误完成了

00:45:01.940 --> 00:45:05.510
完成true不正确没有出现在左侧和右侧

00:45:05.510 --> 00:45:10.640
添加了side done true，所以最终结果我们并没有做到true

00:45:10.640 --> 00:45:14.960
如果我们应用完全相同的推理逻辑，我们最终要做的就是

00:45:14.960 --> 00:45:21.380
甘蔗中包含标记为true的项目，但没有标题，这是一种

00:45:21.380 --> 00:45:26.510
不是您所期望的，因为像我们已经应用了完全相同的逻辑，但是

00:45:26.510 --> 00:45:31.220
我们最终得到的是看起来很奇怪而且看起来很奇怪的东西，因为

00:45:31.220 --> 00:45:35.180
我们有点在这里有这个隐式模式，我们希望做的事情总是

00:45:35.180 --> 00:45:40.310
有标题和完成字段，但此合并本质上已篡改

00:45:40.310 --> 00:45:45.080
我们的架构，所以我们在这里做什么，也许我们需要一个架构来明确地说

00:45:45.080 --> 00:45:50.000
确切地说，某些东西必须具有什么领域，但在那种情况下，我们该怎么做

00:45:50.000 --> 00:45:53.990
如果有人改变我们在具有以下特征的对象中的字段，则有人会改变

00:45:53.990 --> 00:45:59.450
模式，然后另一个人很好地删除了整个对象，我们说

00:45:59.450 --> 00:46:02.990
删除将获胜，因此在这种情况下，对内容的任何更改

00:46:02.990 --> 00:46:06.830
被删除的项目中的内容只会丢失，但我们之前说过，我们不会

00:46:06.830 --> 00:46:12.140
想丢失数据，那么我们该如何解决呢？

00:46:12.140 --> 00:46:15.770
有人同时更改此设置并将其设置为true，那么我们实际上是

00:46:15.770 --> 00:46:19.100
也将带回标题，即使标题实际上是

00:46:19.100 --> 00:46:23.600
在左侧删除，我们有点复活了整个删除的项目，

00:46:23.600 --> 00:46:29.600
说好吧，这将回到标题并完成，但随后我们

00:46:29.600 --> 00:46:32.920
忘记有人删除了这个项目，所以好像

00:46:32.920 --> 00:46:37.550
有些东西必须在这里提供，我们真的不知道这是什么，我们可以

00:46:37.550 --> 00:46:41.960
说，也许覆盖具有空地图的内容不应该具有

00:46:41.960 --> 00:46:46.100
与删除它的语义相同，然后我们再次添加它，或者它应该

00:46:46.100 --> 00:46:49.850
具有相同的语义，所以恐怕这将以一点点结束

00:46:49.850 --> 00:46:55.840
令人沮丧的音符，就像我们根本不知道如何暴露这些

00:46:55.840 --> 00:47:00.560
同时编辑应用程序中的数据结构的方式不是

00:47:00.560 --> 00:47:05.000
令人困惑的是，所以我认为我认为其中有很多价值

00:47:05.000 --> 00:47:08.330
具有这些数据结构，您可以自动合并

00:47:08.330 --> 00:47:12.560
不必编写手动冲突解决方案

00:47:12.560 --> 00:47:18.590
代码，但是即使您抽象出这样的方式，但同时并发仍然很困难

00:47:18.590 --> 00:47:21.560
可以进行颜色和通讯，还有您遇到的所有问题

00:47:21.560 --> 00:47:26.990
有些时候您有时可以在这些合并的情况下结束多长时间，

00:47:26.990 --> 00:47:32.540
没有一个正确的方法来做，所以如果你们当中有人有我想做的想法

00:47:32.540 --> 00:47:37.120
听到完成，否则我们将继续努力，只是尝试不同的方法

00:47:37.120 --> 00:47:42.860
方法看哪种API对开发人员有意义，我们可以回到

00:47:42.860 --> 00:47:47.150
过去的糟糕日子，说好吧，我们将要遇到这种糟糕的情况

00:47:47.150 --> 00:47:50.990
我们只是要让用户手动解决所有修改，我认为

00:47:50.990 --> 00:47:54.440
这对用户真的很友好，所以我认为就像事物的普及

00:47:54.440 --> 00:48:00.620
像Google文档，甚至喜欢融合或类似的解决冲突的东西

00:48:00.620 --> 00:48:06.800
它表明实际上人们确实需要一些工具和帮助才能

00:48:06.800 --> 00:48:10.160
为了解决冲突，我们可以说好吧，我们将所有内容放到

00:48:10.160 --> 00:48:14.270
中央服务器并序列化所有的选项-但是我们又得到了

00:48:14.270 --> 00:48:17.840
您一直需要网络通信的问题，这是

00:48:17.840 --> 00:48:21.650
东西不能离线工作，这也是一个耻辱，所以我认为值得工作

00:48:21.650 --> 00:48:25.700
关于这个问题，但是如果您对更多感兴趣，这是一个开放的问题

00:48:25.700 --> 00:48:30.050
有关此内容的详细信息，我已经在这里发布了推文，以便您可以找到

00:48:30.050 --> 00:48:34.790
那里有所有论文的链接，这里是第二页，这里是

00:48:34.790 --> 00:48:38.840
第三页参考文献，因此我们的论文是其中的其中之一

00:48:38.840 --> 00:48:42.140
还有其他一些关于不同的CR职责和不同

00:48:42.140 --> 00:48:47.750
运营转型职能，因此涉及大量细节

00:48:47.750 --> 00:48:51.980
这是我一直在写的书，我刚寄给出版商

00:48:51.980 --> 00:48:56.750
就在两天前，因此您可以早早在线获得此版本

00:48:56.750 --> 00:49:00.170
这不是特别要合并，这是一种非常广泛的

00:49:00.170 --> 00:49:04.760
数据库体系结构介绍以及数据库在做什么

00:49:04.760 --> 00:49:09.440
引擎盖也是如此，如果您对这种事情感兴趣，我会尽量

00:49:09.440 --> 00:49:13.130
检查一下，如果您对此有任何想法，也许可以给我任何反馈

00:49:13.130 --> 00:49:16.550
非常感谢您的光临，我希望您有一个

00:49:16.550 --> 00:49:28.300
大会剩余时间[鼓掌]

00:49:28.630 --> 00:49:34.130
您有1到2分钟的时间问问题吗，我还没来得及

00:49:34.130 --> 00:49:40.369
好的，有人对我们有任何疑问或意见吗？

00:49:40.369 --> 00:49:46.280
应用程序是正确的，所以问题是除了操作之外的推杆

00:49:46.280 --> 00:49:50.000
变换算法是否有使用加权运算符的算法

00:49:50.000 --> 00:49:53.660
决定最后一个操作，例如删除操作具有

00:49:53.660 --> 00:50:00.799
损失的最小影响是它们的权重，也许是神经网络

00:50:00.799 --> 00:50:08.210
可能的概率使决策更快，因此您可以使用加权，但

00:50:08.210 --> 00:50:14.420
不能从根本上解决问题，那就是您最终可能

00:50:14.420 --> 00:50:17.359
然后在某些情况下，您陷入僵局，

00:50:17.359 --> 00:50:22.130
有两件事具有相同的权重，其中之一必须获胜，所以

00:50:22.130 --> 00:50:26.660
然后，您可以任意决定一件事是否应该战胜另一件事，如此

00:50:26.660 --> 00:50:32.630
这就是我在像您这样的权衡中得到的结果

00:50:32.630 --> 00:50:37.190
可以在模式中指定某种语义注释，说我们

00:50:37.190 --> 00:50:41.119
要删除赢还是我们要更新赢的问题是

00:50:41.119 --> 00:50:45.349
我认为很难与开发人员进行交流，例如

00:50:45.349 --> 00:50:47.750
真正的意思是如果您没有分布式博士学位

00:50:47.750 --> 00:50:51.589
系统，您仍然能够了解您的模式中的此标志

00:50:51.589 --> 00:50:56.950
其实意味着，我认为以某种方式使事物易于理解

00:50:56.950 --> 00:51:00.619
您可以去构建一个应用程序的人，而他们不必知道

00:51:00.619 --> 00:51:05.569
内部如何解决冲突的所有内部细节，我

00:51:05.569 --> 00:51:09.859
认为会很好，所以也许优先事项是一种方法

00:51:09.859 --> 00:51:13.579
这样做，但我不确定另一个问题是我是怎么做的

00:51:13.579 --> 00:51:19.760
我的幻灯片是使用iPad的，我使用名为iPad的应用程序手工绘制了它们

00:51:19.760 --> 00:51:27.000
一家名为53的公司的论文好的，非常感谢您的光临

00:51:27.000 --> 00:51:29.060
你

