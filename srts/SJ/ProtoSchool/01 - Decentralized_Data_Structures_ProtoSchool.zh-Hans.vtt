WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.600 --> 00:00:07.359
大家好，欢迎来到今天的项目学校

00:00:07.359 --> 00:00:10.480
分散数据结构研讨会

00:00:10.480 --> 00:00:15.839
在这里我们将学习如何使用集中式数据结构

00:00:15.839 --> 00:00:20.880
应用于ipfs网络上，我希望到年底

00:00:20.880 --> 00:00:25.519
此事件使您了解了哈希加密的好处，即哈希加密

00:00:25.519 --> 00:00:28.960
关于解决多少文化以及如何工作的内容

00:00:28.960 --> 00:00:33.280
对角集中的是循环图功率对等

00:00:33.280 --> 00:00:38.800
像ipfs这样的网络，但是在我们开始之前，只有几个

00:00:38.800 --> 00:00:42.399
请注意，此事件遵守ipfs

00:00:42.399 --> 00:00:47.840
非洲社区行为准则，我们热衷于促进开放和

00:00:47.840 --> 00:00:51.360
我们的参与者热情的环境，所以我们很高兴有

00:00:51.360 --> 00:00:54.960
如果您在此期间有任何疑问，也请大家在这里

00:00:54.960 --> 00:00:58.719
演示文稿，请留下他们的评论，我们继续讨论

00:00:58.719 --> 00:01:03.440
一路走来，也许您会得到一个答案

00:01:03.440 --> 00:01:07.760
其他一些社区成员，所以今天晚上的议程

00:01:07.760 --> 00:01:12.240
我们将介绍um的简要介绍，以介绍如何制作学校

00:01:12.240 --> 00:01:15.520
关于农产品学校的任务和简要介绍

00:01:15.520 --> 00:01:20.799
我自己，那么我们将深入研究分散的数据结构

00:01:20.799 --> 00:01:24.560
以及它们当前如何在web3上实现，以及它们如何

00:01:24.560 --> 00:01:27.759
以及它们如何在Web 2上实现

00:01:27.759 --> 00:01:31.840
我们将关闭此链接以进行质量检查会话和虚拟环聊

00:01:31.840 --> 00:01:36.640
对于可能对此感兴趣的任何人

00:01:38.000 --> 00:01:43.439
因此，仅简要介绍一下自己，我是索尼娅，我是一名开发人员

00:01:43.439 --> 00:01:46.560
我曾在几个分散的应用程序上工作

00:01:46.560 --> 00:01:50.320
包括组织者，我也是传统的

00:01:50.320 --> 00:01:54.479
可以找到我以前的文章的技术作家

00:01:54.479 --> 00:02:02.640
在我的网站realtorlife.github.io上，我也扎根于

00:02:02.640 --> 00:02:06.880
如果您是github twitter或电报的所有主要平台

00:02:06.880 --> 00:02:11.360
如果您愿意的话，可能想看看我以前的其他工作

00:02:11.360 --> 00:02:16.480
只想与我联系，但是如果您也喜欢电子邮件，则可以

00:02:16.480 --> 00:02:20.560
只需通过真实链实时liveportalmode.com给我发送电子邮件

00:02:20.560 --> 00:02:25.360
保持联系，让我们创造美好的事物

00:02:26.400 --> 00:02:29.599
那么什么是产生学校，它的任务是什么

00:02:29.599 --> 00:02:33.040
优质农产品学校是社区驱动的开源

00:02:33.040 --> 00:02:36.879
致力于简化项目

00:02:36.879 --> 00:02:41.680
任何人都可以开始学习去中心化Web技术

00:02:41.680 --> 00:02:48.319
在本章中，我们非常希望为开发人员提供

00:02:48.319 --> 00:02:53.040
了解ipfs等不同技术的机会

00:02:53.040 --> 00:02:56.800
ipld是行星际链接的数据系统

00:02:56.800 --> 00:03:02.560
lib p2p等，我们通过倡导轻松地执行此操作来做到这一点

00:03:02.560 --> 00:03:06.800
在没有目前集中的机构的情况下转移价值

00:03:06.800 --> 00:03:12.800
充当清算代理，我将对此进行深入讨论

00:03:12.800 --> 00:03:15.760
很快

00:03:16.480 --> 00:03:19.920
这些数据结构又是什么

00:03:19.920 --> 00:03:24.959
今天在网络上寻址如何工作，以及我们认为它将如何

00:03:24.959 --> 00:03:28.319
将来工作

00:03:28.480 --> 00:03:32.480
好吧，我们可能都熟悉数据结构，如果您是

00:03:32.480 --> 00:03:36.720
开发人员，您可能已经在考虑数据结构

00:03:36.720 --> 00:03:41.040
数据结构是一个数据结构是一个简单的集合

00:03:41.040 --> 00:03:44.400
数据值及其之间的关系

00:03:44.400 --> 00:03:48.080
这可以是应用的功能或操作

00:03:48.080 --> 00:03:54.640
以非常容易访问或修改的格式

00:03:54.640 --> 00:03:58.159
我的意思是我们在不同类型的程序中使用数据结构

00:03:58.159 --> 00:04:02.879
和软件已经是一个数据结构的例子，我们可能会

00:04:02.879 --> 00:04:08.400
熟悉的是收集的

00:04:08.400 --> 00:04:12.480
是其中分配了字符串属性的一种

00:04:12.480 --> 00:04:18.160
例如一个人的名字或一个用户名，例如：

00:04:18.160 --> 00:04:23.199
我们在这里收集这种结构

00:04:23.199 --> 00:04:30.400
一个人的名字一个人的用户名，在平台github或twitter上

00:04:30.400 --> 00:04:34.720
这只是我们现有的常见数据结构之一

00:04:34.720 --> 00:04:43.120
它们既可以以数组，对象图的形式出现，也可以以更多的形式出现

00:04:43.120 --> 00:04:49.680
在Web 2上，在Web 2上，这是当前的Web模型，这些数据结构是

00:04:49.680 --> 00:04:52.720
通过集中权限访问和共享

00:04:52.720 --> 00:04:57.600
如您在图示中所见，中央服务器是

00:04:57.600 --> 00:05:02.720
所有数据结构都是所有数据的全部完整网络数据和用户

00:05:02.720 --> 00:05:06.160
信息仅在已发出请求时存储

00:05:06.160 --> 00:05:10.639
通过互联网获取获得的中心服务

00:05:10.639 --> 00:05:14.160
发布请求，然后通过

00:05:14.160 --> 00:05:19.520
跨网并发送到用户的

00:05:19.520 --> 00:05:25.759
设备，系统已成为默认设置，因为

00:05:25.759 --> 00:05:29.680
设置非常容易，非常容易

00:05:29.680 --> 00:05:35.680
供其所有者委派规则或命令，并且因为他们发送了

00:05:35.680 --> 00:05:38.960
因为有对整个数据的集中控制

00:05:38.960 --> 00:05:43.120
系统不仅易于维护，而且

00:05:43.120 --> 00:05:46.960
有改变系统结构的明确方法，或者

00:05:46.960 --> 00:05:52.000
实际上运行整个系统的流程

00:05:52.000 --> 00:05:58.400
集中式服务器监视模型已为许多公司使用

00:05:58.400 --> 00:06:07.600
并且它已经内置在当今网络上的许多软件解决方案中

00:06:07.600 --> 00:06:10.639
所以如果

00:06:10.720 --> 00:06:14.319
数据请求只能向中央服务器发出

00:06:14.319 --> 00:06:20.560
位置如何，如何处理信息以及如何处理

00:06:20.560 --> 00:06:25.039
它位于网络上的中央服务器上

00:06:25.039 --> 00:06:29.759
就像今天这样，保留着服务清单或目录

00:06:29.759 --> 00:06:36.400
数据元素，例如每个数据结构的路径或文件名

00:06:36.400 --> 00:06:39.600
这些主要地址就是我们今天所知道的

00:06:39.600 --> 00:06:46.160
网址或统一资源定位符，因为那些服务目录

00:06:46.160 --> 00:06:50.560
我们用来定位和检索数据，以便在任何位置获取信息

00:06:50.560 --> 00:06:54.080
给定的位置通常可以更改或完全更改

00:06:54.080 --> 00:06:57.840
在没有修改跟踪器的情况下覆盖

00:06:57.840 --> 00:07:03.199
服务器本身会说是否发起了数据请求

00:07:03.199 --> 00:07:07.440
然后从记录中检索数据

00:07:07.440 --> 00:07:14.000
服务器位置和作为返回数据一部分的内容标头倾向于

00:07:14.000 --> 00:07:19.440
如下图所示指示返回数据的位置

00:07:19.440 --> 00:07:28.080
其中example.com是return database.png的位置

00:07:29.520 --> 00:07:36.080
现在这种数据服务的集中化有几个

00:07:36.080 --> 00:07:41.759
它带来了挑战，因为尽管它导致了创造

00:07:41.759 --> 00:07:45.440
更多基于Web的服务以及更高的

00:07:45.440 --> 00:07:50.879
互联网本身的某些缺陷可能非常刺眼

00:07:50.879 --> 00:07:55.840
并且很难忽略例如

00:07:55.840 --> 00:07:59.360
在网络受限的情况下创建

00:07:59.360 --> 00:08:03.759
正确的连通性说明服务器是否宕机

00:08:03.759 --> 00:08:07.919
然后所有依赖中央的服务或所有应用程序

00:08:07.919 --> 00:08:12.960
服务器也趋向于停止工作

00:08:12.960 --> 00:08:16.720
配电还有第二个挑战

00:08:16.720 --> 00:08:20.240
由于这些高度集中的过程

00:08:20.240 --> 00:08:26.479
那么决策往往倾向于自上而下的层次结构

00:08:26.479 --> 00:08:29.120
这可能导致审查制度的独裁统治

00:08:29.120 --> 00:08:33.760
集中服务器的所有者然后充当网守

00:08:33.760 --> 00:08:38.159
此特定服务的信息

00:08:38.159 --> 00:08:41.919
还有三分之一，三分之一的挑战，很多集中

00:08:41.919 --> 00:08:48.000
um服务系统趋向于没有故障或没有土地设置或使用

00:08:48.000 --> 00:08:53.519
桶服务备份服务器，则在以下情况下可能会发生数据丢失

00:08:53.519 --> 00:08:57.839
您可能熟悉的硬件故障

00:08:57.839 --> 00:09:02.240
像这样的问题，即使在很小的层面上

00:09:02.240 --> 00:09:07.040
例如丢失手机或丢失笔记本电脑（如果您有任何硬件）

00:09:07.040 --> 00:09:12.560
挑战并发现您对存储在中央服务器上的数据的访问

00:09:12.560 --> 00:09:16.880
常常永远失去

00:09:17.760 --> 00:09:21.440
那么如何处理这些问题呢

00:09:21.440 --> 00:09:28.240
通过使用分散数据结构解决的问题之一

00:09:28.240 --> 00:09:32.640
往往发生在分散式非分散式服务器上

00:09:32.640 --> 00:09:39.200
是创建专门的数据结构

00:09:39.200 --> 00:09:43.760
允许对内容进行验证并将其链接在一起

00:09:43.760 --> 00:09:49.360
这是因为所有这些数据库都在多个服务器之间共享

00:09:49.360 --> 00:09:52.800
形成相互连接的节点的网格

00:09:52.800 --> 00:09:59.920
如您在此插图中看到的，已连接了设备和数据库

00:09:59.920 --> 00:10:08.079
到最终用户和互连的节点网格

00:10:08.079 --> 00:10:11.360
而倾向于发生的是大型数据结构

00:10:11.360 --> 00:10:14.480
在这种分散式系统上

00:10:14.480 --> 00:10:17.600
网络对等方和互连方式相同

00:10:17.600 --> 00:10:21.120
任何网页都可以链接到其他位置

00:10:21.120 --> 00:10:25.519
那么实质上是什么驱动了集中式数据结构

00:10:25.519 --> 00:10:31.200
是可以访问的经过验证和链接的数据

00:10:31.200 --> 00:10:35.279
直接从网络对等点

00:10:36.399 --> 00:10:42.640
那么寻址如何在互连节点的系统上很好地工作

00:10:42.640 --> 00:10:45.760
这是加密哈希的来源

00:10:45.760 --> 00:10:50.000
用作链接内容的新形式

00:10:50.000 --> 00:10:56.880
所谓的内容寻址和在ipfs上的ipfs内容寻址本质上是

00:10:56.880 --> 00:11:01.760
使我们摆脱对中央政府的依赖

00:11:01.760 --> 00:11:08.800
因为用户可以直接从其他人检索数据

00:11:08.800 --> 00:11:12.000
使用散列的同龄人

00:11:12.000 --> 00:11:16.640
每次添加对象时生成

00:11:16.640 --> 00:11:24.880
到网络并在ipfs上进行散列是任何数据大小的地方

00:11:24.880 --> 00:11:33.200
或类型um在后面返回为字符串

00:11:33.200 --> 00:11:38.800
根据数据本身的内容进行多次计算

00:11:38.800 --> 00:11:46.000
基本上哈希是根据内容和

00:11:46.000 --> 00:11:50.480
密码哈希计算的结果值为

00:11:50.480 --> 00:11:56.079
我们所说的哈希是一个字符串

00:11:56.079 --> 00:12:00.160
您可以将其视为唯一的名称或指纹

00:12:00.160 --> 00:12:04.800
用于已在ipfs网络上添加的数据

00:12:04.800 --> 00:12:08.839
如您在下面的插图中看到的

00:12:08.839 --> 00:12:13.000
可以从地址中检索buzz.png

00:12:13.000 --> 00:12:19.200
 qmw98一直到此为止，因为这是加密哈希

00:12:19.200 --> 00:12:22.880
为imagebuster.png生成的

00:12:22.880 --> 00:12:28.000
将其添加到ipfs网络后，我们将进一步讨论密码学

00:12:28.000 --> 00:12:33.839
我们进行哈希运算，但这只是关于如何进行哈希运算的一个想法

00:12:33.839 --> 00:12:39.120
在ipfast网络上完成的哈希处理

00:12:39.120 --> 00:12:45.760
有助于数据结构的分散化以及我们如何解决

00:12:45.760 --> 00:12:48.880
内容以及我们如何在iPhone上检索内容

00:12:48.880 --> 00:12:53.839
网络本身

00:12:59.360 --> 00:13:04.480
那么什么是点对点

00:13:04.839 --> 00:13:09.839
结合使用良好的网络

00:13:09.839 --> 00:13:14.480
加密哈希和内容寻址，您将

00:13:14.480 --> 00:13:17.040
解锁我们现在称为点对点的东西

00:13:17.040 --> 00:13:23.680
网络是相反的

00:13:23.680 --> 00:13:29.760
您网址所在的位置地址用于表明我们使用的是哪个授权

00:13:29.760 --> 00:13:33.920
应该去找数据，这些权威通常是领域

00:13:33.920 --> 00:13:39.760
最终集中式Web上的文件内容没有直接的

00:13:39.760 --> 00:13:44.399
与基于位置的地址的关系

00:13:44.480 --> 00:13:52.240
在ipfs和其他对等网络上，您会发现自哈希

00:13:52.240 --> 00:13:57.199
因为我们使用散列在分散式网络的中心请求数据

00:13:57.199 --> 00:14:07.600
我们可以将其视为哈希，可以将哈希视为

00:14:08.399 --> 00:14:12.639
作为链接，而不仅仅是一个名称

00:14:15.680 --> 00:14:20.240
现在，内容寻址具有多种含义

00:14:20.240 --> 00:14:25.279
例如，只要存在文件的有效副本

00:14:25.279 --> 00:14:32.800
那么ipfs网络上的数据就永远不会丢失

00:14:32.800 --> 00:14:37.519
内容寻址的惊人含义

00:14:37.519 --> 00:14:41.839
它是否使用户能够检查数据的指纹

00:14:41.839 --> 00:14:46.800
或针对提供验证的链接散列

00:14:46.800 --> 00:14:59.839
当前在位置寻址链接上不可用

00:15:00.800 --> 00:15:04.720
现在已经有很多不同种类的协议

00:15:04.720 --> 00:15:08.560
使用um这些密码要素

00:15:08.560 --> 00:15:12.320
散列为他们的点对点网络提供支持

00:15:12.320 --> 00:15:16.800
这包括git以太坊和比特币

00:15:16.800 --> 00:15:22.639
例如，让我们深入研究加密哈希

00:15:22.639 --> 00:15:27.199
以及如何生成cid或内容标识符，以及

00:15:27.199 --> 00:15:31.120
在ipfast网络上使用

00:15:34.639 --> 00:15:37.839
现在当例如添加新信息时

00:15:37.839 --> 00:15:43.040
系统生成并记录到网络的内容地址

00:15:43.040 --> 00:15:47.759
永久链接到信息本身

00:15:48.399 --> 00:15:53.199
ipfess使用其他对等技术的组合，例如

00:15:53.199 --> 00:15:57.600
分布式哈希表和bitsweb确定物理

00:15:57.600 --> 00:16:01.440
数据的位置并检索它，这样当

00:16:01.440 --> 00:16:06.639
用户必须从ipfs检索数据的请求

00:16:06.639 --> 00:16:10.880
提供内容标识符或cid

00:16:10.880 --> 00:16:14.079
系统必须从中确定

00:16:14.079 --> 00:16:18.240
数据的物理位置并检索它

00:16:18.240 --> 00:16:21.440
而且由于cid是基于内容本身的

00:16:21.440 --> 00:16:25.199
对数据元素的任何更改都必然会更改

00:16:25.199 --> 00:16:31.440
在几乎所有情况下，它的内容地址都在编辑存储区中，并且在和

00:16:31.440 --> 00:16:35.600
um，所有情况除外，可读文件系统除外

00:16:35.600 --> 00:16:39.519
涉及编辑存储的信息不是

00:16:39.519 --> 00:16:43.000
允许的，这几乎就是我们所说的

00:16:43.000 --> 00:16:49.120
不变性现在不变性是

00:16:49.120 --> 00:16:52.880
信任ipfs网络，因为

00:16:52.880 --> 00:16:59.120
再次因为加密散列是根据内容本身计算的

00:16:59.120 --> 00:17:06.319
如果您想检索例如哈希的内容，则必须

00:17:06.319 --> 00:17:10.400
向网络提供哈希本身

00:17:10.400 --> 00:17:14.880
然后将查找与您匹配的哈希

00:17:14.880 --> 00:17:17.280
提供并检索了信息

00:17:17.280 --> 00:17:22.880
在该地址的末尾（例如，如果您提供哈希）

00:17:22.880 --> 00:17:28.319
但发现原始内容已被修改

00:17:28.319 --> 00:17:35.919
那么您将无法满足信任度计算，您将不会获得

00:17:35.919 --> 00:17:47.120
您提供的房屋末端的内容

00:17:47.120 --> 00:17:50.640
那么内容标识符实际上如何

00:17:50.640 --> 00:17:55.039
他们是如何生成的，是否有哪些不同的格式？

00:17:55.039 --> 00:18:00.799
他们认为我更喜欢网络，首先

00:18:00.799 --> 00:18:06.320
我们要谈的是，内容寻址可以

00:18:06.320 --> 00:18:10.799
可用于所有不同类型的文件和数据

00:18:10.799 --> 00:18:15.600
从json对象到发布论文到各种视频

00:18:15.600 --> 00:18:20.320
为了使密码散列本身起作用，我们需要知道哪种数据格式

00:18:20.320 --> 00:18:24.160
我们正在合作，然后才能找到

00:18:24.160 --> 00:18:28.320
使用合适的编码和解码工具，因此首先

00:18:28.320 --> 00:18:34.240
例如，创建cid的步骤是转变网络趋势

00:18:34.240 --> 00:18:38.000
要做的是使用

00:18:38.000 --> 00:18:42.080
与其匹配的加密哈希

00:18:42.080 --> 00:18:48.080
它的大小会影响输出大小，这几乎就是我们所说的

00:18:48.080 --> 00:18:53.200
散列，所以其他的其他格式

00:18:53.200 --> 00:18:57.039
在生成内容标识符时考虑

00:18:57.039 --> 00:19:02.080
由网络是多抄本的散列算法

00:19:02.080 --> 00:19:06.880
内容标识符本身的哈希长度和哈希值

00:19:06.880 --> 00:19:14.000
它是根据内容本身创建的，因此这些只是组件

00:19:14.000 --> 00:19:19.600
内容标识符cid的形式

00:19:19.600 --> 00:19:22.640
因此，例如，多编解码器是一个前缀

00:19:22.640 --> 00:19:26.720
指示用于集成数据的编码

00:19:26.720 --> 00:19:31.760
因此，如果您输入的是json对象，而您输入的是

00:19:31.760 --> 00:19:35.760
视频格式，然后为每个编解码器使用多编解码器

00:19:35.760 --> 00:19:39.360
根据内容本身会有所不同

00:19:39.360 --> 00:19:46.160
如果您是用于

00:19:46.400 --> 00:19:52.160
为添加在上的每个对象运行哈希函数

00:19:52.160 --> 00:19:56.320
网络ipfs中使用的默认算法

00:19:56.320 --> 00:20:02.480
产生cid是shire256

00:20:04.480 --> 00:20:10.000
但是根据它们的加密哈希值，它们会有所不同

00:20:10.000 --> 00:20:13.200
用于整合基础内容

00:20:13.200 --> 00:20:17.039
本身，所以还有其他几种um算法

00:20:17.039 --> 00:20:22.960
使用慈善机构，但默认为慈善机构56

00:20:23.919 --> 00:20:27.919
因此，加密散列本身的实际长度

00:20:27.919 --> 00:20:32.960
并且通常可以将其描述为默认长度，该长度通常为256

00:20:32.960 --> 00:20:37.120
基于默认的哈希算法，但这可能会有所不同

00:20:37.120 --> 00:20:42.960
根据内容本身，然后是

00:20:42.960 --> 00:20:46.799
量子标识符是哈希值本身

00:20:46.799 --> 00:20:52.159
那是哈希过程的结果

00:20:53.360 --> 00:21:00.080
那么cid或内容标识符对cad的影响是什么

00:21:00.080 --> 00:21:04.320
允许网络建立链接到其他数据的数据结构

00:21:04.320 --> 00:21:08.080
格式完全不同的结构，以及

00:21:08.080 --> 00:21:13.679
在整个网络中，我们使用这些哈希值进行分发

00:21:13.679 --> 00:21:19.440
并链接数据，并在ipfs上将这些数据结构

00:21:19.440 --> 00:21:24.080
linkedin的结构称为移动树，在某些情况下

00:21:24.080 --> 00:21:27.760
在某种程度上，导演没有

00:21:27.760 --> 00:21:33.760
单击工艺品，但在此之后我们将立即解决

00:21:33.760 --> 00:21:40.000
那我的目标树是什么，害羞的是什么，摩根树是什么

00:21:40.000 --> 00:21:45.280
以及将对象添加到ipfs时首先如何工作

00:21:45.280 --> 00:21:51.440
它被切成小块，所以可以是206 KB的部分

00:21:51.440 --> 00:21:55.120
每个部分都经过哈希处理，而cd是

00:21:55.120 --> 00:22:00.320
为每个这些块组合成的每个块创建

00:22:00.320 --> 00:22:04.640
一个基础数据的层次结构数据结构

00:22:04.640 --> 00:22:11.679
计算cid，这样您将得到一系列对象

00:22:11.679 --> 00:22:15.200
通过他们链接的

00:22:15.200 --> 00:22:20.640
这就是它的工作原理这是它的外观

00:22:20.640 --> 00:22:25.360
在此图中实现，例如节点e

00:22:25.360 --> 00:22:29.919
包含对节点f和节点g的引用

00:22:29.919 --> 00:22:38.080
因为，这对这棵马尔科夫树意味着什么

00:22:38.840 --> 00:22:44.159
是节点e的散列是唯一的

00:22:44.159 --> 00:22:47.600
包含节点地址的节点

00:22:47.600 --> 00:22:51.679
f和节点g uh，这是

00:22:51.679 --> 00:22:59.200
可能是因为节点f和g包含对象的某些部分

00:22:59.200 --> 00:23:03.200
链接到节点e和节点e

00:23:03.200 --> 00:23:06.240
包含对象的已链接部分

00:23:06.240 --> 00:23:11.360
现在想象到节点c和节点b，如果我们运行它

00:23:11.360 --> 00:23:15.440
并通过哈希算法运行目录e

00:23:15.440 --> 00:23:21.360
其中包含子目录f和g以及我们得到的内容派生哈希

00:23:21.360 --> 00:23:25.919
从包含对这两个目录的引用返回，这就是方法

00:23:25.919 --> 00:23:31.520
它从根到节点g一直向下应用

00:23:31.520 --> 00:23:38.240
所以在这里扎根，或者这是在树上建立的树的最终基础

00:23:38.240 --> 00:23:43.200
散列过程的结尾对于包含每一个树的树是唯一的

00:23:43.200 --> 00:23:46.799
节点一直向下，所以这些数据

00:23:46.799 --> 00:23:52.159
结构从叶节点一直向后构建，一直到

00:23:52.159 --> 00:23:54.960
根节点

00:23:55.760 --> 00:24:00.400
这也内置在标签结构中

00:24:00.400 --> 00:24:05.760
而dags只是说说方向性循环的一种奇特的方式

00:24:05.760 --> 00:24:09.360
图是描述一个非常

00:24:09.360 --> 00:24:14.159
特定类型的merkle或哈希树，其中不同的分支

00:24:14.159 --> 00:24:19.679
一棵树中的一个分支可以指向一个树中的其他分支

00:24:19.679 --> 00:24:23.440
如图所示，向前方向

00:24:23.440 --> 00:24:27.840
因此，此链接数据的收集非常防篡改

00:24:27.840 --> 00:24:32.960
因为所有内容都是经过哈希验证的，并且因为我们使用的是

00:24:32.960 --> 00:24:36.880
我们没有很多重复的对象

00:24:36.880 --> 00:24:40.400
事实上，这解决了重复数据删除问题

00:24:40.400 --> 00:24:45.440
非常好，持有相同的物体

00:24:45.440 --> 00:24:50.960
内容，它们被认为是相等的，并且它们共享相同的哈希值，并且

00:24:50.960 --> 00:24:55.679
在fps网络上仅启动一次，因此我们已经介绍了

00:24:55.679 --> 00:25:00.159
到目前为止，我会检查一下我们是否

00:25:00.159 --> 00:25:06.799
有任何问题，但如果您也有

00:25:08.880 --> 00:25:12.080
如果您有任何疑问，我想是吧

00:25:12.080 --> 00:25:15.919
是个很好的时机，也许把他们留在评论部分，我会尽力

00:25:15.919 --> 00:25:21.200
对他们来说，但我们可以说的一件事

00:25:21.200 --> 00:25:24.400
这种集中的数据结构实际上是

00:25:24.400 --> 00:25:30.159
解决的是，它们阻止了单个点的创建

00:25:30.159 --> 00:25:34.400
黑客或恶意攻击者可能导致的故障

00:25:34.400 --> 00:25:40.640
继续危害网络，这是因为它提供了一个

00:25:40.640 --> 00:25:44.080
许多网络冗余冗余，因为这使得

00:25:44.080 --> 00:25:49.120
分散网络在这种情况下更具弹性

00:25:49.120 --> 00:25:53.200
如果个别服务器

00:25:53.200 --> 00:25:57.279
下去，那么你还有其他几个可以

00:25:57.279 --> 00:26:04.080
可以在任何给定时间作为上限或备份服务器使用

00:26:04.080 --> 00:26:07.760
增强了网络本身的灵活性，因为它更具灵活性

00:26:07.760 --> 00:26:12.480
冗余的话，网络就可以

00:26:12.480 --> 00:26:16.480
以更高的效率添加或删除节点

00:26:16.480 --> 00:26:20.480
这本身就提高了网络安全性，因为如果一个节点

00:26:20.480 --> 00:26:24.960
或出现在分散网络上

00:26:24.960 --> 00:26:30.720
或损坏，那么很多都仅限于受影响的节点，并且

00:26:30.720 --> 00:26:34.880
不会传播到整个um

00:26:34.880 --> 00:26:41.600
网络本身当然还有很多很多

00:26:41.600 --> 00:26:45.120
这些数据结构的优点

00:26:45.120 --> 00:26:48.880
但是到目前为止我们看到的是采用

00:26:48.880 --> 00:26:55.760
Web3新技术创建过程中去中心化数据结构的设计

00:26:55.760 --> 00:27:00.880
互联网一开始就是分散的

00:27:00.880 --> 00:27:07.679
网络作为基于对等系统的对等网络工作，但是

00:27:07.679 --> 00:27:13.520
在摆脱了1999年的互联网泡沫之后，

00:27:13.520 --> 00:27:17.840
演变成只读静态网络

00:27:17.840 --> 00:27:24.000
或网络2，我们今天将其称为读写和互动形式

00:27:24.000 --> 00:27:28.799
互联网，但随着采用率的提高

00:27:28.799 --> 00:27:32.880
基于信任和可验证的系统

00:27:32.880 --> 00:27:36.720
分散数据结构和区块链技术

00:27:36.720 --> 00:27:40.159
我们看到的解决方案正在增加

00:27:40.159 --> 00:27:46.159
在这个生态系统和ipfs中构建只是其中之一，

00:27:46.159 --> 00:27:52.559
更多的机会来建立更多的惊人解决方案

00:27:52.559 --> 00:27:55.840
因为您可以看到ipfs生态系统

00:27:55.840 --> 00:28:02.399
这是巨大的，而且它每天都在增长，这些仅仅是

00:28:02.399 --> 00:28:04.720
一些产品和解决方案

00:28:04.720 --> 00:28:12.000
在ibfs的ipfs上构建，利用所有不同的特性

00:28:12.159 --> 00:28:17.120
分散数据结构的组成部分，所以我将所有这些都建立在

00:28:17.120 --> 00:28:22.399
密码散列的原理是基于

00:28:26.240 --> 00:28:33.279
建立在各种算法之上

00:28:33.279 --> 00:28:38.080
不同类型的数据结构，例如comoco树

00:28:38.080 --> 00:28:44.320
或不同类型的潜水，因此您随时可以查看其中任何一个

00:28:44.320 --> 00:28:49.360
他们如何工作，看看他们如何为ipfs做贡献，看看是否有

00:28:49.360 --> 00:28:52.559
例如，您入门的好地方

00:28:52.559 --> 00:28:58.640
如果您对构建用于存储和分发的解决方案感兴趣

00:28:58.640 --> 00:29:02.399
容器包装，这是使用的绝佳机会

00:29:02.399 --> 00:29:06.080
分散式系统，如果您有兴趣建立

00:29:06.080 --> 00:29:11.279
智能合约或大数据解决方案，或者如果您有兴趣存储和

00:29:11.279 --> 00:29:16.080
分发前端应用程序和用户数据嗯，有很多

00:29:16.080 --> 00:29:20.159
技术入门的机会

00:29:20.159 --> 00:29:24.159
ipfs，我们很乐意看到您加入

00:29:24.159 --> 00:29:28.080
社区嗯，我们还有很多其他的经历

00:29:28.080 --> 00:29:31.520
可以使您了解更多有关资源的资源

00:29:31.520 --> 00:29:35.200
例如，您可以查找一些

00:29:35.200 --> 00:29:38.799
这些主题，例如um了解ipfs

00:29:38.799 --> 00:29:43.120
处理文件或了解数据的生命周期

00:29:43.120 --> 00:29:49.520
在分散式网络um上的分布式方式上，我们也有

00:29:49.520 --> 00:29:53.440
其他产生学校资源，例如解剖

00:29:53.440 --> 00:29:58.000
对此感到遗憾的是，或了解对等数据的方式

00:29:58.000 --> 00:30:02.640
链接实际上可以与内容寻址一起使用

00:30:04.399 --> 00:30:08.320
我们也有即将举行的活动，您可以加入我们

00:30:08.320 --> 00:30:14.880
用于ipfs um社区见面骚扰或主要ipfs社区

00:30:14.880 --> 00:30:17.600
可以宣布的聚会

00:30:17.600 --> 00:30:23.279
不久的将来，我还将举办几场活动

00:30:23.279 --> 00:30:26.559
用蓝色PHP构建一些分布式应用程序

00:30:26.559 --> 00:30:30.960
或找到重新构想的存储环境

00:30:30.960 --> 00:30:35.120
使用filecoin，这将都是交互式学习课程，并且

00:30:35.120 --> 00:30:38.880
也爱你在那里

00:30:39.520 --> 00:30:43.440
再次，您可以在普渡学校（Purdue school）跟随农产品学校

00:30:43.440 --> 00:30:50.000
我在产品学校开始使用其他任何交互式教程

00:30:50.000 --> 00:30:55.120
设计并可供您入门的产品

00:30:55.120 --> 00:30:58.240
与呃或者如果你有任何

00:30:58.240 --> 00:31:03.200
我们今天可能还没到的问题，那么您可以联系

00:31:03.200 --> 00:31:07.760
社区中的其他社区成员

00:31:07.760 --> 00:31:11.760
呃fpfest github社区回购协议有很多

00:31:11.760 --> 00:31:18.159
可供您连接的资源，也许还可以开始使用ipfs本身，以及

00:31:18.159 --> 00:31:22.640
当然在推特上，您可以按照protoschool进行协议实验室

00:31:22.640 --> 00:31:29.760
ipfs现货或我宣称非洲几乎可以住宿

00:31:29.760 --> 00:31:34.080
在船上，我们宣布了可能会发生的一切

00:31:34.080 --> 00:31:38.320
um以及指向其他资源的链接以开始使用

00:31:38.320 --> 00:31:42.960
所以这是演讲的结尾，现在我将开始学习

00:31:42.960 --> 00:31:53.360
问题，也许是聊天中的问题

