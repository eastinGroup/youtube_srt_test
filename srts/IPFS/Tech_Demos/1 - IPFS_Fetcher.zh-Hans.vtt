WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.799 --> 00:00:05.439
你们都准备好了，所以

00:00:05.839 --> 00:00:12.960
现在还是永远不会好，嗯，那就让我演示吧

00:00:12.960 --> 00:00:16.800
嗯，这将是一个真正的简短演示um，因为它只是um

00:00:16.800 --> 00:00:20.560
展示一些我们正在做的事情

00:00:20.560 --> 00:00:27.199
所以我想，如果可以的话，我会快速分享我的屏幕

00:00:27.199 --> 00:00:31.840
我被允许这样做，让我们看看

00:00:32.960 --> 00:00:39.600
所以，昨天，昨天，你，整个，你，嗯

00:00:39.600 --> 00:00:42.879
我们可能呃，我相信会提到

00:00:42.879 --> 00:00:49.440
我们是um w3 uh dt的主要项目

00:00:49.440 --> 00:00:53.039
数据系统团队，因为我们将ipld prime纳入

00:00:53.039 --> 00:00:59.359
我们本周早些时候去ipfs um，我们建立了一个最小的

00:00:59.359 --> 00:01:04.400
基本上是由我实现的，我不知道我不知道你想要什么

00:01:04.400 --> 00:01:09.360
称其为hack，基本上只是使ipld成为主要外观

00:01:09.360 --> 00:01:14.799
就像旧的一个um，所以我们建立了这个概念

00:01:14.799 --> 00:01:18.799
ai的a认为它是一个通用节点

00:01:18.799 --> 00:01:22.799
所以哦，顺便说一句，谁知道我不知道有多少人知道我

00:01:22.799 --> 00:01:28.000
感觉最主要的是旧的ipld，有两个不同的库um ipld

00:01:28.000 --> 00:01:30.320
 prime就像一个超级棒的图书馆，

00:01:30.320 --> 00:01:34.880
确实喜欢ipld规范的所有部分，包括类似选择器，包括

00:01:34.880 --> 00:01:39.680
模式，就像我们所有东西一样，是一个很棒的数据模型

00:01:39.680 --> 00:01:43.840
然后我那旧的ipld就像一个东西

00:01:43.840 --> 00:01:49.840
是不是做一些事情，但不是大多数ipld规范，它会解锁

00:01:49.840 --> 00:01:54.079
像所有这些很酷的数据一样，就像我们可以做的数据操作一样

00:01:54.079 --> 00:01:58.399
如果我们在所有应用程序中都做到了

00:01:58.399 --> 00:02:01.840
可以一直拿到它的最大边缘

00:02:01.840 --> 00:02:06.399
ipfs，所以我们构建了这个东西，基本上就像我们开始时一样

00:02:06.399 --> 00:02:09.920
通过建立嗯嗯这种黑客，嗯效果

00:02:09.920 --> 00:02:14.879
有效地像新的ipld素数一样将其包装

00:02:14.879 --> 00:02:17.920
使它看起来像旧想法的东西

00:02:17.920 --> 00:02:21.680
嗯，这很好，通常就像是最简单的过渡方式

00:02:21.680 --> 00:02:24.720
就像放一些东西可以让你

00:02:24.720 --> 00:02:28.480
不必每次都移走所有东西的基线

00:02:28.480 --> 00:02:31.360
从那里开始工作，所以我们建立了这个叫做

00:02:31.360 --> 00:02:35.120
通用节点是两者的基本单位

00:02:35.120 --> 00:02:38.000
库是节点的概念，尽管它们含义不同

00:02:38.000 --> 00:02:42.800
嗯，但是我们建立了一个像他们俩一样的人

00:02:42.800 --> 00:02:48.400
嗯，然后我们嗯嗯，然后我们去了，有一个服务

00:02:48.400 --> 00:02:51.120
嗯，就像你的普遍

00:02:51.120 --> 00:02:57.120
当前在ipfs中使用ipld的入口点um

00:02:57.120 --> 00:03:00.959
嗯，那就是这个叫go merkle dag um的图书馆

00:03:00.959 --> 00:03:05.840
这是可以让您从本质上说的东西

00:03:10.080 --> 00:03:14.239
这基本上可以让你

00:03:14.239 --> 00:03:22.000
例如um读ipld数据um写ipld数据uh

00:03:22.000 --> 00:03:26.239
嗯，删除东西，什么时候，什么时候我说读，意思是

00:03:26.239 --> 00:03:32.720
从像块存储或潜在的ipld uh数据中获取负载

00:03:32.720 --> 00:03:36.879
来自ipfs网络um的uh

00:03:36.879 --> 00:03:40.480
嗯，有点像是透明层

00:03:40.480 --> 00:03:44.239
嗯，它确实做了很多事情，还包括

00:03:44.239 --> 00:03:51.599
um dag protobuf旧ipld um的ipld um的实现

00:03:51.599 --> 00:03:57.920
呃，就像ld这样的旧形式，所以我们建立了像pr这样的整体

00:03:57.920 --> 00:04:01.680
像基本上使它使用uh ipld prime

00:04:01.680 --> 00:04:05.280
引擎盖，这很好，这使我们达到了基本上

00:04:05.280 --> 00:04:08.879
用于ipld的旧接口

00:04:08.879 --> 00:04:13.200
在引擎盖下使用ipld prime的ipfs um中，这很棒

00:04:13.200 --> 00:04:17.199
但是所有这些旧界面的设计都不适合与

00:04:17.199 --> 00:04:20.320
ipld prime这使我们能够将其纳入

00:04:20.320 --> 00:04:23.600
系统um，而无需一次转换所有内容

00:04:23.600 --> 00:04:28.080
um，但它不会建立针对um量身定制的新界面

00:04:28.080 --> 00:04:33.199
恩ipld prime um，所以我们现在恩，恩，所以现在我们正在研究一些

00:04:33.199 --> 00:04:35.600
那就是我今天想展示的东西

00:04:35.600 --> 00:04:39.600
对于这个超长的介绍，我很抱歉，这是我们打造的第一件事

00:04:39.600 --> 00:04:44.639
这就是我们所说的ipfs fetcher嗯，这是

00:04:44.639 --> 00:04:50.320
嗯，这是一个uh接口，您将使用uh请求ipld

00:04:50.320 --> 00:04:53.520
来自您当地的loca的数据um

00:04:53.520 --> 00:04:57.600
存储或从呃

00:04:57.600 --> 00:05:00.960
或来自联邦调查局网络的内部呃

00:05:00.960 --> 00:05:06.880
嗯，所以我要把它拉起来，嗯，我们是嗯

00:05:06.880 --> 00:05:10.720
[音乐]我们已经决定打破的一件事

00:05:10.720 --> 00:05:13.280
相对于的写作部分

00:05:13.280 --> 00:05:15.919
ipld um和一件很棒的事情

00:05:15.919 --> 00:05:18.320
嗯，这允许你做的是

00:05:18.320 --> 00:05:22.400
嗯，在旧的图书馆中，你有这个要注意的核心概念，例如创建

00:05:22.400 --> 00:05:24.800
会议，这可能会变得超级技术

00:05:24.800 --> 00:05:30.000
道歉，嗯，现在，嗯，现在喜欢

00:05:30.000 --> 00:05:33.360
而且您基本上总是想参加会议，但是这很晚才结束

00:05:33.360 --> 00:05:36.240
功能，所以我们拥有所有有时不使用的代码

00:05:36.240 --> 00:05:39.440
嗯，在新版本中，唯一可以使用的方法是通过

00:05:39.440 --> 00:05:42.639
会话，这很棒，因为它迫使您执行该操作并确保

00:05:42.639 --> 00:05:46.240
你是在正确地设置东西，但是

00:05:46.240 --> 00:05:50.240
嗯，您可以看到我们有一些提取功能嗯，您可以提取块

00:05:50.240 --> 00:05:55.360
呃，您可以获取一个匹配的块您可以获取一组匹配的块

00:05:55.360 --> 00:05:58.639
一个选择器，真的很棒，因为

00:05:58.639 --> 00:06:01.520
意味着我们可以遍历不是

00:06:01.520 --> 00:06:05.440
整个父亲，但宁可是父亲的选择

00:06:05.440 --> 00:06:09.039
但是我们也有um接口，可以让您提取

00:06:09.039 --> 00:06:15.919
嗯，你一次就知道了整个图。

00:06:16.000 --> 00:06:19.120
我们在这里还有什么呢我们正在建造一些东西

00:06:19.120 --> 00:06:24.479
嗯，如果您已经加载了ipld的一部分，我们会允许您开始

00:06:24.479 --> 00:06:29.280
树，你可以从一个节点开始，嗯，我们知道我实际上没有使用什么

00:06:29.280 --> 00:06:35.840
正确的分支机构很抱歉，我们允许您这样做

00:06:35.840 --> 00:06:41.360
嗯，尤其是我们允许您使用特殊的节点类型来执行此操作

00:06:41.360 --> 00:06:45.600
是ipld prime的一个非常酷的功能，它使您可以

00:06:45.600 --> 00:06:48.960
基本上为uh提前定义类型

00:06:48.960 --> 00:06:52.880
您的要使用的节点的呃，比如说我在工作

00:06:52.880 --> 00:06:55.599
与我想要的某种专门的数据结构

00:06:55.599 --> 00:07:00.560
只是看起来某种类型的方式，所以我们要添加

00:07:00.560 --> 00:07:05.520
嗯，这又对那些没有

00:07:05.520 --> 00:07:08.880
在带有代码的杂草中，我们很乐意喜欢更长的时间

00:07:08.880 --> 00:07:12.800
在其他时候在ipld上使用更长的引物可能很有用

00:07:12.800 --> 00:07:16.000
嗯，无论如何，是的，所以我们将它们构建为当前版本

00:07:16.000 --> 00:07:19.840
如果您实际上一直将其深入到

00:07:19.840 --> 00:07:22.960
底部嗯，我们最终要做的只是

00:07:22.960 --> 00:07:26.319
使用um块服务uh来获取uh

00:07:26.319 --> 00:07:30.160
当我们加载单个块时，块服务是一种

00:07:30.160 --> 00:07:33.919
逐个获取块，它要么在本地加载，要么调出位交换

00:07:33.919 --> 00:07:37.840
嗯，但将来我们可能会用图同步或

00:07:37.840 --> 00:07:40.479
图形同步和位交换um的组合

00:07:40.479 --> 00:07:44.319
但是，是的，那是我们的，这是我们的界面，现在这将是

00:07:44.319 --> 00:07:48.160
就像慢慢地将树过滤成um xfs

00:07:48.160 --> 00:07:51.360
还有什么不好的，谢谢大家

00:07:51.360 --> 00:07:54.879
带着我，我意识到我们没有一个非常

00:07:54.879 --> 00:07:57.360
就像我们非常喜欢程序员一样

00:07:57.360 --> 00:08:01.599
而不是非程序员友好的东西来演示，所以谢谢

00:08:01.599 --> 00:08:06.879
是的，这就是我遇到的所有问题

00:08:10.840 --> 00:08:13.840
顾虑

00:08:14.560 --> 00:08:18.400
超级酷谢谢您演示很棒

00:08:18.400 --> 00:08:22.560
快速聚集在一起并快速移动

