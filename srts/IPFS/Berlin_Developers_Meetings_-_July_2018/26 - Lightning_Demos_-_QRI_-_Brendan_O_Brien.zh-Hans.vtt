WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:06.720
b5和Clarisse大家好，大家中有些人已经看到了

00:00:06.720 --> 00:00:10.740
我会保持相对简短，但我只是想演示我们一直在做的事情

00:00:10.740 --> 00:00:14.849
在查询上，特别是我认为对于这种人群云雀转变

00:00:14.849 --> 00:00:25.710
或更有趣的一点是，这真的很明显，所以我很抱歉

00:00:25.710 --> 00:00:28.769
我们该怎么做？查询是什么？我们制作一个数据集版本

00:00:28.769 --> 00:00:34.739
控制系统，我们花了很多时间，我们认为我们可以提出一种

00:00:34.739 --> 00:00:41.550
用于称为数据集的文档模型，有助于标准化和制作文档数据

00:00:41.550 --> 00:00:48.329
设置互换性和互操作性更好，所以所有这些都基于ipfs

00:00:48.329 --> 00:00:52.649
我们使用它，我们广泛使用loopy，所以今天

00:00:52.649 --> 00:00:59.039
很快，我将向您展示什么是云雀般的转变，我们有很多人

00:00:59.039 --> 00:01:02.760
开始时，如果实际上生成数据集的代码会很好

00:01:02.760 --> 00:01:06.810
骑着数据集本身和很多从事数据科学工作的人

00:01:06.810 --> 00:01:13.220
我真的想要Python，因为python很棒，所以经过一番搜索，我们发现了一个

00:01:13.220 --> 00:01:17.850
从Google罗勒构建工具中提取出来的项目

00:01:17.850 --> 00:01:22.560
云雀，这是不完整的巡演语言，所以你不会

00:01:22.560 --> 00:01:25.979
有狂野的循环，你在这里没有递归，所以这很好

00:01:25.979 --> 00:01:30.689
并确保使沙盒可执行代码环境安全

00:01:30.689 --> 00:01:34.710
不像Python没有全局解释器锁，所以稍后我们可以

00:01:34.710 --> 00:01:40.920
并行化的版本，但目前所有这一切都是一个简单的过程

00:01:40.920 --> 00:01:43.890
该示例将执行下载步骤，请放心，我们已经做了很多

00:01:43.890 --> 00:01:48.329
考虑何时可以访问互联网，但是在这里我们

00:01:48.329 --> 00:01:51.930
要做一些API的操作，然后我们将返回一些数据，然后

00:01:51.930 --> 00:01:58.979
该脚本在这里被指定为转换后的Sky文件，因此如果我们翻转

00:01:58.979 --> 00:02:06.329
到终端，我要运行的是，所以我要运行查询添加，然后我

00:02:06.329 --> 00:02:09.360
只需指定黄色文件即可

00:02:09.360 --> 00:02:12.510
整个数据集文档，您会在这里注意到，我将给它

00:02:12.510 --> 00:02:15.970
一些未与文件存储在一起的机密

00:02:15.970 --> 00:02:18.760
也要警告我们，嘿，您要给脚本一些秘密，您应该

00:02:18.760 --> 00:02:24.790
很好地知道发生了什么，但是如果我们按Enter，它将立即运行

00:02:24.790 --> 00:02:28.870
转换脚本获取输出数据并生成数据集smash

00:02:28.870 --> 00:02:34.530
到ipfs上并使其对我们可用，因此如果我使用查询LS，我可以进行一些显示

00:02:34.530 --> 00:02:40.240
这些是我在本地的数据集，然后我们有了ipfs守护程序版本

00:02:40.240 --> 00:02:46.810
是查询连接，因为守护程序一词对某些人来说很可怕，所以我们该怎么办

00:02:46.810 --> 00:02:52.150
我们在这里拥有什么，我们现在有一个同时运行查询的ipfs节点

00:02:52.150 --> 00:02:59.830
层，所以我可以只为这个小伙伴做，我们可以做很棒的同伴列表

00:02:59.830 --> 00:03:04.180
然后我们可以显示ipfs网络，这使连接混乱

00:03:04.180 --> 00:03:06.730
经理，以确保您可以看到其中一些支持查询

00:03:06.730 --> 00:03:10.210
协议，因此新的出色的连接管理器API意味着我们可以

00:03:10.210 --> 00:03:13.480
无论如何都要优先考虑对查询对等体的连接

00:03:13.480 --> 00:03:22.570
现在向您展示实际的数据集本身，我们将直接访问我们的本地网络

00:03:22.570 --> 00:03:25.600
前端的用户界面，因此我们既可以将其作为电子应用程序发布，也可以将其作为网络应用程序发布

00:03:25.600 --> 00:03:32.110
随您的安装查询一起移动，所以在这里我们可以看到

00:03:32.110 --> 00:03:36.190
生成的数据集的实际主体，其结构只是

00:03:36.190 --> 00:03:38.980
基本上说，这是我们对实际方案的了解不多

00:03:38.980 --> 00:03:44.230
数据集，但是它是一个数组，使用它创建的任何元数据都会发生变化

00:03:44.230 --> 00:03:47.440
日志，所以它是快照，因此我可以看到所有附带的信息

00:03:47.440 --> 00:03:51.940
那，我们偷偷地潜入了可视化模板，所以我们可以

00:03:51.940 --> 00:03:56.410
实际上看到这只是一个使用go模板的HTML模板

00:03:56.410 --> 00:03:59.530
引擎盖下的引擎，这样我们就可以潜入我们想要的任何地方

00:03:59.530 --> 00:04:07.300
渲染这些东西，最后但并非最不重要的一点是，我们自己也进行了转换

00:04:07.300 --> 00:04:20.230
我们的参数会显示出来，那么为什么不爱JSI PFS是ipfs，那么我们就可以

00:04:20.230 --> 00:04:22.620
一样

00:04:24.669 --> 00:04:34.820
是的，我知道，所以我们将做完全相同的交易，然后说“是”，因此，我们所做的一切

00:04:34.820 --> 00:04:37.460
在这里完成的是，我们就像一个不知道如何写的人一样在思考

00:04:37.460 --> 00:04:40.970
学者转换我们已经建立了一组详细的配置，在此

00:04:40.970 --> 00:04:43.729
情况下，我们只是进入了新配置，而不是更改

00:04:43.729 --> 00:04:48.050
基础脚本本身，所以如果我查询LS，现在可以看到我有这个新的

00:04:48.050 --> 00:04:53.630
JSI PMS做出了贡献，所以现在有人拥有这是理想的选择

00:04:53.630 --> 00:04:56.210
有人只是把它从互联网上撕下来就可以了

00:04:56.210 --> 00:05:02.870
我想去找我的Jess仓库，而不是刷新它，这就是我们的Jas

00:05:02.870 --> 00:05:08.389
贡献者，我们可以看到它实际上是一个不同的列表

00:05:08.389 --> 00:05:17.099
是的，所以[掌声]

