WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.439 --> 00:00:07.620
大家好，我们来看看go和DSi BFS之间的私有网络

00:00:07.620 --> 00:00:14.190
然后我将做一个最佳的三个数据存储演示，以便我们继续

00:00:14.190 --> 00:00:20.760
并开始这项工作，所以我首先要做的是公开经营

00:00:20.760 --> 00:00:25.109
版本，然后我将运行实际的私有版本，所以这是

00:00:25.109 --> 00:00:32.160
将会是一个Jas和一个go节点，彼此交谈，所以第一个公开，所以

00:00:32.160 --> 00:00:36.870
这不是群钥匙，需要一秒钟才能启动，然后它们才能运行

00:00:36.870 --> 00:00:42.059
所以我们在流量开始时在这里看到的是正常现象，我们看到了

00:00:42.059 --> 00:00:46.559
节点之间顶部的多流协议交换

00:00:46.559 --> 00:00:50.610
然后进入我们烦人的IO加密协商，然后

00:00:50.610 --> 00:00:55.070
之后，所有内容都经过加密，因此我们如何处理专用网络

00:00:55.070 --> 00:01:07.049
它现在将运行，我将继续并重新启动，因此使用私有

00:01:07.049 --> 00:01:11.040
网络，我们正在做的是，我们正在努力泄漏尽可能少的公众信息

00:01:11.040 --> 00:01:16.590
信息可能是人为可能的，也可能是机器人可能的，所以我们该怎么做

00:01:16.590 --> 00:01:26.220
是我们一开始就交换现时数，所以您可以看到没有

00:01:26.220 --> 00:01:29.729
多流，你看不到，你看不到sekai哦，一切都很好

00:01:29.729 --> 00:01:35.600
在开始时看到的24比特随机数交换后已加密

00:01:35.600 --> 00:01:40.200
这是我们的24字节长度，两个便笺都要发送，然后

00:01:40.200 --> 00:01:46.290
一切都加密了，我将快速运行Interop测试，所以我们拥有

00:01:46.290 --> 00:01:52.290
对于中断EST，我们有几个go节点，几个J需要一些

00:01:52.290 --> 00:01:56.460
使用相同的密钥，使用不同的密钥，一些公共，我们正在努力获得

00:01:56.460 --> 00:02:00.689
他们要确保东西不会做不应该做的所有事情

00:02:00.689 --> 00:02:06.200
一旦所有节点启动，它应该运行得相当快

00:02:12.960 --> 00:02:17.920
因此，我们使用相同的专用网络密钥对CJ s 2j进行了处理，我们将J s与

00:02:17.920 --> 00:02:21.970
他们正在做的相同的私有网络密钥是我们将数据放入一个

00:02:21.970 --> 00:02:24.790
节点，然后我们将其从另一个节点中拉出来，所以我们将数据放入

00:02:24.790 --> 00:02:27.820
用气体将其抽出Jaspal中的数据用go抽出

00:02:27.820 --> 00:02:32.320
这完全可以正常工作，而且在不应该互相交谈的情况下

00:02:32.320 --> 00:02:38.740
他们不互相交谈，是的，他们过去了，所以已经有私人的了

00:02:38.740 --> 00:02:45.820
网络支持，我们实际上应该活在31岁左右，但这是

00:02:45.820 --> 00:02:50.830
所有的功能正常工作，所以有人对此有任何疑问吗

00:02:50.830 --> 00:02:55.170
在我转入s3之前

00:03:10.270 --> 00:03:20.800
好吧，现在移到s3数据存储中，这样jess现在就拥有s3数据存储支持，并且

00:03:20.800 --> 00:03:27.520
您可以使用它并且它是实时的，所以这里有一个S或SP数据存储库

00:03:27.520 --> 00:03:33.360
现在要运行这个，我只有一个桶在运行Jacob Hyun德国，

00:03:33.360 --> 00:03:41.290
只是一个临时文件夹，因为您知道数据的持久性，所以我将在

00:03:41.290 --> 00:03:46.870
随时间进行全面调试，只是为了看看这样做是什么，您会在这里看到错误

00:03:46.870 --> 00:03:50.320
这不是真正的错误，因为它正在初始化存储库，所以这是

00:03:50.320 --> 00:03:54.940
第一次回购初始化将花费更长的时间，然后我

00:03:54.940 --> 00:03:58.840
只是上传了25个随机千字节的数据

00:03:58.840 --> 00:04:04.780
没有什么超级大的，但我们转到AZ 3，我们刷新并将其嵌套在

00:04:04.780 --> 00:04:08.380
在我们的ipfs目录中的try文件夹中，我们看到我们的数据块存储了所有

00:04:08.380 --> 00:04:13.390
我们的配置反转，如果我再次运行此命令，您会知道运行大约需要15秒

00:04:13.390 --> 00:04:18.040
第一次包括节点启动，我将再次运行，我们执行

00:04:18.040 --> 00:04:21.670
上传这就是上传并将您拉回去，然后确认我得到了

00:04:21.670 --> 00:04:26.620
我放在那里的数据，所以速度只有一半，所以我很快

00:04:26.620 --> 00:04:29.950
是不是做过Oregan，所以速度要慢得多

00:04:29.950 --> 00:04:35.640
我改变了铲斗区域就这样

00:04:41.100 --> 00:04:50.230
是的，所以很多人都希望备份信息并将其放到s3上，我宁愿

00:04:50.230 --> 00:04:52.900
而不是在本地拥有所有东西，因此这是一个很好的用法，因此您可以

00:04:52.900 --> 00:04:55.870
只需将其放在此处，即可根据需要将其拆分为

00:04:55.870 --> 00:04:59.710
您的密钥或数据存储在本地，您可以指定要在哪里和想要什么

00:04:59.710 --> 00:05:06.040
在那里，我们现在也支持数据存储区中的自定义锁，因为那是

00:05:06.040 --> 00:05:12.120
为了使s3正常工作，我们需要做的其中一件事情

