WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.770 --> 00:00:10.309
好吧，谁知道这套牌有什么用呢？

00:00:10.309 --> 00:00:19.439
有点不错，让我们来谈谈智能文件导入

00:00:19.439 --> 00:00:27.779
到目前为止，已被命名为X的项目代表了数据导入

00:00:27.779 --> 00:00:35.219
导出数据并导出，整个车棚就像说话一样

00:00:35.219 --> 00:00:39.300
关于名称，因为我们选择了很多人提出来的

00:00:39.300 --> 00:00:43.980
嘿，有很多东西叫做Dax，所以也许这不应该是回调

00:00:43.980 --> 00:00:48.930
可以在那个白色的棚子上称重，我不想考虑这件事

00:00:48.930 --> 00:00:56.149
我看到了一个叫做Multi Dax的东西，这很酷，是的，这东西有一个

00:00:56.149 --> 00:01:00.559
你可以去这里再读一遍

00:01:09.409 --> 00:01:14.189
您搜索它，它就会在那里，所以有一种粗糙的斑点

00:01:14.189 --> 00:01:19.649
在这里谈论什么是布局，以及分离器，我们要谈的是

00:01:19.649 --> 00:01:24.539
一会儿再谈一下，然后讨论一下什么的架构

00:01:24.539 --> 00:01:28.170
我们正在谈论以及如何将其插入非常非常基础的内容中

00:01:28.170 --> 00:01:34.590
长期以来，您一直都知道这是IP防护目标的一部分，并且

00:01:34.590 --> 00:01:40.110
对于我们所有人中的许多用例而言，好处确实对您所有人都是巨大的

00:01:40.110 --> 00:01:45.209
只是没有时间来做这个而还没有为这个做过

00:01:45.209 --> 00:01:50.399
一段时间以来，还有其他事情要优先考虑，但实际上是时候

00:01:50.399 --> 00:01:54.659
重温这个，就像我希望您说服我说的那样10

00:01:54.659 --> 00:01:59.219
分钟，对此有很多非常有力的保证，如果我们

00:01:59.219 --> 00:02:03.840
优先考虑下一个季度，您知道每季度25个季度左右

00:02:03.840 --> 00:02:07.289
事情会变得越来越好，并且会有很多开放的用例

00:02:07.289 --> 00:02:12.120
所以我们会深入探讨，但让我们知道，开始要比开始更基本

00:02:12.120 --> 00:02:19.530
因此，您添加的是一个想象，向ipfs添加一些东西，您会得到一个

00:02:19.530 --> 00:02:24.900
一堆散列，你知道你是否在做普通的ipfs，这是你知道的

00:02:24.900 --> 00:02:29.310
这是一个很好的FS，您要添加一堆，因此就像较低级别的IP LD

00:02:29.310 --> 00:02:36.919
哈希链接图，然后最重要的是，我们正在对UNIX文件UNIX进行建模，例如

00:02:36.919 --> 00:02:43.340
熟悉的文件系统，我们希望有朝一日能真正获得POSIX和飞机

00:02:43.340 --> 00:02:47.549
符合或可能不完全符合要求，但至少获得

00:02:47.549 --> 00:02:58.349
如果您还没有的话，这里的权限就是文件系统的内容

00:02:58.349 --> 00:03:02.760
有机会深入研究了IP LD工作的内容

00:03:02.760 --> 00:03:06.269
真正在考虑比文件更低级别的原语

00:03:06.269 --> 00:03:11.010
事实证明文件不是所有这些都基于的正确的东西，所以所有的

00:03:11.010 --> 00:03:14.790
上诉日的工作一直在努力进行一个项目，然后像改组一样

00:03:14.790 --> 00:03:22.330
它位于一颗新的更好的心脏之上，因为真正考虑了结构化数据

00:03:22.330 --> 00:03:26.020
较低的一层更有意义，您可以轻松地将其转换为

00:03:26.020 --> 00:03:30.849
文件，反之亦然，我觉得API很笨重

00:03:30.849 --> 00:03:34.840
您所知道的世界是Web 2.0世界，所以它是所有结构化数据，而不是您

00:03:34.840 --> 00:03:40.660
移动一堆文件，我的意思是你是，但不喜欢你的逻辑，所以

00:03:40.660 --> 00:03:46.239
接下来的很多事情都是特定于文件的，但确实有很多问题

00:03:46.239 --> 00:03:50.290
其他类型数据的机会，所以目标是激发它

00:03:50.290 --> 00:03:53.680
与文件，也许钉，然后考虑其他类型的数据

00:03:53.680 --> 00:03:58.450
结构，因此在普通的UNIX文件系统中，我们知道目录和

00:03:58.450 --> 00:04:03.280
您知道目录或诊断文件或doc节点的文件，并且您知道我们需要

00:04:03.280 --> 00:04:08.470
一个大文件，然后将其切成一堆，所以您知道这是一个图形

00:04:08.470 --> 00:04:13.480
这个目录我想不是，我想是的，你可以在这里看到一堆

00:04:13.480 --> 00:04:17.410
就像您可以看到该目录是一个设置对象一样，您知道它是

00:04:17.410 --> 00:04:23.070
指向一些对象，然后有一个文件恰好是

00:04:23.070 --> 00:04:27.910
碰巧足够大，可以指向其他四个子日志，所以大文件是

00:04:27.910 --> 00:04:30.910
如果您有一个非常大的文件，则将其切成小块，这会

00:04:30.910 --> 00:04:36.130
现在，您如何做，这是一种标准的文件系统技术，您如何

00:04:36.130 --> 00:04:41.350
选择对文件进行分块并将其布局对

00:04:41.350 --> 00:04:47.080
系统的性能以及对用例的巨大影响

00:04:47.080 --> 00:04:50.590
当您开始谈论布局但结构时，就会陷入困境

00:04:50.590 --> 00:04:55.390
图的意思是布局，因此当我们获取文件并将其导入时，

00:04:55.390 --> 00:05:00.610
我们从中构造出的图形在该形状中将具有某种形状

00:05:00.610 --> 00:05:04.660
声明它，我们称之为布局，您有一堆不同的东西

00:05:04.660 --> 00:05:09.850
可能有一棵平衡的树，但是可能会有什么问题

00:05:09.850 --> 00:05:18.100
听起来像是一个问题，如果您拥有正常的标准平衡树可以

00:05:18.100 --> 00:05:20.500
如果您开始尝试播放视频，并且您知道自己喜欢

00:05:20.500 --> 00:05:26.590
CID中的根节点，然后您尝试很好地播放视频

00:05:26.590 --> 00:05:28.830
发生

00:05:33.510 --> 00:05:40.810
所以听起来好像不会系紧时间到第一个字节

00:05:40.810 --> 00:05:44.650
检查，因为如果您有一个非常好的平衡树，那么您会知道

00:05:44.650 --> 00:05:48.310
去尝试寻找第一口，你会下降很多水平

00:05:48.310 --> 00:05:52.810
您找到第一个区块，然后开始流式传输，因此实际上

00:05:52.810 --> 00:05:58.290
您知道第一个节点立即指向数据的偏斜树

00:05:58.290 --> 00:06:04.000
对于普通文件来说这是更有效的方式，这已经成为重点

00:06:04.000 --> 00:06:10.200
不是默认值，而是说如果您通过AB-t细流将为您完成此操作

00:06:10.200 --> 00:06:16.660
但其他类型的文件可能需要不同的布局，这些布局您都知道很好

00:06:16.660 --> 00:06:20.080
细流结构对于诸如视频之类的东西有意义，但可能存在

00:06:20.080 --> 00:06:24.640
您可能想做的其他事情就是布局

00:06:24.640 --> 00:06:30.510
现在，涉及到的其他内容开始考虑

00:06:30.510 --> 00:06:37.540
可能能够以更智能的方式对数据进行重复数据删除，所以请考虑

00:06:37.540 --> 00:06:43.870
一会儿，您有两个文件，并且您知道在其中更改了一个段

00:06:43.870 --> 00:06:48.610
其中之一，也许您现在以正常的方式插入单个字符

00:06:48.610 --> 00:06:52.090
天真的大小的块或东西，那么文件的其余部分将是不同的

00:06:52.090 --> 00:06:55.990
将要散布到一组不同的散列中，稍后我将展示给大家

00:06:55.990 --> 00:07:02.830
在这里，所以您知道是否有这样的假设，即您知道对文件进行分块，然后

00:07:02.830 --> 00:07:07.060
就像您进行更改并说出c3一样，或者您插入了一个

00:07:07.060 --> 00:07:11.950
现在，当您返回并到达UNK哈希时，现在字符c3 c4 c5 6 6到

00:07:11.950 --> 00:07:17.350
7一切都将有所不同，所以听起来有些愚蠢，结果是您

00:07:17.350 --> 00:07:20.770
知道我们知道如何做比比其他技术更好的事情

00:07:20.770 --> 00:07:27.460
找出确定性分块的非常简单的方法

00:07:27.460 --> 00:07:33.130
根据内容本身发生的事情以及那些包裹的东西

00:07:33.130 --> 00:07:38.550
指纹识别，您知道32

00:07:39.120 --> 00:07:46.780
循环哈希函数，例如忘记了措辞，但它们的特定种类

00:07:46.780 --> 00:07:50.860
散列散列散列函数，当您将其应用于文件时开始产生

00:07:50.860 --> 00:07:55.180
某些数字，您可以想出一种算法来选择块

00:07:55.180 --> 00:07:59.260
这样，如果您要向2 C 3插入某些内容，则C 3可能会发生变化

00:07:59.260 --> 00:08:04.360
可能是C 4发生变化，但其余的将放置在其余的大部分中

00:08:04.360 --> 00:08:08.190
文件将以完全相同的方式进行分块，以便获得相同类型的

00:08:08.190 --> 00:08:12.850
不错的属性，所以很多人已经很长时间了

00:08:12.850 --> 00:08:17.800
这也是一个晚上的BFS，你知道你可以通过一个特别的chunk rap和

00:08:17.800 --> 00:08:23.350
指纹识别，这会做关于ipfs robin指纹识别的神话

00:08:23.350 --> 00:08:29.740
帮助整个神话，我将展示它对它只会产生的无济于事

00:08:29.740 --> 00:08:35.410
非常小的块，虽然慢了一段时间，但现在有了badge，就可以了

00:08:35.410 --> 00:08:39.220
也可以选择根本不进行任何分块，这就是get现在要做的事情

00:08:39.220 --> 00:08:43.050
如果根本不进行分块，会发生什么情况

00:08:48.620 --> 00:08:55.800
是的，还有什么是真实的，发生了什么事，就像一个千兆文件

00:08:55.800 --> 00:09:05.069
千兆字节，您更改一个字符是的，所以不要那样做

00:09:05.069 --> 00:09:09.269
自2005年以来，您知道我会很快，因为那不是您应该回到的

00:09:09.269 --> 00:09:14.310
过去的事实证明，这是很多人拥有的原因之一

00:09:14.310 --> 00:09:16.829
获得大型存储库的麻烦是因为这样

00:09:16.829 --> 00:09:19.790
根本无法很好地处理视频和大型资产等问题

00:09:19.790 --> 00:09:24.389
如果我们得到这个进口商的东西，可能真的是真的

00:09:24.389 --> 00:09:28.380
好，有一天它可以使它回到类似它的地方

00:09:28.380 --> 00:09:33.389
关于此事的对话，所以我们现在开始做某人的驾驶工作

00:09:33.389 --> 00:09:35.940
就像一般用途的东西一样，就像您抛出的任何数据一样

00:09:35.940 --> 00:09:39.000
对我来说，我想出一些算法来尝试对它进行分块

00:09:39.000 --> 00:09:43.380
智能化的说唱指纹识别是该rsync的一个版本，可以执行某些操作

00:09:43.380 --> 00:09:48.720
与adler 32类似，我认为有人确实在使用他们所使用的功能，还有其他功能

00:09:48.720 --> 00:09:56.250
诸如如果我们对文件的布局有所了解该怎么办？

00:09:56.250 --> 00:10:16.639
例子让我们看一堆渲染文件我要压缩它们

00:10:19.130 --> 00:10:28.050
对，我想是的，所以如果我补充一点，你知道那不会很好

00:10:28.050 --> 00:10:34.199
但我在那里有一个特殊命令，我认为它是焦油，我认为

00:10:34.199 --> 00:10:39.120
我会很快想到的，那是一个非常特殊的情况是

00:10:39.120 --> 00:10:43.649
它巧妙地导入了tar球，并看着tar球的标头

00:10:43.649 --> 00:10:46.259
并为此创建了特定的对象，我将向您展示其中的不同之处

00:10:46.259 --> 00:10:52.730
在两个图之间，所以看看这个

00:11:06.940 --> 00:11:23.350
好吧，停在那儿，哦，我们忘了通过它-不，不，那不行，我猜

00:11:23.350 --> 00:11:29.130
只有一个物体太小了，在这里让我创造更大的东西

00:11:57.730 --> 00:12:00.910
我们去

00:12:08.310 --> 00:12:12.700
因此，这向我展示了它是我编写的工具的基础，我将对其进行演示

00:12:12.700 --> 00:12:18.010
稍后它向我展示了ipfs生成的基础图，因此我们可以

00:12:18.010 --> 00:12:30.370
可视化，所以这就像右图所示，这些是

00:12:30.370 --> 00:12:35.020
像tarball的基础文件块一样，这是一个中间节点，因此

00:12:35.020 --> 00:12:41.290
这是一个平衡树，所以就像根节点，根节点一样，依此类推

00:12:41.290 --> 00:12:45.190
这不是完美的汉娜故事，但是如果我们要添加的话，它就是这样构建的

00:12:45.190 --> 00:12:53.490
用不同的方法，例如添加，这是Terkel的方法，我们应该做同样的事情

00:12:53.490 --> 00:12:56.600
[音乐]

00:13:04.530 --> 00:13:08.820
刷新它，然后您得到不同的形状，所以这里发生了什么

00:13:08.820 --> 00:13:15.360
好吧，第一个中的很多数据块实际上是在尝试优化

00:13:15.360 --> 00:13:21.000
前几个块，所以在第一个块中有一堆对象，

00:13:21.000 --> 00:13:24.630
那么最底层的它恰好是一个间接的块，它可能有更多的块

00:13:24.630 --> 00:13:30.540
我认为像xt4这样的间接块有四个或类似的东西

00:13:30.540 --> 00:13:35.220
关于您可能想要什么布局的大量研究

00:13:35.220 --> 00:13:41.490
在某些类型的文件系统用例中进行了优化，但tar和

00:13:41.490 --> 00:13:44.580
因此，如果我们现在可视化篷布，这将是一件很酷的事情

00:13:44.580 --> 00:14:09.210
覆盖所有版本哦，是的，它在这里的某个地方，请确保您在

00:14:09.210 --> 00:14:17.250
跟着走，所以这里发生了什么，所以这就像一种方式

00:14:17.250 --> 00:14:25.050
添加东西，使得tarball标头本身是单个IP

00:14:25.050 --> 00:14:33.420
所有对象，所以如果我们喜欢看这个东西，如果我们喜欢在哪里

00:14:33.420 --> 00:14:36.950
猫带了吗

00:14:44.010 --> 00:14:49.180
是的，我们去了那里，那里是什么，你知道那里有一些数据

00:14:49.180 --> 00:14:55.720
这是tarball标头中的东西出奇的大可能是一些

00:14:55.720 --> 00:15:01.900
那里有其他东西，但是如果我构建它就更聪明，那就是我的感觉

00:15:01.900 --> 00:15:04.779
您知道目标是实现某些目标

00:15:04.779 --> 00:15:08.470
能够透明地看到此数据，您将能够看到

00:15:08.470 --> 00:15:11.830
就像其中的结构，这就是获得能力的动力

00:15:11.830 --> 00:15:16.420
就像不必知道IFIF不够聪明

00:15:16.420 --> 00:15:20.200
了解那些内部数据结构，但这就是

00:15:20.200 --> 00:15:26.290
系绳是，实际数据在此处不正确，因此实际数据

00:15:26.290 --> 00:15:31.529
链接，如果我们要遵循该数据，那么这就是该文件的实际类似数据

00:15:31.529 --> 00:15:37.540
所以为什么有人会想到为什么导入一个

00:15:37.540 --> 00:15:40.500
这样的压缩包可能会有用

00:15:51.250 --> 00:15:57.910
是的，所以您可能能够做的一件事就是知道它是一个压缩包

00:15:57.910 --> 00:16:02.199
您可能希望将压缩包搜索到一个特定的文件中，然后将其拉出

00:16:02.199 --> 00:16:08.529
正确，所以当您想知道我们是否要看这个特定的东西时，我

00:16:08.529 --> 00:16:10.899
认为我认为我们实际上可以在这里做到这一点，让我们现在就尝试一下，我不

00:16:10.899 --> 00:16:14.430
认为我曾经尝试过，但是让我们做吧

00:16:14.759 --> 00:16:21.430
所以如果我们接受这个哦，这可能行不通，因为我认为这是期望的

00:16:21.430 --> 00:16:29.759
我们可能可以做到这一点，所以如果我们把它拿出来，那么我们喜欢走进去

00:16:29.759 --> 00:16:33.850
这是因为这是紧张地使用protobuf的东西战争的东西

00:16:33.850 --> 00:16:43.720
如果使用的是更多内容，我们希望遍历更好，但是

00:16:43.720 --> 00:16:48.009
关键是您应该能够遍历该图并拉出一个特定的

00:16:48.009 --> 00:16:53.500
文件，所以这是另一回事，如果您有十个tarball，

00:16:53.500 --> 00:16:57.100
如果您以正常的标准方式对文件进行分块，则我们将包含同一个文件

00:16:57.100 --> 00:17:01.089
我自称不了解这个焦油球，她会把它压碎

00:17:01.089 --> 00:17:04.510
标准方式，如果您使用驾驶指纹识别和

00:17:04.510 --> 00:17:11.890
对齐并可能复制内容，但是如果您这样做，可能不会

00:17:11.890 --> 00:17:17.530
它与smart一起导入，然后立即将复制st。

00:17:17.530 --> 00:17:21.189
只要有一个压缩包恰好包含相同的文件，它就会

00:17:21.189 --> 00:17:26.020
现在就摆放一下，您知道哪里有很多焦油球

00:17:26.020 --> 00:17:34.960
具有完全相同的内容发行版本的软件包发行版本

00:17:34.960 --> 00:17:40.020
经理是对的，所以想一想NPM或类似的事

00:17:40.020 --> 00:17:47.799
软件包包含与您所有版本的软件包完全相同的代码

00:17:47.799 --> 00:17:52.419
就像他们所有人一样现在他们正坐在一个NPM上

00:17:52.419 --> 00:17:57.789
艺术墙等等，就像您知道的那样，想解压缩对不起，请复制他

00:17:57.789 --> 00:18:03.070
所有这些不仅对存储有用，而且对带宽也有用，如果您

00:18:03.070 --> 00:18:06.490
使用ipfs拉下NPM的东西，你

00:18:06.490 --> 00:18:12.509
拉下包装X，那么您可能不需要拉下所有的tarball

00:18:12.509 --> 00:18:21.220
每个人离开NPM的速度太慢了，这就是为什么原因之一

00:18:21.220 --> 00:18:24.730
很有前途，但需要像这样的更聪明的进口商的东西，有一堆东西

00:18:24.730 --> 00:18:29.350
弄清楚还有哪些其他类型的程序包管理器包含一组文件

00:18:29.350 --> 00:18:36.840
与我们拥有的其他类型的软件包管理器非常相似

00:18:43.950 --> 00:18:49.899
所以我想像二进制文件可能具有像巨大的二进制程序这样的基础

00:18:49.899 --> 00:18:53.169
一些软件包中的某些二进制文件很大，它们的兆字节在

00:18:53.169 --> 00:18:57.909
大小，但是当您查看内部结构时，它们会重复很多

00:18:57.909 --> 00:19:03.100
东西，你可以聪明地复制，你可以复制Lipsy

00:19:03.100 --> 00:19:07.690
在大多数包装经理中，我喜欢立即这样做，也许不是因为我认为

00:19:07.690 --> 00:19:11.639
链接器可能会更改地址，但在那里有一些婚礼

00:19:11.639 --> 00:19:17.110
它可以大量复制的另一件事是像Linux ISO这样的东西，所以

00:19:17.110 --> 00:19:22.720
想象一下，如果您运行Ubuntu或Debian，您知道ISO安装程序系统，并且您

00:19:22.720 --> 00:19:27.779
拥有数百个ISO，而您所知道的所有这些都针对不同的ISO

00:19:27.779 --> 00:19:32.379
体系结构和不同的版本等等，您必须喜欢保留所有

00:19:32.379 --> 00:19:36.250
这些周围，实际上，您可能知道数百个ISO

00:19:36.250 --> 00:19:40.539
兆字节包含一堆文件，这些文件在之后是完全相同的版本

00:19:40.539 --> 00:19:45.009
一个版本一个版本地更新，所以如果您聪明地将其导入ISO，

00:19:45.009 --> 00:19:49.120
可以查看其内部文件系统，并智能地复制它们，因此

00:19:49.120 --> 00:19:54.039
然后拥有另一个ISO就是更改，因此

00:19:54.039 --> 00:19:59.470
这种东西的承诺，你知道有很多这样的事情

00:19:59.470 --> 00:20:05.529
由于UNIX和计算的发展，我们最终使用了很多文件

00:20:05.529 --> 00:20:10.929
就像文件和Bob Dole一样，只是文件和文件的移动

00:20:10.929 --> 00:20:18.179
并证明它通常充满了相同的东西，所以让我举一个例子

00:20:18.210 --> 00:20:22.170
我做了很多演示，您重复使用相同的图像，图像很大

00:20:22.170 --> 00:20:28.400
所以你知道我是否必须去谈谈

00:20:30.890 --> 00:20:38.210
所以我有8场主题演讲文件，这只是一堆ipfs演讲，

00:20:38.210 --> 00:20:48.990
如果我想让我看看我是否还在继续回忆-那么我做了什么

00:20:48.990 --> 00:20:54.210
这是我有一个工具，可以让我测试某些工具之间的差异

00:20:54.210 --> 00:21:01.590
不同的回购类型和我们正在使用的导入器，您知道让我们

00:21:01.590 --> 00:21:07.140
用一个普通大小的块检查出导入的大小，那是七个

00:21:07.140 --> 00:21:11.430
演出，他们复制了一些东西，像是随机的，我有点

00:21:11.430 --> 00:21:16.140
感到惊讶的是，它必须像完全相同的文件或其他东西一样

00:21:16.140 --> 00:21:23.370
真的很难得到那么幸运，但接下来让我们看看拉比二

00:21:23.370 --> 00:21:28.350
演出，所以我刚进口了一束，然后就像夜晚一样

00:21:28.350 --> 00:21:32.040
完全天真的东西，就像通用的拉宾指纹

00:21:32.040 --> 00:21:37.620
只是你知道的事就为我省下了四场演出

00:21:37.620 --> 00:21:40.800
现在知道有关基诺的任何事情，想像一下是否知道有关基调的知识，

00:21:40.800 --> 00:21:44.970
它如何表示自己的内部文件，这可能会大大地分块

00:21:44.970 --> 00:21:50.610
更好的权利，所以这就像一个承诺，有一堆

00:21:50.610 --> 00:21:54.480
我们可以学习如何分块的各种文件，因此

00:21:54.480 --> 00:21:59.880
该项目的目标是要提出类似这样的下一件事是

00:21:59.880 --> 00:22:03.930
提出了一种解决该问题的通用方法，因为

00:22:03.930 --> 00:22:06.360
那里有很多不同的文件，您不想

00:22:06.360 --> 00:22:11.100
为所有事物实施特殊的垃圾邮件，但您想构建一个项目，例如

00:22:11.100 --> 00:22:15.720
当某人需要一个人创建我们时，他们可以然后进行基准测试

00:22:15.720 --> 00:22:21.570
反对你知道做天真的事，否则人们可以进行研究

00:22:21.570 --> 00:22:25.740
其中一些像滚动哈希函数之类的东西，看看他们是否可以得到

00:22:25.740 --> 00:22:30.030
工作得更好，所以想法是想像这样的结构

00:22:30.030 --> 00:22:32.390
说让我们撕掉所有文件

00:22:32.390 --> 00:22:35.120
从IP us的核心实现中导入内容

00:22:35.120 --> 00:22:41.210
不同的模块集，并具有一组知道的程序和库

00:22:41.210 --> 00:22:45.980
如何导入文件，必然会消耗文件作为输入和输出

00:22:45.980 --> 00:22:52.160
我呼吁de Grasse，所以您可以考虑如何配置

00:22:52.160 --> 00:22:58.910
那就是那个用来调整其工作原理的分块器，然后您会知道ipfs

00:22:58.910 --> 00:23:03.140
将其作为库导入并在本地运行，可能还有其他一些实现

00:23:03.140 --> 00:23:08.090
可能实际上调用了其他程序或其他程序，但这就是我们

00:23:08.090 --> 00:23:10.940
可以使它可插拔，以便人们可以反对

00:23:10.940 --> 00:23:15.890
说嘿，你知道我刚想出一种导入基调文件的方法，在这里

00:23:15.890 --> 00:23:19.940
你走了，或者嘿想出了一种在这里走ISO的方法

00:23:19.940 --> 00:23:25.910
这就是我们可以扩展的方式，这就是我们可以做到的，理想情况下，我们

00:23:25.910 --> 00:23:28.429
会用一种语言来做到这一点，而不是不得不去看不同的话

00:23:28.429 --> 00:23:31.570
语言，但这涉及整个问题，例如什么组装和

00:23:31.570 --> 00:23:37.520
就像将成为赢家，但您现在就知道我们可以跟随

00:23:37.520 --> 00:23:39.770
与我们对其他实现的结构相同的结构

00:23:39.770 --> 00:23:44.960
两种语言，看看效果如何，因此我们对其中的一些问题有所保留

00:23:44.960 --> 00:23:48.770
我们已经有了基本的布局之类的东西，还有一些分块器

00:23:48.770 --> 00:23:52.250
我喜欢压缩包，但我们想做很多更酷的事情，我认为

00:23:52.250 --> 00:23:56.929
ISO的发展前景非常广阔，我认为让它真正发挥作用

00:23:56.929 --> 00:24:00.200
对于包装经理来说，这也确实很有前途，因此，如果我们将其视为

00:24:00.200 --> 00:24:04.880
短期用例，并追随它们，然后我们可能会加快速度

00:24:04.880 --> 00:24:09.380
今早一大堆东西在谈论我们正在做的事情

00:24:09.380 --> 00:24:15.320
JavaScript CD的结尾就结束了，因此，如果他们像CDN那样放弃了一大堆

00:24:15.320 --> 00:24:19.100
像jQuery这样的JavaScript就像您知道每个版本一样

00:24:19.100 --> 00:24:24.260
相当大的东西具有相同的东西，您可以巧妙地将它们切掉

00:24:24.260 --> 00:24:27.710
相同或类似捆绑包的模块，例如Web Pack捆绑包

00:24:27.710 --> 00:24:32.200
模块是相同的，并且喜欢以这种方式导入，所以您不必喜欢

00:24:32.200 --> 00:24:40.340
一直将所有相同的东西粘合在一起，所以这是一堆

00:24:40.340 --> 00:24:45.170
有趣的工作在这里，我认为我们可以重新启动项目的方式

00:24:45.170 --> 00:24:51.350
是通过组建工作小组来进行的，因此首先要考虑的是方法

00:24:51.350 --> 00:24:54.800
确定用例以及对此可能感兴趣的人员

00:24:54.800 --> 00:25:00.530
可能会从中受益的项目，然后看看您是否知道我们有

00:25:00.530 --> 00:25:04.310
在公司中做到这一点的带宽，或者我们知道我们一直在拖延时间，

00:25:04.310 --> 00:25:09.140
没什么，但这对我教授这两种实现都有利。

00:25:09.140 --> 00:25:13.070
将使集群受益，因为它将能够更智能地理解

00:25:13.070 --> 00:25:17.210
收集的数据就是我刚才所说的一个叫做pack的工具

00:25:17.210 --> 00:25:21.800
从未见过这是围绕数据集分布进行的实验

00:25:21.800 --> 00:25:26.570
已经有一种方法可以描述您使用的进口商，以便我们

00:25:26.570 --> 00:25:31.250
有一些描述，但您可以始终采用相同的文件

00:25:31.250 --> 00:25:35.750
描述并输出相同的图形，以便您在进口商转换时知道

00:25:35.750 --> 00:25:41.060
如果没有，您总是可以在数据包管理器中返回完全相同的结果

00:25:41.060 --> 00:25:44.900
ISOs容器，所以事实证明，一个docker容器只是一堆

00:25:44.900 --> 00:25:49.670
焦油球砸碎在一起，很多星空墙通常都含有相同的

00:25:49.670 --> 00:25:52.040
有时它们是焦油球中的星星球

00:25:52.040 --> 00:25:54.530
因此，如果您曾经玩过类似容器图像的游戏，

00:25:54.530 --> 00:25:59.090
里面只有一堆焦油球，所以如果您要聪明地导入它们

00:25:59.090 --> 00:26:02.150
你可以复制一吨这样的东西，然后也许你可以缩小

00:26:02.150 --> 00:26:07.640
像整个容器一样，我认为打到我们这里的docker hub可能

00:26:07.640 --> 00:26:12.710
大幅缩小，然后您就不必花很多时间思考

00:26:12.710 --> 00:26:16.760
就像人们在海上花费的所有带宽一样

00:26:16.760 --> 00:26:20.090
就像只是一遍又一遍地下载相同的图像一样

00:26:20.090 --> 00:26:25.940
相同的字节或移动它是荒谬的，并且您知道您可以然后

00:26:25.940 --> 00:26:29.900
开始，看看一旦开始这样做，它怎么会变得更加疯狂

00:26:29.900 --> 00:26:37.040
您可能会想到自己像OS一样，或者就像您在Windows上运行VM一样

00:26:37.040 --> 00:26:41.240
像这样的东西或像内部数据一样能够理解的东西

00:26:41.240 --> 00:26:45.590
你们的结构知道您像VM映像一样，不仅像ISO，而且

00:26:45.590 --> 00:26:49.460
就像正在运行的计算机的映像，然后智能地将其导入，然后

00:26:49.460 --> 00:26:53.570
喜欢了解它的这种内部状态，就像你知道自己一样

00:26:53.570 --> 00:26:57.230
就像Frosty的迁移一样，但都像流程的迁移一样

00:26:57.230 --> 00:27:00.230
就像我没有你曾经看过其中的一些作品，但那是你知道一个现场

00:27:00.230 --> 00:27:05.000
带有虚拟机管理程序的系统上运行，并且有一个虚拟机正在运行，然后发生某些情况

00:27:05.000 --> 00:27:08.900
而且您有一个该VM的稍旧快照，他们想

00:27:08.900 --> 00:27:13.610
将该过程迁移到其他地方，例如在云中使用很多

00:27:13.610 --> 00:27:19.460
这样做，您知道这类东西甚至都不会在那儿应用，是的，我们

00:27:19.460 --> 00:27:25.450
谈论媒体，然后您会进入一个非常有趣的领域，那就是

00:27:25.450 --> 00:27:29.929
一旦拥有了所有这些中继导入器的东西，就可以开始放入

00:27:29.929 --> 00:27:36.650
功能在那里，所以想象一下对图像或某物应用滤镜，然后

00:27:36.650 --> 00:27:39.530
表达滤镜的方式不是通过应用

00:27:39.530 --> 00:27:43.820
过滤，然后渲染，但拍摄原始图像并附加一个

00:27:43.820 --> 00:27:49.520
在代码中对其进行过滤，然后运回，用户运行起来，因此这是一个

00:27:49.520 --> 00:27:53.870
文件，它看起来像一个普通文件，但是如果您可以智能地执行代码

00:27:53.870 --> 00:28:00.380
在它从ipfs传给用户之前，它就像是一个文件

00:28:00.380 --> 00:28:04.520
与其他所有方法相同，因为输出了购买时间但存储了一些时间

00:28:04.520 --> 00:28:08.720
引擎盖下面的方式非常不同，所以您知道这暗示着

00:28:08.720 --> 00:28:11.929
我们可以开始做的很多其他事情可以进行压缩

00:28:11.929 --> 00:28:15.320
你可以用这种方式进行加密和解密，我有一点

00:28:15.320 --> 00:28:18.590
在我拥有压缩文件并剥去眼睛之前，先进行随机破解

00:28:18.590 --> 00:28:22.190
指向压缩文件并指向键的对象，然后我

00:28:22.190 --> 00:28:26.150
挂载那个和一个挂载，然后我看到文件

00:28:26.150 --> 00:28:31.940
未加密，每次写入时都会将加密内容写入IVF，因此

00:28:31.940 --> 00:28:34.490
那是很多可以去的地方，但是有一些重要的地方

00:28:34.490 --> 00:28:39.230
到达那里的路障，这就是这个，您知道我们最近如何做所有这一切

00:28:39.230 --> 00:28:46.190
等等，是的，我想我要在这里暂停，因为我认为

00:28:46.190 --> 00:28:49.760
我们已经在吃午饭了，我要把你从食物中拉出来，他们

00:28:49.760 --> 00:28:54.380
不想那样做，我要提问，然后如果您有兴趣

00:28:54.380 --> 00:29:00.410
希望您能对此有更多的了解，并可能希望加入我们的工作小组

00:29:00.410 --> 00:29:07.340
这让我知道，然后我将了解我们是否可以开展工作

00:29:07.340 --> 00:29:10.360
下一个季度或下一个季度的分组

00:29:10.360 --> 00:29:33.159
伟大的任何正确的问题，所以我确实设想一组理智的默认值，但

00:29:33.159 --> 00:29:37.059
重要的是，我们始终能够返回完全相同的文件，并且

00:29:37.059 --> 00:29:44.529
这是ffs后面的东西出现的地方，这很重要

00:29:44.529 --> 00:29:53.769
与我知道我们被称为的地方，我认为这是一个格式字符串，我想是这样

00:29:53.769 --> 00:29:57.730
定义，所以这将是Dex项目的一部分，就像是一个字符串

00:29:57.730 --> 00:30:04.570
只是一个字符串，它定义了涉及哪些配置选项

00:30:04.570 --> 00:30:06.970
您可以获取完全相同的文件，并每次产生完全相同的输出

00:30:06.970 --> 00:30:10.870
时间，然后您就知道是否要从那里升级

00:30:10.870 --> 00:30:16.870
完全理智，所以可以将其加入进来，这样维权人士可以添加东西

00:30:16.870 --> 00:30:20.559
被增强以包括您知道可以指定的字符串（如果您知道的话）

00:30:20.559 --> 00:30:22.960
什么是正确的，而不是指定其他的选项

00:30:22.960 --> 00:30:27.970
在那里，但我认为随着时间的流逝，我们可以达到相同的默认值，但是

00:30:27.970 --> 00:30:31.539
通过基准测试，您应该知道严格的基准测试

00:30:31.539 --> 00:30:39.880
表示嘿，当您执行此视频时，其他任何人都会变得更好

00:30:39.880 --> 00:30:46.200
是的，是的

00:30:52.190 --> 00:30:57.560
因此，我认为最大的障碍可能是社交能力比

00:30:57.560 --> 00:31:03.280
我认为这只是演示内容，然后提出

00:31:03.280 --> 00:31:08.840
在同性恋社区看来，他们会喜欢的东西会

00:31:08.840 --> 00:31:15.200
必须学习如何处理内部大块文件，因此

00:31:15.200 --> 00:31:21.050
那需要仔细考虑一下，内部不是

00:31:21.050 --> 00:31:26.900
如此复杂，这是相当不错的结构，所以这很漂亮

00:31:26.900 --> 00:31:29.690
和平只是考虑一堆的影响而已

00:31:29.690 --> 00:31:35.150
假设文件始终是单个文件的工具，我想

00:31:35.150 --> 00:31:40.430
这些工具中有很多会期望您像

00:31:40.430 --> 00:31:45.230
压缩表示形式，就像普通的标准文件一样

00:31:45.230 --> 00:31:48.220
只是有点希望发生，但是[音乐]

00:31:48.220 --> 00:31:52.610
是的，我想我认为这会相当重要

00:31:52.610 --> 00:31:56.660
努力，但我认为覆盖整个范围肯定是值得的

00:31:56.660 --> 00:31:59.630
一堆用例，您突然应该可以使用所有

00:31:59.630 --> 00:32:03.530
适用于git版本控制和提交等的工具，并将其应用于

00:32:03.530 --> 00:32:08.150
现在像您一样对非常大的数据进行版本控制真的很难对版本进行控制

00:32:08.150 --> 00:32:11.330
大数据仍然令人难以置信，就像人们已经为此工作了很多年一样

00:32:11.330 --> 00:32:19.130
而且它仍然很糟糕，因此很多有关git的工具都非常不错，

00:32:19.130 --> 00:32:21.770
人们在github和整个方面构建的很多东西

00:32:21.770 --> 00:32:25.040
一堆其他工具，也非常不错，如果能够

00:32:25.040 --> 00:32:29.600
在大数据的版本控制中重复使用所有这些功能，但这成为一个问题

00:32:29.600 --> 00:32:32.480
像我们怎么做的是复数是什么

00:32:32.480 --> 00:32:35.570
上课真的看起来很像，说嘿，我们要添加所有的支持

00:32:35.570 --> 00:32:41.330
我认为最大的部分是说服该小组

00:32:41.330 --> 00:32:45.740
值得的，那就像是在看事情的真正困难的事实一样

00:32:45.740 --> 00:32:52.990
所有这些回购都着眼于什么，现在可以突然做对了

00:33:02.880 --> 00:33:05.880
是的

00:33:12.320 --> 00:33:15.320
是的

00:33:37.770 --> 00:33:48.150
代码是数据权，数据是代码，所以对于那些不熟悉IPL的人来说，

00:33:48.150 --> 00:33:53.770
努力是它正在深入计算，所以事实证明

00:33:53.770 --> 00:33:58.990
浪费在如何改善分布上实际上是一个

00:33:58.990 --> 00:34:03.480
最重要的应用是重新考虑我们如何混合使用计算和数据

00:34:03.480 --> 00:34:09.790
因此，您可以阅读此处的大量说明

00:34:09.790 --> 00:34:15.880
用例讨论潜在的事物，进行一系列不同的讨论

00:34:15.880 --> 00:34:18.520
我认为我们在这里聚集的最有价值的东西可能是

00:34:18.520 --> 00:34:23.560
这个很棒的书目，你知道你可以潜入一堆

00:34:23.560 --> 00:34:28.090
就像这里真的很棒的纸一样，很多这些东西更多地是关于

00:34:28.090 --> 00:34:33.550
计算胜于数据，所以我不知道您是否还会保留所有内容

00:34:33.550 --> 00:34:36.730
在那儿，我觉得D可能会产生不同的效果，例如弹出一个不同的

00:34:36.730 --> 00:34:44.500
项目之类的东西，但是嗯，是的，我认为其中很多确实成为了现实。

00:34:44.500 --> 00:34:50.620
首先考虑一下我们如何表示文件

00:34:50.620 --> 00:34:57.400
只存储字节流，为什么我们不考虑存储代码呢？

00:34:57.400 --> 00:35:07.000
因此，就语言而言，有一些工作要做，

00:35:07.000 --> 00:35:09.160
一系列问题实际上很有趣，因为我正在写一封关于我们的电子邮件

00:35:09.160 --> 00:35:14.770
今天致某人，我正在从事一种叫做“我的积木很平静”的事情

00:35:14.770 --> 00:35:19.230
思考或调用块或它谈论的有关完全做到这一点的事情

00:35:19.230 --> 00:35:26.530
所以你知道一个例子就是这个栈流是yep的一部分

00:35:26.530 --> 00:35:30.730
教授探索了一系列愿望，并提出了一个非常简单的想法

00:35:30.730 --> 00:35:37.700
可以结合其他对象并产生东西的语言

00:35:37.700 --> 00:35:44.600
像两个普通文件将其子级连接起来，所以他将链接一个

00:35:44.600 --> 00:35:50.060
文件想要链接两个子文件，它们会将它们加在一起

00:35:50.060 --> 00:35:53.480
它自己的内部数据段，然后您就可以编写一个

00:35:53.480 --> 00:35:57.560
代表它的功能，然后您可以发货，所以这是IP全部

00:35:57.560 --> 00:36:02.660
这些事情发生在我们不想开始写特殊情况的地方

00:36:02.660 --> 00:36:06.320
到ipfs中，我们不想像这样哦，这真是个很酷的主意

00:36:06.320 --> 00:36:11.780
让我们用另一种语言来编写类似代码的东西，并将其包括在内

00:36:11.780 --> 00:36:14.510
使用BFS，在这里拥有VM真是太好了

00:36:14.510 --> 00:36:21.560
就像Wes Emily VM一样，然后在我剥离对象时指向代码本身

00:36:21.560 --> 00:36:25.760
然后在另一件事上应用该功能，这样看起来

00:36:25.760 --> 00:36:31.700
就像文件将是一个函数调用，您知道它也指向

00:36:31.700 --> 00:36:35.210
到代码本身，因此它知道如何解释自己，然后它将

00:36:35.210 --> 00:36:39.170
指向数据，然后您便知道如何流式传输

00:36:39.170 --> 00:36:52.250
该文件正是如此，所以有些东西非常优雅，

00:36:52.250 --> 00:36:59.570
潜伏在那里，我们一直在探索

00:36:59.570 --> 00:37:04.580
事物，我们发现了代表这些事物的相当不错的方式，我认为

00:37:04.580 --> 00:37:09.560
我们被封锁实际上是时间，我想我们当中有些人是如此分散

00:37:09.560 --> 00:37:14.600
我认为斯蒂芬无法一次完成所有这些隔离工作

00:37:14.600 --> 00:37:17.750
例如某人已经想通了很多，

00:37:17.750 --> 00:37:20.960
就像想要建造它，但是随后需要维护下去，我自称

00:37:20.960 --> 00:37:30.980
写得好，所以我的意思是，这绝对是一个公开的帮助

00:37:30.980 --> 00:37:35.690
在FLD团队中，因为午餐后马上来

00:37:35.690 --> 00:37:40.310
讨论一下，如果您想听到我的饮食感觉，因为有一个

00:37:40.310 --> 00:37:43.580
许多非常有价值的东西可能会由此产生，因此进口商

00:37:43.580 --> 00:37:49.490
东西是VIP OD参数，足以做进口商的东西而无需

00:37:49.490 --> 00:37:53.599
想了很多，然后又晚了，但与此同时，我们

00:37:53.599 --> 00:37:56.390
可以继续进行这些探索，然后产生更有趣的东西

00:37:56.390 --> 00:38:00.019
对，所以我们有点想在此阶段提供服务

00:38:00.019 --> 00:38:05.539
就非常简单的分块和短期收益而言

00:38:05.539 --> 00:38:10.369
拆分我们已经可以做的事，然后在我们考虑可计算性之后

00:38:10.369 --> 00:38:15.829
文件，然后打开了一大堆其他可能性，所以是的

00:38:15.829 --> 00:38:21.890
我认为计算和

00:38:21.890 --> 00:38:27.140
我们如何表示事物，这将很好，我们必须通过所有

00:38:27.140 --> 00:38:32.749
可能性，然后像我们出去一样早点开始做一些事情，是的

00:38:32.749 --> 00:38:36.170
希望您知道我们可以开始减少那里的大量数据

00:38:36.170 --> 00:38:41.589
因为实际上很多东西只是垃圾而已，对不起，重复了

00:38:41.589 --> 00:38:48.950
其他问题，或者如果有人的话，我们真的可以释放您的食物

00:38:48.950 --> 00:38:52.519
想要广泛讨论这一点，您可以留下，否则我们将其称为

00:38:52.519 --> 00:39:02.420
完成并看到您运行，谢谢，是的，如果您对工作感兴趣

00:39:02.420 --> 00:39:05.959
将这里的人分组，或者如果您在以后的谈话中正在观看此视频

00:39:05.959 --> 00:39:08.199
给我们

