WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.860 --> 00:00:06.960
您好，欢迎大家，这是ipfs每周的酷9月9日

00:00:06.960 --> 00:00:12.780
2019年9月我正在动脑筋，今天我将成为您的主持人，我们将有一个

00:00:12.780 --> 00:00:18.930
关于Dirk步行协议的Dirk演讲以及那里即将进行的改进

00:00:18.930 --> 00:00:27.060
而且我刚刚将注释添加到了聊天中，所以如果您还有其他需要

00:00:27.060 --> 00:00:30.650
想掩盖今天坚持的议程

00:00:30.800 --> 00:00:45.300
如果我可以请一个笔记记录员，请在笔记中注明好消息或名字

00:00:45.300 --> 00:00:48.329
已经不是很厚了，因为我只是复制并粘贴了上周的

00:00:48.329 --> 00:00:52.640
帮你省些打字，我会写正确的

00:00:53.480 --> 00:00:58.230
有没有人要添加任何东西到议程上，还是我们直接跳过

00:00:58.230 --> 00:01:06.030
好东西，不，是毛茸茸的，是的，以防万一

00:01:06.030 --> 00:01:11.159
斯科特（Scott）上的任何人，在离线培训营开始之前没有听说过这项技能

00:01:11.159 --> 00:01:16.140
重新安排它的时间是9月27日至30日在俄勒冈州，我是西方

00:01:16.140 --> 00:01:19.470
莱斯利和我很安全，所以如果有人对离线的第一乐章感兴趣

00:01:19.470 --> 00:01:25.080
或网络与应用程序之间的连接如何脱机工作，然后

00:01:25.080 --> 00:01:29.790
低带宽用例Molly和我将在屏幕上四处寻找

00:01:29.790 --> 00:01:32.850
看看这里还有谁，还有这个快速社区的其他一些人，

00:01:32.850 --> 00:01:38.820
我感觉会在附近的人迈克尔·伯恩（Michael Byrne），我的哦，迈克尔·伯恩（Michael Burns）

00:01:38.820 --> 00:01:46.290
是的，是的，我可以看到他那火热的斧头家伙，是的，所以我们中的一些人会在那里

00:01:46.290 --> 00:01:48.960
我们希望有更多的公司，我们还有几张票，还有

00:01:48.960 --> 00:01:53.399
剩下的奖学金，所以我将链接粘贴到聊天室中，然后在

00:01:53.399 --> 00:01:56.060
分钟也

00:01:59.790 --> 00:02:10.320
很酷的其他人，不，带走爸爸

00:02:10.680 --> 00:02:13.680
好吧

00:02:18.750 --> 00:02:25.260
你们看到我的屏幕可以看见你的脸

00:02:26.380 --> 00:02:29.789
[音乐]

00:02:31.170 --> 00:02:40.780
不，是，很酷，所以对于那些不认识我的人，我叫杜克，我就像

00:02:40.780 --> 00:02:51.250
协议实验室嗯，今天我要谈论的是位交换，这样我就可以

00:02:51.250 --> 00:02:57.640
指针在这里，所以位交换是我PFS从网络获取内容的方式，因此

00:02:57.640 --> 00:03:02.080
它会从其本地存储区中询问四个存储区，还是我们

00:03:02.080 --> 00:03:05.110
找不到那里会很不错的交换位交换或出去

00:03:05.110 --> 00:03:13.480
网络，所以当我PFS要求从位交换东西时，只有一点背景

00:03:13.480 --> 00:03:19.450
通常以两种主要方式进行操作，因此一种方式是请求

00:03:19.450 --> 00:03:24.670
整个文件里塞满了东西，所以通常它会请求路由块路由

00:03:24.670 --> 00:03:29.650
块包含到子节点的链接，然后这些子节点包含到子节点的链接

00:03:29.650 --> 00:03:34.330
进一步的子节点，因此请求模式将被要求一个块

00:03:34.330 --> 00:03:39.459
几个街区，然后问他们我们另一个主要的方式

00:03:39.459 --> 00:03:44.590
请求块是通过询问路径，例如，当它请求一个

00:03:44.590 --> 00:03:51.850
网站上的页面，它将询问路线并检查链接以查找

00:03:51.850 --> 00:03:56.670
页面，一旦找到该页面，它将检查链接以查找医生HTML和

00:03:56.670 --> 00:04:02.739
然后它将获取该文档中的所有块，因此Chris Patten在这里是

00:04:02.739 --> 00:04:08.910
请求一个块请求一个块请求出生的块请求多个块

00:04:09.840 --> 00:04:13.520
所以我们有很高的扇出度

00:04:13.520 --> 00:04:17.690
例如在Wikipedia或网页中，通常会有几个节点

00:04:17.690 --> 00:04:22.250
具有所有信息的网络，例如为其提供服务的服务器

00:04:22.250 --> 00:04:26.600
最初，然后会有很多节点包含树的一部分，因此

00:04:26.600 --> 00:04:30.800
当它使用浏览器时，他们会为不同的用户下载不同的位

00:04:30.800 --> 00:04:35.780
网站中的文档，因此右侧有这种可视化效果

00:04:35.780 --> 00:04:38.750
在这里您可以看到三个不同的对等点，每个对等点都有不同的部分

00:04:38.750 --> 00:04:54.560
树，那么我们如何找到东西，以便将第一件事交换一下，它会完成所有

00:04:54.560 --> 00:04:59.180
对等方连接到“发给我”的路由块，我们称之为“ 1”

00:04:59.180 --> 00:05:05.510
因此，如果没有人，Tenzer不会请求所有这些连接的对等节点，然后

00:05:05.510 --> 00:05:15.380
问DHT嘿，谁拥有这个东西，谁曾经是这个区块的提供者

00:05:15.380 --> 00:05:19.610
有人回应或少数同伴回应，我们将其添加到称为“ a”的内容中

00:05:19.610 --> 00:05:25.340
会话，因此通常会询问相同的同龄人将有相关的

00:05:25.340 --> 00:05:30.530
像一大堆同龄人一样的块将具有相同的文件，因此会话只是

00:05:30.530 --> 00:05:34.220
给我们提供了一种将所有同龄人保持在一起的方式，这样我们就可以做出任何

00:05:34.220 --> 00:05:43.910
随后对同一组对等方的请求，因此我们有一个这样的概念

00:05:43.910 --> 00:05:55.160
列出，因此在此示例中，对等体来自对等体B和P OB的一次CID 1和CID 2

00:05:55.160 --> 00:06:02.200
保留其本地副本，其中包含ID为PR的ID，因此如果PR为ID则阻止

00:06:02.200 --> 00:06:07.430
一旦PR B收到了cid的阻止，我们可以说也许是在它的阻止中

00:06:07.430 --> 00:06:13.130
存储已经将其发送到PR a，并将其从本地删除

00:06:13.130 --> 00:06:18.740
泥浆一份清单的副本，因此只要保留一份清单，就可以保留一份清单

00:06:18.740 --> 00:06:22.270
对等体已连接，然后将其丢弃

00:06:23.759 --> 00:06:28.650
有一个理事会消息，所以在一个类似的例子中，假设PRA发送了一个

00:06:28.650 --> 00:06:34.259
CID一和二的对等方与Pierre B，然后PRA收到某人的阻止

00:06:34.259 --> 00:06:38.639
否则PRA告诉POV嘿，我不再需要这个了

00:06:38.639 --> 00:06:49.710
而Pierre B可以将其从浆糊的需求列表中删除，因此我们如何知道哪个

00:06:49.710 --> 00:06:56.069
要向会话中的对等点基本上发送给哪些对等点的IDS，其排序方式为

00:06:56.069 --> 00:07:02.879
延迟，当我们收到一堆请求时，我们将请求拆分

00:07:02.879 --> 00:07:09.089
在这个例子中，我们有一个三因子的分裂因子

00:07:09.089 --> 00:07:17.069
这三行和CID零，三，六和九将分别发送给同级

00:07:17.069 --> 00:07:25.050
D和G的CID是1 4 7到e，H的CID是2 5和8到C和F，所以

00:07:25.050 --> 00:07:31.800
可以看到多个，因此将一个发送给多个对等方，这样，在这种情况下，我们可能

00:07:31.800 --> 00:07:37.319
对于多个对等体，返回相同的块，我们称其为重复，因此，如果我们

00:07:37.319 --> 00:07:41.189
开始得到很多重复，然后我们更改分割因子，因此在此

00:07:41.189 --> 00:07:47.399
情况下，我们将本书的系数更改为5，共有5行，如您所见，每行

00:07:47.399 --> 00:07:52.499
现在将CID发送给较少的对等方，因此CID 0被发送到a，F 5被发送到

00:07:52.499 --> 00:07:57.959
a和F，依此类推，如果我们发现缺少框，则表示超时或

00:07:57.959 --> 00:08:02.999
我们只是在很多时候才获得唯一身份，然后我们更改了拆分因子

00:08:02.999 --> 00:08:10.129
再次发送每两年一次，这就是目前的工作方式

00:08:11.839 --> 00:08:16.699
最后是速率限制的概念，所以每个会话

00:08:16.699 --> 00:08:23.659
因为一次直播的速率限制为32次，而一次直播的速率限制是我希望我们发送的

00:08:23.659 --> 00:08:27.319
说出来嘿，我们想要这个东西，但我们还没有收到任何人的回音

00:08:27.319 --> 00:08:35.659
说他们有，所以在此示例中，我们有8个待处理，所以说

00:08:35.659 --> 00:08:42.680
我们从ipfs那里获得了8个区块的请求，所以我们发出了最大数量的实时信号

00:08:42.680 --> 00:08:46.220
在本例中，此示例中的队列很多冻结，我们的live 1

00:08:46.220 --> 00:08:51.740
队列的限制为4，因此我们将4个块放入发送的实时1队列中

00:08:51.740 --> 00:08:57.769
将它们发送给对等方，在这种情况下，我们返回2个块CID 0和2

00:08:57.769 --> 00:09:02.509
现在它们已经完成，所以我们现在有空间放置两个移动两个块

00:09:02.509 --> 00:09:10.220
从待处理的队列到实时队列，那么有什么问题

00:09:10.220 --> 00:09:15.529
在当前的位交换实现中，我们要解决的一个问题是

00:09:15.529 --> 00:09:19.850
实际上，我们真正想要的是按延迟对码头进行排序

00:09:19.850 --> 00:09:27.829
以吞吐量显示，以便最大程度地增加带宽，并在一个请求之间分配一个请求

00:09:27.829 --> 00:09:33.470
同伴，但通常我们一次只会收到一个或两个区块的请求

00:09:33.470 --> 00:09:39.829
当像以前的幻灯片中一样发生这种情况时，也会发生这种情况。

00:09:39.829 --> 00:09:44.779
幻灯片，这里只有两个插槽，因此

00:09:44.779 --> 00:09:51.230
在我们的同龄人中分裂这么少的一次，这才是真正有意义的

00:09:51.230 --> 00:09:58.399
当我们只有一点点时间时，会进行各种请求拆分，因此我们想要的是

00:09:58.399 --> 00:10:02.000
迈向我们所谓的流式传输，意思是对待那些

00:10:02.000 --> 00:10:06.050
单独而不是分组，然后根据我们的概率选择同伴

00:10:06.050 --> 00:10:12.199
坚持的基础，我们还有另一个问题是，一旦限制了每个会话的时间

00:10:12.199 --> 00:10:16.959
真的，我们不想让同龄人超负荷，所以我们想对每个同龄人进行限速

00:10:16.959 --> 00:10:23.509
因此，例如，在网关上，我们最终让您知道了数千个会话

00:10:23.509 --> 00:10:28.400
当重新获得重复的块时，效率有点低下

00:10:28.400 --> 00:10:33.710
我们正在做发现，所以我们希望有一种方法来弄清东西在哪里

00:10:33.710 --> 00:10:39.440
无需获取障碍物，我们也想尝试保持耳朵忙碌的含义

00:10:39.440 --> 00:10:43.040
始终确保同行有东西要发送给我们，以便他们保持管

00:10:43.040 --> 00:10:48.520
充分利用以优化带宽使用

00:10:50.980 --> 00:10:56.990
所以斯蒂芬和我有点聚在一起，我们提出了一些协议

00:10:56.990 --> 00:11:02.570
扩展um，所以目前这是一项正在进行的工作，但

00:11:02.570 --> 00:11:06.950
我会告诉你我们目前的想法是什么，所以我们有了新的想法

00:11:06.950 --> 00:11:11.660
一条消息称为“有一条消息”，基本上，这使同伴可以说我

00:11:11.660 --> 00:11:15.920
有此块但不实际发送该块，因此这特别有用

00:11:15.920 --> 00:11:25.010
为了发现，所以在我们这里的例子中，一群人说P种族结束了我

00:11:25.010 --> 00:11:31.550
想要有消息说像嘿，您是否有此CID，在此显示BC和D

00:11:31.550 --> 00:11:37.370
说是的，我知道了，所以普拉说好了，现在给我我意思是这里的方块C

00:11:37.370 --> 00:11:44.060
和D只是说哦，我也有这个方块，然后Pierre B实际上发送了

00:11:44.060 --> 00:11:48.520
在优化的情况下，如果块足够小，则返回块

00:11:48.520 --> 00:11:58.580
我们可以跳过一半，所以pob会立即将块发送回去，因此

00:11:58.580 --> 00:12:01.589
我们添加的第二个产品扩展名是没有

00:12:01.589 --> 00:12:08.070
消息，所以目前为了知道一个对等方是否有一个障碍，我们只是有

00:12:08.070 --> 00:12:13.110
要求块，然后取回块或等待超时

00:12:13.110 --> 00:12:16.320
没有消息允许彼得立即向我们发出信号并说我

00:12:16.320 --> 00:12:23.730
没有这个，所以这可以让我们非常快速地确定分布

00:12:23.730 --> 00:12:28.680
我们想要的块的数量，因此在此示例中，该幻灯片有些复杂

00:12:28.680 --> 00:12:32.760
但我会尽力解释一下，让我们想象一下，我们想请求八个

00:12:32.760 --> 00:12:39.269
如此阻止-但是ipfs对于8个块来说确实有点聪明，良好的交换知道大约3个

00:12:39.269 --> 00:12:44.970
码头BC和D，所以它问您B前三个街区，并说

00:12:44.970 --> 00:12:52.200
他们中的其他人，嘿，只是让我知道是否有这个，然后它向C墩询问砌块

00:12:52.200 --> 00:12:55.380
四五和六，其余的说让我知道你是否有

00:12:55.380 --> 00:12:57.870
它，最后是PID，它要求最后一个

00:12:57.870 --> 00:13:03.149
两个街区，说让我知道你是否还有其他人，所以所有同龄人

00:13:03.149 --> 00:13:06.750
回应，他们说我有这个障碍物我有这个障碍物我没有这个障碍物

00:13:06.750 --> 00:13:11.670
我确实有这个，但是我还没有说出来，所以它可以让我们

00:13:11.670 --> 00:13:16.800
高效地获取块，并找出对等点（如果对等体在哪里）

00:13:16.800 --> 00:13:21.360
我们期望它没有它，所以很清楚有人有吗

00:13:21.360 --> 00:13:29.810
问题还好

00:13:30.529 --> 00:13:36.730
另外一个扩展是拥有出色的队列大小，因此

00:13:36.730 --> 00:13:45.370
这是当我说我从PA请求了一堆数据块时，PA是

00:13:45.370 --> 00:13:50.460
向我发送回覆，但并非所有障碍都适合每条讯息

00:13:50.460 --> 00:13:55.630
因此，进行一点交换实际上会轮询其对Fanus的响应，因此它不仅会

00:13:55.630 --> 00:14:00.330
将所有回复发送给第一个家伙，下一个回复是第二个家伙

00:14:00.330 --> 00:14:06.760
它将向每个正在请求的对等方发送一些响应，并且它将

00:14:06.760 --> 00:14:12.910
直到完成为止的循环操作，因此在此示例中，我们请求了八个

00:14:12.910 --> 00:14:17.020
从这里开始的方块，同伴能够容纳三个方块

00:14:17.020 --> 00:14:21.820
放入消息中，响应消息的大小有限，并且有

00:14:21.820 --> 00:14:27.370
剩下五个街区，所以它告诉我们，还有五个街区，所以我们

00:14:27.370 --> 00:14:32.590
一种监视器，此队列大小，此未完成的队列大小，以及是否得到

00:14:32.590 --> 00:14:36.910
太高了，那么我们知道我们可以退缩，所以这使我们可以像请求

00:14:36.910 --> 00:14:47.939
一大堆东西，但不要让同龄人超负荷，所以这些是

00:14:47.939 --> 00:14:50.849
扩展程序，现在我将讨论实际的一些更改

00:14:50.849 --> 00:14:56.839
实施，就像我之前提到的

00:14:56.869 --> 00:15:02.909
我们可以要求阻拦，并且在我们要求阻拦的同时，我们

00:15:02.909 --> 00:15:09.689
还可以询问其他同龄人是否也有封锁，以防万一这种啤酒不是这样

00:15:09.689 --> 00:15:13.409
假设在这种情况下，pob做出回应，说实际上我没有这个

00:15:13.409 --> 00:15:17.429
阻止，但是pra说它确实有阻止，我们可以直接去询问

00:15:17.429 --> 00:15:27.899
给定数组，因此我们给出了一个块，我们如何

00:15:27.899 --> 00:15:32.459
选择我们要发送给哪个对等方，就像我说的那样

00:15:32.459 --> 00:15:36.869
目前尚有一个开放性问题，但我们目前的想法是

00:15:36.869 --> 00:15:40.349
优先告知已经告知我们他们将要阻止的啤酒

00:15:40.349 --> 00:15:45.539
优先P是我们永远不会提供一个that块，我们将忽略对等点

00:15:45.539 --> 00:15:51.259
说他们没有障碍，然后鉴于所有这些事情都是平等的

00:15:51.259 --> 00:15:57.209
然后接下来我们根据对等体没有比率的含义来对等对体进行排序

00:15:57.209 --> 00:16:01.289
已经告诉我们，它有很多我们正在寻找的街区

00:16:01.289 --> 00:16:06.059
之前，很可能会有我们正在寻找的下一个街区，

00:16:06.059 --> 00:16:10.229
最后我们选择队列最短的对等体，这样每个对等体都有一个

00:16:10.229 --> 00:16:21.149
我们要发送给它的队列或我应该说的请求的队列，非常好

00:16:21.149 --> 00:16:25.799
如果我们有一大堆一次，我们有一个整体

00:16:25.799 --> 00:16:31.349
一堆同龄人我们如何说要发送哪个人到哪个下午，所以在我们的示例中

00:16:31.349 --> 00:16:41.129
这里我们有对等体a和B，我们有一次块0 1 2＆3，所以对等体a告诉

00:16:41.129 --> 00:16:49.589
抱歉，对不起，我们对等a告诉我们，它具有CID 3 PA B

00:16:49.589 --> 00:16:55.470
 CID 2，但没有CID 0，我们还没有任何有关谁的信息

00:16:55.470 --> 00:17:03.010
可能或曾经有一个没有CID 1，所以我们算出最大

00:17:03.010 --> 00:17:12.950
我们可以为每个区块的每个同伴获得的潜力，所以在这里

00:17:12.950 --> 00:17:22.490
表示我们正在分配一个值，表示如果我们将CID 3发送到PA

00:17:22.490 --> 00:17:26.450
我们以0.8的概率期望pra将其归还给

00:17:26.450 --> 00:17:31.250
我们，因为它说有，所以在这种情况下，两个同龄人都说他们有

00:17:31.250 --> 00:17:36.290
这两个模块具有最高的潜在增益0.8，然后在

00:17:36.290 --> 00:17:40.520
为了在这两个之间进行选择，我们只需按照

00:17:40.520 --> 00:17:45.020
请求块，因此在CID 3之前请求CID 2，所以最终

00:17:45.020 --> 00:17:57.440
发送CID 2发送一个CID 2发送一个给对等B

00:17:57.440 --> 00:18:02.720
正如我说的，我们正在解决一些设计问题，这涉及到我

00:18:02.720 --> 00:18:06.020
我已经写了概念证明，并且正在做大量的基准测试，

00:18:06.020 --> 00:18:10.030
与Stephen一起工作，还有一些开放式设计问题

00:18:10.030 --> 00:18:16.070
人们可能有兴趣在我们的问题委员会中进行讨论，因此一种设计

00:18:16.070 --> 00:18:22.040
给出的问题是，同龄人告诉我们他们有多少后备力量

00:18:22.040 --> 00:18:27.530
他们必须发送给我们，我们如何准确地改变大小或数量

00:18:27.530 --> 00:18:31.460
塞满我们要发送给他们的数量，这是一个悬而未决的问题

00:18:31.460 --> 00:18:38.330
此刻，其次我们如何改变需求块的数量与

00:18:38.330 --> 00:18:46.610
一等分，所以在这里我们应该将一个块发送给两个对等NBC，然后它就不会

00:18:46.610 --> 00:18:50.570
一定要看一下，我们是否应该将一个区块发送给pRb，并确保我们说了一个

00:18:50.570 --> 00:18:56.180
必须是a，看看如果我们知道您在会话中有50个对等方，我们会发送什么

00:18:56.180 --> 00:18:59.690
是所有人的1/2，这有点像我们正在努力解决的一个开放问题

00:18:59.690 --> 00:19:08.920
通过，这使我走到了尽头，所以看到亚伦有任何问题

00:19:13.290 --> 00:19:20.650
基准测试看起来如何，您是否有任何有趣的统计数据，所以看起来

00:19:20.650 --> 00:19:26.140
好，我不想说太多，因为我还没有实现所有部分

00:19:26.140 --> 00:19:33.580
所以我不想在完成之前先陈述任何可靠的事实

00:19:33.580 --> 00:19:36.640
完整的实现，因为我不想说它要好得多，而且

00:19:36.640 --> 00:19:39.490
然后我们发现实际上，一旦完成了实施

00:19:39.490 --> 00:19:42.970
有一些事情会使它变慢一些，但总的来说

00:19:42.970 --> 00:19:48.910
在某些特定的用例中，它的工作原理要好得多，例如当它被阻止时

00:19:48.910 --> 00:19:56.320
首先跨很多不同的码头，这个协议使它变得更快

00:19:56.320 --> 00:19:59.830
检索所有块，我们可以减少很多开销，因为我们可以快速

00:19:59.830 --> 00:20:03.040
发现它们在某些情况下所处的位置实际上并不能赚到多少

00:20:03.040 --> 00:20:07.410
在某些情况下会有所不同，这取决于用例

00:20:14.700 --> 00:20:29.370
其他问题你好珍妮丝，所以你提到你改变了他们的权利

00:20:29.370 --> 00:20:33.720
现在，您根据延迟时间（通过更改为

00:20:33.720 --> 00:20:43.080
好的权利，那么我的意思是，您是否想过让他们两个都

00:20:43.080 --> 00:20:47.940
分配一些权重，因为等待时间也很重要，我的意思是很难

00:20:47.940 --> 00:20:52.560
说基本上哪个更重要

00:20:52.560 --> 00:20:59.130
所以我认为基本上我们想要最大化的是我们有多少东西

00:20:59.130 --> 00:21:05.580
从IPA回来，所以我们要努力做到的始终是

00:21:05.580 --> 00:21:10.320
管道满了，所以我们有点最大化吞吐量而不是带宽

00:21:10.320 --> 00:21:15.570
或等待时间，所以这是一个相当棘手的问题

00:21:15.570 --> 00:21:19.770
确切的带宽是多少，甚至测量延迟实际上也是

00:21:19.770 --> 00:21:23.970
很多时候很棘手，因为它变化很大，所以我们要尝试的是

00:21:23.970 --> 00:21:29.580
模拟，或者我们正在尝试对现有网络做出尽可能好的反应

00:21:29.580 --> 00:21:34.740
条件会随时间而变化，因此，如果我们保持管道充满，那么我们

00:21:34.740 --> 00:21:39.450
我们可以做到这一点而不必真正进行过多的计算或

00:21:39.450 --> 00:21:42.510
考虑得太多，它会自然而然地发生

00:21:42.510 --> 00:21:48.060
感觉斯蒂芬，你想尝试，基本上我们没有第三次优化

00:21:48.060 --> 00:21:51.750
是的，但是这些只是在特定时期内，更像是我们正在优化

00:21:51.750 --> 00:21:55.910
为她自己的吞吐量，然后喜欢切换我们可以切换的唯一内容

00:21:55.910 --> 00:21:59.940
而不是像过去那样，我们试图做的就是看起来像它

00:21:59.940 --> 00:22:04.380
回应最快，但这并不意味着他们是最快的

00:22:04.380 --> 00:22:09.600
总体上还是在开始时看起来还不错，似乎正在回归

00:22:09.600 --> 00:22:13.860
真的很快，但后来又因为他们有更大的体积而陷入困境

00:22:13.860 --> 00:22:17.160
这样的人，基本上，我们就像是在尝试不对模型进行建模

00:22:17.160 --> 00:22:21.600
尽可能多的网络，它说的就像针对我们想要的进行了优化

00:22:21.600 --> 00:22:27.230
然后调整变量，我们必须尝试喜欢有意义的折衷方案

00:22:30.559 --> 00:22:38.700
是的，这确实有道理，这取决于这些东西的种类

00:22:38.700 --> 00:22:44.909
的应用程序在后台运行得非常厉害，所以我的意思是有时您有一个

00:22:44.909 --> 00:22:48.659
大文件，这是很有意义的，但是如果您要传送视频或

00:22:48.659 --> 00:22:54.690
那么相反的事情可能是我的意思是这是老鼠的经典问题

00:22:54.690 --> 00:22:58.799
想法受到打击，这取决于我们在寻找什么

00:22:58.799 --> 00:23:04.049
就像是一条给予者的狗，解决了像一次性一样的初始障碍，然后

00:23:04.049 --> 00:23:08.639
我们经常去找我的经纪公司，就像我们通常会随机进入一个你不会

00:23:08.639 --> 00:23:14.549
甚至知道这就像我是的，所以基本上在这里，我们只是从字面上看

00:23:14.549 --> 00:23:19.289
试图把它称为最大，我就像试图找到一种方法来保持

00:23:19.289 --> 00:23:24.419
在这里忙着向我们发送数据，所以这将给我带来最大的收益，但事实并非如此

00:23:24.419 --> 00:23:28.799
是的，你说得对，就像你有用法但是打开一个会话，然后像你一样

00:23:28.799 --> 00:23:31.440
就像问块，也许它的重量，你要求块，想等一下

00:23:31.440 --> 00:23:34.830
有点要求块，但你真的想要像返回的同龄人

00:23:34.830 --> 00:23:39.779
最快的块，这是我们必须要测量的东西

00:23:39.779 --> 00:23:44.159
在链接内部，我们必须基本上平衡这一点，如果技术

00:23:44.159 --> 00:23:47.250
就像我们有的一样，尽管有很多针对它进行了优化的东西，但是我们在问

00:23:47.250 --> 00:23:51.210
一次只针对延迟优化的一件事，是的

00:23:51.210 --> 00:23:55.080
完全是这样，这可能是更复杂的东西，因为通常

00:23:55.080 --> 00:24:04.799
是否有找到适合自己的尺码的一种方法，谢谢其他人

00:24:04.799 --> 00:24:07.130
问题

00:24:15.060 --> 00:24:22.170
哦，我想这不是每周总结的话题，也没有其他问题了

00:24:22.170 --> 00:24:27.450
非常感谢您加入我们的行列，是的，我们可以致电给他们

00:24:27.450 --> 00:24:32.640
2019年9月，我希望国家谷物鸭子公司令人惊叹，非常感谢你的光临

00:24:32.640 --> 00:24:35.030
下周

