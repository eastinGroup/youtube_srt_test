WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.949 --> 00:00:08.099
很酷，所以这是咖啡谈的第三集，这周我要

00:00:08.099 --> 00:00:13.049
在谈论GX​​，这是我正在研究的超酷软件包管理器

00:00:13.049 --> 00:00:21.119
是在我的PFS上盖上的，是的，这也是我在巴黎买到的咖啡

00:00:21.119 --> 00:00:30.570
实际上很好，嗯，但是，嗯，所以

00:00:30.570 --> 00:00:34.500
在Chemex中进行操作，而不是过多地谈论其工作原理

00:00:34.500 --> 00:00:45.510
因为我之前已经做过，是的，所以GX是两个字母的名字，代表

00:00:45.510 --> 00:00:48.870
绝对没有，我只是在键盘上按字面意思输入了前两个字母

00:00:48.870 --> 00:00:55.559
我可以并且确定我正在从事的工作的名称以及原因

00:00:55.559 --> 00:01:01.109
因为我厌倦了所有这些不同的包装经理，而不是

00:01:01.109 --> 00:01:11.310
用正确的方式做事很好啊，因为经理真的很喜欢基地

00:01:11.310 --> 00:01:15.750
它做的基于基础的事情还可以，我有一个包装，需要其他这些条件

00:01:15.750 --> 00:01:19.229
我需要去得到那些东西，然后我需要去得到那些东西

00:01:19.229 --> 00:01:23.970
事情需要等等，就像每个程序包管理器都要做的那样，

00:01:23.970 --> 00:01:29.220
每个软件包管理器似乎都以不同的方式做事，为什么这样做没有做

00:01:29.220 --> 00:01:35.520
感觉，这有点像有效经理的基本水平

00:01:35.520 --> 00:01:42.570
需要做的，我想真的GX与其说是软件包管理器，不如说是

00:01:42.570 --> 00:01:46.680
内容分发和管理附录的基本框架

00:01:46.680 --> 00:01:51.810
嗯，您可以轻松地在GX之上构建一个软件包管理器，例如go

00:01:51.810 --> 00:01:57.630
现在我已经建立了GX dash go，它工作得很好，因为我的方式

00:01:57.630 --> 00:02:05.700
设计GX就像它一样工作，如果我有一个go项目，而我

00:02:05.700 --> 00:02:09.840
与它一起使用DX，它会向前看TX破折号，由节点项目执行

00:02:09.840 --> 00:02:13.410
它最终会做一些要寻找GX破折号知道的事情

00:02:13.410 --> 00:02:18.960
叫出一堆类似子钩子的东西，任何像get钩子这样的人都会

00:02:18.960 --> 00:02:27.450
知道如何工作，并像获得破折号一样获取任何您命名的二进制文件

00:02:27.450 --> 00:02:33.180
您可以将其运行为某个名称并获得该名称，并且该名称有点像集成到

00:02:33.180 --> 00:02:38.220
该工具使它感觉统一，这是一个非常酷的功能，

00:02:38.220 --> 00:02:44.510
就像我正在努力将同样的感觉带入包装经理一样

00:02:44.510 --> 00:02:51.270
所以现在的问题是，为什么我为什么要做这个um内容寻址真的

00:02:51.270 --> 00:02:59.400
很好，能够有一个散列表示该程序包是

00:02:59.400 --> 00:03:03.840
正是您所期望的无用包装可能会有所不同

00:03:03.840 --> 00:03:07.800
除非您的操作系统有类似瞬态依赖性的内容，否则您可以

00:03:07.800 --> 00:03:14.970
仍然喜欢考虑没有版本混乱的帐户，您可以说，好吧，我

00:03:14.970 --> 00:03:19.709
依赖于此包的哈希值，您几乎可以保证得到

00:03:19.709 --> 00:03:25.110
完全相同的软件包，您没有收到奇怪的semper废话命令哦，我做了一个未成年人

00:03:25.110 --> 00:03:31.530
或补丁颠簸，它破坏了每个人的代码，这很有趣，所以我说不

00:03:31.530 --> 00:03:38.940
12月，我们正在直接进行操作，您知道这就是您要导入的内容，所以我

00:03:38.940 --> 00:03:43.160
希望这将解决我们遇到的一些问题，下一件事是

00:03:43.160 --> 00:03:51.720
好吧，这是一个很酷的文件系统，称为I PFS，它非常整洁

00:03:51.720 --> 00:03:56.760
确实知道您可以点对点分发文件和其他有趣的东西

00:03:56.760 --> 00:04:01.860
像那个um，所以我在PFS的基础上建立2倍，这意味着我们得到了所有

00:04:01.860 --> 00:04:09.360
基于它的漂亮的内置对等文件传输，让您可以

00:04:09.360 --> 00:04:15.000
我们要做的是，我需要安装一个软件包，然后如果我旁边的人有它，我

00:04:15.000 --> 00:04:20.700
可以从他们那里安装它，而不是从全局服务器上安装它，或者

00:04:20.700 --> 00:04:26.430
从您那里知道某个地方的随机CDN，例如当您知道

00:04:26.430 --> 00:04:31.680
在北极j / s上坐着小门，你知道一条通向真实地方的小烟斗。

00:04:31.680 --> 00:04:38.729
世界，有人叫运行MPM安装，它不会杀死我们的互联网，

00:04:38.729 --> 00:04:43.080
真的发生了，那真的很有趣，我们试图找出是什么

00:04:43.080 --> 00:04:46.500
随着互联网的发展，我们的视频通话中断了，每个人都喜欢

00:04:46.500 --> 00:04:49.860
看起来很对，谁在使用Hey，正在使用Internet的Mike，就像我一样

00:04:49.860 --> 00:04:54.750
只是运行了NPM安装，我认为没有人会注意到我们没有注意到，但是

00:04:54.750 --> 00:05:00.479
如果您知道NPM软件包是否在I PFS中，那么他将

00:05:00.479 --> 00:05:04.949
从您那里他们认识我们周围的人，因为那些厚实的ge'ez

00:05:04.949 --> 00:05:08.400
可能是世界上大多数NPM软件包都安装在计算机下

00:05:08.400 --> 00:05:13.560
在某个时候，我想如果我

00:05:13.560 --> 00:05:21.449
没错，是的，是的，再加上重复，这真的很棒

00:05:21.449 --> 00:05:25.380
因为如果我在两个不同的地方都拥有相同的事物，那么我不会

00:05:25.380 --> 00:05:29.310
必须排序两次，只是您知道被同一哈希引用

00:05:29.310 --> 00:05:37.080
去，所以我们还没有太多的数字，但我们希望至少有四个

00:05:37.080 --> 00:05:43.050
n pm通过执行所有这些重复操作，我们可以节省很多空间

00:05:43.050 --> 00:05:53.310
关于David在这里的任何评论你们自己去，我想见自己，所以我

00:05:53.310 --> 00:05:58.380
还没有数字，我们有几种策略可以进行分块或

00:05:58.380 --> 00:06:04.280
进行NPM软件包的拆包，具体取决于我们选择的

00:06:04.280 --> 00:06:09.800
取决于我们如何添加bffs之类的包，这些包会创建不同的

00:06:09.800 --> 00:06:17.479
不同的30分钟打个招呼

00:06:19.120 --> 00:06:24.830
有人要椅子，因为我们要去上学很多，所以

00:06:24.830 --> 00:06:29.090
是的，就像我们可以L包以不同的方式前进，这将创造

00:06:29.090 --> 00:06:38.060
不同的重复数据删除措施还可以，对不起，哦，另一个角落

00:06:38.060 --> 00:06:45.529
我通过PFS选择使用IP作为GX的运输律师

00:06:45.529 --> 00:06:48.860
我们免费获得的其他东西样品包装完整性之一

00:06:48.860 --> 00:06:52.389
像npm这样仍在战斗的​​事情是如何确保

00:06:52.389 --> 00:06:58.060
如果我们安装了一个软件包，我们实际上看到了我们希望的unicode，

00:06:58.060 --> 00:07:06.590
您可以和我们聊聊更多有关GX工作的天气情况，以及

00:07:06.590 --> 00:07:12.770
南方的GX打包所有东西的方式都被灰烬引用，因此

00:07:12.770 --> 00:07:16.879
您可以确保自己的代码可以复制

00:07:16.879 --> 00:07:21.620
项目，因为您将始终根据他们的资产安装正确的软件包

00:07:21.620 --> 00:07:26.389
而不是像模块名称和版本那样，您可以始终进行验证

00:07:26.389 --> 00:07:32.259
它们在您本地计算机上的完整性，而无需依赖任何其他服务

00:07:32.259 --> 00:07:39.379
那个时候的邪恶问题我特别不喜欢输入哈希，而我

00:07:39.379 --> 00:07:44.029
在记住它们方面不是特别擅长，我宁愿输入我不错的包裹

00:07:44.029 --> 00:07:51.800
一次说出名称，哦，如何处理，嗯，是的，我想了很多

00:07:51.800 --> 00:07:57.529
关于这个，我的方式就像我们的D＆G轴，我们有这个概念

00:07:57.529 --> 00:08:03.139
在您喜欢的地方休息，以便您了解正确的遥控器，我们正帮助您

00:08:03.139 --> 00:08:07.909
可以说好吧，我有这个遥控器，它的名字叫做github com的起源

00:08:07.909 --> 00:08:16.639
/ blah blah blah在GX中，您可以将um repo指定为hack和I PFS哈希

00:08:16.639 --> 00:08:22.069
或IP NS条目，或者您知道我P＆S dns条目可以解决的任何问题

00:08:22.069 --> 00:08:26.360
而这实际上只是一个目录或s对象的IP

00:08:26.360 --> 00:08:32.490
链接被命名的位置，并通过该名称指向软件包，如果您

00:08:32.490 --> 00:08:39.659
将存储库添加到您的GX配置中，然后就可以让GX继续安装此软件包

00:08:39.659 --> 00:08:44.159
以其短名称命名，它将使用您的存储库来将其解析为

00:08:44.159 --> 00:08:49.680
哈希名称和我设置的方式是可以配置

00:08:49.680 --> 00:08:54.180
您可以配置全局存储库/环境存储库，因此我可以设置一个

00:08:54.180 --> 00:08:59.730
您知道的Linux节点一的存储库

00:08:59.730 --> 00:09:02.730
您所处的情况，也可以仅针对每个包裹设置它们，以便

00:09:02.730 --> 00:09:08.399
在软件包配置中，这是要使用的存储库，因此这

00:09:08.399 --> 00:09:13.440
让我们仍然拥有一个不错的漂亮名称空间，但这也使我们

00:09:13.440 --> 00:09:20.520
避免像全局命名空间这样的冲突废话，所以您不会知道

00:09:20.520 --> 00:09:26.040
您不必输入所有这些哈希名称，只需要知道输入

00:09:26.040 --> 00:09:31.920
您的回购名称一次并进行配置，然后从那里可以使用该权限

00:09:31.920 --> 00:09:36.930
但是例如，我继续执行mpm之类的操作，现在我想

00:09:36.930 --> 00:09:43.980
从那里安装一些没有它的东西，最好从这里复制粘贴

00:09:43.980 --> 00:09:48.510
然后手动设置它可能会传达信息，因为这似乎

00:09:48.510 --> 00:09:55.770
如果我对很多软件包都这样做会很痛苦，所以对于四个npm，我们会

00:09:55.770 --> 00:10:01.620
整个nvm注册表或仓库只有一个npm哈希，这可能会结束

00:10:01.620 --> 00:10:06.690
就像一个域一样，它可能是BFS的npm名称或类似的名称

00:10:06.690 --> 00:10:14.130
或我的BFS名称，然后将其添加为NPM注册表存储库，然后随时添加

00:10:14.130 --> 00:10:20.420
您输入一个NPM包名称，它将转到该名称以查找映射到的哈希

00:10:20.420 --> 00:10:26.370
IC还可以，房间不好，绝对要考虑一下，我就像在收缩

00:10:26.370 --> 00:10:35.010
当我在包装中的NPM + F上进行收缩包装时，Jack对此感到抱歉

00:10:35.010 --> 00:10:39.270
如此闪亮，因此您实际上可以使用某个版本，并且您可以保证

00:10:39.270 --> 00:10:44.010
软件包，并且在您首次安装后，请想象一下您是

00:10:44.010 --> 00:10:48.920
开发一个新的先生笔记，您将为所有用户进行GX安装

00:10:48.920 --> 00:10:54.380
您的包裹现在就可以将Jason包裹运送到生产服务器了，是的

00:10:54.380 --> 00:10:59.540
Jason软件包可以为您安装的模块提供灰烬，

00:10:59.540 --> 00:11:04.820
您可以方便地以名字命名，但是当它成为纯粹的版本时

00:11:04.820 --> 00:11:08.720
服务器到生产服务器，它将由ash安装，因此

00:11:08.720 --> 00:11:12.230
生产服务器实际上可以在运行代码之前对其进行验证

00:11:12.230 --> 00:11:17.150
正确的包装，当它是正确的，就像当很多

00:11:17.150 --> 00:11:19.820
当有人部署一个漏洞时，漏洞就像权重一样发生

00:11:19.820 --> 00:11:25.490
就像是从我的机器上的某处获取的一段代码，

00:11:25.490 --> 00:11:28.190
工作得很好，因为我接触了正确的代码，但在此制作中

00:11:28.190 --> 00:11:35.150
服务器有人设法使用新税和其他税中的一种来运送一些

00:11:35.150 --> 00:11:39.020
我无法验证的包裹中的新衣服，我开始跑步

00:11:39.020 --> 00:11:44.960
该软件包在我的生活服务上的生产服务器上，并通过使用GX plus我

00:11:44.960 --> 00:11:49.490
PFS是免费的，我可以免费进行完整性检查，而您仍然

00:11:49.490 --> 00:11:55.150
在开发应用程序时仍然可以方便地使用名称

00:11:55.150 --> 00:11:58.150
好的

00:12:01.020 --> 00:12:05.430
我想如果您说得对，我们也可以读吉姆，这是另一回事

00:12:05.430 --> 00:12:11.430
现在静音了，所以我也可以参考GX的另一件事是

00:12:11.430 --> 00:12:18.750
尺骨船的想法是，像你一样可以开始一切，就像

00:12:18.750 --> 00:12:22.500
注册表，而不是成为所有模块所有代码所在的地方

00:12:22.500 --> 00:12:26.970
存储的可能只是我们对您可能需要的模块X的灰烬的引用

00:12:26.970 --> 00:12:30.480
安装，然后将模块留在网络上，这就是您可以告诉我们的全部

00:12:30.480 --> 00:12:35.610
将所有内容存储在整个地球上的一台服务器或一台或多台服务器中

00:12:35.610 --> 00:12:39.510
能够为每个人提供服务，就像使用网络连接自由者

00:12:39.510 --> 00:12:44.550
包，我将看到您像免费的名称空间色板所有权

00:12:44.550 --> 00:12:47.970
像这样的很长时间是每一个分组训练器芯片的战斗

00:12:47.970 --> 00:12:51.150
特别是那些变成公司的公司，因此他们必须提供

00:12:51.150 --> 00:12:58.020
该服务很好，可以创建一个私有名称空间，甚至只是一个组

00:12:58.020 --> 00:13:01.800
Project在太空中仍然可以在公共场所居住但他们想要的组织

00:13:01.800 --> 00:13:05.550
在我们将发布的模块名称中拥有该名称空间的所有权

00:13:05.550 --> 00:13:10.650
在该部长的领导下，您可以使用IPS来做到这一点，这也是我们聊天的一部分

00:13:10.650 --> 00:13:17.250
就像您一样，而不是仅使用原始I PFF灰烬，您可以决定pns

00:13:17.250 --> 00:13:21.630
这些可变的链接，这些链接超出了PFS网络的范围，并且仍然未经验证

00:13:21.630 --> 00:13:25.470
通过对模块进行加密操作但通过对数字进行验证来实现

00:13:25.470 --> 00:13:29.670
记录上的签名让我们发布他的名字，您可以创建

00:13:29.670 --> 00:13:35.100
例如您组织的多个独立名称或多个

00:13:35.100 --> 00:13:41.430
组织在这种情况下，所以这不是检查，但像这样几乎就像一个

00:13:41.430 --> 00:13:47.670
测试用例清洗实验，例如我们在注册表中所做的警告

00:13:47.670 --> 00:13:56.460
镜像，我们一直在发布，我们一直在发布IP mls记录，

00:13:56.460 --> 00:14:02.550
基本上在晚上10点列出所有模块名称，这样我们

00:14:02.550 --> 00:14:08.580
就像这个宇宙一样，这个命名空间是nvm，所有

00:14:08.580 --> 00:14:12.800
NPM上现在可用的模块

00:14:13.960 --> 00:14:22.150
所以我相信像你一样在直播中，然后是的，你有点杀了它

00:14:22.150 --> 00:14:27.280
我想谈谈GX的另一件事是

00:14:27.280 --> 00:14:33.280
我之前提到的关于UM调用样式的设计方法

00:14:33.280 --> 00:14:38.830
转到子二进制文件，所以工作的方式就是您喜欢的一切之后

00:14:38.830 --> 00:14:44.560
假设我在安装每个软件包或安装完每个软件包后都进行GX安装

00:14:44.560 --> 00:14:48.610
已安装，它将调出特定环境进行后期安装

00:14:48.610 --> 00:14:52.510
或预安装挂钩，例如在安装前将其称为预安装和

00:14:52.510 --> 00:15:00.460
然后在安装后，它将调用安装后，并进行更新

00:15:00.460 --> 00:15:04.660
这样做是为了处理各种不同的事情，这样您便知道GX本身

00:15:04.660 --> 00:15:08.650
可以完成这些软件包的核心工作，从而解决依赖关系

00:15:08.650 --> 00:15:13.330
将它们拉下来放在正确的位置，然后您的子工具就可以

00:15:13.330 --> 00:15:16.300
使它适用于您的语言或您的语言所需的最小逻辑

00:15:16.300 --> 00:15:20.260
环境平台之类的，我认为这就像一个真正的

00:15:20.260 --> 00:15:24.210
这样的事情对我们来说是一件很美的事情

00:15:24.210 --> 00:15:30.640
将使所有这些儿童包裹管理者受益，然后我们仍然不强迫

00:15:30.640 --> 00:15:34.630
关于孩子的很多事情，您都知道使用了所有不同的程序包管理器

00:15:34.630 --> 00:15:38.980
因为他们有真正做事的自由，但是他们想要的却可以

00:15:38.980 --> 00:15:43.150
指定在什么位置安装东西，可以指定要运行的脚本

00:15:43.150 --> 00:15:47.680
安装后，他们可以做很多非常酷的事情，我认为

00:15:47.680 --> 00:15:52.060
这是直到做到的事情真的做得很好的事情之一

00:15:52.060 --> 00:15:58.420
模块化方面，我想把它推到另一个

00:15:58.420 --> 00:16:02.770
类似的事情，您可以做的一件事是，我们可以说

00:16:02.770 --> 00:16:10.330
嗯，我想让我的环境成为二进制文件，所以我可以拥有一个GX包

00:16:10.330 --> 00:16:15.040
安装二进制文件，然后进行预安装就像检查您的

00:16:15.040 --> 00:16:19.420
平台检查，以确保我们在该平台上拥有正确的未成年人，然后

00:16:19.420 --> 00:16:24.220
重定向软件包以使用其他您知道的二进制安装或什至类似的软件包

00:16:24.220 --> 00:16:27.570
让它选择依赖项并获取该依赖项库

00:16:27.570 --> 00:16:33.090
您运行的平台以及GX安装chrome或其他方式的方式

00:16:33.090 --> 00:16:37.950
会说好的，您使用的是Linux x86，您应该获取此文件并下载

00:16:37.950 --> 00:16:42.600
这个，并使用这些依赖项进行安装，就可以了

00:16:42.600 --> 00:16:48.780
这就是我的希望，这是像实际系统一样的自体分布

00:16:48.780 --> 00:16:57.060
二进制文件和系统软件包更容易，但是不错的下标是模块化的

00:16:57.060 --> 00:17:01.920
足够使您可以做一些大家都不熟悉的酒桶之类的事情

00:17:01.920 --> 00:17:09.839
所以家用酿酒桶就像这个版本的您可以安装软件包，但是我们在

00:17:09.839 --> 00:17:15.000
的感觉，因此它们的dmg文件通常用于mac，它们具有视觉效果

00:17:15.000 --> 00:17:19.770
安装程序并将其投射为某种魔术来运行这些视觉效果和存储，而实际上没有

00:17:19.770 --> 00:17:26.670
如此有效地向您展示，您可能会有类似的东西

00:17:26.670 --> 00:17:33.150
GX的第2步，并为您运行安装程序的所有魔力，但使用

00:17:33.150 --> 00:17:38.760
GX下载实际边界，是的​​，您完全可以做到这一点，然后

00:17:38.760 --> 00:17:44.220
具有安装后挂钩，可以通过GUI窗口进行魔术操作

00:17:44.220 --> 00:17:49.080
然后为您单击按钮，这就是您可以进行的投射

00:17:49.080 --> 00:17:55.790
只是把它扔在安装后的脚本中，那将是超级布宜诺斯艾利斯

00:17:57.309 --> 00:18:06.909
是的，是的，11个讨厌的东西呢？例如，如果您安装了一个

00:18:06.909 --> 00:18:13.059
从NPM锚固购买礼物或例如酒桶使用官员喜欢的东西

00:18:13.059 --> 00:18:17.289
下载位置（如果它实际上下载了它没有放的电池）

00:18:17.289 --> 00:18:22.230
除了其他地方，他们还有其他方法可以做这样的事情

00:18:22.230 --> 00:18:27.600
从s的IP外部获取内容，因为还不存在

00:18:27.600 --> 00:18:31.990
例如，如果我从某处取某东西以从github安装软件包

00:18:31.990 --> 00:18:36.279
不会是一个我们无法获得帮助的节日，所以必须从某种程度上获取它

00:18:36.279 --> 00:18:48.759
嗯，嗯，所以我们能做的就是如果您将其克隆下来

00:18:48.759 --> 00:18:54.999
github，它仍然具有它仍然具有来自GX的package.json，所有您需要执行的操作

00:18:54.999 --> 00:18:59.950
要做的是运行GX install，然后从那里开始获取所需的一切

00:18:59.950 --> 00:19:04.929
并以完全相同的方式安装它，所以它真的无关紧要

00:19:04.929 --> 00:19:10.269
您只要拥有package.json就可以得到该软件包，并且看起来很正确，

00:19:10.269 --> 00:19:13.110
将会是一样的

00:19:13.799 --> 00:19:20.879
嗯，我想这就是你要问的，也许我只是在想

00:19:20.879 --> 00:19:27.720
像我既不运行GX也不安装github.com /我的用户名我的包

00:19:27.720 --> 00:19:32.070
我只是想在这个时候从github和

00:19:32.070 --> 00:19:38.009
把它放到我的PFS上，用灰把它放到我的Jason包中，如果

00:19:38.009 --> 00:19:47.460
李怡（Jared Lee oh yeah）好开心的哥们，我们目前做起来并不困难

00:19:47.460 --> 00:19:52.230
我不是现在没有内置的um，但是那也不太可能

00:19:52.230 --> 00:19:56.629
您很难以某种方式知道检查，您知道检测到这是得到

00:19:56.629 --> 00:20:02.399
端点，并从那里知道如何处理它，这是一件很酷的事情，类似

00:20:02.399 --> 00:20:09.090
对于在GX中去撒谎，请使用import导入方法，

00:20:09.090 --> 00:20:14.489
先说GX go import，然后再说github之类的go包路径，例如go import路径

00:20:14.489 --> 00:20:18.869
它将递归地拉下它的依赖关系，然后使

00:20:18.869 --> 00:20:22.679
将其所有依赖项放入GX程序包中并进行构建，然后为您提供

00:20:22.679 --> 00:20:27.090
您想要导入的东西的最终哈希有点像我PFS添加，但是

00:20:27.090 --> 00:20:32.549
去打包，我花了很多时间在打包上

00:20:32.549 --> 00:20:37.649
您可以使用BFS本身来做到这一点，您知道庞大的废话集团

00:20:37.649 --> 00:20:43.830
是的，它会起作用的，是的，这几乎就是我所说的意思

00:20:43.830 --> 00:20:48.119
因为是的，那里的下载管理器可以帮助您

00:20:48.119 --> 00:20:57.779
功能不错，很酷，还有其他问题吗？大卫，我很好，我很好

00:20:57.779 --> 00:21:08.929
嗯嗯是修复人们可以去哪里找到更多的问题是的。

00:21:08.929 --> 00:21:15.389
存储库在我的用户名下面，为什么您要在github上睡觉/ GX any

00:21:15.389 --> 00:21:20.039
问题就可以继续进行，并在IRC um上提交问题或侏儒

00:21:20.039 --> 00:21:25.830
提交问题是很好的，请尝试一下，您知道吗给它做一些测试运行之一

00:21:25.830 --> 00:21:30.660
我本周的目标是在我的PFS期间将其用于拉lib

00:21:30.660 --> 00:21:34.190
点对点光线充足的点对点已经退出，但我要做出

00:21:34.190 --> 00:21:43.830
我将PFS用作GX依赖项，换管会很有趣

00:21:43.830 --> 00:21:49.680
总是有像任何快速示例一样的项目，例如一个项目，

00:21:49.680 --> 00:21:54.600
人们可以喜欢尝试并喜欢本体X并注入安装，我看到了

00:21:54.600 --> 00:22:01.050
像我们这样拉着包裹，所以如果您现在就去点对点

00:22:01.050 --> 00:22:07.550
将克隆下来，然后克隆下来，然后运行GX install，这是可行的

00:22:07.550 --> 00:22:12.410
是的，因为它有很多像我有很多包装的例子

00:22:12.410 --> 00:22:17.910
建议不要运行自己的Damon，因为它会自行设置

00:22:17.910 --> 00:22:22.380
并以这种方式通过I PFS进行操作，它可以更快地完成工作

00:22:22.380 --> 00:22:30.240
目前，所以我仍在弄清楚这一点，是的，我很快就会喜欢

00:22:30.240 --> 00:22:34.500
它会更快，我会解决的，但是如果您不运行自己的I PFS

00:22:34.500 --> 00:22:42.600
达蒙·贾克斯（Damon Jax）运行得更快，不确定为什么，但是对，它是我免费的点对点润滑油

00:22:42.600 --> 00:22:47.340
现在在不同的计算机上完成了多次，将其克隆到CD中

00:22:47.340 --> 00:22:55.650
然后GX安装了um，它对构建唯一的想法有效，对不起我

00:22:55.650 --> 00:23:01.410
不要以为Alpha会蓬勃发展，它可以避免完全等待，是的，唯一的事情

00:23:01.410 --> 00:23:05.760
您必须确保必须安装GX + GX go，因为您要

00:23:05.760 --> 00:23:08.870
正在安装go软件包

00:23:09.590 --> 00:23:13.039
所以这就像它的模块化方面，但我将尝试

00:23:13.039 --> 00:23:19.390
找出一种可以同时进行安装的方法，这很好

00:23:19.390 --> 00:23:28.750
但是是的，这是GX，是的，还有其他任何问题，我们都想称呼它为

00:23:29.440 --> 00:23:36.909
记得很好，谢谢大家的光临，下次再见

00:23:36.909 --> 00:23:43.980
它享受咖啡欢呼的耳朵

