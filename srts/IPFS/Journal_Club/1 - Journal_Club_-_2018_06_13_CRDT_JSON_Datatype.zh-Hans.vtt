WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:07.890
婚礼开始于大家好欢迎大家参加2018年6月13日的日记俱乐部

00:00:07.890 --> 00:00:11.820
咨询过像无冲突一样谈论特朗普

00:00:11.820 --> 00:00:20.090
复制的JSON数据类型谢谢，我将共享屏幕

00:00:20.090 --> 00:00:29.429
认为这是不正确的分享

00:00:29.429 --> 00:00:47.160
请等一秒钟，好极了，您能看到论文和笔记吗？

00:00:47.160 --> 00:00:52.710
是的，很酷很烂，看起来不错

00:00:52.710 --> 00:00:56.940
是的，只是让我知道是否有任何问题打扰我，我可能不会

00:00:56.940 --> 00:01:01.739
再次看到您的手，请随时打扰我，非常感谢

00:01:01.739 --> 00:01:07.979
时间，让我们跳入论文，以便论文成为无冲突复制

00:01:07.979 --> 00:01:14.220
Martin和Alastair的jason-- jason--数据类型

00:01:14.220 --> 00:01:22.860
我对无冲突数据的看法是

00:01:22.860 --> 00:01:28.590
认为这是解决许多分布式问题的一种非常有趣的方式

00:01:28.590 --> 00:01:34.979
当涉及到协作应用程序时，这的基本思想

00:01:34.979 --> 00:01:39.210
论文是他们提出了一种算法，并为

00:01:39.210 --> 00:01:46.290
解析修改并发的JSON数据结构

00:01:46.290 --> 00:01:52.439
自动在每个副本中本地进行，因此不需要任何副本

00:01:52.439 --> 00:01:59.750
副本可以修改的共识类型，修改其自己的本地状态

00:01:59.750 --> 00:02:05.850
乐观地遵循算法并编辑所有

00:02:05.850 --> 00:02:13.140
需要正确的方法，他们确信当他们传播时，他们的

00:02:13.140 --> 00:02:15.870
修改每个人都会拥有的网络

00:02:15.870 --> 00:02:22.080
最终处于同一状态，以便该状态在本地收敛，这是

00:02:22.080 --> 00:02:27.569
超级酷，所以最终我们得到了一个对等网络或同一个网络

00:02:27.569 --> 00:02:33.150
分布式网络，其中不同的副本将汇聚成相同的副本

00:02:33.150 --> 00:02:38.760
声明没有用户输入丢失，我们不需要任何保证

00:02:38.760 --> 00:02:41.489
网络，最终所有的同行

00:02:41.489 --> 00:02:48.209
将收到具有相同Jason修改和所有操作的相同事件

00:02:48.209 --> 00:02:55.190
实际上是在本地执行的，无需达成共识和集中

00:02:55.190 --> 00:03:01.140
身份来解决冲突，无论如何，这基本上就是

00:03:01.140 --> 00:03:06.959
我们今天要为这篇论文而讨论，我真的很想看看何时

00:03:06.959 --> 00:03:11.130
当我跳入论文时，我真的很喜欢看到一个有问题的灵魂问题

00:03:11.130 --> 00:03:17.310
解决方案类型的方法，所以我想说的是我们将要解决的问题

00:03:17.310 --> 00:03:22.140
今天在谈论，作者用很多方法很好地解释了这一点。

00:03:22.140 --> 00:03:30.000
例如，我们已经复制了一个Jason Jason数据结构，因此

00:03:30.000 --> 00:03:35.910
许多不同的副本，它们可以是副本的不同对等体

00:03:35.910 --> 00:03:44.220
可以脱机并随意修改Jason数据结构，然后修改

00:03:44.220 --> 00:03:48.390
当这些副本回到这些对等点重新联机时会发生什么

00:03:48.390 --> 00:03:53.160
并与其他人离线共享他们需要的修改是

00:03:53.160 --> 00:03:57.750
可能是一些并发的修改，它们相互冲突，所以通常

00:03:57.750 --> 00:04:02.600
发生了什么，然后我们得到了很多共识算法或其他一些算法

00:04:02.600 --> 00:04:08.370
集中式对等方为他们提供服务或集中式系统以确保

00:04:08.370 --> 00:04:16.789
解决了冲突，但是这些CR DT方法与

00:04:16.789 --> 00:04:22.680
本文提出的解决方案恰好是添加一堆元数据并

00:04:22.680 --> 00:04:26.980
到数据结构本身，并具有

00:04:26.980 --> 00:04:34.470
一个非常著名的算法，它将确保不同的副本可以

00:04:34.470 --> 00:04:43.840
比赛可以在当天在远程的相邻数据结构中应用修改

00:04:43.840 --> 00:04:48.610
本地和远程对等方，没有任何冲突，我认为那是真的

00:04:48.610 --> 00:04:52.570
很酷，这是非常有趣的结果，与此有关的真正有趣的事情

00:04:52.570 --> 00:04:55.750
纸张也是我们在谈论杰森（Jason），它表达力十足

00:04:55.750 --> 00:05:04.420
已经，所以我们基本上可以为Jason的顶部构建很多应用程序

00:05:04.420 --> 00:05:10.000
是结构，而这正是其中最有趣的一种

00:05:10.000 --> 00:05:16.540
这些结构最有趣的结果，所以我们要去

00:05:16.540 --> 00:05:21.280
很快通过介绍，所以RC R DT只是什么

00:05:21.280 --> 00:05:27.010
应用程序中的一些例子说明我们拥有什么样的抽象

00:05:27.010 --> 00:05:32.860
API是否需要本地处理这些Jason结构，

00:05:32.860 --> 00:05:38.260
每个人对JSON API的期望都很简单，然后我们

00:05:38.260 --> 00:05:43.570
将跳入实施细节，并了解在其中如何工作

00:05:43.570 --> 00:05:50.470
是的，是的，基本上，我基本上已经经历了很多

00:05:50.470 --> 00:05:55.840
快速介绍一下，我们已经或多或少地了解了上下文

00:05:55.840 --> 00:06:04.150
杰森被保存在不同的副本中，更改是在本地完成并传播的

00:06:04.150 --> 00:06:07.930
最终跨整个网络，最终所有对等节点都将获得全部

00:06:07.930 --> 00:06:14.650
Jason博客上完成的操作，因此我们不需要以下任何保证

00:06:14.650 --> 00:06:20.830
网络本身真的很好，并开辟了广泛的应用

00:06:20.830 --> 00:06:25.630
对于我们的开发人员来说，所以如果我们可以考虑点对点网络，我们可以考虑

00:06:25.630 --> 00:06:33.550
关于网络真的很杂乱的情况，

00:06:33.550 --> 00:06:38.770
一堆不同的应用程序，对于这种杰森

00:06:38.770 --> 00:06:42.190
CRD团队正是我所停止的

00:06:42.190 --> 00:06:46.960
在介绍过程中，以及当我认为非常有趣的观点时

00:06:46.960 --> 00:06:58.120
就是Jason CRT的目的还是作为副作用，它对您有帮助吗？

00:06:58.120 --> 00:07:02.350
知道发展点对点或分散式协作

00:07:02.350 --> 00:07:07.600
从开发人员的角度来看，应用程序真的很容易，因为现在我们有了

00:07:07.600 --> 00:07:14.430
进入一种情况，我不会称之为共识，而是所有

00:07:14.430 --> 00:07:20.560
合并时本来可能是充满冲突的混乱情况

00:07:20.560 --> 00:07:24.490
来自完全相同的抽象副本的不同副本的不同操作

00:07:24.490 --> 00:07:29.530
我们，这样对开发人员来说真的很容易，也很干净

00:07:29.530 --> 00:07:33.480
显然，所有这些都伴随着我们要付出的代价

00:07:33.480 --> 00:07:42.280
所以这真的很像是一些介绍性的介绍

00:07:42.280 --> 00:07:47.230
关于杰森是什么的想法，或者我认为我们可以略过这部分

00:07:47.230 --> 00:07:50.860
关于我们正在谈论Jason C的事实的有趣部分

00:07:50.860 --> 00:07:58.450
事实是，杰森（Jason）嵌入了地图和列表，并且还注册了

00:07:58.450 --> 00:08:02.170
有可以嵌入的不同类型，这正是这个

00:08:02.170 --> 00:08:08.170
本文的新颖之处在于该如何创建一个

00:08:08.170 --> 00:08:14.740
算法和数据结构，将能够正确处理

00:08:14.740 --> 00:08:19.930
内嵌的CR职责，因为CRT已经存在了很长时间

00:08:19.930 --> 00:08:24.730
如今已成为一个非常热门的话题，但它已经在许多其他系统中使用

00:08:24.730 --> 00:08:31.770
在论文中也已经谈到了这一点，但是关于这一点的重大问题

00:08:31.770 --> 00:08:36.850
现在正是本文，我们实际上可以嵌入并使之变得非常复杂

00:08:36.850 --> 00:08:41.050
并在其中表现出无冲突的结构，这正是

00:08:41.050 --> 00:08:48.970
我们的目标是，是的，我认为我们可以比这些跳过Jason部分，因此

00:08:48.970 --> 00:08:53.790
这是关于复制和冲突解决的

00:08:53.790 --> 00:08:58.290
我认为有趣的一点是，共识一直是一个非常热门的话题，因为

00:08:58.290 --> 00:09:05.220
众所周知，关于CR责任的真正酷事是没有

00:09:05.220 --> 00:09:10.740
需要共识权，所以默认情况下有解决冲突的方法

00:09:10.740 --> 00:09:17.130
而且我们不需要达成任何共识就可以与其他同行达成共识

00:09:17.130 --> 00:09:21.500
我们是否可以进行这些操作，这真的很强大，并且

00:09:21.500 --> 00:09:27.000
非常有趣的一种不同的方法和心态

00:09:27.000 --> 00:09:30.720
和我的朋友们谈论这个问题时，我被问了很多

00:09:30.720 --> 00:09:34.440
和同事，所以我认为这是一个非常有趣的想法

00:09:34.440 --> 00:09:43.080
保留，是的，正如我们已经在短时间内谈到​​的那样，它有自己的特色

00:09:43.080 --> 00:09:50.910
一个州或每个领域都有其自己的副本，我们的基本目标是

00:09:50.910 --> 00:09:59.430
当我们尝试作者时，sava的三个主要原则

00:09:59.430 --> 00:10:05.490
借助此算法和Ciardi Jason，他们确实在推动这一目标

00:10:05.490 --> 00:10:11.700
最终的一致性很强而又没有冲突的想法，以便每个参与者

00:10:11.700 --> 00:10:17.550
网络，如果还没有，如果对等方获得了所有已经被抛弃的事件，如果

00:10:17.550 --> 00:10:22.560
或在网络上传播，他们最终将融合到同一个

00:10:22.560 --> 00:10:28.680
状态，另一个非常重要的一点是，两者之间都没有不存在的关系

00:10:28.680 --> 00:10:34.530
输入应该由于在某些时候进行的同时修改而丢失

00:10:34.530 --> 00:10:40.170
我可以想到CRT

00:10:40.170 --> 00:10:49.110
每次在寄存器上同时拥有两个并发权限时，

00:10:49.110 --> 00:10:54.810
算法将放弃第一种权利，所以那不是

00:10:54.810 --> 00:11:01.710
如果他们有任何问题，这里针对的是什么

00:11:01.710 --> 00:11:06.210
这种情况最有可能会导致CRT保持两种结果，我们将看到

00:11:06.210 --> 00:11:09.919
有点向前，所以是的，我一直很好，我们已经走了

00:11:09.919 --> 00:11:13.459
通过所有的贡献，我有很多笔记，但是你可以看一下

00:11:13.459 --> 00:11:15.970
然后

00:11:17.629 --> 00:11:23.419
再次是这些是CRD茶的想法

00:11:23.419 --> 00:11:29.569
虽然这是作者所知的第一种作品发表的作品

00:11:29.569 --> 00:11:34.910
确实嵌入了许多塞拉茶，创造了一个非常有趣的地方

00:11:34.910 --> 00:11:46.689
应用程序的结构等等，我想我们也可以跳转到

00:11:47.420 --> 00:11:53.090
所以-也许是并发编辑示例，所以还有其他方法

00:11:53.090 --> 00:11:56.390
我已经说过了，但是对付耳部疾病也没那么有趣

00:11:56.390 --> 00:12:02.930
已经有一段时间了，确实看到事情开始出现，所以

00:12:02.930 --> 00:12:08.210
这篇论文的真正酷的地方还在于它们在图表中真正地展示了

00:12:08.210 --> 00:12:15.080
当有一个

00:12:15.080 --> 00:12:20.950
合并不同的修改最终结果是什么最终结果

00:12:20.950 --> 00:12:26.210
这样在每个同伴中都可以看到，实际上还有一些非常有趣的地方，

00:12:26.210 --> 00:12:31.880
我们作为开发人员以及对某人感兴趣的人的一些极端案例

00:12:31.880 --> 00:12:36.770
对这种数据结构感兴趣的人确实需要意识到，因为他们有

00:12:36.770 --> 00:12:41.870
无论如何都要处理，是的，让我们通过

00:12:41.870 --> 00:12:49.840
两个副本同时显示CR DT的一些示例

00:12:49.840 --> 00:12:55.400
并发脱机修改，然后最终共享修改

00:12:55.400 --> 00:13:03.040
彼此之间，因此基本上只是其中的一小部分

00:13:03.040 --> 00:13:12.170
如果我们愿意，Jason CR DT如何真正在另一个更大的网络中工作

00:13:12.170 --> 00:13:15.800
周围有例子，有五个例子，让我们真正地看一下

00:13:15.800 --> 00:13:21.620
快速的想法是，如果您有两个副本，则左侧副本P和

00:13:21.620 --> 00:13:26.330
正确的副本Q，然后每个副本以相同的状态开始

00:13:26.330 --> 00:13:30.980
修改，然后最终执行金属沟通，然后我们

00:13:30.980 --> 00:13:37.790
可以看到算法是如何解决冲突的，所以第一个想法已经

00:13:37.790 --> 00:13:45.250
再次很有趣，我们有两个好，所以让我们先来看一下，我们有一个

00:13:45.250 --> 00:13:56.020
映射与密钥键Val值密钥和作为寄存器的副本P更改

00:13:56.020 --> 00:14:03.569
键是键值，是其案例值的副本，以查看和

00:14:03.569 --> 00:14:08.129
然后他们执行金属通信，这是一个寄存器，但是因为我们

00:14:08.129 --> 00:14:15.569
一个失去任何投入的人，冲突解决基本上是保持两个

00:14:15.569 --> 00:14:22.199
寄存器，所以在冲突结束时有一个多值寄存器

00:14:22.199 --> 00:14:28.259
然后再合并，这些在应用程序级别上可能没有多大意义，但

00:14:28.259 --> 00:14:33.779
这个想法不是以有意义的方式解决冲突

00:14:33.779 --> 00:14:37.350
应用程序级别，我们将保存示例，其中甚至

00:14:37.350 --> 00:14:46.290
更何况这些见解更有趣，因为CRT

00:14:46.290 --> 00:14:50.850
 Jason确实是要确保两个副本都具有相同的结局

00:14:50.850 --> 00:14:57.180
结果而不必解决任何冲突，这并不意味着

00:14:57.180 --> 00:15:01.559
一个应用程序级别有意义，这将是其他人的责任

00:15:01.559 --> 00:15:07.170
开发人员最有可能，但只要两个副本具有相同的状态，则

00:15:07.170 --> 00:15:13.319
以一种确定性的方式很容易地选择其中一个寄存器或执行

00:15:13.319 --> 00:15:20.490
不管怎样，另一个例子也很有趣，所以我们离开了

00:15:20.490 --> 00:15:29.399
得到一张地图，其值用蓝色涂成蓝色，最右边的副本将

00:15:29.399 --> 00:15:35.269
实际上首先清除整个地图颜色，然后添加绿色

00:15:35.269 --> 00:15:44.059
而最左边的副本基本上只会添加Reds键值

00:15:44.059 --> 00:15:50.569
发生的事情是因为最右边的副本清除了污垢

00:15:50.569 --> 00:15:58.199
左手连一个按键都没有碰到，蓝色将一并删除

00:15:58.199 --> 00:16:02.249
所以我们陷入一种情况，来电者会看到红色和绿色

00:16:02.249 --> 00:16:08.850
在某种程度上，这或多或少是一种期望，所以没有太多

00:16:08.850 --> 00:16:13.710
来自这里的一个非常奇怪的结果

00:16:13.710 --> 00:16:18.000
发生这种情况的原因恰恰是最右边的副本实际上清洁了整个对象。

00:16:18.000 --> 00:16:23.640
正确映射，因此对于下一个示例，它也非常简单

00:16:23.640 --> 00:16:29.010
基本上每个都显示一个示例，其中两个副本同时创建

00:16:29.010 --> 00:16:35.850
在相同地图键下的有序列表，所以我们从空地图开始

00:16:35.850 --> 00:16:45.750
最左侧的文档会创建一个列表，或创建一个键或将列表分配给

00:16:45.750 --> 00:16:53.390
关键杂货店和最右边的杂货店做相同的事情，但它们添加了不同的区别

00:16:53.390 --> 00:17:00.960
列表中的已订购商品我们最后得到的是该列表将被订购

00:17:00.960 --> 00:17:07.320
以相同的方式，因此，例如鸡蛋是否真的无关紧要

00:17:07.320 --> 00:17:14.430
火腿是第三和第四项，重要的是

00:17:14.430 --> 00:17:21.060
会聚，并且他们俩都得到相同类型的有序列表，这是

00:17:21.060 --> 00:17:25.110
将通过灯或时钟来实现，我们将要检查如何

00:17:25.110 --> 00:17:29.910
实际上，它的工作原理会更详细一些，如果要在几分钟内完成，那么这是

00:17:29.910 --> 00:17:36.090
完全相同，几乎相同的想法，只是使整个过程井井有条

00:17:36.090 --> 00:17:40.560
它在此处显示的列表中，我们可以将其用作文本文档，例如

00:17:40.560 --> 00:17:44.430
应用程序级别，我认为这些可能是

00:17:44.430 --> 00:17:49.080
我们可以从这些Jason的CRT中得到两个最有趣的例子

00:17:49.080 --> 00:17:54.080
算法，所以第一个例子是

00:17:54.500 --> 00:18:02.670
我们在同一个地图键中分配不同类型的值，因此这些mckee a是一个

00:18:02.670 --> 00:18:10.850
沉没的地图，而这在最右边的副本下

00:18:10.850 --> 00:18:18.120
键a分配得最少，所以要发生的是不可能

00:18:18.120 --> 00:18:24.720
有意义的是，我将地图与数组合并，然后再次合并，因为我们不想

00:18:24.720 --> 00:18:28.810
失去任何用户输入，我们将保留它们两个标记它们

00:18:28.810 --> 00:18:35.430
好的，我们将获得此地图类型map具有此值选项卡列表具有此列表，以及

00:18:35.430 --> 00:18:42.310
然后应用程序级别必须解决这些冲突，所以

00:18:42.310 --> 00:18:49.240
总是这些边缘情况，其中上层有一些工作

00:18:49.240 --> 00:18:54.580
应用程序必须执行，但除了

00:18:54.580 --> 00:19:00.280
人类真正做出决定，这些决定是否更有意义？

00:19:00.280 --> 00:19:05.230
其他，这是本示例和最后一个见解的另一种见解

00:19:05.230 --> 00:19:08.560
根据我的观点，可能是其中最有趣的一种，至少

00:19:08.560 --> 00:19:14.830
地图是无序的，列表是有序的

00:19:14.830 --> 00:19:20.080
所以我想您可以为

00:19:20.080 --> 00:19:25.270
当您在列表上的地图上合并冲突时，有一种获取方法

00:19:25.270 --> 00:19:30.580
在此方案中排序还是在此处留给应用程序层来定义

00:19:30.580 --> 00:19:33.700
订购那是一个很好的问题

00:19:33.700 --> 00:19:42.400
这样的想法是，每个对等体都有一个ID，每个副本

00:19:42.400 --> 00:19:48.130
具有一个类似于LAN端口的ID，并且保持一个LAN端口时钟类似于

00:19:48.130 --> 00:19:54.220
LAN端口ID，可以确保临时按以下顺序进行操作：

00:19:54.220 --> 00:20:02.980
网络中正在发生的事情是正确的，所以无论何时有一些项目

00:20:02.980 --> 00:20:09.550
已添加到一个副本中的列表中，并且将项目添加到了另一个副本中的列表中

00:20:09.550 --> 00:20:14.620
每当两者合并时，它们都将根据

00:20:14.620 --> 00:20:23.410
到他们的ID等级，他们的Lamport等级会随机进入

00:20:23.410 --> 00:20:29.800
一种方法，但由于灯在末尾，因此确定性地对列表进行了排序

00:20:29.800 --> 00:20:34.230
一次，即使他们有点

00:20:35.010 --> 00:20:41.160
据推测，与此同时，他们将拥有麻风病俱乐部

00:20:41.160 --> 00:20:46.020
一种解决方案，然后确定性地找出哪一个

00:20:46.020 --> 00:20:51.750
首先是这个有意义吗，还是好的，谢谢

00:20:51.750 --> 00:20:55.470
你是的，但真的是一个很好的问题，那是

00:20:55.470 --> 00:21:00.780
我认为关于蜜蜂的最酷的事情之一就是你

00:21:00.780 --> 00:21:08.549
知道可怕的最终订单振铃列表是确定性的两个副本

00:21:08.549 --> 00:21:13.860
设置为具有相同的顺序好，所以最后一个例子也确实

00:21:13.860 --> 00:21:19.320
有趣的是，它基本上与我们看到的示例相同

00:21:19.320 --> 00:21:28.679
最左边的副本用来清除整个项目的颜色

00:21:28.679 --> 00:21:37.650
一份待办事项清单，所以我们要做一张地图，其中有一堆

00:21:37.650 --> 00:21:44.820
待办事项的项目，我们得到了左侧的副本，清理了整个整体

00:21:44.820 --> 00:21:51.299
待办事项清单，然后我们得到了正确的副本，实际上是在设置购买牛奶

00:21:51.299 --> 00:21:58.470
项目完成，因此当我们合并副本时，发生了相同的事情

00:21:58.470 --> 00:22:03.240
蓝色，我们将要发生的事情之前没有看到的是，因为

00:22:03.240 --> 00:22:09.299
左边的一个清除了该项目，右边的一个仅更改了它，因为我们要结束

00:22:09.299 --> 00:22:14.190
使用待办事项清单，我们要做的是甚至没有标题的项目，因此这使得没有

00:22:14.190 --> 00:22:20.750
感觉到什么或应用程序级别，但那又不是

00:22:20.750 --> 00:22:24.720
Jason CR DT的责任，以确保这在

00:22:24.720 --> 00:22:30.710
应用程序级别，这必须由开发人员或

00:22:30.710 --> 00:22:38.520
他们在论文中提出了建议，实际上是建议创建的未来工作

00:22:38.520 --> 00:22:44.610
某种JSON模式，它位于CR DT Jason的顶部，因此

00:22:44.610 --> 00:22:51.240
这些示例将被避免，因此列表中会有一个

00:22:51.240 --> 00:22:57.090
没有完成或标题，然后删除所有内容，这样可能

00:22:57.090 --> 00:23:03.179
是什么使得这最有意义，所以是的，基本上就是这些

00:23:03.179 --> 00:23:11.210
最奇怪的一种合并示例

00:23:11.210 --> 00:23:17.929
可以像Jason一样工作，所以我认为这真的很酷-

00:23:17.929 --> 00:23:22.049
作者真的非常好，可以直观地展示出实际内容

00:23:22.049 --> 00:23:26.730
在幕后发生的事情，结果的确可以帮助我们

00:23:26.730 --> 00:23:32.669
上下文，所以这实际上正是我们经历的唯一

00:23:32.669 --> 00:23:41.850
本节中的内容是API，因此API同样只是一种

00:23:41.850 --> 00:23:48.740
几乎类似于原始Jason a的伪代码示例

00:23:48.740 --> 00:23:56.280
一堆邻接关系rdt一个原语或API，这对我们来说是最有趣的部分

00:23:56.280 --> 00:24:04.820
可能是这些ID x0，所以基本上我们拥有的是我们初始化设置的doc

00:24:04.820 --> 00:24:14.549
将购物的a的值作为切碎的购物清单作为清单，然后

00:24:14.549 --> 00:24:21.540
我们得到一个零的项目，它实际上不是一个项目

00:24:21.540 --> 00:24:27.780
而不是用来指示列表标题的特殊光标，并且

00:24:27.780 --> 00:24:31.950
这基本上就像是唯一您可以添加我们可以理解的内容

00:24:31.950 --> 00:24:37.470
这个API的一切都非常简单，而且很容易获得

00:24:37.470 --> 00:24:45.030
通过再次发生什么在这里，我们插入我们得到这个他们

00:24:45.030 --> 00:24:52.260
零游标，然后将其插入X

00:24:52.260 --> 00:24:58.110
当您在第一个位置的第一个位置拿到鸡蛋时

00:24:58.110 --> 00:25:01.690
列表，然后我们再次插入

00:25:01.690 --> 00:25:06.610
然后我们得到了之前被断定的奶酪，所以基本上就是

00:25:06.610 --> 00:25:15.250
但这说明我们如何处理AR DT距离，但这就是

00:25:15.250 --> 00:25:18.090
反正几乎可以预期

00:25:18.090 --> 00:25:24.700
所以我们经历了所有的水果和所有我们想吃的事情，我想这是

00:25:24.700 --> 00:25:30.790
我希望我对Jason的CR DT有一个很好的了解

00:25:30.790 --> 00:25:38.490
Celerity应该用于哪些应用程序，它如何解决

00:25:38.490 --> 00:25:45.580
冲突，或者至少在某些情况下最终状态如何

00:25:45.580 --> 00:25:51.820
教育工作者的例子发生在解决冲突中，所以我们现在可以开始

00:25:51.820 --> 00:25:56.049
进入更多的实施细节中，我们已经

00:25:56.049 --> 00:26:04.110
确实需要将哪种类型的元数据保存在JSON CR DT中，并且

00:26:04.110 --> 00:26:10.390
当我们插入时，我们可以进行什么样的操作以及为读者提供什么？

00:26:10.390 --> 00:26:15.970
清除JSON中的某些元素，以便我们能够

00:26:15.970 --> 00:26:23.530
这些GCR DT可以达到我们想要的所有属性，所以第一件事就是

00:26:23.530 --> 00:26:28.900
评估他们展示的表情，所以这些表情是我们要去的

00:26:28.900 --> 00:26:33.190
很快地通过它们，其中有一些有趣的见解

00:26:33.190 --> 00:26:40.000
但是我认为最重要的部分是如何进行我们的运营以及如何

00:26:40.000 --> 00:26:46.299
应用操作，那是我认为我们可以在其中学习最多的知识，是的

00:26:46.299 --> 00:26:53.470
有趣的见解或某种背景思想是，每一种

00:26:53.470 --> 00:27:02.020
操作或在rdt上本地执行或在rdt上执行的每个突变

00:27:02.020 --> 00:27:09.030
实际上首先会生成一个操作，所以这是基于

00:27:09.030 --> 00:27:15.840
请先了解我们的职责，然后再在本地应用修改算法

00:27:15.840 --> 00:27:20.550
生成此操作，该操作几乎是唯一可识别的

00:27:20.550 --> 00:27:26.490
仅在本地，但在整个网络中，然后可以被闲聊或共享

00:27:26.490 --> 00:27:30.120
与其他同伴，以便他们也可以应用该操作，然后成为

00:27:30.120 --> 00:27:37.110
确保所有内容均正确放置，其中一项是其中的一项

00:27:37.110 --> 00:27:45.230
操作是游标，而该游标几乎是一个键列表，

00:27:45.230 --> 00:27:52.290
在Jason的位置识别您所看到的本地位置的ID

00:27:52.290 --> 00:27:58.850
诚心诚意，但我们将看到这个蛋实际上是如何融合在一起的

00:27:58.850 --> 00:28:02.760
稍后，当我们要讨论应用

00:28:02.760 --> 00:28:08.490
操作，这是很多实现细节的开始，这是一个

00:28:08.490 --> 00:28:13.830
我不知道您是否熟悉这种操作

00:28:13.830 --> 00:28:19.200
语义表示法，实际上在该链接中，

00:28:19.200 --> 00:28:26.250
作者，基本上这是关于如何评估的正式代表

00:28:26.250 --> 00:28:35.490
表达式，所以通过表达式，我的意思是如何定义变量或如何

00:28:35.490 --> 00:28:42.090
从列表中获取一个索引，依此类推等等，所以我认为

00:28:42.090 --> 00:28:52.850
最有趣的部分是这些ibx 4，因此此idx 4是我们想要

00:28:52.850 --> 00:29:00.620
遍历一个列表，其中列表中的某些元素已被删除

00:29:00.620 --> 00:29:05.550
因此，这实际上是其中最有趣的部分的介绍

00:29:05.550 --> 00:29:10.560
Jason Cality，这是在元素添加到

00:29:10.560 --> 00:29:15.870
Jason C或T的问题是我们不能仅仅删除整个元素，所以

00:29:15.870 --> 00:29:22.710
例如，如果我们在CRT中某处有一个元素为1的列表

00:29:22.710 --> 00:29:29.490
第三，如果由于某种原因我们在本地要删除第二个，则第二个

00:29:29.490 --> 00:29:38.039
要素三，我们不能仅仅去那里并删除所有东西，因为其他

00:29:38.039 --> 00:29:44.640
其他副本实际上可能正在对该副本执行某些操作

00:29:44.640 --> 00:29:49.529
列表中的元素，然后我们丢失的是

00:29:49.529 --> 00:29:54.240
整合整个东西真的很需要，所以这个想法是每一个

00:29:54.240 --> 00:30:02.100
Jason树中的树中的元素位于其中，称为a

00:30:02.100 --> 00:30:15.080
当前集合，并且该集合具有已被

00:30:15.080 --> 00:30:23.840
依靠那个元素，所以基本上所有的操作

00:30:23.840 --> 00:30:29.520
一直在使用的元素出于某种原因或其他原因使用了该元素

00:30:29.520 --> 00:30:36.090
无论是用于遍历还是创建它或它们是什么

00:30:36.090 --> 00:30:42.929
在这些元素中表示元数据，因此基本上清除状态只是

00:30:42.929 --> 00:30:47.970
从该元素的列表中删除操作ID，并最终

00:30:47.970 --> 00:30:52.740
当它完全为空时，我们可以考虑在应用程序级别上

00:30:52.740 --> 00:30:57.510
该元素被删除，这可能仍然有点令人困惑，但我们要去

00:30:57.510 --> 00:31:03.029
通过这一点，以后我的想法是，我只想给一个

00:31:03.029 --> 00:31:11.850
一个快速的例子，如何服务于阅读这些水泥形式

00:31:11.850 --> 00:31:16.669
这里的语义是这样的

00:31:17.510 --> 00:31:27.220
这个IDX for-expression向我们表明，只要我们有

00:31:27.900 --> 00:31:36.620
每当我们有下一个元素存在的上下文时

00:31:36.620 --> 00:31:46.020
因此，它们将使该元素存在，并且它的存在设置向我们展示的元素

00:31:46.020 --> 00:31:54.150
是否仍然依赖于该操作是否为空，那么我们

00:31:54.150 --> 00:31:58.740
可以在列表上向前移动光标，因为我们正在遍历列表

00:31:58.740 --> 00:32:06.720
而不降低索引，这意味着我们再次成为

00:32:06.720 --> 00:32:12.240
遍历列表只是上下文，我们遍历列表，我们正在

00:32:12.240 --> 00:32:19.080
只要达到这一个要素，我们就会用英语前进，检查其

00:32:19.080 --> 00:32:24.899
存在集（如果当前集为空）表示存在以下信念：

00:32:24.899 --> 00:32:29.580
元素实际上已被删除，并且在遍历时不应考虑

00:32:29.580 --> 00:32:33.960
列表，所以我们只是继续前进而不会降低索引，因此基本上

00:32:33.960 --> 00:32:39.600
整个表达的意思是什么，这只是如何

00:32:39.600 --> 00:32:46.350
阅读阅读本文，我们将向前看如何真正清除整个内容

00:32:46.350 --> 00:32:54.260
上下文和整个元素稍微更详细或更可能

00:32:54.260 --> 00:33:00.000
以一种更简化的方式在外面，所以这正是我

00:33:00.000 --> 00:33:06.870
谈论，所以无论如何我们都必须将所有节点保留在树中

00:33:06.870 --> 00:33:13.320
他们是否已被删除，这实际上是一个问题

00:33:13.320 --> 00:33:18.960
当谈到空间效率时，因为最终我们将本地化

00:33:18.960 --> 00:33:24.750
我们很多人可能会保留许多实际上已删除的元素

00:33:24.750 --> 00:33:29.070
例如，它们不会显示在应用程序层，但我们

00:33:29.070 --> 00:33:34.140
必须保留它们，因为当前设置为空，因为我们不确定

00:33:34.140 --> 00:33:38.880
是否还删除了所有其他副本，因为如果有其他副本

00:33:38.880 --> 00:33:43.889
实际上正在更改我们看到已删除的这一个元素，然后

00:33:43.889 --> 00:33:48.120
我们得到了一个可以改变它的操作，然后我们就没有了

00:33:48.120 --> 00:33:52.409
融合不是一个主意

00:33:52.409 --> 00:33:57.659
将会继续工作，所以这有很多问题，其中之一就是我们必须

00:33:57.659 --> 00:34:02.220
当网络中的所有副本都已经存在时，请保留大量不必要的数据

00:34:02.220 --> 00:34:06.480
删除是一种元素，实际上没有必要将其保留在其中，我们可以

00:34:06.480 --> 00:34:11.040
实际上只是将其删除，但这是我们如何处理这种情况

00:34:11.040 --> 00:34:15.869
我们知道所有其他同龄人都相信这些要素，我们如何做到这一点

00:34:15.869 --> 00:34:20.909
垃圾回收我们如何快照这是另一种操作

00:34:20.909 --> 00:34:26.159
或可以帮助我们进行垃圾收集的帮手，就像

00:34:26.159 --> 00:34:33.569
见奇数中最大的一种开放式开放点之一，或者

00:34:33.569 --> 00:34:40.379
公开的问题，有很多讨论，佩德罗（Pedro）一直在做一个非常

00:34:40.379 --> 00:34:45.839
善于解释和解决问题，并且您知道检查

00:34:45.839 --> 00:34:49.440
讨论，我认为如果您真的对这一点感兴趣，那是

00:34:49.440 --> 00:34:55.500
真的很酷，继续前进并检查此链接并做出贡献，所以还好

00:34:55.500 --> 00:35:02.790
所以基本上我们在本节中只是想确保我们可以

00:35:02.790 --> 00:35:06.720
了解如何读懂这不是一件容易的事，我花了一段时间

00:35:06.720 --> 00:35:11.520
也是我们以后可以检查的链接，如果您是

00:35:11.520 --> 00:35:15.000
对此非常感兴趣，然后介绍如何清除

00:35:15.000 --> 00:35:20.849
说明如何删除元素，以及这些哑石的作用是什么

00:35:20.849 --> 00:35:26.609
在已删除但未删除的节点上重击

00:35:26.609 --> 00:35:33.170
数据结构的意思是，但是我们已经要再说一遍了

00:35:33.170 --> 00:35:38.910
几分钟后，所以下一个会话部分是

00:35:38.910 --> 00:35:43.829
开始变得更加有趣或至少更加实用，然后我

00:35:43.829 --> 00:35:47.280
还有一个图表，其中显示了整个算法，所以现在我们

00:35:47.280 --> 00:35:50.910
进入一种情况，我相信我们可以开始应对

00:35:50.910 --> 00:35:54.250
我们真正需要什么样的元数据，然后是什么算法

00:35:54.250 --> 00:35:58.270
以及将确保收敛发生

00:35:58.270 --> 00:36:03.670
没有冲突，所以我想我只是已经提到过这是一个

00:36:03.670 --> 00:36:10.210
基于Jason CR DT的操作这意味着即使在突变之前

00:36:10.210 --> 00:36:16.120
在本地完成操作生成，并且操作种类

00:36:16.120 --> 00:36:22.720
封装有关什么是突变的所有必要信息

00:36:22.720 --> 00:36:30.850
副本要在本地执行的操作，然后其唯一标识

00:36:30.850 --> 00:36:36.970
这些操作在整个网络中一样，因此副本

00:36:36.970 --> 00:36:43.830
可以改变这些操作，因此基本上可以将R DT视为

00:36:43.830 --> 00:36:50.560
如果我们知道，可以通过一系列操作来构建

00:36:50.560 --> 00:36:55.000
操作，然后我们可以遍历并构建整个基于Jason的树

00:36:55.000 --> 00:37:00.220
关于这一点，这就是我们将要讨论的是如何产生

00:37:00.220 --> 00:37:04.120
这些操作，然后我们将了解如何应用这些操作，因为

00:37:04.120 --> 00:37:10.000
就像是一种真正的算法正是如何应用这些操作

00:37:10.000 --> 00:37:19.180
因此，我们的想法是，我们将继续保留哦，实际上，这是一个

00:37:19.180 --> 00:37:25.480
真的很有趣，好吧，所以确切地表示了突变

00:37:25.480 --> 00:37:32.250
作为网络独有的操作

00:37:33.490 --> 00:37:39.160
在本地创建操作之前，我们先创建操作，然后

00:37:39.160 --> 00:37:44.980
然后适当地涂抹，然后将其运用到整个网中，好，这样我们就得到了Lamport

00:37:44.980 --> 00:37:48.840
时间戳和Lamport时间分对确保某种程度的确非常重要

00:37:48.840 --> 00:37:56.560
我们有一些我们可以保留伤亡人数，因此

00:37:56.560 --> 00:38:01.810
操作最终将是任意的，但它们是确定性的，

00:38:01.810 --> 00:38:09.460
这意味着Lamport的时钟确保了如我们所讨论的

00:38:09.460 --> 00:38:15.430
之前有evans问题，当我们在两个副本中获得订单清单时，

00:38:15.430 --> 00:38:24.190
当我们在本地合并它们时，我们可以确定，尽管两组的顺序

00:38:24.190 --> 00:38:31.000
将是随机的，因此可能是我的副本是第一副本还是第二副本

00:38:31.000 --> 00:38:36.880
但至少我们确信，

00:38:36.880 --> 00:38:42.550
网络，这正是我们想要的

00:38:42.550 --> 00:38:47.450
所以这就是使用Lamport的水箱的重点

00:38:47.450 --> 00:38:52.250
到处都有很多，所以我们在操作中已经有了依赖项，

00:38:52.250 --> 00:38:58.820
我们稍后会看到这一点，以确保该操作

00:38:58.820 --> 00:39:03.320
是并发的，顺序将是任意的但是确定性的，因此

00:39:03.320 --> 00:39:08.690
每个人都对此表示同意，所以结构实际上看起来像什么

00:39:08.690 --> 00:39:16.760
我们需要元数据，以便我们可以安全地确保融合

00:39:16.760 --> 00:39:23.510
当在本地和其他对等方应用这些时，操作的ID为

00:39:23.510 --> 00:39:27.980
一个Lampert ID，它有一个依赖项集

00:39:27.980 --> 00:39:34.730
依赖集是基本的，这对于操作

00:39:34.730 --> 00:39:42.880
依赖集级别是所有以下操作的Lampert ID的集合：

00:39:42.880 --> 00:39:49.760
这一项操作取决于，而实际取决于什么意味着

00:39:49.760 --> 00:39:57.099
所有已经进行的操作

00:39:58.409 --> 00:40:03.549
先应用它，所以说是的，所有已应用的操作

00:40:03.549 --> 00:40:09.339
在创建此操作之前，如果它们是并发的，则

00:40:09.339 --> 00:40:13.809
将必须是依赖项集的一部分，因此我们确保每次

00:40:13.809 --> 00:40:20.079
对等体或副本将应用一个操作，必须满足所说的所有依赖关系

00:40:20.079 --> 00:40:25.509
否则，有一种方法可以确保向厨师烹饪我们所拥有的

00:40:25.509 --> 00:40:34.239
已经看到了，所以它基本上显示了到达某个节点或某个路径的路径

00:40:34.239 --> 00:40:39.189
树中的节点，然后突变基本上只是准确地告诉了什么

00:40:39.189 --> 00:40:42.999
突变是插入还是删除都可以做什么？

00:40:42.999 --> 00:40:48.459
这个由光标指向的节点的坐标，因此基本上就是它和一个

00:40:48.459 --> 00:40:57.159
我们可以从一组这些操作中建立相邻的CR DT，所以这是

00:40:57.159 --> 00:41:00.549
真的很酷，因为我们可以在网络中随意进行这些操作

00:41:00.549 --> 00:41:07.929
并将其应用于本地，我们就有了CR DT算法，所以我认为其中之一

00:41:07.929 --> 00:41:13.449
最重要的部分就是依赖关系偶然的依赖关系

00:41:13.449 --> 00:41:22.209
操作，基本上是这样，我已经解释过了

00:41:22.209 --> 00:41:27.369
正是操作需要确定的har依赖关系

00:41:27.369 --> 00:41:32.339
被应用，以便可以安全地应用，这基本上是

00:41:32.339 --> 00:41:34.400
你

00:41:35.619 --> 00:41:42.769
是的，这些的主要目标是它所说的，但这就是秘密

00:41:42.769 --> 00:41:46.759
将应用在一个特定副本上生成的操作顺序

00:41:46.759 --> 00:41:51.440
在每个副本上以相同的顺序进行，因为可以应用一个操作

00:41:51.440 --> 00:41:57.349
仅当其依赖项已应用时，否则将被缓冲

00:41:57.349 --> 00:42:04.369
并且码头将一直等待操作，直到操作完成为止

00:42:04.369 --> 00:42:15.880
基本上这样见面，我想我们可以在这里代替这里

00:42:15.880 --> 00:42:24.349
反对如何实际应用操作的形式语义

00:42:24.349 --> 00:42:30.369
显示我所拥有的一张图，你能看到吗我

00:42:30.369 --> 00:42:34.609
更改了屏幕，您现在可以看到它吗，好酷

00:42:34.609 --> 00:42:43.430
好的，所以在这一点上再加上一些背景信息，因为这可能

00:42:43.430 --> 00:42:48.499
帮助，我跃跃欲试，以便给您一些背景信息

00:42:48.499 --> 00:42:58.880
现在发生的事情是本地副本希望更改Jason CR DT状态

00:42:58.880 --> 00:43:05.450
就本地而言，这样就可以发生，或者无论本地如何，都可以创建一个操作

00:43:05.450 --> 00:43:13.220
当副本要更改距离ERD T或通过从

00:43:13.220 --> 00:43:21.319
一个远程码头，所以算法现在必须确保

00:43:21.319 --> 00:43:27.289
这些操作的应用方式可以使我们获得所需的收敛性，因此

00:43:27.289 --> 00:43:34.099
这恰好是显示如何应用

00:43:34.099 --> 00:43:42.200
操作在本地状态下的副本，所以这就是全部

00:43:42.200 --> 00:43:51.300
元数据和元数据的处理方式在不同种类的不同数据中

00:43:51.300 --> 00:44:01.170
元素的结构，所以这个想法是，我认为我实际上

00:44:01.170 --> 00:44:05.610
之前没有提到这个，所以我们不得不首先对不起，所以这个主意

00:44:05.610 --> 00:44:14.610
是我们已经进行了操作，我们在树中的注释中添加了注释，然后

00:44:14.610 --> 00:44:21.720
我们也有整棵树，所以所有这三个像几个级别

00:44:21.720 --> 00:44:27.780
不同类型的元数据，因此整个树保留了整个Jason CR DT

00:44:27.780 --> 00:44:31.970
保留一个列表，其中包含已应用到该列表的所有操作ID

00:44:31.970 --> 00:44:37.470
操作本身会保留其ID，然后保留一组依赖关系，因此

00:44:37.470 --> 00:44:45.480
所有需要应用的操作ID的集合，以便进行这些操作

00:44:45.480 --> 00:44:50.250
可以安全地应用，并且这些元素的一部分

00:44:50.250 --> 00:44:55.770
正如我们之前所见，树中的节点保留了一个称为“当前集”的集

00:44:55.770 --> 00:45:02.430
其中显示或保留所有操作的操作ID的列表，

00:45:02.430 --> 00:45:07.380
以一种或另一种方式与该元素进行了互动，例如

00:45:07.380 --> 00:45:13.470
每次在操作中应用该操作ID时遍历一个节点

00:45:13.470 --> 00:45:22.440
被添加到该元素的存在集合中，所以基本上就像

00:45:22.440 --> 00:45:29.280
Sierra T Jason保留的三种类型的元数据，现在

00:45:29.280 --> 00:45:34.590
我们将通过算法看到的是，这些不同级别的

00:45:34.590 --> 00:45:42.240
应用本地操作时，元数据实际上是由服务器操作的

00:45:42.240 --> 00:45:48.780
本地操作还可以，所以我们说我们有本地操作，因此

00:45:48.780 --> 00:45:54.240
复制品首先要更改一个元素，以构建Opera

00:45:54.240 --> 00:46:00.130
正如我们所看到的那样，我们已经看到了所有的元素

00:46:00.130 --> 00:46:05.230
刚才，然后我们在本地应用它，这意味着我们

00:46:05.230 --> 00:46:13.240
会按照光标显示的方式下降树，因此路线再次是

00:46:13.240 --> 00:46:19.090
一组音符，音符键，然后我们遍历整棵树

00:46:19.090 --> 00:46:25.080
根据光标，直到到达树中的节点

00:46:25.080 --> 00:46:30.790
修改过的mutated，当您遍历时，我们正在添加操作

00:46:30.790 --> 00:46:36.160
到达节点之前，我们已经看到过的所有节点的存在ID的ID

00:46:36.160 --> 00:46:43.390
一旦到达光标所指向的最后节点，就可以应用

00:46:43.390 --> 00:46:49.000
可以说是突变，在这里应用是指无破坏性

00:46:49.000 --> 00:46:50.860
因为分心会有所不同

00:46:50.860 --> 00:46:55.030
我们之前会先讨论一下，假设我们只是分配一个

00:46:55.030 --> 00:47:01.900
新值或键值到地图，因此我们应用突变，然后如果它是一个

00:47:01.900 --> 00:47:07.410
非本地操作，那么我们只是缓冲我们已经本地应用的我们缓冲的

00:47:07.410 --> 00:47:12.670
我们介绍了操作，然后将其发送到某种网络，以便

00:47:12.670 --> 00:47:17.670
其他人可以在本地应用相同的操作

00:47:17.670 --> 00:47:21.550
在本地接收到，仍然需要进行几项检查

00:47:21.550 --> 00:47:29.650
在此之前，首先我们必须查看基于已应用操作的检查

00:47:29.650 --> 00:47:34.270
如果此操作已经完成，则该列表是Jason CR DT的一部分

00:47:34.270 --> 00:47:38.920
是否申请，因为那再一次，我们无法从网络中获得任何保证

00:47:38.920 --> 00:47:44.050
可能会得到两次相同的操作的三倍，所以我们必须

00:47:44.050 --> 00:47:52.270
确保我们不对同一操作应用不止一次，所以如果

00:47:52.270 --> 00:47:57.640
操作尚未应用，我们将基于

00:47:57.640 --> 00:48:01.720
该操作以及已应用于整个Jason的操作

00:48:01.720 --> 00:48:07.060
CR DT如果所有依赖项依赖项都得到了实际满足，则

00:48:07.060 --> 00:48:08.799
正是我们真正需要这些的原因

00:48:08.799 --> 00:48:14.169
对操作topo的依赖性以及另一个原因的原因之一

00:48:14.169 --> 00:48:19.419
清除状态，但我们看到了前进状态，因此如果尚未执行该操作

00:48:19.419 --> 00:48:23.259
满意，然后缓冲它，直到我们等到

00:48:23.259 --> 00:48:26.979
我们会收到更多操作，然后重新检查是否可以应用它们

00:48:26.979 --> 00:48:31.719
很多，然后过程是完全一样的，所以一旦我们想在本地应用它

00:48:31.719 --> 00:48:38.499
仅基于后代树基于游标的情况下，修改

00:48:38.499 --> 00:48:43.059
我们遍历的不同节点，然后我们不将其发送到网络或

00:48:43.059 --> 00:48:46.899
我们甚至可能根据协议发送，如果我们只想

00:48:46.899 --> 00:48:53.559
无论如何，都是八卦，基本上就是突变排序时要分配的想法

00:48:53.559 --> 00:48:58.869
分配而不是删除要删除的有趣部分的原因在于

00:48:58.869 --> 00:49:04.539
通过完全相同的算法经历完全相同的过程，无论是

00:49:04.539 --> 00:49:09.939
本地操作或远程操作，但是当涉及到发送树时

00:49:09.939 --> 00:49:18.069
我们要做的不是拥有，不仅是将操作ID添加到他们，或者

00:49:18.069 --> 00:49:22.569
抱歉，而不是将操作ID添加到当前的一组节点中

00:49:22.569 --> 00:49:29.109
遍历，删除之后，将要发生的是

00:49:29.109 --> 00:49:37.149
要清除当前设置，所以基本上就是我要发生的事情

00:49:37.149 --> 00:49:39.839
在这里

00:49:39.960 --> 00:49:50.260
是的，这里是癌症，所以基本上我们还是想删除列表，所以我们

00:49:50.260 --> 00:49:57.100
当我们到达列表时，通过检查游标来遍历信念

00:49:57.100 --> 00:50:03.790
再次遍历列表中的所有元素，然后从当前元素中删除

00:50:03.790 --> 00:50:08.260
在每个应该删除的元素中设置

00:50:08.260 --> 00:50:15.970
删除操作的依赖项，所以这意味着我们改为

00:50:15.970 --> 00:50:22.090
只是删除元素本身，因为如果其他节点

00:50:22.090 --> 00:50:27.370
在此元素的集合中进行某种修改，然后我们

00:50:27.370 --> 00:50:31.510
接收这些操作，整个过程将会收敛，但是什么是

00:50:31.510 --> 00:50:37.810
确保是我们可以进入一种情况，如果所有的操作

00:50:37.810 --> 00:50:47.380
从这些节点上已经有些依赖于这些节点的节点将被删除

00:50:47.380 --> 00:50:51.490
依赖单元格，那么我们可以将元素视为已删除，这就是

00:50:51.490 --> 00:50:55.900
确切地说，当我们到达空集时，正是我们所处的情况

00:50:55.900 --> 00:51:00.280
我们可以得到Thompsons，以便其中的节点占用空间吗

00:51:00.280 --> 00:51:05.230
但实际上它们已不再有价值，因为它们实际上已删除

00:51:05.230 --> 00:51:08.380
他们，但我们必须留在那里，因为我们不确定其他所有

00:51:08.380 --> 00:51:16.740
副本知道此节点已被清除，它们可能是并发的，并且

00:51:16.740 --> 00:51:22.990
离线修改它，所以这对我来说真的很有趣

00:51:22.990 --> 00:51:28.180
意见，所以很明显，我们在这里的权衡是某种元数据和空间

00:51:28.180 --> 00:51:36.010
所有这些冲突解决方法，这是最重要的部分之一

00:51:36.010 --> 00:51:42.430
我相信真正正确理解算法的算法是机制

00:51:42.430 --> 00:51:48.460
如何设置如何处理

00:51:48.460 --> 00:51:51.700
差异服务器层以某种方式或在

00:51:51.700 --> 00:51:58.750
和对象，是的，这差不多就是那里没有

00:51:58.750 --> 00:52:02.920
更重要的是，这是一个相当简单的算法，仅此而已

00:52:02.920 --> 00:52:10.000
关于确保保留所有元数据，然后在处理时正确处理

00:52:10.000 --> 00:52:13.349
当我们应用操作时

00:52:14.680 --> 00:52:23.490
是的，而且基本上就是为了再

00:52:23.490 --> 00:52:27.670
我将再次经历这些，这真的很重要，因为

00:52:27.670 --> 00:52:33.910
没有真正明确地在论文中明确说过或写过，但对我来说，我

00:52:33.910 --> 00:52:38.440
就是实现了这些的一站式库

00:52:38.440 --> 00:52:42.550
算法和数据结构这正是真正开放的

00:52:42.550 --> 00:52:47.610
整个数据模型的全部，这就是全部

00:52:47.610 --> 00:52:53.800
正确生成操作，然后全部保留所有

00:52:53.800 --> 00:52:58.150
文档级别的元数据，这些元数据是已经执行的操作的列表

00:52:58.150 --> 00:53:02.140
在本地操作级别应用唯一ID及其自己的集合

00:53:02.140 --> 00:53:05.980
依赖关系，以便仅当所有其他操作都可以应用此操作时，

00:53:05.980 --> 00:53:09.940
我们应用的操作以及在世界范围内应用的非水平操作

00:53:09.940 --> 00:53:16.000
并检查该节点是否存在，基本上就是它

00:53:16.000 --> 00:53:23.320
以及所有这些算法以及所有这些

00:53:23.320 --> 00:53:31.180
元数据，我们确信我们会获得所有强大的最终收敛性II

00:53:31.180 --> 00:53:37.780
而不会丢失任何修改，并且我们从

00:53:37.780 --> 00:53:42.790
数据结构，使所有所有副本进入相同状态而没有任何状态

00:53:42.790 --> 00:53:47.680
冲突，所以我可能会跳过，因为我已经在谈论

00:53:47.680 --> 00:53:51.670
我可能会跳过这些更正式的收敛定义

00:53:51.670 --> 00:53:55.810
认为我们会以一种或另一种方式经历它们

00:53:55.810 --> 00:54:00.310
基本上，如果您真的很喜欢的话，最后会有一个有趣的部分

00:54:00.310 --> 00:54:05.410
到它的数学中，作者证明了如何很好地

00:54:05.410 --> 00:54:14.710
算法中不同步骤的不同，确保我们

00:54:14.710 --> 00:54:18.790
总是汇合汇合非常有趣的阅读内容

00:54:18.790 --> 00:54:24.040
那是因为我们至少得到了我相信这经历了一点

00:54:24.040 --> 00:54:30.130
以任何正式的方式提供更多信息，所以是的，我的意思是，基本上我想

00:54:30.130 --> 00:54:35.230
希望那不是那么令人困惑，因为对我来说，它还是有点内心和

00:54:35.230 --> 00:54:41.790
真的以一种非常简洁的方式试图解释整个事情是如何发生的，但是

00:54:41.790 --> 00:54:47.260
就像论文真的显示了如何建立这些Jason CR职责

00:54:47.260 --> 00:54:53.590
您可以嵌入所有不同类型的地图列表，也可以使用寄存器

00:54:53.590 --> 00:54:59.920
真正表达非常结构，并确保并发操作

00:54:59.920 --> 00:55:05.500
并发突变可以局部优化合并，并确保

00:55:05.500 --> 00:55:09.670
我认为这一切都收敛了，无需达成共识。

00:55:09.670 --> 00:55:13.930
希望很多您知道进一步的工作或有关垃圾的热门话题

00:55:13.930 --> 00:55:20.650
收集和类似的东西可以很快解决，以便我们可以或以某种方式

00:55:20.650 --> 00:55:26.620
进行了改进，以便我们绝对可以将这些纳入您的了解中

00:55:26.620 --> 00:55:30.340
应用程序，那么我们已经有了相当有趣的库，例如Auto

00:55:30.340 --> 00:55:36.100
合并，并且应用程序还可以在真实环境中使用CR实体来对等Pat。

00:55:36.100 --> 00:55:42.310
真的很酷，所以我认为很有前途，是的，太棒了

00:55:42.310 --> 00:55:48.700
非常感谢，我觉得我学到了一个问题，对吗？

00:55:48.700 --> 00:55:54.640
似乎其他元数据的大小将是原来的两倍或三倍

00:55:54.640 --> 00:56:00.600
自实施此数据库以来，您已经看到了

00:56:00.600 --> 00:56:06.940
像这样的增长或您如何评估进行扩展，是的，这是

00:56:06.940 --> 00:56:11.560
真的很难估计规模，但我要说的是，如果有很多同龄人

00:56:11.560 --> 00:56:14.920
如果网络中有很多副本，并且网络中有很多对等节点

00:56:14.920 --> 00:56:21.100
进行修改，主要是删除大量的添加和删除节点

00:56:21.100 --> 00:56:28.990
它会快速增长，而且这里的问题还在于，如果我们

00:56:28.990 --> 00:56:34.150
谈到基于运营的CR职责，还有其他基于Delta的类型

00:56:34.150 --> 00:56:39.970
除了运营阶段的CR职责外，他们还存在以下问题：

00:56:39.970 --> 00:56:43.670
每当有人加入时，有人需要起义

00:56:43.670 --> 00:56:49.550
加入网络，我们有两种古老的羊或发送所有操作集

00:56:49.550 --> 00:56:54.470
基本上已经是必须与这些新的共享的本地状态

00:56:54.470 --> 00:57:00.560
彼得基本上就是整个行动的清单，所以想象一下

00:57:00.560 --> 00:57:05.810
是在JSON CR BT的开头，有这些操作

00:57:05.810 --> 00:57:10.250
这类元素已发出，没有副本具有

00:57:10.250 --> 00:57:14.540
每当新的彼得来临时，这个元素就不再存在了，我们仍然

00:57:14.540 --> 00:57:18.560
必须发送，所以不仅在存储方面，而且在带宽方面，我的意思是

00:57:18.560 --> 00:57:24.140
网络带宽有很多嗯嗯，它认为

00:57:24.140 --> 00:57:29.650
基于操作的资源仍然很多

00:57:29.650 --> 00:57:34.820
没有快照，没有垃圾的快照，我没有

00:57:34.820 --> 00:57:40.550
确实有数字，但是我从ipfs的一些会议中听说过

00:57:40.550 --> 00:57:45.140
然后还有一些基准测试的功能

00:57:45.140 --> 00:57:48.800
已经完成了，是的，它真的可以快速增长

00:57:48.800 --> 00:57:53.690
好吧，走得真快，所以我想说，是的，这是一个问题

00:57:53.690 --> 00:57:58.010
完全解决是的，是的，这似乎也取决于很多因素，例如

00:57:58.010 --> 00:58:02.450
如果每个人都做得很小，则编辑的平均大小

00:58:02.450 --> 00:58:06.920
就像您知道文本文档会比

00:58:06.920 --> 00:58:10.970
这是为了您在列表中的编辑对象

00:58:10.970 --> 00:58:17.839
当不是例子而是例子的一种非常酷的例子时

00:58:17.839 --> 00:58:23.510
作者实际上建议创建一个基于以下内容的Google文档：

00:58:23.510 --> 00:58:30.619
 Jason CRT是我们构建字符串时的每一种

00:58:30.619 --> 00:58:38.780
并且每个char字符实际上至少是正确的元素，因此

00:58:38.780 --> 00:58:44.930
人们可以从角色层面去改变或移除或改变，

00:58:44.930 --> 00:58:48.770
一切都会正确进行，冲突将得到妥善解决，因此您可以

00:58:48.770 --> 00:58:54.460
想象像与很多人一起撰写论文

00:58:54.460 --> 00:58:59.830
更改和删除字符，其中许多字符永远不会

00:58:59.830 --> 00:59:05.950
必须成为您已经知道他们已构成结构的追逐活动的一部分，因此它可以

00:59:05.950 --> 00:59:10.869
很快就建立起来，是的，我也要问

00:59:10.869 --> 00:59:16.000
因为我不喜欢嵌入其中，所以我们从事的工作是女孩

00:59:16.000 --> 00:59:21.490
相关的这可以让我对景观有一个整体的感觉

00:59:21.490 --> 00:59:25.060
我知道不同类型的意甲之间有机会

00:59:25.060 --> 00:59:29.440
有基于操作的三角洲，我知道有基于状态的系列，是的

00:59:29.440 --> 00:59:34.480
还有其他我想念的吗，我是什么？

00:59:34.480 --> 00:59:38.619
我意识到像是要进行三个小时的讲座的提示，是的

00:59:38.619 --> 00:59:42.640
也许是的，但是我发生了，但是我不得不说，那些就是我一直在做的。

00:59:42.640 --> 00:59:48.190
也是关于此类的最丰富的阅读和学习，我认为

00:59:48.190 --> 00:59:52.510
Delta C我们的职责本身也真的很有趣，而且

00:59:52.510 --> 00:59:58.690
我看过这一直是超级超级热门话题，其中有很多事情

00:59:58.690 --> 01:00:02.980
发生了很多新事，而且我什至没有

01:00:02.980 --> 01:00:07.900
我相信能够赶上每篇新文章，

01:00:07.900 --> 01:00:13.330
每天都在田野上看到艺术，只有你不喜欢这个杰森

01:00:13.330 --> 01:00:18.730
这是我的职责，但我要说的是，这是CR的三种主要类型

01:00:18.730 --> 01:00:22.690
仍在使用的职责，但接下来我可能不得不

01:00:22.690 --> 01:00:30.609
看起来研究薄弱，如果可以的话，我会稍后再回覆，是的，我是

01:00:30.609 --> 01:00:35.109
一个非常基本的问题，我想我想知道您是否已经运行过测试

01:00:35.109 --> 01:00:39.070
显然这取决于网络规模和

01:00:39.070 --> 01:00:43.300
我所做的更改数量很大，但是喜欢了解所有这些更改的速度

01:00:43.300 --> 01:00:51.550
离线节点确实达到了最终的一致性，是的，

01:00:51.550 --> 01:00:56.170
好问题，我想我还没有进行任何测试，然后又有一些测试

01:00:56.170 --> 01:01:04.660
基准测试，我也可以从已经用Auto测试过的东西中挖掘出来

01:01:04.660 --> 01:01:13.049
合并以及同伴间的战争，但我想这全都取决于

01:01:13.049 --> 01:01:18.509
网络，还有什么样的修改，我认为

01:01:18.509 --> 01:01:27.269
那完全取决于我期望其他期望，但是你知道我

01:01:27.269 --> 01:01:31.769
认为这是最有趣的事情之一

01:01:31.769 --> 01:01:36.869
具有这些基准和不同类型方法的测试

01:01:36.869 --> 01:01:42.599
算法和不同类型的CR职责，因为如果有的话，

01:01:42.599 --> 01:01:49.769
这些技术是否真的想成为许多应用程序的一部分

01:01:49.769 --> 01:01:54.109
最重要的是很多应用领域

01:01:54.109 --> 01:01:58.680
要做的改进，对于那些我们只有您知道的事情，我们只有在有

01:01:58.680 --> 01:02:06.269
是指标，但也很抱歉，这也很有趣

01:02:06.269 --> 01:02:10.440
我会觉得塞拉病已经存在了很长时间，或者

01:02:10.440 --> 01:02:16.199
当我们考虑所有分散的和

01:02:16.199 --> 01:02:20.039
分布式的或大部分集中式的不是那么多，而是所有这些

01:02:20.039 --> 01:02:23.819
共识想法以及如何真正建立开始有趣的

01:02:23.819 --> 01:02:28.979
集中式应用程序虽然年代不长，但是已经被使用过了

01:02:28.979 --> 01:02:36.949
相当多，所以我的意思是，这仍然是一种非常正确的研究

01:02:36.949 --> 01:02:43.319
这样的领域，我认为我真的非常值得

01:02:43.319 --> 01:02:49.469
真的付出了努力，是的，资源可以提出来

01:02:49.469 --> 01:02:57.690
因为说出来好吧，停止这些应用程序真的很有趣

01:02:57.690 --> 01:03:00.979
录制哦，很酷

