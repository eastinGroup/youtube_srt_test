WEBVTT
Kind: captions
Language: zh-Hans

00:00:14.370 --> 00:00:21.050
好的，欢迎大家参加本周的IPL，您认为会见

00:00:21.050 --> 00:00:28.290
2019年11月11日，是的，每周我们都会经历完成的工作，并且

00:00:28.290 --> 00:00:34.379
我们计划要做的，然后讨论我们可能要开始的其他任何项目

00:00:34.379 --> 00:00:42.210
和我自己在一起，所以在过去的一周里，通常这只是今天，

00:00:42.210 --> 00:00:48.360
他们仍然是关于先生日的讨论，并为表现提供支持

00:00:48.360 --> 00:00:54.780
我得出的结论是，对于IPL D，使用

00:00:54.780 --> 00:00:59.570
坚固，因为我们需要做出他们不希望应用旋转的更改，

00:00:59.570 --> 00:01:06.270
我还调查了也许可以延期，但我们仍然有我们的员工

00:01:06.270 --> 00:01:11.039
与调查生态系统的其余部分一起工作，但这是有可能的

00:01:11.039 --> 00:01:17.490
利益弯曲，并以一种我们可以扩展的方式扩展另一个第三方库

00:01:17.490 --> 00:01:22.229
需要你，它与所有其他东西非常兼容，如果你问我

00:01:22.229 --> 00:01:26.819
问他们用户论坛得到了一个答复，他们正在讨论事情，但是

00:01:26.819 --> 00:01:31.110
如果确实有可能，我的计划仍然是写一篇有关

00:01:31.110 --> 00:01:38.700
这是因为防锈社区呼吁2020年说出您想要什么

00:01:38.700 --> 00:01:44.819
看看明年有没有生锈，我的物品是我希望能够

00:01:44.819 --> 00:01:50.849
以某种方式扩展第三方Mario确实需要很好

00:01:50.849 --> 00:01:54.390
只是需要某种方式，是的，所以我们会看看他们是否把它们捡起来

00:01:54.390 --> 00:02:00.110
是否，但这是我的计划，但与此相关的是C孔的作者

00:02:00.110 --> 00:02:07.979
kraid讨论了这个问题，并使我感到粉红色，他仍然想拥有高科技

00:02:07.979 --> 00:02:15.780
支持，现在的想法是，他可能会分叉一定的方式，但是

00:02:15.780 --> 00:02:24.060
它的工作方式是您真的可以正常编译吗，它将使用正常调查

00:02:24.060 --> 00:02:28.470
您将不会获得支持，但是您可以添加其他

00:02:28.470 --> 00:02:34.200
行到您的项目，然后它将使用此分支，这是技术支持和

00:02:34.200 --> 00:02:40.260
那么您将获得技术支持，但其他模块仍将使用此fork版本

00:02:40.260 --> 00:02:46.710
基本上可以正常工作，这是目前的基本想法，我不确定这是否

00:02:46.710 --> 00:02:52.380
之所以会奏效，是因为我认为如果您采用这种方式，则可以公开发布这些模块

00:02:52.380 --> 00:02:56.640
公开开放e-club，因此您只能将它们保存在github存储库中，但我们会

00:02:56.640 --> 00:03:01.980
不管怎么说，总而言之，有两个讨论，我会

00:03:01.980 --> 00:03:06.060
我想帮助他，因为我希望我能找到一些方法

00:03:06.060 --> 00:03:10.260
它会起作用，然后希望说服其他人以相同的方式这样做，并且

00:03:10.260 --> 00:03:15.060
最后，再次说服原始调查作者相信，如果

00:03:15.060 --> 00:03:20.070
那五个人在用叉子而不是原始的，为什么不

00:03:20.070 --> 00:03:27.480
行业，是的，我们会看到的，但可以肯定的是，我的计划基本上是

00:03:27.480 --> 00:03:32.220
有一个计划B，只是不使用urly，而是使用标志性的

00:03:32.220 --> 00:03:39.120
正确，但这有点像我不喜欢我变得像背景的东西

00:03:39.120 --> 00:03:43.590
我正在努力或希望获得帮助，但这并不是我们的首要任务，因为

00:03:43.590 --> 00:03:51.090
正如我说的那样，它不太可能进入上游，那么还有一个好消息

00:03:51.090 --> 00:03:56.850
是文本规范，这是我参与的某个标准

00:03:56.850 --> 00:04:02.160
有点他们有校验和的扩展名，我说服他们使用多重哈希

00:04:02.160 --> 00:04:07.140
他们的东西，你被合并，所以在下一个版本的规范将

00:04:07.140 --> 00:04:13.950
就像在今年年底，他们可能会使用校验和多

00:04:13.950 --> 00:04:19.650
哈希和好消息是因为他们还计划将其作为

00:04:19.650 --> 00:04:25.730
官方OGC标准，类似于主要的地理标准

00:04:25.730 --> 00:04:32.190
组织和大多数助手也成为了ISO标准，因此基本上

00:04:32.190 --> 00:04:36.470
这种方式就像这样的mod已经冒泡到ISO标准

00:04:36.470 --> 00:04:39.060
希望所以这有点像

00:04:39.060 --> 00:04:50.400
我想是的，然后在我研究的粗略方面

00:04:50.400 --> 00:04:55.500
说我想让推力的东西也可以和别人一起工作，所以这个东西是我

00:04:55.500 --> 00:05:00.810
考察我们拥有的生态系统，我刚刚发现我们拥有

00:05:00.810 --> 00:05:07.950
关键的Epps已完成rust multi hash项目，但lip实用程序团队已经

00:05:07.950 --> 00:05:12.210
p2p的故障，因此我们p2p没有使用上游

00:05:12.210 --> 00:05:18.180
项目，所以我目前正在为这些页面乞求并确保

00:05:18.180 --> 00:05:25.920
基本上是p2p，无论我们使用了相同的版本，是的，

00:05:25.920 --> 00:05:30.540
较大的信息，原因是大部分完成了lip p2p粗糙版本

00:05:30.540 --> 00:05:36.480
甚至完全是由飓风的错误造成的，所以这不是吹笛者的崩溃

00:05:36.480 --> 00:05:43.230
因此，如果我看到它们是分叉的，那很容易，但是我知道

00:05:43.230 --> 00:05:48.840
我们过去遇到过的主要开发人员之一，所以

00:05:48.840 --> 00:05:53.070
基本上不是，这是一个友好的叉子，不是他们想要做的

00:05:53.070 --> 00:05:56.640
根本不同的东西，只是他们移动起来更快

00:05:56.640 --> 00:06:00.810
前进，所以这应该不是什么大问题，而且他们遇到了一个问题

00:06:00.810 --> 00:06:05.640
他们想回到上游，所以那是我在做的，是的，不是

00:06:05.640 --> 00:06:11.070
它实际上比您想像的更令人兴奋，因为它基本上是

00:06:11.070 --> 00:06:14.550
取得了巨大的进步，因为您合并了这些上游补丁并获得了它们

00:06:14.550 --> 00:06:20.430
一键移动，是的，它取得了很大的进步，虽然不错，但是

00:06:20.430 --> 00:06:28.370
不像是精神上的挑战，是的，这就是我所拥有的

00:06:28.370 --> 00:06:31.370
埃里克

00:06:31.890 --> 00:06:42.430
是的，有人认为您有很多标准化的东西，所以我仍然

00:06:42.430 --> 00:06:47.290
挂断了代码生成中的兔子漏洞，并试图准备要

00:06:47.290 --> 00:06:53.500
优化友好，这是我去过一段时间的地方和事情

00:06:53.500 --> 00:06:56.860
变得更坚定了，但也越来越多了

00:06:56.860 --> 00:07:04.030
问题我不记得我到底提供了什么最新更新，所以我

00:07:04.030 --> 00:07:07.960
可能会回溯一点，并确保我一口气提供上下文

00:07:07.960 --> 00:07:15.720
在所有内存分配上进行性能优化时，都是这样

00:07:15.720 --> 00:07:22.510
通常以数量而不是大小来衡量，或者是最主要的问题之一

00:07:22.510 --> 00:07:27.700
我一直在担心如何设计要摊销的系统

00:07:27.700 --> 00:07:33.160
在过去的几周中尽可能多地分配资源，我学到了很多东西

00:07:33.160 --> 00:07:36.610
有关编译器内部的更多信息，尤其是可以证明的一项功能

00:07:36.610 --> 00:07:43.600
与我们息息相关，所以我们最终会有很多事情要逃脱

00:07:43.600 --> 00:07:49.990
堆，因为我们想通过所有遍历的接口来处理它们

00:07:49.990 --> 00:07:53.290
代码选择器是我们很多很酷的功能，因为它们都可以工作，因为

00:07:53.290 --> 00:07:57.910
我们可以将所有内容变成单态的节点接口

00:07:57.910 --> 00:08:04.510
没错，但要让事物作为接口进入，它们必须是

00:08:04.510 --> 00:08:09.850
指针，因此它们必须几乎总是意味着它们必须处于打开状态

00:08:09.850 --> 00:08:15.640
堆，但它们一定是指针，所以一件重要的事情是

00:08:15.640 --> 00:08:22.140
我最近了解到，一旦您有了一个完整的结构，

00:08:22.140 --> 00:08:26.560
使内部指针进入该位置

00:08:26.560 --> 00:08:32.669
相同的结构基本上是免费的，不会导致更多的堆分配，因此

00:08:32.669 --> 00:08:41.620
这是个好消息，这使我们有办法对新闻进行大量摊销

00:08:41.620 --> 00:08:45.279
是我们仍然必须确保设计内部结构吗

00:08:45.279 --> 00:08:51.579
该代码实际上可以预先进行大范围分配，然后能够

00:08:51.579 --> 00:09:01.600
拔掉那些指针，所以说起来容易做起来难

00:09:01.600 --> 00:09:04.870
事实证明，这实际上与某些

00:09:04.870 --> 00:09:11.559
我们今天在所有代码中已经拥有的接口，例如一些

00:09:11.559 --> 00:09:14.769
最早的草稿，所以我们有一个便笺界面，我们有匹配的便笺

00:09:14.769 --> 00:09:22.509
构建器界面，便笺构建器会建立一些价值，然后当您

00:09:22.509 --> 00:09:27.069
在其上调用最终的build方法将返回一个应该是然后的注释

00:09:27.069 --> 00:09:32.559
为只读，因此注释生成器界面的整体语义

00:09:32.559 --> 00:09:36.220
是您建立了一些小的价值，然后又建立了更大的价值，然后填补了它

00:09:36.220 --> 00:09:42.970
具有较小的值，以便您以这种方式进行构建，这几乎就是

00:09:42.970 --> 00:09:46.449
与我们想要提高效率相反，因为我们要从

00:09:46.449 --> 00:09:54.250
一个较大的扩展分配，然后填写它，结果是该接口

00:09:54.250 --> 00:10:01.269
本身就是内部结构的相反方向

00:10:01.269 --> 00:10:08.319
想要很长一段时间才能快速前进，所以最近两周的好消息

00:10:08.319 --> 00:10:12.730
经过几轮的研究，我们获得了许多有关内部指针的知识

00:10:12.730 --> 00:10:18.220
我们可以做很多优化，但要弄清楚如何

00:10:18.220 --> 00:10:22.329
使它们在我们目前拥有的界面中发挥作用仍然非常

00:10:22.329 --> 00:10:28.779
具有挑战性，一种可能的前进方式是，例如，同时拥有一个音符

00:10:28.779 --> 00:10:32.889
当前的建造者，从小到大，然后也许

00:10:32.889 --> 00:10:36.639
并行构建另一个接口，然后执行此范围分配

00:10:36.639 --> 00:10:42.970
填充它，所以这将是一种选择，但会增加数量

00:10:42.970 --> 00:10:46.059
基本上是我们代码的表面积，这是我的一点

00:10:46.059 --> 00:10:54.040
不知道这是一个好主意，还是我一直在尝试的另一种设计

00:10:54.040 --> 00:10:59.440
充实是如果我们可以让内脏做

00:10:59.440 --> 00:11:04.720
范围分配，但随后执行几乎相同的操作

00:11:04.720 --> 00:11:11.199
像笔记生成器已经做的那样收缩，我认为答案可能是

00:11:11.199 --> 00:11:14.139
实际上是肯定的，这就是我最近一直在尝试的模型

00:11:14.139 --> 00:11:20.050
一周左右的时间真的很有趣，但我认为有足够的时间

00:11:20.050 --> 00:11:26.829
定义明确的可见度模型，其中您仅显示指向某部分的指针

00:11:26.829 --> 00:11:32.889
当范围的那部分完成时，在很大程度上，我认为这是

00:11:32.889 --> 00:11:37.990
可以以安全易变的方式完成所有操作，但是它已经被实现了

00:11:37.990 --> 00:11:42.699
变得越来越复杂，而且还会带来一些非常有趣的东西

00:11:42.699 --> 00:11:48.220
注释上是否使用获取子项构建器字段方法的约束

00:11:48.220 --> 00:11:55.930
建造者当前返回您的东西应该在其中工作

00:11:55.930 --> 00:11:58.899
类型的边界正确，因此，如果您要向构建者索要

00:11:58.899 --> 00:12:02.769
字段，它为您提供了您本应花费的食物制造者类型

00:12:02.769 --> 00:12:09.069
能够不止一次地使用该东西来构建多个食物实例，如果

00:12:09.069 --> 00:12:16.480
我们尝试做基于范围的分配，然后我们可以

00:12:16.480 --> 00:12:22.480
将其全部塞入相同的界面，但最终将得到该子生成器

00:12:22.480 --> 00:12:28.209
您获得该字段的原因是因为它将绑定到现有内存

00:12:28.209 --> 00:12:32.019
将不再持有有关能够用来生产更多产品的合同

00:12:32.019 --> 00:12:36.910
而不是该类型的一个值，这可能比我应该更详细

00:12:36.910 --> 00:12:40.019
现在进入

00:12:40.139 --> 00:12:46.589
所以基本上有很多关于相同接口是什么的问题，

00:12:46.589 --> 00:12:51.370
因此，如果以后有人要谈论更多这一点，我想我需要的不止一个

00:12:51.370 --> 00:13:02.079
意见，我将其留在那儿，我看到鱼竿畏缩了，是的，如果抱歉，

00:13:02.079 --> 00:13:05.620
正确的反应，尽管实际上是我是否正在其他工作上

00:13:05.620 --> 00:13:09.220
关于我已经了解的有关go编译器内存布局的内容的文档，因此

00:13:09.220 --> 00:13:14.970
这可能有助于您弄清楚要放在哪里

00:13:14.970 --> 00:13:22.350
我当前的草稿仅位于cogent目录中，我不知道这是否是

00:13:22.350 --> 00:13:34.570
是它的最后安息之地，是的，我想就是这样，我真的

00:13:34.570 --> 00:13:38.830
享受阅读正在处理的大量文档的方式所带来的乐趣

00:13:38.830 --> 00:13:56.860
棒冷却，然后下一个是棒，除了文档之外，我

00:13:56.860 --> 00:14:04.170
上周完成了，好吧，我上周完成了大部分，那是

00:14:04.170 --> 00:14:08.050
我很高兴为学生复习了一会儿，但我真的很想

00:14:08.050 --> 00:14:14.770
考虑从团队外部获取意见，以便确定某人或

00:14:14.770 --> 00:14:23.680
可以看看的人，如果他们能弄清楚我们所拥有的

00:14:23.680 --> 00:14:27.730
过去几个月以来一直在做这份工作，那是一次成功

00:14:27.730 --> 00:14:32.260
表示它正在执行应做的事情，嗯，我不知道该过程是什么

00:14:32.260 --> 00:14:36.940
有没有可能我们合并它，然后让某人对其进行审查，或者也许我们得到了

00:14:36.940 --> 00:14:40.480
有人正在审查它的状态，现在我还是不知道，但我是

00:14:40.480 --> 00:14:43.390
很高兴你们正在努力通过它

00:14:43.390 --> 00:14:50.410
除了我继续前进之外，这非常有帮助，所以我有这样的痒

00:14:50.410 --> 00:14:56.410
我现在已经不需要几个月的时间了

00:14:56.410 --> 00:15:02.770
故意将自己与浏览器JavaScript断开很多

00:15:02.770 --> 00:15:08.140
意味着我不愿意让我的库在浏览器中运行，而我的

00:15:08.140 --> 00:15:15.160
测试都是针对节点的，这不是很理想，但是我也不是

00:15:15.160 --> 00:15:22.270
对浏览器中测试库代码的状态感到满意，所以我

00:15:22.270 --> 00:15:27.680
上个星期已经深入浏览器了

00:15:27.680 --> 00:15:32.240
土地和浏览器测试以及伪造者和网络工作者以及其他许多人

00:15:32.240 --> 00:15:39.170
技能的提高，但也写了一些小工具来帮助更好地测试

00:15:39.170 --> 00:15:44.059
浏览器，并且比今天可用的选项更有效，我全是

00:15:44.059 --> 00:15:51.350
我正在使用一个JavaScript C板Pazza，我正在写一个作为学习的方式

00:15:51.350 --> 00:15:57.160
那就是我所拥有的所有东西，但我也有差距

00:15:57.160 --> 00:16:04.339
这个项目也可以让您对C球更加熟悉

00:16:04.339 --> 00:16:11.470
一个星期的学习真的就是我

00:16:11.589 --> 00:16:17.660
是的，我看起来也像一年前浏览器测试的东西一样

00:16:17.660 --> 00:16:22.790
因为他们也将今天视为当前的方式，就像我们现在所做的那样

00:16:22.790 --> 00:16:28.269
成绩单或与业力有关的事物，以及所谓的东西

00:16:28.269 --> 00:16:37.970
疯狂，就像它是如此沉重，是的，所以我尝试像UM一样使用

00:16:37.970 --> 00:16:44.120
尝试了一些基本上使用tap格式的库，您可以拥有

00:16:44.120 --> 00:16:49.879
就像通过管道传输到浏览器一样，这很好，但我不是

00:16:49.879 --> 00:16:54.470
确定它是否会再次像Perl一样，就像世界一样

00:16:54.470 --> 00:17:01.209
测试是可行的，但是任何新的流程问题都比这还重要

00:17:01.209 --> 00:17:05.299
是的，那是我的意思，这就是我真正的主要原因之一

00:17:05.299 --> 00:17:10.640
几年前从浏览器中退房是试图对您的疯狂

00:17:10.640 --> 00:17:14.270
知道要使各种浏览器兼容的东西，但是

00:17:14.270 --> 00:17:19.309
测试浏览器中的测试只是荒谬的，实际上并没有

00:17:19.309 --> 00:17:23.630
改善了很多，这只是一个荒谬的事情，因为像

00:17:23.630 --> 00:17:27.949
人们对此感到满意吗，但您知道每个人都有自己的小技巧

00:17:27.949 --> 00:17:36.620
绕开它，是的，我的意思是硒仍然处于恐惧状态，

00:17:36.620 --> 00:17:41.330
我认为我们拥有的是

00:17:41.330 --> 00:17:46.070
因为我们处在中间的那个区域，我们不关心n个UI测试

00:17:46.070 --> 00:17:52.220
我们不需要控制浏览器就可以测试我们想要的界面或Dom

00:17:52.220 --> 00:17:57.559
采取库代码并说这在浏览器中有效，所以这是一个子集

00:17:57.559 --> 00:18:03.169
大多数在浏览器中操作的人关心的是什么，这是

00:18:03.169 --> 00:18:08.299
如果您想端到端地进行服务，该区域将无法很好地发挥作用，那么

00:18:08.299 --> 00:18:13.279
一堆选项，您可以在其中以某种形式使用硒

00:18:13.279 --> 00:18:18.289
选项是可以执行操作的选项

00:18:18.289 --> 00:18:21.860
对于我们想要的重量级人物，我们只想说好，我有一个图书馆

00:18:21.860 --> 00:18:25.760
我希望在某个时候处于浏览器环境中，我想断言我的

00:18:25.760 --> 00:18:33.799
测试在浏览器中运行，但是我已经在其中取得了一些成功，

00:18:33.799 --> 00:18:40.640
我会尽快将其发布并获得一些反馈，但我的计划是返回

00:18:40.640 --> 00:18:46.390
覆盖我生产的一些最新JavaScript内容，并加以改编

00:18:46.390 --> 00:18:53.870
进行了一些浏览器测试，因为例如，我知道自己更瘦了

00:18:53.870 --> 00:19:02.450
比我本来就需要大量缓冲，因为您赢得了一个数组，我们所做的很多事情

00:19:02.450 --> 00:19:06.860
需要，如果可以避免缓冲，如果可以，可以避免

00:19:06.860 --> 00:19:10.640
库负责提取缓冲区polyfill然后

00:19:10.640 --> 00:19:16.850
这是积极的，但是作为后端工程师，我只是不知道

00:19:16.850 --> 00:19:22.130
考虑一下那些我所能找到的最好的工具，

00:19:22.130 --> 00:19:25.220
只要你知道改变我的想法，那是一件好事

00:19:25.220 --> 00:19:38.450
所以是的，很酷，还有其他[音乐]

00:19:42.290 --> 00:19:54.169
你想讨论吗，所以我只是赢了一个问题，这个问题今天才出现，我

00:19:54.169 --> 00:19:58.730
在问之前需要在这里多加思考，但是我很喜欢

00:19:58.730 --> 00:20:02.090
您已经考虑过了，所以我非常想知道答案是

00:20:02.090 --> 00:20:08.299
我查看了架构文档的内容是

00:20:08.299 --> 00:20:13.340
假设结构是，所以您可以在架构中找到罢工的表现

00:20:13.340 --> 00:20:20.030
它应该认真地实现，但是如果您想将其文明化以适应不同的情况，该怎么办

00:20:20.030 --> 00:20:28.309
格式不同我为什么要问这个基本背景

00:20:28.309 --> 00:20:34.490
故事是，是的，不是，但是，嗯，我觉得很明显

00:20:34.490 --> 00:20:38.990
问题是，例如，尤其是结构

00:20:38.990 --> 00:20:46.040
所以在模式中我们有红牌，所以我称它们为繁忙的记录

00:20:46.040 --> 00:20:53.450
因此可能将它们称为结构，但在数据模型中我们没有此结构，因此

00:20:53.450 --> 00:21:00.470
数据模型，我们只有一个列表，基本上就是我们要放入的东西

00:21:00.470 --> 00:21:08.179
记录到其中，但关键是例如在Rossum接口类型中

00:21:08.179 --> 00:21:13.130
在即将到来的事物之间交换数据的标准之间

00:21:13.130 --> 00:21:19.730
基于Web IDL的健康状况，我会进一步简化它，基本上他们不会

00:21:19.730 --> 00:21:25.220
确实定义了一个地图类型，但是它们只有一个记录类型，这基本上意味着

00:21:25.220 --> 00:21:31.130
在我们的世界中，将其从被打击的模式转变为它会很奇怪

00:21:31.130 --> 00:21:39.350
进入地图然后进入列表，这样我们就可以将其用作记录类型了

00:21:39.350 --> 00:21:43.010
基本上可以直接从我们的模式进入记录时间，

00:21:43.010 --> 00:21:47.630
一切都会好起来的，但是如果您将我转移到

00:21:47.630 --> 00:21:52.700
追逐你是要使用普通的地图册，就像

00:21:52.700 --> 00:21:55.789
贝蒂在我脑海中浮现，好像是这样吗

00:21:55.789 --> 00:22:03.320
我们喜欢思考，是的，只是我们会看到一点点，我想我们可能会

00:22:03.320 --> 00:22:09.289
实际上有一个很简单的路径（即使尚未记录），因为我们

00:22:09.289 --> 00:22:16.340
可以将架构视为一个文档，我们可以进行一些转换

00:22:16.340 --> 00:22:22.940
继续，所以我想我之前曾经有过非常相似的想法

00:22:22.940 --> 00:22:26.840
做一些选择器规格的东西，我们进行了有关序列大小选择器的事情

00:22:26.840 --> 00:22:30.099
很多，但我们仍将地图用于可扩展性目的，所以我们已经

00:22:30.099 --> 00:22:34.580
将一个字段重命名为单个字符，但是那不是我的意思

00:22:34.580 --> 00:22:39.320
想看看我何时调试，所以我想你知道如果我们有一个调试

00:22:39.320 --> 00:22:43.009
采取一种模式并将其转换为另一种模式的功能，以及

00:22:43.009 --> 00:22:50.749
刚刚剥离了所有重命名指令，有趣的是，

00:22:50.749 --> 00:22:57.859
这些是表示细节，这意味着模式语义

00:22:57.859 --> 00:23:03.349
是相同的，所以我们实际上可以在同一数据上使用其中任何一个

00:23:03.349 --> 00:23:10.999
很容易，所以我认为我们可以做类似的事情来突然制作一个模式

00:23:10.999 --> 00:23:15.289
符合Wasi标准，我们可以说可以采用真实的模式

00:23:15.289 --> 00:23:19.009
我们首先编写，然后将其转换为另一个模式，其中每个

00:23:19.009 --> 00:23:23.229
struct是带注释的表示元组

00:23:24.399 --> 00:23:28.720
我没有尝试编写任何函数来做类似的事情，但这听起来

00:23:28.720 --> 00:23:33.379
就像我们可以做的事情，是的，这听起来像是

00:23:33.379 --> 00:23:40.509
如果我们将其转换为Erlang的话，方法也是相同的

00:23:40.929 --> 00:23:46.759
就像Erlang没有任何地图一样

00:23:46.759 --> 00:23:52.309
好吧，它不是那么拥有什么，它做了什么，所以这是一个巨大的问题

00:23:52.309 --> 00:23:56.720
与沙发电视，因为它是在赚钱，所以打赌他们如何做人蔡司是

00:23:56.720 --> 00:24:04.309
他们基本上有一个元组列表，其中键基本上是

00:24:04.309 --> 00:24:08.989
我可以列出两个元组，其中第一个元素是键，第二个是键

00:24:08.989 --> 00:24:14.000
一个是价值，然后是的，这就是他们的方式

00:24:14.000 --> 00:24:18.890
有一张地图，但他们是的，这更像是在法国的一点

00:24:18.890 --> 00:24:24.800
至少在内部，对您没有的世界进行编程真的很重要

00:24:24.800 --> 00:24:31.790
是一件痛苦的事，但是对于这些情况，是的，如此可惜，我想知道斯图我

00:24:31.790 --> 00:24:35.720
认为是有道理的，因为真的我想知道我们想要多紧密

00:24:35.720 --> 00:24:39.440
将表示耦合到方案MACD有点像问题

00:24:39.440 --> 00:24:46.820
或类似，但如果您可以在Ruby中使用转换，是的，我认为这是

00:24:46.820 --> 00:24:51.050
值得注意的是，我们可能还没有，但是如果您要对

00:24:51.050 --> 00:24:56.750
只按摩其表示部分的模式，然后在那儿

00:24:56.750 --> 00:25:04.150
是某些必须保留的属性，这是很酷的

00:25:04.150 --> 00:25:09.140
就像您有其他要从架构到架构的功能，

00:25:09.140 --> 00:25:14.750
它正在按摩其他一些东西，例如它正在移除或

00:25:14.750 --> 00:25:20.120
添加可为空的注释会改变行为的权利，但是如果它们是

00:25:20.120 --> 00:25:29.060
只是按摩代表性的东西，是的，嗯，再次，我们要进入

00:25:29.060 --> 00:25:34.220
我们尝试去做的各种事情都遇到麻烦

00:25:34.220 --> 00:25:40.040
到特定的环境，这就是我们要做注释和

00:25:40.040 --> 00:25:44.900
那种东西科钦是显而易见的地方，但这是

00:25:44.900 --> 00:25:52.940
实际上，Cochin基本上是您知道的，我们已经有了这个不错的层，但是

00:25:52.940 --> 00:25:55.460
当橡胶在所有这些不同的环境中击中道路时，

00:25:55.460 --> 00:25:59.360
到处都是特殊情况，我想我们可以适应很多

00:25:59.360 --> 00:26:06.080
它们具有不同的编码格式，例如想出新的东西

00:26:06.080 --> 00:26:10.430
或其他，但随后我们将不得不公开特定的规则，

00:26:10.430 --> 00:26:13.760
那就是我们在注解上会变得丑陋的地方，但是那将会是

00:26:13.760 --> 00:26:17.929
使其实用化所必需的邪恶，因为许多消费者

00:26:17.929 --> 00:26:22.610
这些东西将是他们将在特定环境中使用它

00:26:22.610 --> 00:26:24.410
所以他们都在乎他们不在乎

00:26:24.410 --> 00:26:28.760
关于这个东西可以很好地移植的事实，不，我只是想在自己的电脑上工作

00:26:28.760 --> 00:26:35.230
环境，我想要所有随之而来的好东西，是的，是的

00:26:35.230 --> 00:26:40.700
是的，很酷，非常感谢您的这次接洽

00:26:40.700 --> 00:26:45.580
像这样，所以今晚我可以睡个好觉

00:26:46.900 --> 00:26:56.170
Sybil需要冷静，还有别的吗？

00:26:56.380 --> 00:27:01.910
很酷，然后我向所有观看电视节目的成千上万的人道别

00:27:01.910 --> 00:27:08.960
直播，再见，下周见

00:27:08.960 --> 00:27:12.229
[音乐]

