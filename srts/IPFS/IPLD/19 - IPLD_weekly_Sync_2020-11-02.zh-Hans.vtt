WEBVTT
Kind: captions
Language: zh-Hans

00:00:14.400 --> 00:00:20.119
欢迎大家参加本周的ipld同步会议，即11月2日

00:00:20.119 --> 00:00:24.480
2020年，因为每周我们都会讨论

00:00:24.480 --> 00:00:28.800
我们在上周完成了工作，然后完成了我们计划的工作

00:00:28.800 --> 00:00:33.600
下周讨论开放的性别项目

00:00:33.600 --> 00:00:39.760
嗯，我从我自己开始，就像是一个重大新闻和

00:00:39.760 --> 00:00:45.039
令人欣慰的是，最终rust multi hash 0.12发布了

00:00:45.039 --> 00:00:49.440
这是包含微小的，多哈希的东西的东西，它是

00:00:49.440 --> 00:00:54.079
像几个月前一样多哈希，所以现在您可以

00:00:54.079 --> 00:00:57.680
使用rust mod代替中的微型multihash

00:00:57.680 --> 00:01:03.120
如果您已使用它，现在它不兼容标准

00:01:03.120 --> 00:01:06.560
这意味着对于那些不熟悉锈蚀的人来说，

00:01:06.560 --> 00:01:09.920
您可以在没有分配器的系统上使用它

00:01:09.920 --> 00:01:14.400
而且是的，所以它不会在堆上为该分配做任何分配

00:01:14.400 --> 00:01:19.280
多头的东西嗯，但显然有一些功能，您可以

00:01:19.280 --> 00:01:22.640
希望对此有支持，例如，如果您想加入

00:01:22.640 --> 00:01:28.400
适当的向量等等，是的，但这只是选择

00:01:28.400 --> 00:01:33.280
是的，所以这很酷，然后是iPod上的其他内容，我做了什么

00:01:33.280 --> 00:01:35.840
是关于扩展的探索报告

00:01:35.840 --> 00:01:42.720
具有更高级列表对表示形式的架构映射

00:01:42.720 --> 00:01:46.240
嗯，这与字符串讨论有关

00:01:46.240 --> 00:01:49.439
但这也很像一种单独的方式

00:01:49.439 --> 00:01:52.880
嗯，是的，我还有更多的想法

00:01:52.880 --> 00:01:56.240
这种事情，但我还是要写下来，或者想想

00:01:56.240 --> 00:02:00.479
更多，但我认为这样的人真的是

00:02:00.479 --> 00:02:04.000
我认为很有趣，因为它也给人一种与众不同的看法

00:02:04.000 --> 00:02:06.320
或像模式和数据之间的分隔

00:02:06.320 --> 00:02:09.360
模型以及它们之间的关系等等，所以我认为是的

00:02:09.360 --> 00:02:16.959
我认为这就像万一你被所有这些东西淹没了一样

00:02:16.959 --> 00:02:20.000
串起任何讨论内容，不想阅读所有我认为的内容

00:02:20.000 --> 00:02:23.120
当然，这一点甚至超出了讨论范围，值得一读

00:02:23.120 --> 00:02:26.400
所以如果您还没有读过其他任何独立的书，是的

00:02:26.400 --> 00:02:29.920
看一下[音乐]

00:02:29.920 --> 00:02:33.200
是的，这是简短版本，您可以构建

00:02:33.200 --> 00:02:36.720
像基本数据模型这样的更高层次的东西

00:02:36.720 --> 00:02:42.400
在模式中，我认为这就是我所做的一切

00:02:42.400 --> 00:02:48.239
上周，所以我名单上的下一个是丹妮尔

00:02:48.720 --> 00:02:52.560
很酷，所以本周的笔记更加冗长，因为我认为

00:02:52.560 --> 00:02:55.599
我的意思是记下我一直在做的事情对自己来说是一件好事，但同时也要

00:02:55.599 --> 00:02:59.120
从历史上看，以后我会看笔记

00:02:59.120 --> 00:03:03.200
嗯，基本上我确实完成了多编解码器

00:03:03.200 --> 00:03:06.879
上周与外部贡献者一起实施了新的实施方案

00:03:06.879 --> 00:03:10.720
但直到现在我才真正将其推入主仓库

00:03:10.720 --> 00:03:14.959
所以现在我已经取消存档该仓库，有一个拉取请求删除所有

00:03:14.959 --> 00:03:18.239
现有代码并添加新的实现代码

00:03:18.239 --> 00:03:21.680
最初将所有代码生成为go常量

00:03:21.680 --> 00:03:24.560
我们说了无类型的常量，但是现在它们确实有一个

00:03:24.560 --> 00:03:27.680
编解码器类型，可能需要称为代码我

00:03:27.680 --> 00:03:31.040
不确定输入是否欢迎，但要点全是命名

00:03:31.040 --> 00:03:34.319
类型是这样，以便我们可以使用字符串之类的方法

00:03:34.319 --> 00:03:37.040
我认为这很好，因为否则它们只是整数而您不能

00:03:37.040 --> 00:03:42.159
除非您有单独的功能，否则我们真的会对他们有很多帮助。

00:03:42.159 --> 00:03:46.560
几个更多的字符串调用主要是通过volker我知道这个话题

00:03:46.560 --> 00:03:49.440
有点过头了，但至少对我而言，加快速度很有用，因为

00:03:49.440 --> 00:03:53.439
我不是，我也被介绍给安德鲁的

00:03:53.439 --> 00:03:58.239
生态系统仪表板，所以我认为这里的重点是正确的

00:03:58.239 --> 00:04:02.799
现在我们有一些人来维护仓库和软件包等等，但是有时候

00:04:02.799 --> 00:04:04.400
事情确实跌破了裂缝并得到了

00:04:04.400 --> 00:04:07.280
仅仅因为我们有很多回购而被遗忘了

00:04:07.280 --> 00:04:10.560
所以我认为我将基本上开始关注

00:04:10.560 --> 00:04:14.000
至少每周一次左右的问题和请求请求

00:04:14.000 --> 00:04:17.600
来自我们可能已经忘记的外部人这样说

00:04:17.600 --> 00:04:21.519
几天或几天没收到我们的评论

00:04:21.519 --> 00:04:29.600
几周左右，还有更多的大麻工作，我大约一个小时前添加了

00:04:29.600 --> 00:04:32.400
如果将varex代码gen prs合并，则会添加

00:04:32.400 --> 00:04:35.280
很高兴，因为我的代码会变得更好，但是我看到其中之一

00:04:35.280 --> 00:04:40.160
已经合并，所以很好，但是我也一直在审查那些

00:04:40.160 --> 00:04:42.960
从角度来看，已经添加了更多测试

00:04:42.960 --> 00:04:46.080
api的原因，因为我希望所有内部

00:04:46.080 --> 00:04:49.280
您知道人们不会直接使用的详细信息

00:04:49.280 --> 00:04:52.960
我认为这将直接包含在规范合规性测试中

00:04:52.960 --> 00:04:57.199
仍然是本季度的优先事项，我当然是

00:04:57.199 --> 00:04:59.919
已经为完成这些任务提供了我的帮助，因为我会

00:04:59.919 --> 00:05:04.560
使用它们，我还实现了对

00:05:04.560 --> 00:05:08.639
链接加载，我知道它正在引用其他节点，但是

00:05:08.639 --> 00:05:12.000
目前有点混乱，所以我明天要发布拉取请求

00:05:12.000 --> 00:05:15.039
我的最后一件事就是明天我要去旅途中

00:05:15.039 --> 00:05:18.240
展示谈论这是一个播客

00:05:18.240 --> 00:05:20.639
谈论您可以删除哪些功能

00:05:20.639 --> 00:05:24.000
我认为这是一个有趣的话题，而不是大家都在谈论

00:05:24.000 --> 00:05:27.199
有关添加功能的信息，这样我就有了一些像您所知道的想法

00:05:27.199 --> 00:05:32.960
点导入或类似struct embedding以及我真的讨厌的东西

00:05:32.960 --> 00:05:39.840
但是如果有人有什么想法，我明天很乐意提出

00:05:40.639 --> 00:05:42.960
谢谢

00:05:43.840 --> 00:05:53.840
梅利莎的抽奖旁边

00:05:55.919 --> 00:06:04.080
文档中的链接，嗯，好吧，我觉得工作很忙很忙

00:06:04.080 --> 00:06:06.639
就像我晚上工作太晚了，然后

00:06:06.639 --> 00:06:11.280
进入我的周末很深，因为我在做专注的事情，你知道如何

00:06:11.280 --> 00:06:17.440
它进入您所在的区域，然后您将其砰然一声跳出来，我认为这是michael的

00:06:17.440 --> 00:06:21.120
周末的普通模式，我不能放手

00:06:21.120 --> 00:06:25.759
东西，无论如何，所以我正在做

00:06:25.759 --> 00:06:30.639
汽车到计划者的事情我做得很好，我没有完成，因为有

00:06:30.639 --> 00:06:36.160
在这个领域还有很多，但是我处于一种状态，我想把它带到

00:06:36.160 --> 00:06:40.240
为了这个最初的目的，例如我们可以将其推进多远

00:06:40.240 --> 00:06:44.720
功用最小的事情

00:06:44.720 --> 00:06:48.479
嗯，而没有创建一个全新的兔子洞

00:06:48.479 --> 00:06:53.199
所以这件事现在可以做这个多阶段的事情，您可以

00:06:53.199 --> 00:06:57.280
您可以在汽车文件中运行该文件，它只会在

00:06:57.280 --> 00:07:00.560
在那里用模式描述它们，然后给你一个巨大的清单，

00:07:00.560 --> 00:07:03.440
有关遇到频率的统计信息

00:07:03.440 --> 00:07:08.160
然后您也可以在其中添加一个已知模式的库，并且

00:07:08.160 --> 00:07:12.000
他们将使用已知的模式运行它，并将其添加到组合中

00:07:12.000 --> 00:07:16.400
然后，当您添加自己的架构时，您可以开始

00:07:16.400 --> 00:07:20.479
使常见的形状变得常见，例如

00:07:20.479 --> 00:07:27.280
在文件中的硬币数据中，大麻uh，因为它是可变的arity

00:07:27.280 --> 00:07:33.680
你有这些块之间，就像在1到32个元素之间

00:07:33.680 --> 00:07:36.720
数组，但是数据结构都一样，但是

00:07:36.720 --> 00:07:39.120
他们最终被描述为独立的事物，因为它不知道

00:07:39.120 --> 00:07:41.599
怎么不知道同一件事，所以一次

00:07:41.599 --> 00:07:45.840
您开始用模式描述它，然后说好吧，这实际上是一个

00:07:45.840 --> 00:07:49.520
这只是一个元素数组，可能是任何元素

00:07:49.520 --> 00:07:55.599
长度um，然后您开始将所有变化捕获到一件事情中um

00:07:55.599 --> 00:07:58.000
所以你建立一个图书馆，然后最终你

00:07:58.000 --> 00:08:03.039
您在那儿找不到任何新颖的图式，然后

00:08:03.039 --> 00:08:06.319
描述所有事情，然后就可以获取统计信息

00:08:06.319 --> 00:08:08.960
他们会出现在哪里，所以我这样做了，在下面的五个点上有一个

00:08:08.960 --> 00:08:12.400
那里还有几个其他的小巧的骇客，例如um，因为

00:08:12.400 --> 00:08:17.599
发射猎鹰数据如此之大，它可以做类似您运行它的事情

00:08:17.599 --> 00:08:20.400
在图书馆的东西上，你说

00:08:20.400 --> 00:08:25.120
您发现的任何新颖的积木都将它们放在这里的另一个汽车档案中

00:08:25.120 --> 00:08:28.800
然后您可以使用它来继续使您的

00:08:28.800 --> 00:08:32.159
新颖的汽车锉刀越来越小，因此执行这些操作的速度越来越快

00:08:32.159 --> 00:08:35.760
迭代来描述模式，因此我可以想象这是一个有趣的过程

00:08:35.760 --> 00:08:39.440
为现有模式进行模式开发的方法

00:08:39.440 --> 00:08:43.839
用于验证您已使用的架构的数据um

00:08:43.839 --> 00:08:47.200
手动编写表格，例如我要使用的表格

00:08:47.200 --> 00:08:49.680
现在返回到比特币数据，因为我处于中间

00:08:49.680 --> 00:08:53.360
比特币规格，并实际验证模式

00:08:53.360 --> 00:08:57.040
我实际上是为比特币形状手动编写的

00:08:57.040 --> 00:08:59.680
匹配哪些数据的数据变化

00:08:59.680 --> 00:09:04.480
我为此而吐口水，所以这是另一个用例，相当

00:09:04.480 --> 00:09:07.200
不错，但是有局限性，因为

00:09:07.200 --> 00:09:10.720
因为这是在没有上下文的情况下查看块，这又回到了

00:09:10.720 --> 00:09:14.000
我们一直在进行的整个上下文讨论

00:09:14.000 --> 00:09:17.600
令人着迷，我确实发现这变得如此令人着迷

00:09:17.600 --> 00:09:21.360
上下文的限制以及您需要什么上下文

00:09:21.360 --> 00:09:25.760
我们遇到的块与上下文无关，这只是一个带有cid的块

00:09:25.760 --> 00:09:30.000
嗯，是的，您可以描述形状并将其与模式匹配，

00:09:30.000 --> 00:09:36.160
到目前为止，据我所知，还没有明确的答案

00:09:36.160 --> 00:09:38.320
也许我们可以考虑一下

00:09:38.320 --> 00:09:41.680
他头顶的文件硬币里什么都没有

00:09:41.680 --> 00:09:47.760
嗯模式，很明显是冲突的，所以没有

00:09:47.760 --> 00:09:52.240
不像两个完全不同的数据结构，它们编码看起来相同

00:09:52.240 --> 00:09:55.360
所以有很多事情，比如很多

00:09:55.360 --> 00:09:59.600
其中包含两个元素的元组，但在大多数情况下，它们要么附加到

00:09:59.600 --> 00:10:01.839
其他所有这两个元素都切换了

00:10:01.839 --> 00:10:05.360
以便有字符串和字节，然后又有字符串

00:10:05.360 --> 00:10:08.800
因此，偶然地，我们拥有了所有这些独特的形式

00:10:08.800 --> 00:10:12.000
嗯，您可以在架构中遇到

00:10:12.000 --> 00:10:16.000
在文件中的块，说你知道这实际上是这个

00:10:16.000 --> 00:10:19.519
即使您切换了这些元素，这里的事情

00:10:19.519 --> 00:10:22.079
周围会有另一面的东西

00:10:22.079 --> 00:10:28.560
嗯，但是所有这些数据结构在诸如um之类的中间

00:10:28.560 --> 00:10:34.959
特别是汉普顿amt，如果您有叶子节点，然后

00:10:34.959 --> 00:10:37.680
他们存储内联值，你知道它是什么

00:10:37.680 --> 00:10:40.880
你们当中很多人都知道很多，特别是大麻

00:10:40.880 --> 00:10:45.600
um大量的节点是叶节点，因为火腿

00:10:45.600 --> 00:10:49.279
不仅有叶子层，叶子也可以是

00:10:49.279 --> 00:10:52.720
散落在其中，但是随着amt的出现，您已经一片叶子

00:10:52.720 --> 00:10:57.120
层，然后上方的所有东西都是中间空间和整个空间

00:10:57.120 --> 00:11:00.399
一切看起来都一样，所以上下文

00:11:00.399 --> 00:11:03.680
我是如何到达这个节点的？

00:11:03.680 --> 00:11:07.440
你不知道它挂了什么

00:11:07.440 --> 00:11:13.600
um so ii，如果放置cid，则不对值进行内联

00:11:13.600 --> 00:11:18.000
在数据结构中叶子的末尾，那么看起来都一样

00:11:18.000 --> 00:11:21.440
所以我有被称为的架构

00:11:21.440 --> 00:11:28.959
amt非叶或带有链接的amt，因此您可以收集这些

00:11:28.959 --> 00:11:33.040
的东西，但到目前为止，这是有限的

00:11:33.040 --> 00:11:35.680
实际上在链接处具有链接的事物的数量

00:11:35.680 --> 00:11:40.399
结构是一致的，但是如果我们要鼓励它们的话

00:11:40.399 --> 00:11:44.399
将它们链接起来，而不是将它们排队到安全的搅动中，那可能会

00:11:44.399 --> 00:11:48.399
那样走下去会加剧

00:11:48.399 --> 00:11:52.959
因此理想状态位于您可以喜欢的位置，这对于架构很有帮助

00:11:52.959 --> 00:11:56.079
创作并固定一切

00:11:56.079 --> 00:12:00.560
但是要进一步进行分析，您确实确实需要随机访问

00:12:00.560 --> 00:12:05.279
像您这样的块需要在块存储中实际运行的这些东西

00:12:05.279 --> 00:12:09.279
查询他们，然后建立那个链，并连接到一些

00:12:09.279 --> 00:12:12.800
迈克尔在将这些资料放入您的数据存储区中所做的工作

00:12:12.800 --> 00:12:15.839
可以实际从中检索到的东西，我认为这将是

00:12:15.839 --> 00:12:20.160
使用graphql um的东西来描述这些

00:12:20.160 --> 00:12:24.880
连接，而且我认为那是非常重要的工作

00:12:24.880 --> 00:12:31.360
对我们来说是要找出

00:12:31.360 --> 00:12:35.519
上下文与这些块一起工作的方式以及我们如何

00:12:35.519 --> 00:12:39.440
以不昂贵的方式将其构建到我们的工具中

00:12:39.440 --> 00:12:44.240
因为您知道我们在谈论时就像是400场演出的汽车档案

00:12:44.240 --> 00:12:47.760
而你想做的背景下，你知道刚变得失控

00:12:47.760 --> 00:12:53.360
所以嗯，无论如何，那是很多有趣的工作

00:12:53.360 --> 00:12:57.760
其他途径，嗯，我认为远投币团队会喜欢

00:12:57.760 --> 00:13:01.360
现在回答，我看到Farcoin团队继续前进

00:13:01.360 --> 00:13:04.480
只是他们认为不错的优化

00:13:04.480 --> 00:13:07.839
就像史蒂文目前正在扩大

00:13:07.839 --> 00:13:13.760
我们每个人都认为这是很好的，但是我不知道

00:13:13.760 --> 00:13:18.240
认为有人知道应该有多宽，而且有一个整体

00:13:18.240 --> 00:13:21.680
关于amt的很多问题，我们对此没有答案

00:13:21.680 --> 00:13:25.200
那种数据应该能够提供喜欢的答案

00:13:25.200 --> 00:13:28.560
我和迈克尔讨论过的一件事是拿出

00:13:28.560 --> 00:13:33.120
所有这些数据结构中的值变成一个单独的东西

00:13:33.120 --> 00:13:36.720
甚至订购他们在链中编辑过的操作

00:13:36.720 --> 00:13:39.680
因为这是实时数据，所以如果您可以提取所有值并

00:13:39.680 --> 00:13:43.680
所有的变种都会记录下来，然后与其他人一起播放

00:13:43.680 --> 00:13:46.800
数据结构或数据结构中的变化，您可以回答所有问题

00:13:46.800 --> 00:13:49.839
这些问题，您可能会说，如果

00:13:49.839 --> 00:13:53.279
你增加宽度，这是那种

00:13:53.279 --> 00:13:56.399
如果将它换成其他数据结构，则可以节省成本

00:13:56.399 --> 00:13:59.920
那样的话那是高价值的工作

00:13:59.920 --> 00:14:03.040
嗯，在某个时候会很好

00:14:03.040 --> 00:14:08.560
很快，但嗯，我现在还不是我清单上的第二项

00:14:08.560 --> 00:14:12.480
是我要备份到我真的必须关闭其中一些

00:14:12.480 --> 00:14:15.199
我留下来的东西我留下了一些公开工作的痕迹

00:14:15.199 --> 00:14:20.160
和嗯，我必须将它们关闭，所以我下周我去了

00:14:20.160 --> 00:14:25.279
回到我的汽车工作和嗯

00:14:25.279 --> 00:14:28.560
其中的一部分是设计一个新的街机故事jpi

00:14:28.560 --> 00:14:32.399
可能会与其他JavaScript共同共享

00:14:32.399 --> 00:14:37.279
块存储系统，所以在这方面只有一些设计工作，以及如何

00:14:37.279 --> 00:14:40.320
我们可以考虑一下如何提取一些

00:14:40.320 --> 00:14:44.240
就像使用这个数据存储区api一样可怕，因为他只是

00:14:44.240 --> 00:14:50.480
格式过多，但是这个新的抽象

00:14:50.480 --> 00:14:54.160
gazala帮助我真正实现了功能分解

00:14:54.160 --> 00:14:58.000
功能，这样您就可以解决这些存储结构

00:14:58.000 --> 00:15:01.760
在中获取所需的特定功能

00:15:01.760 --> 00:15:05.519
嗯，所以如果您需要随机访问，例如

00:15:05.519 --> 00:15:08.800
那么可以使用随机块，但是如果您只需要迭代

00:15:08.800 --> 00:15:12.160
在它上面，然后您可以将其作为迭代器加载，然后说我只想要我只想要

00:15:12.160 --> 00:15:15.760
所有的我都想看看里面有什么，甚至我只想看所有的CD。

00:15:15.760 --> 00:15:18.959
那是另一回事，你可以说这是我的车

00:15:18.959 --> 00:15:23.519
您提供的任何形式的数据，无论是作为二进制blob还是作为

00:15:23.519 --> 00:15:26.959
流或任何给我所有的线索，然后你就

00:15:26.959 --> 00:15:30.959
得到一个迭代器，这样就可以将其分解为这些单独的函数

00:15:30.959 --> 00:15:35.040
与api的功能分开，足以使您可以加载

00:15:35.040 --> 00:15:37.920
他们分开，只得到代码路径

00:15:37.920 --> 00:15:43.440
在您的捆绑包中，需要那个um以及与此相关的方式

00:15:43.440 --> 00:15:46.800
我花了一半的时间学习如何包括

00:15:46.800 --> 00:15:51.759
我的代码和构建步骤中的打字稿注释

00:15:51.759 --> 00:15:55.279
嗯，你知道这意味着要真正掌握更多

00:15:55.279 --> 00:15:59.680
打字稿和嗯，我一直在做那一阵子

00:15:59.680 --> 00:16:03.120
嗯，事实证明真是太好了，它比我想象的要少得多

00:16:03.120 --> 00:16:07.040
和嗯，它在构建过程中增加了一个非常不错的棉绒步骤

00:16:07.040 --> 00:16:10.639
所以你有棉绒但有结构棉绒

00:16:10.639 --> 00:16:14.480
可以合法化，就像它在合法地发现错误一样

00:16:14.480 --> 00:16:18.480
太棒了，所以我不用去就可以得到类型的好处

00:16:18.480 --> 00:16:21.759
完整的打字稿，所以它只是带有打字稿的普通javascript

00:16:21.759 --> 00:16:25.680
注释和一些，并使用打字稿来描述api

00:16:25.680 --> 00:16:28.480
嗯，所以文档中有一个链接

00:16:28.480 --> 00:16:32.240
例如外部API打字稿

00:16:32.240 --> 00:16:39.279
并非如此的doc并没有被用作代码的核心部分，而是

00:16:39.279 --> 00:16:42.560
导出并用于验证所有代码

00:16:42.560 --> 00:16:44.800
整个过程中的路径，包括测试

00:16:44.800 --> 00:16:51.120
所以嗯，我对此感到满意，嗯，我会继续这样做，但是

00:16:51.120 --> 00:16:54.240
这辆车的东西已经差不多完成了，我只需要为它写文件就可以了，

00:16:54.240 --> 00:16:58.480
然后发布，然后我可以将其打勾

00:16:58.480 --> 00:17:02.720
无论如何，我很抱歉花了太多时间

00:17:02.720 --> 00:17:06.640
谢谢，下一个是彼得

00:17:06.959 --> 00:17:10.240
对，所以我实际上不知道我的一周去了哪里

00:17:10.240 --> 00:17:16.880
嗯，非常对iplt重要的事情

00:17:16.880 --> 00:17:21.439
实际与抢劫案有关的几点

00:17:21.439 --> 00:17:25.439
呃，如果我设法让莲花打球

00:17:25.439 --> 00:17:28.079
有很多严格的嵌入方式，例如无需一定下注

00:17:28.079 --> 00:17:31.520
这根本不可能，因为我基本上需要

00:17:31.520 --> 00:17:34.880
将一个接口分成三个单独的接口

00:17:34.880 --> 00:17:38.640
同时仍让您知道而无需更改吨

00:17:38.640 --> 00:17:42.160
像这样的代码块存储接口特定的代码

00:17:42.160 --> 00:17:46.720
电机在350到400个站点中使用，并且

00:17:46.720 --> 00:17:49.600
我需要将它们分开而不需要走到世界的右边，所以

00:17:49.600 --> 00:17:54.320
那不是很好，但是嗯，如果一切正常

00:17:54.320 --> 00:17:58.080
您将有权使用

00:17:58.559 --> 00:18:02.640
该块存储中的各个块实际上可以知道并发

00:18:02.640 --> 00:18:07.120
密钥源以s开头，以3结尾

00:18:07.120 --> 00:18:13.679
嗯，这本质上是唯一可以保留我们所有内容的东西

00:18:13.679 --> 00:18:16.480
现在需要大规模，是的，我们仍然需要

00:18:16.480 --> 00:18:24.320
简历以找出一些方法来做，让您知道非aws托管博客

00:18:24.320 --> 00:18:27.679
商店，但以我们要去的规模

00:18:27.679 --> 00:18:32.080
不可能在一台机器上完成任何一项操作

00:18:32.080 --> 00:18:36.240
即使你把所有这些都放进去很快

00:18:36.240 --> 00:18:41.600
进入没有dht提供程序的ipfs，就知道我有这个

00:18:41.600 --> 00:18:47.679
即使只是按比例存储块，

00:18:47.679 --> 00:18:50.880
我们需要不能在单个ipfs实例上执行此操作

00:18:50.880 --> 00:18:54.840
不再是因为电池和其他限制，所以

00:18:54.840 --> 00:18:59.919
嗯，这是一件很棒的事情，您知道要得到我们的

00:18:59.919 --> 00:19:04.559
数据存储了更多的性能，但我们基本上需要像

00:19:04.559 --> 00:19:09.600
10 200 x改进，嗯，直到那时，基本上会发生什么

00:19:09.600 --> 00:19:16.240
链条将主要迁移到s3，嗯，这是

00:19:16.240 --> 00:19:21.280
应该有一种方法可以使莲花从中引导

00:19:21.280 --> 00:19:27.840
我们有一种单独的方式喂它，我们假设当前的扬程是多少

00:19:27.840 --> 00:19:30.080
是正确的，如果有人要你知道

00:19:30.080 --> 00:19:34.480
从起源一直走遍整个uh链

00:19:34.480 --> 00:19:37.600
他们仍然可以这样做，因为嗯，块存储是博客存储它

00:19:37.600 --> 00:19:41.280
您是否不知道从哪里获得哈希表中的内容也没关系

00:19:41.280 --> 00:19:44.000
将会匹配，我们会通知您进行验证

00:19:44.000 --> 00:19:48.160
一切都很好，是的，那是我一直在尝试做的

00:19:48.160 --> 00:19:52.480
自星期五以来在这里，它正在打电话但不是

00:19:52.480 --> 00:19:57.520
很好，因为就像我们的块存储抽象一样

00:19:57.520 --> 00:20:01.600
糟糕，这不像我们的商店抽象那么糟糕

00:20:01.600 --> 00:20:07.840
特别是在戈兰高地，但他们都是

00:20:08.400 --> 00:20:12.640
在某些时候，我们需要设计一些东西

00:20:12.640 --> 00:20:16.240
牢记工作，几乎我们现在无所作为

00:20:16.240 --> 00:20:19.360
在存储方面，例如

00:20:19.360 --> 00:20:23.760
最简单的事情，你能够gc

00:20:23.760 --> 00:20:26.799
为此，理想情况下，您尤其需要了解税收

00:20:26.799 --> 00:20:30.080
能够参考搜寻以进行参考计数

00:20:30.080 --> 00:20:35.760
您需要知道一个块，您刚刚存储了它还有哪些其他链接

00:20:35.760 --> 00:20:38.640
如果您今天想这样做，那么基本上您可以在博客商店中

00:20:38.640 --> 00:20:41.200
必须解析每个块并拉出链接，这很疯狂

00:20:41.200 --> 00:20:44.480
取而代之的是，我们将有一个界面，像嘿存储这个博客和那些

00:20:44.480 --> 00:20:46.080
顺便说一句，它所指的链接

00:20:46.080 --> 00:20:49.280
从那以后，您不必做任何事情，而是因为

00:20:49.280 --> 00:20:51.919
我们建立的界面是不可能的

00:20:51.919 --> 00:20:55.200
呃，还有像您知道的事情，我们已经讨论过了

00:20:55.200 --> 00:20:59.360
求和您在每个区块中的枚举

00:20:59.360 --> 00:21:06.240
在商店中，而且放置接口的工作方式也是

00:21:06.240 --> 00:21:11.440
批处理很奇怪，所以是的

00:21:11.440 --> 00:21:15.280
是的，那里有迷你小，但我们可能需要提出更好的建议

00:21:15.280 --> 00:21:18.559
做事的方式呃，因为是的，我们现在所拥有的

00:21:18.559 --> 00:21:22.400
只是没有规模，我们可能会得到很多

00:21:22.400 --> 00:21:26.799
在镜头世界中也有这样的经历

00:21:26.799 --> 00:21:30.960
是的，我几乎只供参考

00:21:30.960 --> 00:21:35.520
um仅供参考，dagdb具有您刚才谈到的索引

00:21:35.520 --> 00:21:38.640
um db有其自己的块存储抽象和

00:21:38.640 --> 00:21:42.880
每次您编写一个块时它都会索引，它会写入所有往返链接

00:21:42.880 --> 00:21:46.559
在那个方块中，这样您就可以随时检查我们将其用于

00:21:46.559 --> 00:21:50.320
高效的图形同步，因此您可以判断是否有完整的图形

00:21:50.320 --> 00:21:53.760
嗯，真的很容易，但是嗯，您也可以将其用于gc

00:21:53.760 --> 00:21:59.840
嗯，这是它的目的之一，但是您能直觉链接吗？

00:21:59.840 --> 00:22:03.520
您自己或api要求您提供

00:22:03.520 --> 00:22:07.600
这是一个块，这是链接，不，不，当您编写一个看它的块时

00:22:07.600 --> 00:22:10.159
长度，然后将其写在那些索引处

00:22:10.159 --> 00:22:14.960
就像从字面上看一样，是的，但是它本身会解析块吗

00:22:14.960 --> 00:22:20.080
或者您将解析的链接基本提供给您

00:22:20.080 --> 00:22:22.159
有你必须了解的猎鹰问题

00:22:22.159 --> 00:22:25.760
所有被写入其中或只是不透明的东西，您

00:22:25.760 --> 00:22:28.559
只是说这是区块，这是该区块所指的链接

00:22:28.559 --> 00:22:33.679
嗯，我认为我可以解析它们

00:22:33.679 --> 00:22:35.919
因为它适用于完整的块实例，所以

00:22:35.919 --> 00:22:41.360
如果他们已经解码，那么他们已经有缓存的um解码，

00:22:41.360 --> 00:22:46.400
我认为我认为它只是读取链接，不会占用链接

00:22:46.799 --> 00:22:49.520
是的，这并不能阻止他们，因为就像您再次写信给和

00:22:49.520 --> 00:22:52.320
因此，每个要写入的新块都有

00:22:52.320 --> 00:22:54.880
往返，因此您始终可以查找一个街区，

00:22:54.880 --> 00:22:58.000
知道作为结果写入的所有块

00:22:58.000 --> 00:23:01.200
或那里的所有参考块，这就是重点

00:23:01.200 --> 00:23:05.200
做往返，这样你就可以了，是的，但是在你的情况下

00:23:05.200 --> 00:23:07.600
你也有你也有代码稳定吗

00:23:07.600 --> 00:23:10.400
你不会像随机的随机块那样

00:23:10.400 --> 00:23:13.440
不知道如何删除链接，所以也有

00:23:13.440 --> 00:23:16.640
哦，是的，我知道那是真的，是的

00:23:16.640 --> 00:23:19.919
他们都是灵巧的，因为这个数据库

00:23:19.919 --> 00:23:23.840
做出决定

00:23:24.159 --> 00:23:27.840
好吧，下一个是埃里克

00:23:30.080 --> 00:23:35.120
这个星期我有很多激动人心的东西，所以我坐下来做了代码

00:23:35.120 --> 00:23:40.000
耶和去ipld总理cogen基本上得到了一吨

00:23:40.000 --> 00:23:45.360
其中的一些新功能仍处于草稿形式，但它们非常令人兴奋

00:23:45.360 --> 00:23:49.279
易于使用的一些小物件可用于代码生成

00:23:49.279 --> 00:23:53.120
例如，地图和列表生成了一堆更多类型化的迭代器，因此，如果

00:23:53.120 --> 00:23:55.360
你一直在使用一些余热阿尔法

00:23:55.360 --> 00:23:58.559
而且您认为感觉好像那里缺少一些东西，会让您

00:23:58.559 --> 00:24:02.720
代码少吸你是对的，它现在在那里

00:24:02.720 --> 00:24:05.679
重新运行你的一代，你应该拥有更好的东西

00:24:05.679 --> 00:24:10.159
嗯，我在尝试原型编写一些更大的东西时遇到了这些问题

00:24:10.159 --> 00:24:13.840
我自己使用模式cogent输出和

00:24:13.840 --> 00:24:17.679
很明显，我们需要更多这些方法，所以

00:24:17.679 --> 00:24:21.679
就像一旦拥有um一样，您就会知道本机类型系统

00:24:21.679 --> 00:24:24.400
您所持有的东西应该能够遍历

00:24:24.400 --> 00:24:26.880
这些数据结构，并继续知道

00:24:26.880 --> 00:24:30.080
后续事物的本机类型是什么

00:24:30.080 --> 00:24:33.679
以前一堆类似的迭代器抛弃了它，然后去了

00:24:33.679 --> 00:24:37.120
过于通用的节点接口，现在有替代方法

00:24:37.120 --> 00:24:39.840
向您提供具体信息，这些是

00:24:39.840 --> 00:24:43.360
更容易使用，它们可能会更快，因为编译器可以内联

00:24:43.360 --> 00:24:47.760
他们周围的事物会自动完成，您会知道

00:24:47.760 --> 00:24:52.080
很好，还有另一个关于

00:24:52.080 --> 00:24:56.480
重新排列令人信服的输出，因此当前代码生成器会吐出一个

00:24:56.480 --> 00:25:02.320
模式中每种类型的文件，这是

00:25:02.320 --> 00:25:05.440
这种方法有点可怕，因为

00:25:05.440 --> 00:25:08.640
除其他外，这意味着如果您进行再生

00:25:08.640 --> 00:25:13.200
而且您已经更改了某些类型的名称，因此不会清除旧的

00:25:13.200 --> 00:25:18.080
文件，所以现在它生成一个有限数量的文件，因此您不必担心

00:25:18.080 --> 00:25:21.840
关于我们可能会迭代的确切布局

00:25:21.840 --> 00:25:25.200
这些文件，但基本上达到有限数量是

00:25:25.200 --> 00:25:34.000
大大提高了可用性，所以真正令人兴奋的是

00:25:34.000 --> 00:25:39.360
我们现在有一个用于此的模式类型的草稿

00:25:39.360 --> 00:25:44.000
去图书馆了解模式类型系统

00:25:44.000 --> 00:25:47.919
现在重新实现了它们，它们以前是占位符，如果

00:25:47.919 --> 00:25:51.360
您想使用任何架构系统，而您必须使用这个非常简陋的系统

00:25:51.360 --> 00:25:54.159
临时占位符集生成器方法

00:25:54.159 --> 00:25:58.640
而不是像ipld模式一样输入模式信息

00:25:58.640 --> 00:26:01.600
我们非常努力的格式，使得它可以像json等一样访问

00:26:01.600 --> 00:26:04.880
而不是使用任何这些，您必须将这些简陋的称呼为

00:26:04.880 --> 00:26:10.159
占位符消失在箱子里的方法

00:26:10.159 --> 00:26:13.919
现在我们重新实现了这些模式类型的草案

00:26:13.919 --> 00:26:18.559
使用schema模式代码gen生成与数据匹配的类型

00:26:18.559 --> 00:26:21.840
模型，因此现在您可以连接任何ipld编解码器

00:26:21.840 --> 00:26:24.880
到模式模式的那些代码生成输出

00:26:24.880 --> 00:26:33.039
它将匹配并识别模式dm dmt数据模型树

00:26:33.039 --> 00:26:37.760
现在您可以将其解析为完全批准的架构

00:26:37.760 --> 00:26:43.120
该库的其余部分使用的系统，因此我们可以将其粘到余热

00:26:43.120 --> 00:26:46.080
胶合解码部分仍然有些草稿，但它可能会

00:26:46.080 --> 00:26:49.279
在接下来的一两周内就要出来了

00:26:49.279 --> 00:26:53.440
所以这甚至在粘上热电之前就变得非常酷

00:26:53.440 --> 00:26:57.279
所以它比现有的东西有更多的测试，所以现在我们可以

00:26:57.279 --> 00:27:00.080
像我这样写有json的测试的东西

00:27:00.080 --> 00:27:05.200
模式文档，可以对其进行解析

00:27:05.200 --> 00:27:10.400
它进入模式类型，如果您在

00:27:10.400 --> 00:27:13.679
看着它，顺便说一下，有一个名为schema dmt的软件包

00:27:13.679 --> 00:27:19.760
所以dmt再次是数据模型树的缩写，而ast是抽象的

00:27:19.760 --> 00:27:23.279
语法树在概念上是相同的，但是没有语法附件

00:27:23.279 --> 00:27:26.640
因为您可以选择任何ipld编解码器

00:27:26.640 --> 00:27:30.640
因此，当您将事物处理到模式dmt中时，您已经匹配了

00:27:30.640 --> 00:27:35.200
模式对我对自我托管的系统如何自我引用表示歉意

00:27:35.200 --> 00:27:39.520
嗯，所以一旦你有了这些数据，你就会知道

00:27:39.520 --> 00:27:41.919
它与架构的结构相匹配

00:27:41.919 --> 00:27:46.559
然后您可以将其解析为完整类型的系统

00:27:46.559 --> 00:27:50.080
引用和它们之间的区别是处理数据的引用

00:27:50.080 --> 00:27:53.360
模型树，您只能在

00:27:53.360 --> 00:27:56.880
您可以检查它是结构上正确的信息，但是

00:27:56.880 --> 00:27:59.919
还有一些我们想要的其他属性

00:27:59.919 --> 00:28:03.440
我们应该验证整个类型系统是否完整，

00:28:03.440 --> 00:28:06.960
实际引用其他类型的类型

00:28:06.960 --> 00:28:12.320
它必须是一个已连接的图，并且验证图的连通性是

00:28:12.320 --> 00:28:15.200
潜在的计算昂贵的操作权

00:28:15.200 --> 00:28:18.720
所以我们不会让模式系统独自做到这一点

00:28:18.720 --> 00:28:22.320
第二个程序包在处理它时验证了它

00:28:22.320 --> 00:28:25.679
所以当你坚持下去的时候

00:28:25.679 --> 00:28:28.799
所有这些东西都经过验证，然后其余的go库使用

00:28:28.799 --> 00:28:32.080
经过充分验证的东西

00:28:32.720 --> 00:28:37.039
因此存在从json一直到经过充分验证的事物的测试

00:28:37.039 --> 00:28:40.559
一些测试检查是否正常工作一些测试检查是否正常工作

00:28:40.559 --> 00:28:44.240
不起作用，它会返回合理的错误消息

00:28:44.240 --> 00:28:48.799
现在，这包括所有验证规则

00:28:48.799 --> 00:28:52.159
以前从未实现过，所以这很重要

00:28:52.159 --> 00:28:54.880
我希望Rod可以与他们一起回顾其中的一些

00:28:54.880 --> 00:28:58.720
我，因为我知道我们之前已经讨论过很多这样的事情，所以现在我终于

00:28:58.720 --> 00:29:02.960
实施了它们，所以像验证规则之类的小验证规则

00:29:02.960 --> 00:29:05.679
包含结构作为成员的内联

00:29:05.679 --> 00:29:09.120
可以这么说，它真的应该在编译时检查

00:29:09.120 --> 00:29:12.320
内联并集判别键不应与任何

00:29:12.320 --> 00:29:16.320
表示形式中的结构字段名称

00:29:16.320 --> 00:29:19.520
是的，所以我们没有工具

00:29:19.520 --> 00:29:23.600
在我们做之前验证一下

00:29:23.760 --> 00:29:27.039
我不知道有多少条规则我实际上应该

00:29:27.039 --> 00:29:29.840
算有几十条这样的小规则

00:29:29.840 --> 00:29:32.720
这些是以前如果要编写架构的地方

00:29:32.720 --> 00:29:35.360
仔细阅读规格并确保

00:29:35.360 --> 00:29:38.080
你没有搞砸，现在我们终于开始拥有

00:29:38.080 --> 00:29:40.960
自动化工具来识别这些东西，所以这是

00:29:40.960 --> 00:29:44.000
将会是巨大的

00:29:44.080 --> 00:29:47.840
这仍然只连接到json解析

00:29:47.840 --> 00:29:52.159
但是我们已经有其他工具，它们来自架构dsl语言

00:29:52.159 --> 00:29:57.039
到json，所以我们很快就能连接

00:29:57.039 --> 00:30:02.480
在外壳中带有竖线字符的那些，然后我们将进行模式验证

00:30:02.480 --> 00:30:07.200
可以使用完整dsl的工具将应用所有验证规则，我们

00:30:07.200 --> 00:30:11.840
我们已经准备好以我们可以输入ci或

00:30:11.840 --> 00:30:14.880
其他人想把这个自动化工具放到哪里

00:30:14.880 --> 00:30:18.320
所以这将是一个巨大的可用性解锁

00:30:18.320 --> 00:30:21.679
一整套的东西我很高兴能做到这一点

00:30:21.679 --> 00:30:26.399
现在很快它还没有插入CLI，但是

00:30:26.399 --> 00:30:30.799
很快，当我为所有人编写更新时，我应该说我们的go代码

00:30:30.799 --> 00:30:37.840
在dmt上

00:30:38.559 --> 00:30:45.200
你的话不是我的，不是，那是dmt丰富了

00:30:47.600 --> 00:30:52.960
我在完整记录中已经说过很多次了，我不好称呼事物

00:30:52.960 --> 00:30:56.799
而且我们也有很多次谈论我们如何

00:30:56.799 --> 00:31:04.080
这些结构几乎像个屁股，但不是带有s

00:31:04.080 --> 00:31:07.919
通过化学方法更好地阻止建筑

00:31:10.080 --> 00:31:13.200
我完全愿意完全否认我们正在谈论的一切

00:31:13.200 --> 00:31:16.960
永远是，我认为这是一个好名字

00:31:17.360 --> 00:31:23.279
所以说不，那不是真正的名字，我不能开赛格威的笑话

00:31:23.279 --> 00:31:26.880
嗯，我也有另外一个来宾，像沃尔克这样的琴弦提到我们

00:31:26.880 --> 00:31:31.679
可能所有人都对此感到厌倦，但是嘿，这是一个链接

00:31:31.679 --> 00:31:36.000
此撰写仍主要围绕该数据的命题存在

00:31:36.000 --> 00:31:40.320
我们实际上将要做什么呢，对此我们有了一些新的建议

00:31:40.320 --> 00:31:43.760
嗯，杰里米实际上进来并确保

00:31:43.760 --> 00:31:49.760
我们查看了ipfs实际执行的操作，这可能很重要

00:31:49.760 --> 00:31:53.840
因此，实际上已经完成的工作确实是

00:31:53.840 --> 00:32:00.240
有趣，因此在悬崖笔记中可以使用ipfs add与

00:32:00.240 --> 00:32:03.279
任何文件名当然意味着任何文件名

00:32:03.279 --> 00:32:08.559
字节的任何序列都不一定是utf-8，甚至不一定是unicode，位于

00:32:08.559 --> 00:32:13.600
所有人都如此疯狂地测试了一下，并且有一个链接

00:32:13.600 --> 00:32:18.240
到这里的ipfs Web网关，这也是结果

00:32:18.240 --> 00:32:23.600
结果证明dagp编解码器存储了我们给它的字节，所以这

00:32:23.600 --> 00:32:26.559
起作用，有趣的是注意到dag

00:32:26.559 --> 00:32:31.679
 pb编解码器将其记录为字符串um

00:32:31.679 --> 00:32:36.799
 protobuf规范文件说的是字符串，但很明显，实际上

00:32:36.799 --> 00:32:39.679
支持范围是一个完整的字节序列，不限于

00:32:39.679 --> 00:32:43.440
unicode上有一条评论说可能是字面上的

00:32:43.440 --> 00:32:47.600
字符串和字节之间没有区别

00:32:47.600 --> 00:32:54.840
是的，所以很有趣，Web网关在很大程度上可以处理此问题

00:32:54.840 --> 00:32:58.000
正确地，除了一些我会知道的例外

00:32:58.000 --> 00:33:02.399
稍等片刻，以便在Web网关中的链接中添加网址，例如

00:33:02.399 --> 00:33:06.960
目录和东西，这些都是完全精确的，它们会丢失

00:33:06.960 --> 00:33:10.720
他们没有使用转义序列的字节

00:33:10.720 --> 00:33:13.840
非unicode会使用基于百分比的转义符结束

00:33:13.840 --> 00:33:18.399
对于url来说是正常的，并且显然可以处理整个范围的

00:33:18.399 --> 00:33:21.679
数据，因此所有文件中的所有数据如果

00:33:21.679 --> 00:33:25.600
您可以通过以下链接访问整个目录树：

00:33:25.600 --> 00:33:30.080
 Web网关，就像任何东西一样，是通用的

00:33:30.080 --> 00:33:34.480
直接使用dag pv数据通常可以正确处理问题

00:33:34.480 --> 00:33:38.640
因为它获取了原始数据，所以它可以正常工作，因此Web网关是其中之一

00:33:38.640 --> 00:33:42.000
安装子系统也可以正常工作的示例

00:33:42.000 --> 00:33:44.559
会带给您完整的任意文件

00:33:44.559 --> 00:33:48.720
名称，但并非一切正常，这里是

00:33:48.720 --> 00:33:53.600
我前面提到过的dag json编解码器确实在

00:33:53.600 --> 00:33:58.399
某些ipfs api的ap当前为

00:33:58.399 --> 00:34:04.240
实现有损，因此我们现在有此演示链接到网络上

00:34:04.240 --> 00:34:10.320
网关确实表现出这种行为，在某些情况下，

00:34:10.320 --> 00:34:14.879
数据在dag json编解码器中被编码为字符串

00:34:14.879 --> 00:34:19.760
我确切地知道这个错误在哪里，我自己写了，对此我不满意。

00:34:19.760 --> 00:34:23.520
有时会替换那些无效的utf-8字节

00:34:23.520 --> 00:34:30.079
用斜线u fffd逃逸序列或

00:34:30.079 --> 00:34:35.119
用字节替换它用字节替换它

00:34:35.119 --> 00:34:39.040
所以这是有损的，它会丢弃字节

00:34:39.040 --> 00:34:44.720
因此，但这仅在某些地方显示，而我还没有完全追踪到

00:34:44.720 --> 00:34:47.760
Web网关如何达到此状态，但是我可以在末尾观察到

00:34:47.760 --> 00:34:50.159
链接是正确的，哪一天是正确的

00:34:50.159 --> 00:34:55.280
使用网址转义和百分比，但呈现的文件名不是

00:34:55.280 --> 00:35:00.839
正确，它们会很好地呈现，但是您的浏览器会呈现出来

00:35:00.839 --> 00:35:06.640
我认为是错误um的代码

00:35:06.640 --> 00:35:10.320
这很烂，我们应该修复dag json代码库以逃避这些事情

00:35:10.320 --> 00:35:13.440
并不会丢掉数据

00:35:14.240 --> 00:35:18.320
因此，在继续之前，我想指出的一件事就像

00:35:18.320 --> 00:35:21.599
令人印象深刻的是，所有这些东西都通过了

00:35:21.599 --> 00:35:25.040
像所有转义一样的网关实际上使它一直都变得像

00:35:25.040 --> 00:35:29.680
他们的触发解释嗯，我们聊了很多

00:35:29.680 --> 00:35:34.880
做一个路径规范，这样使我非常有信心，我们应该

00:35:34.880 --> 00:35:37.760
不写回去的路，然后我们应该指向伯爵回传

00:35:37.760 --> 00:35:40.960
因为那样我们就拥有所有相同的转义规则，

00:35:40.960 --> 00:35:43.920
我们不担心人们喜欢不在网关中实现它们，然后

00:35:43.920 --> 00:35:47.680
所有其他这些都像在层之间，所以我们可以只使用伯爵路径，然后

00:35:47.680 --> 00:35:49.839
我们可以编写有关如何解释它们的规范

00:35:49.839 --> 00:35:53.040
当您处于数据模型中时，如何在不同的情况下对它们进行解释

00:35:53.040 --> 00:35:56.240
像这样的库就是我们的解释方式

00:35:56.240 --> 00:36:01.119
是的，我基本上是赞成所有这些

00:36:01.119 --> 00:36:04.400
这是有人逃离的百分比

00:36:04.400 --> 00:36:07.599
定义我说实话再也没有看过

00:36:07.599 --> 00:36:10.320
远比这深远，除了它显然有效

00:36:10.320 --> 00:36:13.280
嗯，每种语言都有一个解析器，就像每种语言都有一个

00:36:13.280 --> 00:36:16.640
伯爵和伯爵路径的解析器，我们曾经遇到过的一切

00:36:16.640 --> 00:36:21.839
进入伯爵，我们的道路已经开始运作，就像我们只用它一样

00:36:23.680 --> 00:36:26.960
是的，那就是我要说的

00:36:26.960 --> 00:36:30.240
我认为以弄清楚我们正在做什么的形式继续进行此对话

00:36:30.240 --> 00:36:33.200
遵循路径规范也是前进的好方法

00:36:33.200 --> 00:36:38.400
所以我同意这对我来说，得到道格真的很好

00:36:38.400 --> 00:36:41.599
杰森（Jason）在道格（Doug）杰森（Jason）中得到了很多积分

00:36:41.599 --> 00:36:44.960
没有解决，我在测试夹具中越来越多地使用杰森

00:36:44.960 --> 00:36:48.880
相关的东西和嗯，这确实是一个真正的问题

00:36:48.880 --> 00:36:52.800
语言之间不一致，甚至内部不一致，所以

00:36:52.800 --> 00:36:56.480
喜欢把那个完全敲出来

00:36:57.200 --> 00:37:00.560
在我再次忘记它之前，我从来没有写下来，我真的

00:37:00.560 --> 00:37:03.839
我是否应该意识到还有另一个错误

00:37:03.839 --> 00:37:08.079
dag json在此过程中的精度

00:37:08.079 --> 00:37:14.079
json与utf-8字节一样支持utf-8字节，因此您可以拥有

00:37:14.079 --> 00:37:20.839
任何字符，它都支持您转义的斜杠

00:37:20.839 --> 00:37:26.480
序列，因此我们的编解码器不会保留

00:37:26.480 --> 00:37:30.160
至少我没有区别，所以我们应该

00:37:30.160 --> 00:37:33.520
对此也增加了严格性，我们可能实际上应该在我的

00:37:33.520 --> 00:37:36.400
意见禁止斜线逃脱和dag json

00:37:36.400 --> 00:37:38.800
因为

00:37:40.079 --> 00:37:45.760
所以更多的规格工作是的，哦，人们正在做一些鬼脸

00:37:45.760 --> 00:37:49.920
我知道我实际上对此提出了一个问题

00:37:49.920 --> 00:37:52.800
几周前，这基本上是关于弦乐和舞曲的

00:37:52.800 --> 00:37:56.240
json，您可以通过多种方式对它们进行编码，并且没有一致性，因此我们应该

00:37:56.240 --> 00:38:01.520
有一个规则，我可以在一秒钟内将其链接

00:38:01.680 --> 00:38:06.240
抱歉，没有看到是的，您非常正确

00:38:09.760 --> 00:38:14.400
好吧，呃，让我看看我可以下一个了，我想我是下一个

00:38:14.400 --> 00:38:20.960
所以上周被放在异步生成器路径上之后

00:38:20.960 --> 00:38:24.560
解决我所有问题的方法

00:38:24.560 --> 00:38:28.720
错误处理的复杂性um我最终放弃了它

00:38:28.720 --> 00:38:32.400
嗯，与迈克尔一起工作，事实证明，

00:38:32.400 --> 00:38:35.760
图同步协议有点复杂

00:38:35.760 --> 00:38:42.000
呃适合我们尝试过的迭代器呃或迭代器生成器范式，但是

00:38:42.000 --> 00:38:45.599
只是不完全是，不是没有融合，所以

00:38:45.599 --> 00:38:49.200
我改回了那种旧学校

00:38:49.200 --> 00:38:54.480
方式并一直在努力，因此增加了验证错误处理

00:38:54.480 --> 00:39:00.079
要求者逻辑，所以这是我的更新

00:39:00.079 --> 00:39:04.880
要明确协议的工作方式是有两个流

00:39:04.880 --> 00:39:10.320
用于控制，一个用于块，因为它的方式是

00:39:10.320 --> 00:39:14.560
设计您实际上无法实施有效的流量控制

00:39:14.560 --> 00:39:18.320
就像你实际上不能在其上生成发生器，而实际上不能喜欢map

00:39:18.320 --> 00:39:21.680
正确的在该结构中暂停和恢复um

00:39:21.680 --> 00:39:24.560
因为它并不是真的在考虑

00:39:24.560 --> 00:39:29.200
流控制，就像您甚至无法从客户端暂停一样，这就像疯了一样

00:39:29.200 --> 00:39:33.599
而且因为它在很多方面都看起来像是位交换

00:39:33.599 --> 00:39:36.079
不会有这个问题，因为您总是请求阻止，所以没有

00:39:36.079 --> 00:39:38.720
担心流控制，但是在点对点协议中，这实际上就像

00:39:38.720 --> 00:39:41.280
真的很重要，这似乎像一个实际的

00:39:41.280 --> 00:39:43.920
总的来说，图同步设计的真正问题是我不认为

00:39:43.920 --> 00:39:47.760
如果没有新协议，我们将能够克服

00:39:47.920 --> 00:39:51.359
是的，我实际上很想写​​另一个新协议

00:39:51.359 --> 00:39:56.400
简单多了，但是无论如何都在此之后

00:39:56.400 --> 00:39:58.880
是的，实际上我们在讨论有关协议的一些想法，

00:39:58.880 --> 00:40:02.000
然后我和杰里米（Jeremy）交谈，杰里米（Jeremy）说他的原始设计

00:40:02.000 --> 00:40:06.240
图同步听起来就像我们在说的那样

00:40:06.240 --> 00:40:11.839
我认为至少会有一个人会收到好评

00:40:13.040 --> 00:40:17.119
下一个是迈克尔

00:40:17.520 --> 00:40:21.040
好吧，所以我上周所做的很多事情都是准备好评论

00:40:21.040 --> 00:40:27.839
嗯，要进行预校准通话，但是除了那个以外，我还做了什么

00:40:27.839 --> 00:40:29.680
哦，今天做了更多的迁移

00:40:29.680 --> 00:40:34.079
做多格式的东西嗯，我不得不说我真的很喜欢这些新东西

00:40:34.079 --> 00:40:37.200
原始的东西，它们看起来好多了

00:40:37.200 --> 00:40:42.560
所有的代码都在清理中，嗯，这真的非常好。

00:40:42.560 --> 00:40:46.000
然后，在周末，我让我无法

00:40:46.000 --> 00:40:49.760
嗯，这是麦科拉从我脑海中弄出来的那种树木

00:40:49.760 --> 00:40:56.160
我开始思考，像这样最简单的应用是什么

00:40:56.160 --> 00:40:59.359
嗯，这项技术，我意识到这是

00:40:59.359 --> 00:41:06.960
看起来只是一组排序的Cid，而不是地图，因为就像您所需要的一样

00:41:06.960 --> 00:41:10.480
是按某种顺序排序的东西，那么您需要一些东西

00:41:10.480 --> 00:41:13.520
确实有哈希可以正确执行此操作，所以您只需

00:41:13.520 --> 00:41:16.880
哈希的键和值

00:41:17.359 --> 00:41:22.160
您按二进制排序顺序对其进行排序，然后使用最后一个字节（如果为零）

00:41:22.160 --> 00:41:25.359
您只需要对它进行分块处理，就不必像浮动哈希表那样实现

00:41:25.359 --> 00:41:28.319
算法或您喜欢的任何东西都依赖于随机性

00:41:28.319 --> 00:41:33.359
从哈希和嗯，我真的只是想实现它，所以

00:41:33.359 --> 00:41:35.359
我想看看它如何在实践中发挥作用

00:41:35.359 --> 00:41:39.040
并看看您将如何实现它，然后开始对其中的一些内容进行研究

00:41:39.040 --> 00:41:40.720
结构的性能尺寸

00:41:40.720 --> 00:41:44.560
拥有如此简单且可预测的内容将使我们能够真正喜欢

00:41:44.560 --> 00:41:47.760
调整性能维度，并查看产生的结果

00:41:47.760 --> 00:41:50.480
一旦开始添加，您就会知道不同的块结构

00:41:50.480 --> 00:41:54.880
就像你知道一个浮动的指纹，然后它将变得

00:41:54.880 --> 00:41:58.240
真的很复杂，像这样，整个过程

00:41:58.240 --> 00:42:01.839
变得更加复杂，并且将变得更加困难

00:42:01.839 --> 00:42:07.440
预测很多这种行为，嗯，所以我做了那个

00:42:07.440 --> 00:42:11.680
一旦我做了那个嗯，我和杰里米的谈话

00:42:11.680 --> 00:42:13.920
被困在我谈论这些块存储的地方

00:42:13.920 --> 00:42:17.040
问题，我正在传达一些我和

00:42:17.040 --> 00:42:21.599
民俗人谈论了，他甚至说我认为完全喜欢它

00:42:21.599 --> 00:42:24.640
似乎解决此问题的正确方法是仅添加一个

00:42:24.640 --> 00:42:27.680
b树就像一个仅依赖于单个文件的数据库，我就像

00:42:27.680 --> 00:42:30.720
是的，然后一旦我实现了这棵树，我

00:42:30.720 --> 00:42:35.440
就像哦，您可以完全使用它来实现

00:42:35.440 --> 00:42:39.520
一个笔尖的产业或独立的树嗯，所以我开始

00:42:39.520 --> 00:42:42.400
设计并将其设计为数据库文件格式

00:42:42.400 --> 00:42:45.440
所以这真的很酷，我已经开始实施了，

00:42:45.440 --> 00:42:49.200
设计上的详细规格，现在称为cadb内容地址

00:42:49.200 --> 00:42:53.520
数据库，但实际上它是一个数据库，只是一个文件

00:42:53.520 --> 00:42:57.599
所有键都必须是哈希摘要，并且值显然是二进制的

00:42:57.599 --> 00:43:00.240
阻止它不做任何自己的验证

00:43:00.240 --> 00:43:02.079
你必须确保你给它像

00:43:02.079 --> 00:43:06.319
良好的哈希值，并且一切都与块数据匹配

00:43:06.319 --> 00:43:09.920
嗯，存储界面无法为您做到这一点

00:43:09.920 --> 00:43:13.440
但基本上，您只是使用相同的技术，然后每次

00:43:13.440 --> 00:43:15.920
你写一个新的条目，你重写叶子

00:43:15.920 --> 00:43:19.760
你已经调整了，等等，就像它是典型的b加树的东西

00:43:19.760 --> 00:43:23.359
嗯，是的，我很确定这会像

00:43:23.359 --> 00:43:27.920
我们可以将这些内容写入磁盘的最快方法

00:43:27.920 --> 00:43:32.160
随着时间的推移保持有序的平衡指数

00:43:32.160 --> 00:43:35.599
我们将不得不看一下读取的内容，因为

00:43:35.599 --> 00:43:40.160
当你像这样做树的时候，深度会变大

00:43:40.160 --> 00:43:44.800
事实是，叶子一旦知道就可以预测大小了

00:43:44.800 --> 00:43:48.560
平均哈希摘要大小，因此，如果您查看树的深度

00:43:48.560 --> 00:43:51.280
在平均一半的摘要中，您实际上可以计算出

00:43:51.280 --> 00:43:55.200
您需要多少鲁尔才能将树的整个顶部保留在内存中

00:43:55.200 --> 00:43:58.800
因此，您可以做的就是兑现所有潜在客户的读物并保持

00:43:58.800 --> 00:44:01.760
大部分的交易记忆，所以我认为您实际上可以喜欢

00:44:01.760 --> 00:44:04.720
即使树真的很深，您也可以获得非常快的读取性能，因为您

00:44:04.720 --> 00:44:08.079
可以将整个事情保存在内存中，而您不必喜欢设置一个

00:44:08.079 --> 00:44:11.280
不必修补文件映射，或者您不必喜欢主动

00:44:11.280 --> 00:44:13.680
从缓存中弹出内容，您实际上可以让

00:44:13.680 --> 00:44:17.119
您让东西掉出来，因为您要访问的树的顶部

00:44:17.119 --> 00:44:23.280
嗯，无论如何，那真的很酷，如果可以的话，我正在努力实现

00:44:23.280 --> 00:44:27.920
工作，如果它表现出色，那么我可能会在你之后拉杆

00:44:27.920 --> 00:44:32.960
完成所有悬而未决的任务，并按照更统一的规范进行工作，

00:44:32.960 --> 00:44:35.359
强化实施，然后最终

00:44:35.359 --> 00:44:39.040
我想要一个仅使用此文件的汽车文件格式的新版本

00:44:39.040 --> 00:44:41.520
存储，然后我们从

00:44:41.520 --> 00:44:46.319
汽车文件，例如标头和根，并将其粘贴在某个地方，因为然后

00:44:46.319 --> 00:44:48.880
就像我们开始使用它作为

00:44:48.880 --> 00:44:51.760
汽车文件格式，那么我们想立即获得

00:44:51.760 --> 00:44:55.599
嗯，看到索引CID可以正确访问所有内容

00:44:55.599 --> 00:44:58.480
当您压缩它们时，它们是确定性的，因此我们仍然可以

00:44:58.480 --> 00:45:03.280
确定性投射在紧凑的商店上，现在我们随车运送

00:45:03.280 --> 00:45:06.160
像您这样的文件实际上不必等待加载它们

00:45:06.160 --> 00:45:09.200
您就像在它们上启动数据库一样

00:45:09.200 --> 00:45:12.640
他们会工作的，嗯，这很好，就像有很多真正的

00:45:12.640 --> 00:45:17.359
这个格式的好属性，如果我们将它锁定下来，嗯，是的

00:45:17.359 --> 00:45:19.680
那是我一直在戳的东西

00:45:19.680 --> 00:45:23.359
在研究方面

00:45:23.920 --> 00:45:29.280
谢谢，所以这次我向上滚动到议程我

00:45:29.280 --> 00:45:34.240
没有看到任何引擎项目，但是有谁想谈论什么

00:45:34.240 --> 00:45:37.839
是的，Peter yeah iii要添加到michael

00:45:37.839 --> 00:45:42.400
说如果你们真的在找

00:45:42.400 --> 00:45:46.720
良好的缓存性能，我建议拆分

00:45:46.720 --> 00:45:50.240
基本上有两个具有索引的文件

00:45:50.240 --> 00:45:57.040
完全与数据分离，到目前为止，这是非常糟糕的

00:45:57.040 --> 00:46:00.400
移动它，但这是vfs最理想的操作

00:46:00.400 --> 00:46:04.319
实际上将您的正确字节保留在内存中

00:46:04.319 --> 00:46:09.599
在任何时候，事情是并且能够

00:46:09.599 --> 00:46:16.000
嗯，利用吧，这不是所谓的“预读”，而是“嗯”

00:46:16.000 --> 00:46:20.640
预取以前的显示，取回um ii，不知道我的意思是我必须

00:46:20.640 --> 00:46:24.000
就像我们是否将节点保留在内存中一样

00:46:24.000 --> 00:46:27.040
非常不同，就像有两个文件的问题是

00:46:27.040 --> 00:46:30.160
您不再拥有良好的交易担保，例如

00:46:30.160 --> 00:46:34.960
嗯，就像我可以写lo一样，关于这种过时的文件格式的好处是

00:46:34.960 --> 00:46:38.480
就像页面文件一样，总是写为原子写入

00:46:38.480 --> 00:46:41.760
因此只要您

00:46:41.760 --> 00:46:45.200
确保这些原子权利，因此您只需为

00:46:45.200 --> 00:46:48.880
对于页面文件um，然后页面文件中的最后一件事实际上是

00:46:48.880 --> 00:46:54.400
当前路线um的位置和长度，如果但如果您有两个文件，则

00:46:54.400 --> 00:46:57.839
您就像不知道自己是否处于交易状态

00:46:57.839 --> 00:47:01.359
更新某些内容，这样您就不会喜欢使用实时数据库或块存储

00:47:01.359 --> 00:47:04.880
然后将文件复制出来，就像

00:47:04.880 --> 00:47:07.359
从您的Lotus节点中复制块存储，而无需

00:47:07.359 --> 00:47:11.760
像这样关闭它就像人们对沙发床所做的一样，实际上是

00:47:11.760 --> 00:47:15.760
真的很好，嗯，这是我最喜欢的事情之一

00:47:15.760 --> 00:47:19.040
该数据库实际上是否重要

00:47:19.040 --> 00:47:21.200
有两个文件，因为无论您写

00:47:21.200 --> 00:47:25.119
您是否在第二个文件中关闭

00:47:25.119 --> 00:47:29.119
映像磁盘上没有任何东西

00:47:29.119 --> 00:47:34.319
作为系统调用，可确保在两个单独的fds处同时拥有两项权利

00:47:34.319 --> 00:47:37.440
同时，就像没有办法确保

00:47:37.440 --> 00:47:41.200
在两个之间您处于相同的交易状态

00:47:41.200 --> 00:47:44.960
嗯，至少在文件系统层

00:47:44.960 --> 00:47:50.079
是的，嗯，但是也像我的意思，所以你必须把它们放在一棵树上

00:47:50.079 --> 00:47:56.079
无论如何为了更新它们，就像在数据库中一样

00:47:56.079 --> 00:48:00.160
这就是为什么您不需要像实际的那样不需要单独的索引的原因

00:48:00.160 --> 00:48:05.920
因为您已经有一个喜欢在um中进行查找的排序结构

00:48:05.920 --> 00:48:07.839
就像我不认为实际上有

00:48:07.839 --> 00:48:20.400
就像我们从单独文件的索引中得到的东西一样

00:48:20.400 --> 00:48:23.680
ii认为一个好处是，如果您

00:48:23.680 --> 00:48:27.359
将dnx放入一个单独的文件中，因为它就像

00:48:27.359 --> 00:48:30.100
linux的确像是二级索引

00:48:30.100 --> 00:48:33.359
[音乐]这种情况，因此实际数据在

00:48:33.359 --> 00:48:36.800
文件，索引在某种意义上就像二级索引

00:48:36.800 --> 00:48:41.760
它不包含文件中没有的任何数据，因此您可以

00:48:41.760 --> 00:48:44.960
只是扔掉它，这样您就可以随时重新创建索引并

00:48:44.960 --> 00:48:46.640
如果它是一个单独的文件，则可以执行此操作

00:48:46.640 --> 00:48:50.079
或您只是购买，但您必须扫描整个文件

00:48:50.079 --> 00:48:57.200
是的，要重新创建索引是的，是的，我的意思是，像这样，我不，我不

00:48:57.200 --> 00:49:02.160
认为这是一个很好的选择，老实说，但这就是

00:49:02.160 --> 00:49:07.280
碳水化合物的事情现在正在做，是的，是的，但是那是

00:49:07.280 --> 00:49:10.480
因为您的文件格式结构为

00:49:10.480 --> 00:49:14.000
汽车档案无法使事情井井有条，因为它实际上不是

00:49:14.000 --> 00:49:18.079
像这样的数据库，这就是为什么它是次要的混合

00:49:18.079 --> 00:49:23.760
现在我们最终可能最终都会得到一个辅助文件，因为

00:49:23.760 --> 00:49:27.839
彼得维护链接索引的事情

00:49:27.839 --> 00:49:31.200
对于将不在同一文件中的gc

00:49:31.200 --> 00:49:34.000
因此仍然需要将其作为一个单独的文件并可能将其导出

00:49:34.000 --> 00:49:38.480
分别是um，但您可以做得很好，嗯，是的

00:49:38.480 --> 00:49:43.920
是的，对我们来说，第二个文件的优势也是

00:49:43.920 --> 00:49:46.319
有时候你需要不同的保证

00:49:46.319 --> 00:49:49.599
因此，例如对于主文件，您确实要确保fsync

00:49:49.599 --> 00:49:53.040
确实发生，依此类推，但是基本上，如果您的索引损坏了

00:49:53.040 --> 00:49:57.200
这是我的意思是它不应该被破坏，但是如果这样做的话，这没什么大不了的，因为

00:49:57.200 --> 00:50:00.480
您总是可以重新生成它，所以最终可能

00:50:00.480 --> 00:50:02.880
繁忙的系统中，您将索引文件放在

00:50:02.880 --> 00:50:06.960
更快，可能会有更多错误或您没有得到太多的东西

00:50:06.960 --> 00:50:11.760
我知道，但就像这件事，我了解你为什么想要一个

00:50:11.760 --> 00:50:15.359
排序不好的结构上的二级索引

00:50:15.359 --> 00:50:18.079
但是像这样的结构实际上就像

00:50:18.079 --> 00:50:22.480
文件格式中结构良好的结构，所以我真的看不到像什么

00:50:22.480 --> 00:50:25.119
索引只会像分支读取一样为您节省

00:50:25.119 --> 00:50:29.520
实际上不，但是我的意思是您的附加内容未排序

00:50:29.520 --> 00:50:35.040
就像您的钢笔不一样，但是钢笔写的是对树的引用，

00:50:35.040 --> 00:50:37.839
排序不是汽车文件正常工作的方式

00:50:37.839 --> 00:50:40.000
就像汽车文件一样，就像原子块的版权一样

00:50:40.000 --> 00:50:43.599
所以好像没有扫描就无法索引它们

00:50:43.599 --> 00:50:47.280
就像这样，每次您都在这个结构上

00:50:47.280 --> 00:50:50.720
每次您都没问题时就拥有一个数据库，您将拥有一系列的权限

00:50:50.720 --> 00:50:54.160
操纵树的一部分，重写所有更改的分支

00:50:54.160 --> 00:50:56.800
以及任何新的块数据，然后重写磁头

00:50:56.800 --> 00:51:01.119
所有这些分支的指针，因此指向根的最后一个头指针指向

00:51:01.119 --> 00:51:04.400
已排序树结构的根，用于更新实际索引

00:51:04.400 --> 00:51:07.599
因此您有一个索引，其中包含用于

00:51:07.599 --> 00:51:10.720
寻找文件并喜欢找到您需要的东西

00:51:10.720 --> 00:51:14.240
因此，二级索引不会真正为您节省很多，尤其是一次

00:51:14.240 --> 00:51:18.559
一旦事情变热了，不，你实际上就是在重写

00:51:18.559 --> 00:51:22.160
每次在文件末尾的整个索引，基本上是

00:51:22.160 --> 00:51:25.520
正确的零件会改变零件是的，但是如果

00:51:25.520 --> 00:51:27.359
你只写那些改变的部分

00:51:27.359 --> 00:51:30.400
您的东西不再分类，因为您在这里有东西，您在这里有东西

00:51:30.400 --> 00:51:34.800
在文件的开头，到处都是树，因此

00:51:34.800 --> 00:51:36.960
抓住

00:51:37.359 --> 00:51:40.480
不管压紧在哪里都是一样的

00:51:40.480 --> 00:51:45.440
如果压缩，则在磁盘更改中，所以这就是我们所说的

00:51:45.440 --> 00:51:48.240
就像整个文件格式的整个结构一样

00:51:48.240 --> 00:51:51.520
很多地方没有数据，但实际上并没有

00:51:51.520 --> 00:51:55.680
影响树的性能，因为树的形状仍然相同

00:51:55.680 --> 00:51:58.960
不管您是否压缩它，因为当您更改它时，它都是

00:51:58.960 --> 00:52:03.440
用哈希值重新平衡，我想我要说的是

00:52:03.440 --> 00:52:06.240
您的读物尤其是在冷启动时

00:52:06.240 --> 00:52:10.240
登录信息在那棵树上读着呃，到达您的

00:52:10.240 --> 00:52:12.640
数据项，所有这些现在都在发生

00:52:12.640 --> 00:52:16.319
的文件名，以便您是否拥有登录名随机查找

00:52:16.319 --> 00:52:20.800
索引在一个单独的文件中，您可以将其完全放在您的ssd中，并且可以将它们

00:52:20.800 --> 00:52:23.599
通过较小的索引读取

00:52:23.599 --> 00:52:27.359
即使在寒冷的情况下，结构也会更快地发生，并且只做

00:52:27.359 --> 00:52:32.319
在您的io磁盘上阅读以达到我的意思，这使得

00:52:32.319 --> 00:52:35.599
感觉是否要导出一堆数据，然后将其重新加载以获取

00:52:35.599 --> 00:52:38.480
某些东西可以快速启动并正确运行，但在这里并没有多大意义

00:52:38.480 --> 00:52:41.280
如果您要将该索引作为数据库的一部分进行维护，则一切正确

00:52:41.280 --> 00:52:45.280
因为你每次都要重写整个他妈的索引

00:52:45.280 --> 00:52:48.079
只是以相同的方式改变的部分，就可以做同样的事情

00:52:48.079 --> 00:52:50.960
您要重写的树状结构的结构

00:52:50.960 --> 00:52:52.960
元数据中正在更改的部分

00:52:52.960 --> 00:52:59.440
在您的ssd上的辅助文件中，哦，好吧，辅助索引

00:52:59.440 --> 00:53:03.760
和，而您的io只是一个日志文件系统，仍在追加

00:53:03.760 --> 00:53:08.319
他们写的时候我说的意思是什么意思

00:53:08.319 --> 00:53:10.160
我说的是，我们看到您的称呼

00:53:10.160 --> 00:53:13.440
索引就像二级索引，所以我不是

00:53:13.440 --> 00:53:16.319
谈论有另一个二级索引，但基本上就是您所说的索引

00:53:16.319 --> 00:53:21.359
就像来自您的属性的二级索引

00:53:21.359 --> 00:53:26.559
您的索引不包含主要数据，主要数据仅是追加

00:53:26.559 --> 00:53:31.200
叶子里的东西有人忙，所以我的定义是

00:53:31.200 --> 00:53:35.440
二级索引是始终可以从以下位置重新创建的索引：

00:53:35.440 --> 00:53:38.720
原始数据主索引是其中的索引

00:53:38.720 --> 00:53:43.359
包含数据，如果您丢失了数据，是的，您没有机会，是的

00:53:43.359 --> 00:53:46.800
我的意思是，这就是关于

00:53:46.800 --> 00:53:49.119
你是的，我认为Linux，因此你

00:53:49.119 --> 00:53:52.880
还可以说，即使在您的情况下，您也可以放下

00:53:52.880 --> 00:53:57.839
如果您愿意的话，将此东西放入一个单独的文件中

00:53:59.920 --> 00:54:03.359
是的，我的意思是单独的文件索引必须完全加载到内存中

00:54:03.359 --> 00:54:10.720
那就是您当前使用那个idx的方式汽车文件呃，不，不是

00:54:10.720 --> 00:54:14.160
需要拍张地图，因为它基本上是我的意思

00:54:14.160 --> 00:54:17.280
生成它，但不需要读取

00:54:17.280 --> 00:54:21.599
因此，当它在生成后进行查找时，它就是ab树，并且

00:54:21.599 --> 00:54:25.359
它正在执行搜索，并且不是Mac支持的

00:54:25.359 --> 00:54:28.640
不需要全部都存储在内存中的区域的价格

00:54:28.640 --> 00:54:32.800
它知道有一个文件，它是sid的排序列表，

00:54:32.800 --> 00:54:37.119
记录到主数据文件中的偏移量将被读入

00:54:37.119 --> 00:54:40.640
索引文件，以了解项目在哪里，然后找到它

00:54:40.640 --> 00:54:44.960
有没有读到汽车文件中得到那棵树的物品

00:54:44.960 --> 00:54:49.359
是的，结构是有效的

00:54:49.359 --> 00:54:52.400
与我已经在写的数据结构完全相同

00:54:52.400 --> 00:54:56.799
到pendlete文件，实际上是所有内容都紧凑

00:54:56.799 --> 00:54:59.040
事情，因为我正在对其进行一次扫描

00:54:59.040 --> 00:55:03.839
但是你可以并且呃，因为那只是隐性的

00:55:03.839 --> 00:55:06.640
它用作其排序列表的记录数组

00:55:06.640 --> 00:55:09.040
这些sids你能做的是你可以拥有

00:55:09.040 --> 00:55:12.319
一棵树，你可以有树枝，你可以写一条新路线，并且

00:55:12.319 --> 00:55:15.119
还以仅追加的方式维护您的元数据

00:55:15.119 --> 00:55:21.839
就像您想在车上做的一样

00:55:25.839 --> 00:55:29.119
随机访问就像ssds上的问题一样多

00:55:29.119 --> 00:55:32.880
所以就像我不喜欢它不是实际上它仍然在拉大块

00:55:32.880 --> 00:55:36.640
每次阅读时都在那儿，所以如果您能获得有时很好的本地性和

00:55:36.640 --> 00:55:41.280
那就是你会得到的，呃，我认为这是你的副产品

00:55:41.280 --> 00:55:45.040
更新是像您的根一样，接近根的事物通常会

00:55:45.040 --> 00:55:48.720
所有写的东西至少改变了它们的路径，您将最终得到其中的内容

00:55:48.720 --> 00:55:51.760
被拉回到内存中的同一块

00:55:51.760 --> 00:55:55.119
嗯，所以也许值得思考，但是我怀疑你是对的

00:55:55.119 --> 00:55:58.640
根本不重要，因为靠近根的东西是

00:55:58.640 --> 00:56:00.319
反正一切都将最终留在内存中

00:56:00.319 --> 00:56:05.119
接近树叶的东西才是实际汇率

00:56:05.119 --> 00:56:08.240
我的意思是说您所谈论的树实际上是

00:56:08.240 --> 00:56:11.440
很像我在说的那棵树，只是我的树有

00:56:11.440 --> 00:56:15.599
可以在其旁边写入实际的块数据，因此

00:56:15.599 --> 00:56:19.200
就像所有在同一个文件中一样，我的意思是我要做的一件事

00:56:19.200 --> 00:56:22.319
像um一样，我保持打开单独的文件描述符

00:56:22.319 --> 00:56:24.960
用于阅读和写作，只是为了

00:56:24.960 --> 00:56:28.559
嗯，所以在阅读器上的位置总是相同的，所以

00:56:28.559 --> 00:56:33.040
其实好多了，它确实加快了速度，但是

00:56:33.040 --> 00:56:36.640
我不喜欢访问通常不是什么大问题，但我不知道

00:56:36.640 --> 00:56:40.559
我会对其进行基准测试，看看它看起来像什么

00:56:40.640 --> 00:56:44.960
只是在微基准测试基准上

00:56:45.520 --> 00:56:48.630
所有磁盘操作都没有微基准测试

00:56:48.630 --> 00:56:53.760
[笑声]调查街区的人们

00:56:53.760 --> 00:57:03.440
商店想与您合作，还有其他吗？

00:57:03.440 --> 00:57:09.119
我可以说我有一个公关，呃从一个

00:57:09.119 --> 00:57:14.319
ipld基本架构，我开始通过它来工作

00:57:14.319 --> 00:57:19.200
自动生成uh graphql服务器

00:57:19.200 --> 00:57:22.880
从中也可以做到，这样您就可以在我的pld数据存储中使用

00:57:22.880 --> 00:57:26.000
嗯，然后处理那些人的查询

00:57:26.000 --> 00:57:29.599
进来的是ipld格式，所以基本上

00:57:29.599 --> 00:57:32.640
遵循现有golang的额外热电

00:57:32.640 --> 00:57:35.040
gen

00:57:38.480 --> 00:57:41.520
并弄清楚这两个是如何连接的，但这就是我目前的情况

00:57:41.520 --> 00:57:43.920
从事

00:57:44.240 --> 00:57:47.040
这太酷了

00:57:47.920 --> 00:57:52.400
是的，很酷

00:57:52.880 --> 00:57:57.760
我们没时间了，所以我结束了会议，所以谢谢大家

00:57:57.760 --> 00:58:01.839
参加，下周再见

