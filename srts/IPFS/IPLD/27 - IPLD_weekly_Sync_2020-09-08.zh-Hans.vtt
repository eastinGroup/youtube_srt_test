WEBVTT
Kind: captions
Language: zh-Hans

00:00:14.320 --> 00:00:22.240
欢迎大家参加本周的ipld同步会议2020年9月7日

00:00:22.240 --> 00:00:26.560
每周，我们都会回顾过去一周中我们一直在努力的工作，

00:00:26.560 --> 00:00:33.680
计划进行工作，然后讨论未解决的问题

00:00:33.680 --> 00:00:41.520
来自记者，如果有的话，是的，所以我开始了自己

00:00:41.520 --> 00:00:45.840
所以上周我找到了一些时间上班

00:00:45.840 --> 00:00:49.520
关于rust multihash和我目前正在做什么

00:00:49.520 --> 00:00:55.520
所以计划基本上是将微小的多树篱合并为rust的多哈希

00:00:55.520 --> 00:01:00.320
合并上游，为了做到这一点，我修复了

00:01:00.320 --> 00:01:04.720
嗯，所以基本上

00:01:04.720 --> 00:01:08.799
小型multihash具有与rust multihash相同的功能

00:01:08.799 --> 00:01:13.280
这样合并就很容易了，在我这样做的同时，我也在改进测试

00:01:13.280 --> 00:01:17.840
并明显地发现错误，是的，所以我正在修复错误

00:01:17.840 --> 00:01:24.080
是的，但很高兴的消息是，今天或昨天有人发布了

00:01:24.080 --> 00:01:27.680
缺少的一项功能是添加布雷克（Blake）三项支持

00:01:27.680 --> 00:01:32.479
社区中的某人正在为此做出贡献，因此

00:01:32.479 --> 00:01:35.680
这很酷，我不必做所有的工作，但是

00:01:35.680 --> 00:01:40.720
有别人的帮助，这真的很酷，我也

00:01:40.720 --> 00:01:44.560
研究了防锈cid，然后当然需要使用

00:01:44.560 --> 00:01:49.759
合并后的新um rusts multihash

00:01:49.759 --> 00:01:54.240
我担心这会带来很多变化，但实际上这些变化很漂亮

00:01:54.240 --> 00:01:58.240
小，所以也很酷，所以一次

00:01:58.240 --> 00:02:02.560
锈泥杂物已合并升级锈cd

00:02:02.560 --> 00:02:07.119
只是一个公关，很简单，

00:02:07.119 --> 00:02:12.400
是的，希望这会在本周发生，但可能会拖入下一个

00:02:12.400 --> 00:02:16.640
实际商品周数

00:02:16.640 --> 00:02:23.200
是的，这就是我所拥有的，我名单上的下一个是丹妮尔

00:02:23.200 --> 00:02:27.200
所以我完成了码头和规格方面的工作

00:02:27.200 --> 00:02:30.640
我读了其中的大多数至少两次，但这并不意味着我已经完全掌握了

00:02:30.640 --> 00:02:33.120
但至少我有足够的信心去实际

00:02:33.120 --> 00:02:36.560
开始重击代码，我认为我应该能够遵循

00:02:36.560 --> 00:02:40.400
你们大多数人说的我也确实问过一个

00:02:40.400 --> 00:02:43.519
关于松弛的很多问题，感谢您的帮助

00:02:43.519 --> 00:02:47.840
我也似乎已经找到一种使动作挂在Mac上的方法

00:02:47.840 --> 00:02:51.440
嗯，所以我当时正在和那里的几个开发人员交谈，好像

00:02:51.440 --> 00:02:55.680
ci的处理过程只是下降，所以他们将调查我们

00:02:55.680 --> 00:03:00.800
可能不得不在Mac上禁用ci，直到被调查为止，而我

00:03:00.800 --> 00:03:03.680
基本上会开始帮助他

00:03:03.680 --> 00:03:07.840
进入hackendy，这实际上是标签的一点点

00:03:07.840 --> 00:03:10.560
可以做得更好的事情等等

00:03:10.560 --> 00:03:16.080
直到我完成更大的任务，仅此而已

00:03:17.200 --> 00:03:20.560
谢谢，接下来是艾瑞克

00:03:25.519 --> 00:03:30.640
嗯，所以我已经做了很多写东西的工作，这很有趣

00:03:30.640 --> 00:03:36.400
我认为书面债务也很大，所以有几个

00:03:36.400 --> 00:03:41.120
新问题使人脑筋乱丢

00:03:41.120 --> 00:03:44.239
错误类型的想法库中有很多错误需要

00:03:44.239 --> 00:03:47.840
改善，我很高兴丹尼尔的身边可以提供帮助

00:03:47.840 --> 00:03:52.159
我们和其中一些人一起，我在余热发电方面做了更多的工作，

00:03:52.159 --> 00:03:56.080
模式的东西，所以围绕代码生成的测试范围

00:03:56.080 --> 00:04:01.680
使用我开始使用的新线束结构，东西正在继续扩展

00:04:01.680 --> 00:04:05.120
与上周合作增加了更多的测试

00:04:05.120 --> 00:04:08.879
工会功能特别是在那里发现了几个错误，因此

00:04:08.879 --> 00:04:12.319
好的，现在修复了一段时间

00:04:12.319 --> 00:04:18.799
工会的迭代器会挂断测试覆盖范围，这一点很重要

00:04:18.799 --> 00:04:26.639
所以有了这个固定的东西，我就可以继续进行演示了

00:04:26.639 --> 00:04:33.280
模式的架构，因此该演示现在已经扩展了相当多

00:04:33.280 --> 00:04:37.600
现在它在某些地方使用了工会的形式

00:04:37.600 --> 00:04:39.840
应该是那些我上次不存在的东西

00:04:39.840 --> 00:04:44.160
在这个演示上工作，所以现在我要向他们介绍他们的工作原理

00:04:44.160 --> 00:04:50.000
整个过程都准备好进行解析架构的演示

00:04:50.000 --> 00:04:56.320
模式json有点酷

00:04:56.320 --> 00:05:00.000
就像整个设计系统的梦想一样，这实际上可以很好地发挥作用

00:05:00.000 --> 00:05:03.280
一线多，您可以从以下其中一种中获取节点原型

00:05:03.280 --> 00:05:07.680
代码生成类型，然后将其与字符串一起处理

00:05:07.680 --> 00:05:12.320
进入um json在marshall上，它去了

00:05:12.320 --> 00:05:17.199
因此无需编写任何代码即可在

00:05:17.199 --> 00:05:19.520
结束

00:05:22.720 --> 00:05:26.080
也带来了一些学习经验

00:05:26.080 --> 00:05:30.479
我最终以几种方式按摩了schema schema json

00:05:30.479 --> 00:05:36.479
我稍后再讨论，我也意识到

00:05:36.479 --> 00:05:40.160
整个过程中错误处理体验的强度

00:05:40.160 --> 00:05:45.680
嗯，这又需要大量的工作，所以要弄清楚是有点棘手的

00:05:45.680 --> 00:05:50.160
嗯，当我输入的模式之间不匹配时

00:05:50.160 --> 00:05:53.919
以编程方式，我正在解析并与之匹配的这份文档

00:05:53.919 --> 00:05:57.039
在很多情况下，它会基于类型系统而给我错误

00:05:57.039 --> 00:06:00.319
很有帮助，但不会告诉我在

00:06:00.319 --> 00:06:03.440
如果该类型出现在多个文件中，则完全记录这些文件

00:06:03.440 --> 00:06:05.520
错误消息出现在不同的地方

00:06:05.520 --> 00:06:08.720
没有人想要的那样有帮助，所以有

00:06:08.720 --> 00:06:11.520
在那做的事情

00:06:12.319 --> 00:06:20.000
嗯，架构变更我对此没有做足够的说明

00:06:20.000 --> 00:06:23.840
在我面前的文件中

00:06:24.800 --> 00:06:30.479
所以有一个公关活动，它引入了一些潜在的变化

00:06:31.039 --> 00:06:34.720
我不确定它们是否都是很好的更改，所以更多的是讨论

00:06:34.720 --> 00:06:39.039
我把那份公关标为草稿，因为我不认为那份公关是草稿。

00:06:39.039 --> 00:06:42.880
我想将其合并而不进行讨论，如果的确可以

00:06:42.880 --> 00:06:46.960
可能更像是它产生了一些其他细分的公关

00:06:46.960 --> 00:06:51.759
如果有的话，是内部类型的一些小的重命名

00:06:51.759 --> 00:06:55.199
使它读起来更好

00:06:55.360 --> 00:06:58.960
所以那些很有意思

00:06:58.960 --> 00:07:02.000
将架构架构中的核心联合之一更改为

00:07:02.000 --> 00:07:06.560
是表示当前位置的关键

00:07:06.560 --> 00:07:10.720
从而导致文档结构发生变化

00:07:10.720 --> 00:07:14.880
至少在关闭空白空间之前

00:07:14.880 --> 00:07:21.280
然后就不再那么激烈了那是我所做的改变

00:07:21.280 --> 00:07:25.120
主要是因为这意味着我现在可以进行余热匹配，因为

00:07:25.120 --> 00:07:28.720
具有内联表示的工会的cogen不是

00:07:28.720 --> 00:07:34.880
尚未实施，但我有很多原因

00:07:34.880 --> 00:07:37.759
认为我们可能会推荐钥匙

00:07:37.759 --> 00:07:40.080
工会是最受青睐的选择之一

00:07:40.080 --> 00:07:45.680
在新设计中，所以我想再多谈一点，就像

00:07:45.680 --> 00:07:48.960
考虑我们是否要在架构架构中将其作为主食

00:07:48.960 --> 00:07:53.759
如果不喜欢为什么，并准备喜欢真正捍卫我们

00:07:53.759 --> 00:07:57.280
如此推理，然后还有其他一些

00:07:57.280 --> 00:08:03.280
那里的变化，我现在不记得我住的地方，哦，单位类型

00:08:03.280 --> 00:08:06.960
我还没写完一期新书

00:08:06.960 --> 00:08:10.080
我知道的方式和原因以及单位um的范围

00:08:10.080 --> 00:08:13.360
但我认为这是我们应该考虑添加到计划中的东西

00:08:13.360 --> 00:08:15.759
系统在不久的将来和单位类型是

00:08:15.759 --> 00:08:20.879
基本上是一个基数为1的类型

00:08:21.039 --> 00:08:24.160
它不会经常出现，但是何时出现

00:08:24.160 --> 00:08:27.599
真的想要它，而且解决方法也很粗略，所以

00:08:27.599 --> 00:08:32.240
嗯，到目前为止我一直在研究的东西至少出现了两次

00:08:32.240 --> 00:08:36.880
在这两种情况下，我都陷入了一个循环，没有循环，所以我认为我们应该工作

00:08:36.880 --> 00:08:43.599
除此之外，哦，我们还有一些

00:08:43.599 --> 00:08:47.120
最近几周关于

00:08:47.120 --> 00:08:52.399
身份多哈希，我想转发一点新闻

00:08:52.399 --> 00:08:57.760
来自码头老板项目的伊恩，我们本周正在聊天，他

00:08:57.760 --> 00:09:00.480
正在研究他所拥有的东西

00:09:00.480 --> 00:09:04.480
以前想使用身份多重哈希

00:09:04.480 --> 00:09:09.279
他实现了代码，没有它就可以工作

00:09:09.279 --> 00:09:12.640
这并没有他以前担心的那么大问题，所以我认为

00:09:12.640 --> 00:09:17.120
可能是个好消息，我要去求他写信

00:09:17.120 --> 00:09:22.080
对此进行了一次体验报告，但嗯

00:09:22.080 --> 00:09:27.920
无论如何似乎都行得通

00:09:27.920 --> 00:09:31.120
大约一天就把他带走了，他说代码行数

00:09:31.120 --> 00:09:34.480
在那之后，我们的用户所面临的影响很小

00:09:34.480 --> 00:09:39.040
嗯，所以我们希望他能和他谈谈这是如何工作的，

00:09:40.080 --> 00:09:43.360
它也应该成为身份多边缘技术的最大用途之一

00:09:43.360 --> 00:09:47.600
所以是这样

00:09:48.640 --> 00:09:55.120
是个很好的背景，嗯，嗯，我也要尝试谈一谈

00:09:55.120 --> 00:09:59.279
下周向您介绍有关Unicafe的v2期货的更多信息

00:09:59.279 --> 00:10:02.560
因为他开始从事其他一些实验性文件系统设计的工作

00:10:02.560 --> 00:10:06.720
嗯，我不希望我们的工作能在此基础上融合，因为

00:10:06.720 --> 00:10:10.640
他想到的用例尤其涉及诸如

00:10:10.640 --> 00:10:14.800
功能位和许可系统

00:10:14.800 --> 00:10:17.600
他们将充满purebounce的应用程序级逻辑

00:10:17.600 --> 00:10:20.399
很好，但是再聊一点

00:10:20.399 --> 00:10:22.560
多一点，尝试让我们的船像

00:10:22.560 --> 00:10:26.160
大致相同的方向

00:10:26.320 --> 00:10:28.959
对我来说就是这样

00:10:30.240 --> 00:10:35.040
谢谢，接下来是杆

00:10:39.360 --> 00:10:46.560
好吧，我的标签在哪里好吧，所以

00:10:46.560 --> 00:10:52.880
好吧，所以我这个星期的故事是嗯，我正在慢慢地导航到

00:10:52.880 --> 00:10:56.320
我已经在我的一些测试夹具的东西

00:10:56.320 --> 00:11:00.079
列出了这么长时间，然后再次与文件硬币一起返回

00:11:00.079 --> 00:11:05.360
嗯，这是我接触汽车档案的原因

00:11:05.360 --> 00:11:09.760
首先是回程

00:11:09.760 --> 00:11:17.920
嗯很久以前嗯反正我我牛刮到了一个新的甲板pb

00:11:17.920 --> 00:11:24.000
在javascript um中实现，因为我的汽车文件测试夹具

00:11:24.000 --> 00:11:27.760
包括一些dag pp的东西，而他的并随着向新版的迁移

00:11:27.760 --> 00:11:31.680
最笨拙的多格式堆栈um

00:11:31.680 --> 00:11:35.040
所有的一切都使测试变得一团糟

00:11:35.040 --> 00:11:39.519
迈克尔还没有做，我不知道发生了什么

00:11:39.519 --> 00:11:42.959
完成这项工作的途径是什么，所以我才做到了

00:11:42.959 --> 00:11:46.720
因此，对于新的多格式，有一个新的dag pb实现

00:11:46.720 --> 00:11:52.399
堆叠，并在该新仓库中排名第一

00:11:52.399 --> 00:11:59.120
我开始讨论关于我们如何与新区块互动

00:11:59.120 --> 00:12:05.920
抽象和这些数据形状不是

00:12:05.920 --> 00:12:11.839
最终形式，在此特定情况下以um为单位

00:12:11.839 --> 00:12:16.399
那是一个问题的原因是因为

00:12:16.399 --> 00:12:20.639
嗯，迈克尔在其中建立了块抽象

00:12:20.639 --> 00:12:25.279
读者功能读者抽象

00:12:25.279 --> 00:12:30.720
它接管了所有内置的所有路径解析内容

00:12:30.720 --> 00:12:34.000
的旧编解码器是什么内置的，所以

00:12:34.000 --> 00:12:39.920
在任何其他js编解码器中，路径解析度将推迟到编解码器

00:12:39.920 --> 00:12:42.959
因此，每当您想要解决问题时，它都将其称为

00:12:42.959 --> 00:12:48.160
在该编解码器上解析功能，然后为您解决问题

00:12:48.160 --> 00:12:51.519
总是有很多重复，您可以再次找到相同的代码

00:12:51.519 --> 00:12:55.760
遍及这些编解码器，因为它们大多数都执行了

00:12:55.760 --> 00:12:59.920
同一件事有一些变化，但是非常相似，所以迈克尔拉了一下

00:12:59.920 --> 00:13:03.360
进入块接口，所以如果您进行路径解析，

00:13:03.360 --> 00:13:08.800
这个块，那么它将是大多数时候实际上在本地完成的所有工作，

00:13:08.800 --> 00:13:12.079
起作用的方式是呃，因为在javascript中

00:13:12.079 --> 00:13:15.760
我们只处理简单的对象，所以当我们做一个

00:13:15.760 --> 00:13:18.959
解码我们实例化一个对象

00:13:18.959 --> 00:13:23.040
数据模型中数据的形状，然后在执行时

00:13:23.040 --> 00:13:25.279
然后我们可以通过它

00:13:25.279 --> 00:13:29.760
对象，所以任何路径都告诉我们如何穿过该对象，我们可以

00:13:29.760 --> 00:13:34.240
在内存中执行此操作，然后在序列化时获取一个对象

00:13:34.240 --> 00:13:38.880
适当的形状，然后将其转换为该格式的字节

00:13:38.880 --> 00:13:42.480
dag jason和dax cbo很好，因为这只是问题

00:13:42.480 --> 00:13:45.680
嗯，你如何序列化这些东西

00:13:45.680 --> 00:13:48.240
进入这些编解码器，它们非常灵活，因此您

00:13:48.240 --> 00:13:53.360
可以采用任何大多数形状的内存中的数据

00:13:53.360 --> 00:13:59.440
把它们变成daxy或datejson很棒，但是我们还有其他的编解码器

00:13:59.440 --> 00:14:02.320
不灵活

00:14:02.639 --> 00:14:06.639
而dake pp几乎是其中之一，但堤防seabourn dak jason除外

00:14:06.639 --> 00:14:11.199
是的，他们有非常特别的意见

00:14:11.199 --> 00:14:16.000
关于数据模型um中数据的形状

00:14:16.000 --> 00:14:19.680
所以当您对一个块进行解码时反序列化

00:14:19.680 --> 00:14:25.680
dag pb，您将获得该具有链接属性和数据属性的对象，并且

00:14:25.680 --> 00:14:28.639
links属性具有一个数组，该数组具有

00:14:28.639 --> 00:14:33.120
um个对象，每个对象具有三个属性

00:14:33.120 --> 00:14:39.680
嗯，哈希的大小和名称是什么，

00:14:39.680 --> 00:14:42.800
关于这些东西以及它们是什么，有一些规则

00:14:42.800 --> 00:14:45.920
默认值是什么，如果不存在会发生什么

00:14:45.920 --> 00:14:49.279
甚至关于如果data属性为

00:14:49.279 --> 00:14:53.920
转换为零字节数组的空um

00:14:53.920 --> 00:15:00.560
嗯，那很好，所以解决了路径

00:15:00.560 --> 00:15:03.680
关于dag pb的一些问题，因为有这个全名

00:15:03.680 --> 00:15:07.360
链接名为天猫座的东西，如果你看

00:15:07.360 --> 00:15:12.240
您会看到的dag pp规范，但我们在

00:15:12.240 --> 00:15:16.560
实例化新的javascript时可以提供的信息

00:15:16.560 --> 00:15:20.560
dagpb块，您可以提供一个对象

00:15:20.560 --> 00:15:24.079
在尺寸上有一些变化，不一定是

00:15:24.079 --> 00:15:27.760
完美，编解码器将在序列化之前为您提供正确的解决方案

00:15:27.760 --> 00:15:35.040
嗯，所以可能有几个例子

00:15:35.279 --> 00:15:39.279
嗯，最简单的是数据属性

00:15:39.279 --> 00:15:43.279
可以为空，您可以根本不提供任何数据，那样就可以了

00:15:43.279 --> 00:15:46.399
然后它将序列化为零长度

00:15:46.399 --> 00:15:52.800
字节数组，然后在反序列化时执行resu时，它将作为

00:15:52.800 --> 00:15:56.079
零长度字节数组，因此您传递的内容可能为null，但

00:15:56.079 --> 00:15:58.000
当它来回时，它会作为一个

00:15:58.000 --> 00:16:06.000
零数组，另一个例子很好

00:16:06.000 --> 00:16:08.880
我写的新内容之所以如此，是因为我在

00:16:08.880 --> 00:16:11.920
因为它更好，所以您可以通过

00:16:11.920 --> 00:16:14.720
咬一口，说为我序列化此字节数组

00:16:14.720 --> 00:16:17.759
然后将这个字节数组放入数据属性中，然后

00:16:17.759 --> 00:16:20.320
没有链接，它会给你一个很好的

00:16:20.320 --> 00:16:23.759
形成pp对象，就好像您只是序列化一个字节一样

00:16:23.759 --> 00:16:29.199
数组，但是它将与links对象打包在一起

00:16:29.199 --> 00:16:32.720
您只需给出一个提示即可将其变成正确的

00:16:32.720 --> 00:16:37.199
对象类型和一堆东西，您可以使

00:16:37.199 --> 00:16:40.399
如果您从头开始构建格式，请使其格式更好，因为您知道那里

00:16:40.399 --> 00:16:44.160
是历史上的一些遗留物，使这种格式不太令人愉快

00:16:44.160 --> 00:16:48.160
这样您就可以传递所有这些不同形状的不同对象

00:16:48.160 --> 00:16:51.920
它将为您做往返旅行，他们会出来

00:16:51.920 --> 00:16:56.399
不同，但是当我们有此阻塞块抽象时，

00:16:56.399 --> 00:17:00.639
从数据模型实例化一个新块

00:17:00.639 --> 00:17:04.160
它的形状与它所要匹配的不完全相同

00:17:04.160 --> 00:17:09.839
往返行程中会发生什么，这个阅读器就是路径

00:17:09.839 --> 00:17:13.679
分辨率将根据数据解析

00:17:13.679 --> 00:17:16.160
您传递的方式不完全相同

00:17:16.160 --> 00:17:19.760
如果它来回旅行，那么您会得到非常奇怪的副作用

00:17:19.760 --> 00:17:23.600
如果您要构建的系统是在其中创建块的

00:17:23.600 --> 00:17:26.640
记忆力，不做往返旅行

00:17:26.640 --> 00:17:29.360
不反序列化您正在创建它们并使用它们

00:17:29.360 --> 00:17:35.600
当您创建它们时说您是一个um uni fs系统，

00:17:35.600 --> 00:17:41.760
嗯，它被拉了，正在吸入文件系统，您也想

00:17:41.760 --> 00:17:45.039
同时在文件浏览器中浏览它

00:17:45.039 --> 00:17:49.280
当您处理它时，甚至在序列化之前

00:17:49.280 --> 00:17:52.480
您可以将这些块对象扔进去

00:17:52.480 --> 00:17:58.240
如果您正在执行任何路径操作，那么路径将是错误的，因为

00:17:58.240 --> 00:18:03.440
数据形状不是它们的最终形式，所以现在有一个关于什么的问题

00:18:03.440 --> 00:18:08.000
我们要对这种块抽象做些什么吗？一个选择是

00:18:08.000 --> 00:18:11.679
强迫往返旅行，如果您当时真的很浪费

00:18:11.679 --> 00:18:14.240
永远不会像这样编码，也许您遇到了这样的情况

00:18:14.240 --> 00:18:17.760
实际上不编码，您只是将它们用作抽象

00:18:17.760 --> 00:18:21.760
另一个建议是必须有某种准备方法来

00:18:21.760 --> 00:18:26.400
每个编解码器，其中的编解码器都有一种方法可以注册所需的内容

00:18:26.400 --> 00:18:30.480
做一些数据准备的另一个例子是

00:18:30.480 --> 00:18:35.200
javascript，我们可以拥有具有无关属性的对象

00:18:35.200 --> 00:18:38.799
他们只是被忽略，所以如果您要来回旅行

00:18:38.799 --> 00:18:43.440
并且您有一个传入的属性foo对象，您不会

00:18:43.440 --> 00:18:46.640
关于它的错误，因为它不在寻找无关的属性

00:18:46.640 --> 00:18:52.799
但它会在往返中消失，然后，但如果您不这样做，

00:18:52.799 --> 00:18:57.520
来回走你的路径foo会解决，这只是愚蠢的

00:18:57.520 --> 00:19:02.160
所以嗯，所以现在有一个讨论在

00:19:02.160 --> 00:19:07.120
关于此轮行程和准备数据的方式的第一号

00:19:07.120 --> 00:19:10.720
形状应该起作用，嗯，不是

00:19:10.720 --> 00:19:13.120
解决了，但是需要一些实验，并且可能

00:19:13.120 --> 00:19:19.440
总而言之，使抽象变得不那么干净，但是

00:19:19.440 --> 00:19:25.120
这是第一号问题，另一件事是

00:19:25.120 --> 00:19:30.000
讨论是呃回车的东西是

00:19:30.000 --> 00:19:38.880
um我一直用来写这些um的数据存储接口

00:19:38.880 --> 00:19:42.400
JavaScript中块存储的抽象

00:19:42.400 --> 00:19:47.200
它是从文件硬币中出来的，甚至一开始它就像这样

00:19:47.200 --> 00:19:51.039
非常合适，里面有很多传统的想法

00:19:51.039 --> 00:19:53.840
只是不适用于我们想做的事

00:19:53.840 --> 00:19:58.160
我只是说到那太令人沮丧地错了

00:19:58.160 --> 00:20:04.960
用于普通块javascript ipld块存储系统

00:20:04.960 --> 00:20:08.480
所以汽车回购中的汽车讨论中有一个讨论

00:20:08.480 --> 00:20:14.720
关于一个新的存储um抽象，那里有一个api

00:20:14.720 --> 00:20:20.240
和ghazal在um一样非常有帮助

00:20:20.240 --> 00:20:24.000
想出关于抽象应该是什么样子的想法

00:20:24.000 --> 00:20:28.159
嗯，api应该是什么样子，所以我正在实施中

00:20:28.159 --> 00:20:33.280
那个想法是应该可以转移到其他存储

00:20:33.280 --> 00:20:38.000
我们像迈克尔一直在做的事情

00:20:38.000 --> 00:20:44.880
git lfs um中的ipld应该是相同的抽象

00:20:44.880 --> 00:20:47.039
镜像在那里，所以您可以将其传递

00:20:47.039 --> 00:20:50.559
对存储它们的位置不可知

00:20:50.559 --> 00:20:54.080
所以这是一个富有成果的讨论，这就是我正在做的事情

00:20:54.080 --> 00:20:59.200
这是我这周最有趣的事情

00:21:01.120 --> 00:21:07.540
好的，嗯，任何人的其他更新

00:21:07.540 --> 00:21:12.480
[音乐]嗯，我对此事有一个评论

00:21:12.480 --> 00:21:15.919
一个在标签pb上，因为就像您解释的那样，我是

00:21:15.919 --> 00:21:18.960
想知道嗯，因为我也像我一样

00:21:18.960 --> 00:21:21.919
在讨论中发布了评论，但正如您解释的那样

00:21:21.919 --> 00:21:25.120
嗯，也许在那里有意义

00:21:25.120 --> 00:21:28.240
是那个[音乐]

00:21:28.240 --> 00:21:35.679
从编解码器中，encode方法始终期望正确的形状

00:21:35.679 --> 00:21:40.320
像它应该具有的最终形状，然后我们进行此准备

00:21:40.320 --> 00:21:43.840
方法也在编解码器上，所以因为喜欢

00:21:43.840 --> 00:21:45.760
人们应该通过

00:21:45.760 --> 00:21:49.840
无论如何，博客api，所以从博客api的角度来看，你们d

00:21:49.840 --> 00:21:54.880
传递任何您喜欢的东西，然后在编解码器上调用此准备方法

00:21:54.880 --> 00:21:58.400
基本上将其自身水平，这样您就不必将其推入

00:21:58.400 --> 00:22:03.200
编码方法基本相同，但类似定义编码方法

00:22:03.200 --> 00:22:08.880
始终期望数据的正确形状

00:22:08.880 --> 00:22:12.559
我不知道这是否太严格，但这可能使

00:22:12.559 --> 00:22:15.600
更清洁一点，因为我也觉得

00:22:15.600 --> 00:22:18.799
是的，奇怪的地方放东西，但我想如果你喜欢

00:22:18.799 --> 00:22:24.400
这可能是的，可能会使事情变得更容易，所以

00:22:24.400 --> 00:22:28.000
基本上说，准备好的功能真的只能转化

00:22:28.000 --> 00:22:32.640
然后，是的，那是

00:22:32.640 --> 00:22:36.000
那就是我们进入该讨论的地方以及

00:22:36.000 --> 00:22:39.520
我说过我会去朝那个方向做实验

00:22:39.520 --> 00:22:44.960
关于它，如果您愿意的话，那是您的数目，所以我们

00:22:44.960 --> 00:22:48.400
这是两层，一层是多种格式，一层是块

00:22:48.400 --> 00:22:52.720
并通过块进行交互是很有意义的，因为您只是

00:22:52.720 --> 00:22:57.280
放入对象，然后在块上调用代码和解码方法

00:22:57.280 --> 00:23:00.480
它完成了下面的所有机制，因此您可以隐藏所有

00:23:00.480 --> 00:23:04.159
那里的那些细节，它会很好地工作，但您也可以进行交互

00:23:04.159 --> 00:23:09.200
通过多格式的东西，这是更多的东西

00:23:09.200 --> 00:23:13.919
你在说um给我的编码方法的手册

00:23:13.919 --> 00:23:18.159
这个编解码器，然后给我这个编解码器的解码方法，然后您就可以执行此操作

00:23:18.159 --> 00:23:21.280
块所做的所有自己消除了痛苦

00:23:21.280 --> 00:23:25.760
但您仍然可以通过这种方式进行操作，因此仍可以与这些编解码器进行交互

00:23:25.760 --> 00:23:30.480
如果您仅将多格式与

00:23:30.480 --> 00:23:33.760
多种格式，那么您将处于编解码器需要

00:23:33.760 --> 00:23:38.880
决定呃他们想要多少验证

00:23:38.880 --> 00:23:42.640
在编码方法中做呃，然后最终自己是

00:23:42.640 --> 00:23:46.159
浪费，我在这里特别考虑比特币格式，

00:23:46.159 --> 00:23:50.400
您的形状非常复杂，而且非常具体，必须具有

00:23:50.400 --> 00:23:53.120
属性，此属性，可能必须是这种类型

00:23:53.120 --> 00:23:57.360
然后它不应该有任何其他属性，所以如果我有一个

00:23:57.360 --> 00:24:02.640
准备二可以很容易地接受输入并将其放置在正确的形状，那会

00:24:02.640 --> 00:24:07.039
意思是拿像um散列之类的东西并将其转变为cid

00:24:07.039 --> 00:24:09.679
删除不应该存在的属性，我可以在

00:24:09.679 --> 00:24:13.200
准备方法，但是当我进入编码方法时

00:24:13.200 --> 00:24:16.559
我可能还是要再次做一次，因为我

00:24:16.559 --> 00:24:20.960
我不能，这是太多话了

00:24:20.960 --> 00:24:24.000
我可以假设它的形状正确无误

00:24:24.000 --> 00:24:28.559
嗯，因为那样会导致很多潜在的错误，

00:24:28.559 --> 00:24:31.679
嗯，我假设我可以在这里阅读此属性，因为

00:24:31.679 --> 00:24:35.039
您应该事先准备好这些数据

00:24:35.039 --> 00:24:39.679
而且有些东西值得信赖

00:24:39.679 --> 00:24:46.000
关于javascript中的api，它不检查通过它的数据

00:24:46.000 --> 00:24:48.559
只是做个假设，嘿，你应该已经准备好了

00:24:48.559 --> 00:24:54.559
这个东西，嗯，这让它很尴尬

00:24:54.559 --> 00:24:58.159
忙着说，如果我们这样做，您将需要

00:24:58.159 --> 00:25:02.720
编码中的错误处理，然后基本上

00:25:02.720 --> 00:25:06.960
示例错误在准备器和编码中都结束了

00:25:06.960 --> 00:25:10.159
因为就像没有编码一样

00:25:10.159 --> 00:25:13.360
是的，是的，只是随机地弄碎了东西，人们

00:25:13.360 --> 00:25:16.720
不知道为什么会坏，但我确实有一个

00:25:16.720 --> 00:25:22.400
考虑过如何改善这一点，那是那个

00:25:22.400 --> 00:25:26.799
你可以做这个准备的事情嗯

00:25:27.600 --> 00:25:30.799
是的，它并不能真正解决问题，但是您可以

00:25:30.799 --> 00:25:34.480
打电话准备使用路径的东西

00:25:34.480 --> 00:25:37.919
您可以推迟对任何输入数据的呼叫准备

00:25:37.919 --> 00:25:44.960
直到用户确实调用了该路径的东西，或者他们要求输入

00:25:44.960 --> 00:25:48.159
往返之前解码回表格，所以您

00:25:48.159 --> 00:25:51.279
可以限制您进行双重准备的情况

00:25:51.279 --> 00:25:55.039
嗯，只是那些他们想重新

00:25:55.039 --> 00:25:59.279
他们想用输入数据和um来制作带有原点的块

00:25:59.279 --> 00:26:02.720
然后在编码之前使用该块

00:26:02.720 --> 00:26:07.600
嗯，在这种情况下，您可以打电话给prepare，但在其他情况下，您可以

00:26:07.600 --> 00:26:12.400
可以将那笔费用推迟到其他地方

00:26:12.400 --> 00:26:15.760
这样您就可以制作一个api，在其中您可以说编解码器了

00:26:15.760 --> 00:26:19.840
应该导出一个准备功能

00:26:20.240 --> 00:26:25.120
而且我们也相信，编码功能也可以做到这一点

00:26:25.120 --> 00:26:27.440
好，那是您拥有的另一种选择

00:26:27.440 --> 00:26:30.960
准备哪个会清理，并在代码中清理

00:26:30.960 --> 00:26:34.799
整理和编码，而不是将两者分开

00:26:34.799 --> 00:26:40.880
并使其成为独立的api片段，您可以让编解码器说“好吧，我是

00:26:40.880 --> 00:26:44.480
只会在这些非常有限的状态下调用prepare方法

00:26:44.480 --> 00:26:47.679
在这种情况下，我相信您会做自己的准备

00:26:47.679 --> 00:26:52.799
当我只是调用代码时，它也限制了双重处理，但是

00:26:52.799 --> 00:26:58.320
无论如何，这些都是棘手的细节，

00:26:58.320 --> 00:27:01.440
嗯，需要尝试一下，但是将会有一些重复

00:27:01.440 --> 00:27:04.080
在这里处理

00:27:04.840 --> 00:27:11.360
某个地方好吧

00:27:12.159 --> 00:27:21.440
是的，还有别的吗，嗯，我只是想说些什么

00:27:21.440 --> 00:27:26.320
我认为值得将这两个步骤分开的想法似乎是值得的

00:27:26.320 --> 00:27:30.000
合理且必须准备，我认为那应该是

00:27:30.000 --> 00:27:33.919
可选，我喜欢编码的想法

00:27:33.919 --> 00:27:38.880
如果在事物中发现无法编码的数据，则返回一个方法

00:27:38.880 --> 00:27:43.120
那时的错误不要再尝试按摩了

00:27:43.120 --> 00:27:46.240
因为我认为这将是可能的

00:27:46.240 --> 00:27:49.360
拨打维修电话并进行所有按摩

00:27:49.360 --> 00:27:54.559
对于新写的东西，它确实是完全可选的，例如我们想要这个

00:27:54.559 --> 00:27:58.960
对于具有一些兼容性故事的事物，感觉会更好

00:27:58.960 --> 00:28:02.240
就像上一代的接口，但是如果

00:28:02.240 --> 00:28:04.960
您正在编写新代码，也可以将新代码编写为

00:28:04.960 --> 00:28:09.120
不使用任何这些结构或假设这些转换是

00:28:09.120 --> 00:28:12.159
将会正确存在，因此它并非绝对必要

00:28:12.159 --> 00:28:15.039
如果您知道自己正在使用此新代码编写代码，请致电进行修复

00:28:15.039 --> 00:28:17.840
一代

00:28:18.960 --> 00:28:26.080
是的，但实际上您要增加更多的数量

00:28:26.080 --> 00:28:29.200
检查，因为好用dagpb的例子

00:28:29.200 --> 00:28:35.360
是如果我说我的编码方法只处理精确形式

00:28:35.360 --> 00:28:39.840
反对，就好像他们来回一样，我只是假设他们都是

00:28:39.840 --> 00:28:43.760
在那里，如果他们不在那，那么抛出这个null会怎么样呢？

00:28:43.760 --> 00:28:49.200
数据数组事物，其中dag pb spec指定必须是它

00:28:49.200 --> 00:28:52.640
不能为空属性，必须为零长度的字节数组

00:28:52.640 --> 00:28:58.720
um或它必须有字节在其中um，所以然后我有我的代码然后必须

00:28:58.720 --> 00:29:01.520
说，呃，有您给的支票

00:29:01.520 --> 00:29:04.960
它不能只是这种松散的检查，如果您知道它是否不存在，那么我将更换

00:29:04.960 --> 00:29:07.440
它必须是一个咬合的阵列，它必须具有

00:29:07.440 --> 00:29:10.240
一个长度，现在它不，它不必一定要有一个长度

00:29:10.240 --> 00:29:14.000
显然，它必须是二进制um，并且不能是其他任何东西，所以我

00:29:14.000 --> 00:29:18.320
需要对此进行类型检查，然后我必须针对

00:29:18.320 --> 00:29:22.799
我必须对所有子属性做的另一件事是

00:29:22.799 --> 00:29:26.799
检查每个地图的键，因为一切都是对象一切都是

00:29:26.799 --> 00:29:29.840
用JavaScript映射，所以我必须检查其中的键

00:29:29.840 --> 00:29:33.600
没有多余的键，好吧，您给了我一些链接数据，

00:29:33.600 --> 00:29:37.360
食物你为什么要为什么不离开这个直到

00:29:37.360 --> 00:29:40.320
编解码器在其上运行，编解码器正在检查所有这些内容，然后

00:29:40.320 --> 00:29:44.080
编解码器说不，但这就是我在说的

00:29:44.080 --> 00:29:49.360
在正常的编码方法中，所以我在dagpb中会做什么

00:29:49.360 --> 00:29:52.399
如果您给我一个包含链接数据和foo的对象

00:29:52.399 --> 00:29:56.960
我永远不会像在旧的编解码器中那样触摸foo，而在新的编解码器中没有理由

00:29:56.960 --> 00:30:00.640
甚至可以触摸foo以确认其存在，甚至

00:30:00.640 --> 00:30:03.360
检查所有我关心的东西给我一个对象

00:30:03.360 --> 00:30:07.679
我正在拉出数据和链接，并正在对它们进行序列化，但是您已经

00:30:07.679 --> 00:30:09.760
给我一些东西，也应该是foo

00:30:09.760 --> 00:30:13.600
那是无效的，那不应该这样，因为它不会往返

00:30:13.600 --> 00:30:17.120
它不应该在那儿，准备工作是的，我想

00:30:17.120 --> 00:30:21.520
那应该赢对，所以这意味着我必须

00:30:21.520 --> 00:30:25.200
对出现的每个对象执行递归键检查

00:30:25.200 --> 00:30:27.440
然后，这是附加的

00:30:27.440 --> 00:30:33.200
直到现在我们一直在处理，所以我们避免了嗯，所以

00:30:33.200 --> 00:30:38.240
好像几乎是基线，就像您在做马歇尔一样，是的

00:30:38.240 --> 00:30:42.159
在你看来就像我ii知道为什么在你看来就像它，但是

00:30:42.159 --> 00:30:46.720
这不是我们在这个无类型世界中的运作方式

00:30:46.720 --> 00:30:50.559
嗯，因为它为您提供了很多无类型输入的灵活性

00:30:50.559 --> 00:30:54.720
可以在同一地方重复使用同一事物以用于不同目的的土地

00:30:54.720 --> 00:31:00.159
嗯，你可以一次让东西看起来像两件事

00:31:00.159 --> 00:31:02.399
你知道这是多态

00:31:02.399 --> 00:31:08.640
它提供给我们的不是，这通常不是一个好习惯，但它可能会很有用

00:31:08.640 --> 00:31:15.279
嗯，在这种情况下，这是不理想的，但是这种处理方式

00:31:15.279 --> 00:31:18.399
我们已经能够最大程度地避免使用um

00:31:18.399 --> 00:31:20.480
部分，但是在这种新情况下

00:31:20.480 --> 00:31:24.000
新的抽象，因为我们正在处理这些对象，因此它们必须是纯净的

00:31:24.000 --> 00:31:28.000
我们必须经历这个纯度周期以准备方法，是的，这很有意义

00:31:28.000 --> 00:31:31.919
我会做的是可能不会创建它，而另一个问题是

00:31:31.919 --> 00:31:36.320
您不必创建一个新对象

00:31:36.320 --> 00:31:39.600
这就是诀窍，因此您不能只是清理别人给的旧物件

00:31:39.600 --> 00:31:41.919
您需要创建一些新的东西，

00:31:41.919 --> 00:31:45.519
把它还给你，你不能只拿旧东西为他们清理，因为

00:31:45.519 --> 00:31:48.399
那就打破了我们通常坚持的api合同

00:31:48.399 --> 00:31:52.720
到不与用户输入混淆的javascript中，因为

00:31:52.720 --> 00:31:54.960
他们可能正在将其用于其他用途

00:31:54.960 --> 00:31:58.159
做出新的东西并退货，这使您有机会清洁

00:31:58.159 --> 00:32:01.360
设置属性，然后您所要做的就是获取一个具有链接的对象

00:32:01.360 --> 00:32:03.919
数据foo，您就可以制作一个新的文件，而您所关心的

00:32:03.919 --> 00:32:08.320
关于是拉出链接和数据，然后您给他们，然后

00:32:08.320 --> 00:32:11.039
甚至没有任何理由检查原始版本的属性

00:32:11.039 --> 00:32:14.640
因此您甚至不需要进行任何类型检查或键检查

00:32:14.640 --> 00:32:17.760
因为您所做的只是拉出链接和foo，所以没有错误

00:32:17.760 --> 00:32:20.640
涉及没有检查涉及没有

00:32:20.640 --> 00:32:23.360
是的，因为您知道有人可能会给您一些

00:32:23.360 --> 00:32:26.159
在许多属性上有很多对象

00:32:26.159 --> 00:32:31.519
这些东西可能会变得昂贵，而且大多数情况下您可以避免这种情况

00:32:31.519 --> 00:32:34.559
无论如何，这就是这变得非常混乱

00:32:34.559 --> 00:32:40.000
和嗯，是的，但这是一个不会解决的问题

00:32:40.000 --> 00:32:45.600
摆脱了那些对数据形状有意见的不灵活的格式

00:32:52.559 --> 00:33:01.360
是的，所以最后一个电话

00:33:02.320 --> 00:33:09.200
很酷，然后我们召开了一次快速会议，是的，我们下周再见到我们，嗯

00:33:09.200 --> 00:33:13.120
再见大家eric，在我们关闭eric之前，您做了吗？

00:33:13.120 --> 00:33:15.840
想要完全谈论架构的东西或

00:33:15.840 --> 00:33:18.480
我们将做进一步

00:33:18.880 --> 00:33:25.679
如果我们不得不，我猜我们不必是7点30分，那我就不那么热衷了

00:33:25.679 --> 00:33:27.840
但

00:33:29.679 --> 00:33:33.919
嗯，这应该在流上还是不在，因为所以我停止了直播

00:33:33.919 --> 00:33:39.120
或说它不是私人的，而是开放的

00:33:40.960 --> 00:33:47.279
是的，那么让我们继续记录，是的，嗯，我必须去挖掘一下

00:33:47.279 --> 00:33:54.000
Tabs um，所以我只是提出了一个谈论单位善良问题的问题

00:33:54.000 --> 00:33:59.600
因为它已经完成了单独的问题，即编号292和规格回购

00:34:01.600 --> 00:34:05.360
所以这是在检查其他模式的过程中出现的

00:34:05.360 --> 00:34:09.440
模式更改，使我的解析器正常工作，但是有些事情已经解决了

00:34:09.440 --> 00:34:13.040
在我的一个后燃愿望清单上停留了一段时间

00:34:13.040 --> 00:34:16.480
所以现在它冒泡到顶部

00:34:17.440 --> 00:34:22.560
哦，这个清单在哪儿

00:34:23.200 --> 00:34:26.879
所以我已经准备了该草案草案，以进行潜在的架构更改，它是

00:34:26.879 --> 00:34:32.480
到目前为止，仅在json表单上实现，我还没有将其移植到dsl

00:34:32.639 --> 00:34:36.560
这些基本上就是即将发生的变化

00:34:36.560 --> 00:34:39.760
正如我在建造时重新翻阅

00:34:39.760 --> 00:34:44.240
与共同生成的东西一起解析的演示

00:34:44.240 --> 00:34:51.040
出现的事情之一是工会的两种实现

00:34:51.040 --> 00:34:56.079
到目前为止，已在代码中实现的是键控和同类

00:34:56.079 --> 00:35:00.480
所以我改变了所有不需要键入的内容

00:35:00.480 --> 00:35:05.280
以前这些被写成是工会的内联代表

00:35:05.280 --> 00:35:11.920
所以所有在类型定界联合中的东西都像

00:35:11.920 --> 00:35:16.240
像bool或struct等等，所有这些东西都是

00:35:16.240 --> 00:35:19.599
结构类型，以便将它们全部表示为地图，因此您可以

00:35:19.599 --> 00:35:22.800
发现您序列化了它们，所以您会喜欢

00:35:22.800 --> 00:35:27.280
魔术键叫做kind，然后是字符串或struct或其他任何东西

00:35:27.280 --> 00:35:31.839
将是值，我将所有这些都切换为关键联合

00:35:31.839 --> 00:35:34.400
这意味着像其余部分的身体一样

00:35:34.400 --> 00:35:38.000
被一个缩进，然后单词字符串出现在前面

00:35:38.000 --> 00:35:42.720
作为地图键，而kind关键字就消失了，因为

00:35:42.720 --> 00:35:48.000
它现在用一个键编码为地图，键是提示

00:35:48.960 --> 00:35:55.119
所以坦率地说，我这样做是为了方便开发，但是

00:35:56.400 --> 00:35:59.440
这也是我想要抛弃的东西

00:35:59.440 --> 00:36:04.960
看看我们将其用作狗食示例的感觉，因为

00:36:04.960 --> 00:36:09.040
键控联合表示是对解析器最友好的表示形式

00:36:09.040 --> 00:36:13.280
而且我正计划对此发表更大的文章

00:36:13.280 --> 00:36:15.760
也很快，因为我认为这是我们谈论的话题

00:36:15.760 --> 00:36:18.000
口语几次，但我们需要

00:36:18.000 --> 00:36:21.920
可链接的参考文献，其原因是

00:36:21.920 --> 00:36:28.560
ketune通常更可取，因为关键总是在价值之前

00:36:28.560 --> 00:36:33.520
这对于其他表示策略来说很方便

00:36:33.520 --> 00:36:36.640
工会我们已经描述了所有这些，因为它们是我们所需要的

00:36:36.640 --> 00:36:41.200
参见现有协议，我们希望能够描述但

00:36:41.200 --> 00:36:45.440
使用内联等其他策略

00:36:45.440 --> 00:36:50.880
完全有效，对于种类提示或成员资格提示低于

00:36:50.880 --> 00:36:54.480
一堆数据（如果您已将此东西序列化为

00:36:54.480 --> 00:36:58.400
地图，地图顺序就像是，没有顺序

00:36:58.400 --> 00:37:02.240
那么这可能会以不幸的顺序发生

00:37:02.240 --> 00:37:08.000
这可能令人不快解析，因为这意味着您可能必须解析

00:37:08.000 --> 00:37:11.680
一堆数据，然后才能成为会员

00:37:11.680 --> 00:37:14.320
提示，所以您拥有所有这些数据，并且您

00:37:14.320 --> 00:37:19.119
要么不得不喜欢解析它，但实际上不抬起头

00:37:19.119 --> 00:37:21.440
代币发行是因为您还不关心它们，因为您不知道

00:37:21.440 --> 00:37:24.160
他们的目的是什么，然后得到您的提示，然后

00:37:24.160 --> 00:37:27.119
回溯原始数据并再次解析

00:37:27.119 --> 00:37:30.720
现在您有了令牌，或者可以尝试缓冲令牌，或者可以

00:37:30.720 --> 00:37:34.079
以您想要的任何方式进行缓冲

00:37:34.079 --> 00:37:38.560
基本上，但是如果这些信息的顺序不愉快，那么您就是

00:37:38.560 --> 00:37:42.320
卡住了缓冲内容，基本上遍历了一堆东西

00:37:42.320 --> 00:37:47.440
连续两次，因为第一次看到它，您还不知道它是什么

00:37:47.440 --> 00:37:50.640
如果这些结构真的很大，例如

00:37:50.640 --> 00:37:56.480
兆字节大小的块中的第一件事，是说一个联合，结果是

00:37:56.480 --> 00:38:01.280
是999 KB

00:38:01.280 --> 00:38:07.839
数据，然后该块的最后两个单词是您的联合判别式

00:38:07.839 --> 00:38:11.359
提示您的解析器会很伤心吧

00:38:11.359 --> 00:38:16.560
将分配大量内存来处理此问题

00:38:17.680 --> 00:38:21.440
因此，热联盟在这方面有了跨越式发展，因为在每个编解码器中，

00:38:21.440 --> 00:38:23.920
看到键在值之前出现，然后这个

00:38:23.920 --> 00:38:30.000
只是保证可以解决，所以我会在改变方案时dog狗

00:38:30.000 --> 00:38:34.000
使用这种格式的模式的数量可以说更少

00:38:34.000 --> 00:38:35.680
漂亮，我不知道这是我们所要做的

00:38:35.680 --> 00:38:40.079
应该讨论一下，最大的变化之一是

00:38:40.079 --> 00:38:42.880
以前在游戏中使用的单位类型有一张地图

00:38:42.880 --> 00:38:47.359
一堆键以及所有含义和值的键

00:38:47.359 --> 00:38:49.920
都为空

00:38:52.320 --> 00:38:56.000
这是在现有的杂乱描述中

00:38:56.000 --> 00:38:59.520
这就是其中的一种

00:38:59.520 --> 00:39:02.880
有点老了，就像是对事情的早期草稿，它只是

00:39:02.880 --> 00:39:06.160
活到现在，我认为这实际上是技术上的

00:39:06.160 --> 00:39:12.640
错了，它不能编译，所以我想做的是建议我们需要

00:39:12.640 --> 00:39:17.040
我们需要能够声明具有以下特征的类型的单位种类

00:39:17.040 --> 00:39:21.839
一个有效的成员，所以如果我们这样做，那么我们可以说单位种类

00:39:21.839 --> 00:39:26.800
具有null的表示形式，则架构的化学成分将变为

00:39:26.800 --> 00:39:30.400
正确的局部和可指定的

00:39:30.480 --> 00:39:34.079
我提出的这份公关草案有些不同

00:39:34.079 --> 00:39:37.680
因为还没有引入单位种类

00:39:37.680 --> 00:39:44.640
我做了一个占位符，基本上是类型单位结构

00:39:44.640 --> 00:39:47.920
什么也没有，具有正确的语义

00:39:47.920 --> 00:39:51.599
但这意味着架构架构中的所有这些内容现在都已序列化为

00:39:51.599 --> 00:39:56.320
空的地图，因此可以正常工作，并且通过了所有类型

00:39:56.320 --> 00:40:01.599
在我的演示中使用cogent类型检查和一致性的东西，但喜欢

00:40:01.599 --> 00:40:05.280
也许这不是我们想要的，所以引入一个真正的单位种类会

00:40:05.280 --> 00:40:08.480
让我们在这里做得更好

00:40:08.960 --> 00:40:12.720
嗯，是的，那个单位的东西适用于

00:40:12.720 --> 00:40:17.599
嗯，基本上，所以我认为这些是命名的最大变化

00:40:17.599 --> 00:40:22.240
真的不是很有趣，所以我想问的就是我不知道

00:40:22.240 --> 00:40:27.359
看看那个咨询你的心告诉我你的感觉

00:40:27.359 --> 00:40:31.760
嗯，抱歉，我正在查看单位类型的问题

00:40:31.760 --> 00:40:36.000
你能尽量简洁地告诉我为什么吗

00:40:36.000 --> 00:40:40.800
定义一个具体的null并不能解决这个问题

00:40:41.280 --> 00:40:45.359
嗯，但那是我不知道那是同一回事

00:40:45.359 --> 00:40:49.359
重要的是基数等于一个我并不在乎我们所说的

00:40:49.359 --> 00:40:52.800
我认为我们应该称它为单位，因为文学是

00:40:52.800 --> 00:40:57.920
与其他编程语言理论的历史非常一致

00:40:58.160 --> 00:41:01.839
所以您是否建议即使我们将null删除，也应将其删除

00:41:01.839 --> 00:41:04.400
数据模型

00:41:05.839 --> 00:41:11.119
奇怪的是，这真的让我感到烦恼，因为现在我们的文档种类和模式

00:41:11.119 --> 00:41:14.319
确实说这是表示形式的超集，

00:41:14.319 --> 00:41:17.920
有点烦人，使之复杂化

00:41:18.839 --> 00:41:22.000
嗯，也许我们可以小心地表述为

00:41:22.000 --> 00:41:26.720
表示架构类型级别的单位是

00:41:26.720 --> 00:41:34.240
在表示形式级别与null相同

00:41:34.240 --> 00:41:37.599
就是这样，看起来确实很复杂

00:41:37.599 --> 00:41:40.880
当我们有一个基数的一件事或任何对不起

00:41:40.880 --> 00:41:48.720
与现在相比，单位时间欢迎我们购买任何东西吗

00:41:48.720 --> 00:41:52.640
像是喜欢教练或喜欢

00:41:52.640 --> 00:41:57.280
是的，它是否确实如此，是否真的只是一个像它那样的问题

00:41:57.280 --> 00:42:00.800
像是对它的作用或作用的更好描述

00:42:00.800 --> 00:42:08.000
真的很喜欢，所以好处是

00:42:08.000 --> 00:42:11.359
它的工作方式与编写时的模式完全一样

00:42:11.359 --> 00:42:17.119
在这方面实际上是错误的，只是这样，不是，不是

00:42:17.119 --> 00:42:23.040
像现在一样进行编译，此映射是的定义的一部分

00:42:23.040 --> 00:42:25.040
模式方案中的电子新闻，它具有

00:42:25.040 --> 00:42:28.640
字符串值，那很重要，然后

00:42:28.640 --> 00:42:34.640
该映射中的所有值都为null，因此

00:42:34.640 --> 00:42:40.560
有效的json肯定很棒，但是架构架构

00:42:40.560 --> 00:42:44.000
它描述的类型将此部分描述为地图

00:42:44.000 --> 00:42:47.599
的键是字符串，值是大写n

00:42:47.599 --> 00:42:52.319
 null，好像大写n null是模式架构中其他位置的类型

00:42:52.319 --> 00:42:56.160
这不是只是一个不完整的参考，无法编译

00:42:56.160 --> 00:43:00.000
因此引入单位种类将使我们

00:43:00.000 --> 00:43:06.240
定义这样的类型并完成它，以便它可以这样编译

00:43:06.240 --> 00:43:09.680
空类型的定义

00:43:11.040 --> 00:43:18.000
您可以只定义null类型，就像我们可以将unit称为null

00:43:18.000 --> 00:43:26.480
只要它达到基数就可以命名，我一点也不在乎

00:43:26.480 --> 00:43:30.640
我认为我认为我们仍然可能会错过那些细微之处

00:43:30.640 --> 00:43:35.920
使这个东西比仅仅使null更引人注目

00:43:35.920 --> 00:43:42.720
您可以参考的东西，因为我们仍然需要它

00:43:46.079 --> 00:43:49.280
这是一个很薄的说法，说应该有类型

00:43:49.280 --> 00:43:55.200
我们可以说他们只是居民的人不是所有人

00:43:55.200 --> 00:43:58.720
我认为能够引入一个以上的代表策略是

00:43:58.720 --> 00:44:02.720
也理智，因为它不是永远不会

00:44:02.720 --> 00:44:07.359
我看到有人在上的某个地方制作了一些协议和一些json api

00:44:07.359 --> 00:44:10.400
互联网，并在其中提供了值可以映射的地图

00:44:10.400 --> 00:44:14.079
从字面上看只是真实的，其他任何值都是错误的

00:44:14.079 --> 00:44:18.560
人们这样做，所以我很想能够通过说来代表这一点

00:44:18.560 --> 00:44:21.839
哦，是的，这是某种类型的

00:44:21.839 --> 00:44:25.920
单位种类及其表示为真

00:44:26.720 --> 00:44:29.760
我认为那会很方便

00:44:33.599 --> 00:44:36.480
也可以说这不是世界上最重要的事情

00:44:36.480 --> 00:44:39.760
但这才是真正涵盖的内容

00:44:39.760 --> 00:44:43.440
所有这些情况下，人们都需要具体的终结器

00:44:43.440 --> 00:44:48.160
并且一致，但除了提供

00:44:48.160 --> 00:44:54.400
终止符，null确实会给您但

00:44:54.400 --> 00:45:01.040
是的，还有其他奇怪的用途，例如空击空空地图或

00:45:01.040 --> 00:45:06.960
是，还是一个或零个，是的，所以就像我第一次

00:45:06.960 --> 00:45:10.560
起草不是第一次

00:45:10.560 --> 00:45:14.960
选择器架构的第39稿

00:45:14.960 --> 00:45:18.720
我想让匹配器类型为b [音乐]

00:45:18.720 --> 00:45:22.880
只是应该始终将其序列化为true，因为那是终止符

00:45:22.880 --> 00:45:26.800
该递归系统，我想让它出现

00:45:26.800 --> 00:45:32.400
一如既往地看起来不错，这是不可能的

00:45:32.400 --> 00:45:36.000
当时以架构语言表达

00:45:37.920 --> 00:45:41.040
所以如果你说你有不同的感觉

00:45:41.040 --> 00:45:44.720
表示会有意义，那么拥有一个

00:45:44.720 --> 00:45:51.280
单位类型（默认表示为null），您可以定义其他类型

00:45:51.280 --> 00:45:57.040
代表也许我认为是的也许是

00:45:57.040 --> 00:46:02.000
所以对于那些不在乎的人来说就像是喜欢

00:46:02.000 --> 00:46:05.359
现在是

00:46:05.520 --> 00:46:12.960
但是照顾可以做任何他们喜欢的事

00:46:12.960 --> 00:46:17.040
每隔一段时间，您会发现这种情况并不经常发生，但是

00:46:17.040 --> 00:46:20.720
您可能会想象有人在写工会

00:46:20.720 --> 00:46:24.000
实际上有一种以上的成员类型

00:46:24.000 --> 00:46:32.000
很好，很有趣

00:46:34.640 --> 00:46:38.880
哦，我认为那是听起来比以前更奇怪的事情之一

00:46:38.880 --> 00:46:43.839
缠住你的头

00:46:49.200 --> 00:46:57.119
嗯，这是您在滑雪面罩电子邮件中所做的孩子还是内联的原因？

00:46:57.119 --> 00:47:03.280
 iii不知道我被撕裂了，因为有一些方便的地方

00:47:03.280 --> 00:47:07.280
内联在哪里，如果您在

00:47:07.280 --> 00:47:12.000
在数据模型级别的内存级别，更容易

00:47:12.000 --> 00:47:15.520
处理比那是我的JavaScript的事情

00:47:15.520 --> 00:47:18.800
害怕，是的，我知道我知道我敢打赌，你正在处理一件事情，

00:47:18.800 --> 00:47:22.240
这个单位的事情是一件事情，所以我们正在做一些事情

00:47:22.240 --> 00:47:28.960
我们在这里做了一些妥协，但是，嗯，原因很多

00:47:28.960 --> 00:47:33.839
为什么内联只是一团糟，我们甚至建议您推荐

00:47:33.839 --> 00:47:37.359
他们就像我们有内联主要是因为

00:47:37.359 --> 00:47:41.359
那就是野外存在大量数据的原因

00:47:41.359 --> 00:47:43.359
只是这似乎是一种自然的格式

00:47:43.359 --> 00:47:49.520
很多人所敬畏的人更加清洁和友善

00:47:50.480 --> 00:47:55.599
只是比较干净呃，但是[音乐]

00:47:55.599 --> 00:47:59.280
是的，实际上是的，而且更多的是，我认为

00:47:59.280 --> 00:48:06.000
唯一的密钥，甚至还很友好，也许不是密钥的那种

00:48:06.000 --> 00:48:11.920
当您处于在线状态时，它肯定比嵌入式um更为直观

00:48:11.920 --> 00:48:16.800
查看数据和内联需要您做很多事情

00:48:16.800 --> 00:48:20.400
许多认知跳跃来处理它

00:48:20.400 --> 00:48:23.599
而键控就像有一把钥匙

00:48:23.599 --> 00:48:29.839
这是全部的键，而内联则可以

00:48:29.839 --> 00:48:33.359
属性，在这种状态下，这些属性存在，但

00:48:33.359 --> 00:48:35.200
在另一种状态中，有一个

00:48:35.200 --> 00:48:39.520
指示器，您知道，所以它们对您而言要愉快得多

00:48:39.520 --> 00:48:44.720
看看并了解他们，他们只是更多一点

00:48:44.720 --> 00:48:47.119
效率低下，这就是问题的根源所在

00:48:47.119 --> 00:48:54.079
这些孩子工会是

00:48:54.079 --> 00:49:01.119
使它们变得非常有意义，但是它们可以引导您进入

00:49:01.119 --> 00:49:04.160
不需要做某事的不正常情况

00:49:04.160 --> 00:49:07.599
因为因为因为你这样做

00:49:07.599 --> 00:49:11.760
这些都是美学的，它们不是真正的美学，而是

00:49:11.760 --> 00:49:16.240
舒适性的原因看起来似乎很好，所以文件硬币中的关键联合

00:49:16.240 --> 00:49:20.480
手是完全的浪费，但是这样做是因为感觉

00:49:20.480 --> 00:49:25.200
在数据模型中，我认为一个可能

00:49:25.200 --> 00:49:28.480
有一个奇怪的进化故事，因为我认为那种工会

00:49:28.480 --> 00:49:32.400
在filecoin人们写的那个时候还不存在，或者

00:49:32.400 --> 00:49:35.280
可能只是他们没有的消息传播速度

00:49:35.280 --> 00:49:38.319
知道当时存在，但不是，不是在建造

00:49:38.319 --> 00:49:44.000
根据我们工会的想法，

00:49:44.000 --> 00:49:49.440
我们已经讨论过了，我不知道奇怪的并行进化

00:49:51.359 --> 00:49:56.800
无论如何，好吧，我认为这是单位

00:49:56.800 --> 00:50:00.000
我认为你在伸展它，但是

00:50:00.079 --> 00:50:03.760
嗯，因为你要添加，就像我只是在想像

00:50:03.760 --> 00:50:07.280
引入此东西所需的所有更改，这很多

00:50:07.280 --> 00:50:12.720
就像文档一样，是的，这个单元真的很烦人

00:50:12.720 --> 00:50:15.040
嗯

00:50:16.640 --> 00:50:26.480
是的，我认为我们确实需要它，尽管像

00:50:26.480 --> 00:50:29.839
除非我们介绍了这种模式，否则它不会编译

00:50:29.839 --> 00:50:35.440
否则我们会介绍实际上没有正确编译的技巧

00:50:35.440 --> 00:50:41.680
现在那是无法形容的，是可以修复的，就像那是我们所要做的

00:50:41.680 --> 00:50:44.960
可以解决这个问题，这将与我们的数据模型保持一致

00:50:44.960 --> 00:50:49.200
我们给您一个具体的类型以匹配我们所说的数据模型所具有的

00:50:49.200 --> 00:50:55.839
好吧，这可能是正确的，但我们仍然需要

00:50:56.960 --> 00:51:00.319
不管您叫新事物单元还是叫新事物都没关系

00:51:00.319 --> 00:51:04.960
像它一样为null没关系，因为如果您将其称为unit，则必须执行

00:51:04.960 --> 00:51:09.359
所有其他使单元成为一件事情的工作，我们不需要使用null来完成

00:51:09.359 --> 00:51:13.280
因为我们已经拥有它，我很确定像dsl

00:51:13.280 --> 00:51:20.160
解析器，其余所有东西都无法正确支持

00:51:20.839 --> 00:51:23.839
然而

00:51:24.160 --> 00:51:27.200
还有其他一些奇怪的东西

00:51:27.200 --> 00:51:32.400
即使有，但我不认为它有

00:51:33.680 --> 00:51:36.880
就像我不认为工会会支持任何这些行为

00:51:36.880 --> 00:51:40.160
现在正确地有些像一般

00:51:40.160 --> 00:51:43.599
围绕此未完成的位

00:51:48.079 --> 00:51:50.800
我不知道可能需要更多评论，但是我很确定

00:51:50.800 --> 00:51:53.839
这里要处理的事情

00:52:03.359 --> 00:52:07.119
因为像现在这样，我绝对无法

00:52:07.119 --> 00:52:12.079
我的任何令人信服的东西至少要解析

00:52:12.480 --> 00:52:19.920
任何其他类型的类型定义中的null和

00:52:19.920 --> 00:52:25.119
就像您在我说得好之前说过的那样，这是一件容易的事

00:52:25.520 --> 00:52:29.760
这就像语言一样归结为它

00:52:29.760 --> 00:52:33.280
我不知道你现在是否愿意

00:52:33.280 --> 00:52:38.000
具有严格匹配具有字符串值的映射的架构

00:52:38.000 --> 00:52:41.200
或字符串键，并且值必须为null

00:52:41.200 --> 00:52:47.839
您如何编写一个ipld模式说

00:52:48.640 --> 00:52:52.319
好吧，我们正在努力使空类型具体

00:52:52.319 --> 00:52:55.359
那是你可以参考的东西

00:52:55.359 --> 00:53:01.119
嗯，我的意思是我认为我了解您的问题，但我仍然认为这更重要

00:53:01.119 --> 00:53:05.520
的更多是在您的领域

00:53:05.520 --> 00:53:10.960
有关您的类型的约束您的内存类型不是那么多

00:53:10.960 --> 00:53:15.200
模式本身，因为您可以解决该问题

00:53:15.200 --> 00:53:19.680
实例化一个comp我认为只是修复

00:53:19.680 --> 00:53:23.680
我认为我们有一些工作要做

00:53:26.400 --> 00:53:30.160
我不知道也许您在javascript中实现了更多此类功能

00:53:30.160 --> 00:53:32.800
事情已经比我做过的要多

00:53:32.800 --> 00:53:38.960
像这样的不同观点，我正在寻找东西

00:53:38.960 --> 00:53:44.160
我只是对此空现象没有任何特殊处理

00:53:44.160 --> 00:53:52.720
正确的只是它而已，但这确实来自

00:53:52.720 --> 00:53:57.040
ii认为这确实是因为null是一个事实

00:53:57.040 --> 00:54:01.359
头等舱和javascript中频繁使用的东西

00:54:01.359 --> 00:54:08.400
像null就是没有定义的东西，就是没有东西的东西，所以

00:54:08.400 --> 00:54:12.880
这是一个具体的事情，所以我们

00:54:13.040 --> 00:54:16.160
所以它自然会在语言中掉出来

00:54:16.160 --> 00:54:23.040
当它成为默认案例时，无需过多的努力等等

00:54:23.040 --> 00:54:27.040
也许它没有出现在我正在看的这里，因为

00:54:27.040 --> 00:54:32.160
它被隐式地用作只是掉出来的东西

00:54:33.040 --> 00:54:36.480
它的解释不是很好，但是这里有一个区别

00:54:36.480 --> 00:54:40.559
确实有很大不同的语言之间

00:54:47.040 --> 00:54:49.680
是的，我不知道我在想什么

00:54:50.160 --> 00:54:54.799
我不是说不，我只是说你可以认为你应该

00:54:54.799 --> 00:55:00.880
现在可以在架构dsl类型大写n中说出null

00:55:00.880 --> 00:55:07.760
空格小写n null就像我将要作为一种善意的关键字进行处理

00:55:07.760 --> 00:55:12.640
最后在那里做点什么

00:55:15.760 --> 00:55:21.839
原因也许是我认为那实际上是不允许的

00:55:23.040 --> 00:55:25.520
是的，过去不会像现在这样

00:55:25.520 --> 00:55:29.119
[音乐]但是

00:55:30.079 --> 00:55:34.079
但这是一个问题到底有多大的问题意味着它是

00:55:34.079 --> 00:55:37.280
无法解析的血液化学

00:55:37.760 --> 00:55:41.760
所以如果没有别的，我认为我们对周围的地形有一些类似的评论

00:55:41.760 --> 00:55:45.119
在这里做，然后也许我们可以弄清楚我们想要做什么

00:55:45.119 --> 00:55:49.119
为了将来的一致性而做，但是肯定有一些

00:55:49.119 --> 00:55:53.359
需要环顾四周的怪异空间

00:55:59.760 --> 00:56:05.040
是的，很好，我只是想确保

00:56:05.040 --> 00:56:08.160
在这样做之前，请仔细考虑一下，因为它是如此

00:56:08.160 --> 00:56:14.000
不平凡的嗯，是的，这是一个很大的痛苦

00:56:14.839 --> 00:56:17.839
是的

00:56:18.079 --> 00:56:26.480
好吧，我想我这次真的是真的再次结束了会议，是的，我不是

00:56:26.480 --> 00:56:28.480
认为我们会在这个问题上走得更远

00:56:28.480 --> 00:56:31.119
我并不是说

00:56:31.599 --> 00:56:39.440
好，然后再见，再见，下周见

