WEBVTT
Kind: captions
Language: zh-Hans

00:00:01.320 --> 00:00:04.399
[音乐]

00:00:15.080 --> 00:00:19.100
欢迎大家参加本周的IPL取消同步会议

00:00:19.100 --> 00:00:33.600
现在是2019年10月21日，每周我们都会讨论IPL d15的任何事情

00:00:33.600 --> 00:00:42.239
已经，我们首先开始是的，是我们的，然后经历了任何紧急情况

00:00:42.239 --> 00:00:49.230
这次我什至有一个议程项目，所以我从我自己开始，最后

00:00:49.230 --> 00:00:53.699
一周，所以我仍在努力制作蛋来支撑鸡蛋

00:00:53.699 --> 00:01:01.440
嗯，我不知道这是否是我的大脑，但就像是一个不断的忘记

00:01:01.440 --> 00:01:05.729
作品的房子，基本上就像我每天记得的每一天

00:01:05.729 --> 00:01:10.890
它是如何工作的，然后我抓到了一些东西，然后，这不起作用，然后

00:01:10.890 --> 00:01:15.689
哦，它不起作用，然后我不知道是不是，如果它只是复杂的话

00:01:15.689 --> 00:01:25.560
或者如果是我我不知道但我想我越来越近了，是的

00:01:25.560 --> 00:01:31.530
除此之外，我也喜欢，所以它与IP没有关系，但是当我这样做时，我也可以工作

00:01:31.530 --> 00:01:34.979
他妈的工作，我确实会生锈，所以在那里我会变得更好

00:01:34.979 --> 00:01:47.340
在外国，如果我如果我看着他的职能，那么如果有人有什么

00:01:47.340 --> 00:01:54.450
在这种情况下，生锈时可以ping通我并向我寻求帮助，我认为我

00:01:54.450 --> 00:01:57.840
感觉也很好，所以我主要从事错误处理，所以如果

00:01:57.840 --> 00:02:02.960
你是的，有什么问题生锈需要牙齿吗

00:02:02.960 --> 00:02:06.180
对不起，如果我摔倒了，生锈需要什么

00:02:06.180 --> 00:02:10.890
以为这是另一种方式，我以为走不了那么远

00:02:10.890 --> 00:02:16.310
是的，所以基本的通话信任，所以我们提出了一个建议，

00:02:16.310 --> 00:02:21.540
问题是，以后您将不再拥有所有这些安全保护罩钥匙

00:02:21.540 --> 00:02:26.640
因此，例如，如果黄铜恐慌就崩溃了，它就消失了，而您不想

00:02:26.640 --> 00:02:30.840
这样做，所以您想返回正确的箭头之类的东西，就是这样

00:02:30.840 --> 00:02:43.250
再次很酷的是埃里克（Eric），所以我已经有很长一段时间了

00:02:43.250 --> 00:02:48.660
又是一周，我仍然在离我不远的地方

00:02:48.660 --> 00:02:54.930
在过去的几周里，我一直在做很多研究

00:02:54.930 --> 00:03:01.260
讲述了我们可以从以下代码创建的代码中获得的性能

00:03:01.260 --> 00:03:09.140
go中的代码生成，这只是一个很深的话题，它是

00:03:09.140 --> 00:03:16.830
很难迭代，因为它一次接触所有内容，我知道

00:03:16.830 --> 00:03:20.340
可用作前一指南的高级指导的几件事

00:03:20.340 --> 00:03:24.270
使用我们的礁库的经验，该礁库进行了大量的序列化工作，

00:03:24.270 --> 00:03:30.150
通过我们现在的一些项目，我从中学到的主要知识

00:03:30.150 --> 00:03:36.180
经验是，在使事情表现良好的过程中，内存的数量

00:03:36.180 --> 00:03:40.500
分配不是大小，而是内存分配的实例数

00:03:40.500 --> 00:03:45.780
成为整体表现中最重的东西之一，我也知道

00:03:45.780 --> 00:03:50.490
从后来重新设计事物的艰难方式

00:03:50.490 --> 00:03:59.730
为了避免这种情况，这很棘手，尽管我一直在尝试提前加载其中的很多内容

00:03:59.730 --> 00:04:06.300
我不知道这是否完全明智，因为事实证明，这是我尝试做的

00:04:06.300 --> 00:04:12.180
这使我不得不实施惊人的大量系统

00:04:12.180 --> 00:04:18.000
为了获得整体的印象，如果我尝试优化或构建

00:04:18.000 --> 00:04:23.190
像一套方法一样的基准总是会变得极其极端

00:04:23.190 --> 00:04:26.880
误导，因为我会发现哦，内线

00:04:26.880 --> 00:04:32.820
能够处理这个大小的示例，并且像其他20个示例一样启用了衬里

00:04:32.820 --> 00:04:38.540
编译器优化非常特殊，我扩大了规模，但不涉及世界和

00:04:38.540 --> 00:04:45.360
试图从这些事情的底部弄清真相只是非常非常

00:04:45.360 --> 00:04:50.520
有趣，所以尝试找出在哪里摆脱这些内存分配以及如何

00:04:50.520 --> 00:04:55.320
围绕它进行设计，也可能与API设计纠缠在一起

00:04:55.320 --> 00:05:02.940
前几周的问题，这很有趣，我认为目前的方式

00:05:02.940 --> 00:05:08.910
前进将使我参与进来，只是试图建立一个表格

00:05:08.910 --> 00:05:14.610
最坏的情况是什么，然后找出哪种情况更好更好

00:05:14.610 --> 00:05:20.460
权衡我尚未找到在所有情况下均最佳的解决方案空间

00:05:20.460 --> 00:05:28.890
情况下只会涉及一些最坏情况下的选择

00:05:28.890 --> 00:05:33.570
涉及到每个节点和每个节点构建器中的内存分配

00:05:33.570 --> 00:05:41.640
整棵树，这是可以生存的，但不会发胖，有一些

00:05:41.640 --> 00:05:45.390
我可以进行分期偿还的优化，例如将其向下移动到一个

00:05:45.390 --> 00:05:52.460
非常一致地权衡取舍，然后占用的字节数就增加了

00:05:52.460 --> 00:05:59.130
并且由于GC和他们将工作保持在

00:05:59.130 --> 00:06:02.730
去运行时，事实证明，这些额外的字节将被保留

00:06:02.730 --> 00:06:09.720
在您一生中都知道，而不只是笔记生成器，也许很多

00:06:09.720 --> 00:06:19.920
应用程序将能够忽略这一点，但这不是自由贸易，所以是很长的时间

00:06:19.920 --> 00:06:22.410
短话说来，真的很难

00:06:22.410 --> 00:06:28.320
我可能需要乞求另一双眼睛来帮助我抢七

00:06:28.320 --> 00:06:36.600
确保我没有看到任何关于它的面孔，而且轶事是

00:06:36.600 --> 00:06:39.870
说很难对这种方式进行完全不同的实现

00:06:39.870 --> 00:06:45.180
今天或上个星期的结构代码，所以

00:06:45.180 --> 00:06:48.860
不使用指针而不是像上一代我那样使用大量指针

00:06:48.860 --> 00:06:55.170
认为这会更好，但实际上会稍微慢一点，并采取相同的方法

00:06:55.170 --> 00:07:02.400
出于其他整体原因的总体分配数量mm-hmm这已经很长了

00:07:02.400 --> 00:07:11.000
一周报告的事情，我有一个

00:07:11.000 --> 00:07:17.190
评论关于优化go的东西，所以要小心不要

00:07:17.190 --> 00:07:20.850
为外套平均集体优化了这么多，因为从过去开始

00:07:20.850 --> 00:07:25.680
我曾经处理过的其他事情的经验是，它在每个版本中都发生了变化

00:07:25.680 --> 00:07:30.630
他们基本上最终需要用三个来编译整个系统

00:07:30.630 --> 00:07:33.930
不同版本的代码，因为它们可以解决很多问题

00:07:33.930 --> 00:07:38.580
某些东西在新版本中不再起作用了，所以也许我

00:07:38.580 --> 00:07:42.570
猜猜我的外卖可能已经在较早的版本上进行了测试，因为您可以进行测试

00:07:42.570 --> 00:07:46.350
显然有更新的版本，但是就像我们曾经拥有的一样大

00:07:46.350 --> 00:07:49.590
基准测试仅使用较旧的代码版本运行，以查看其是否类似于

00:07:49.590 --> 00:07:54.210
匹配，或者完全拧紧，因为是的，嗯，是的

00:07:54.210 --> 00:07:57.480
但我只听过有关它的故事，所以我自己参与其中，但我听到了

00:07:57.480 --> 00:08:03.960
故事，但从历史上看，是一个巨大的窗格，是我的大部分

00:08:03.960 --> 00:08:09.120
当事情变得更好并做出一些先前的设计时，人们会感到惊讶

00:08:09.120 --> 00:08:13.170
回想起来，选择看起来很荒谬，因为那里有奇怪的优越

00:08:13.170 --> 00:08:19.950
解决方案而不是一系列特征，但是是的，这是相反的

00:08:19.950 --> 00:08:30.210
所以是的，请给我们一个麦克风，很酷，嗯，名单上的下一个是杆，所以我有一个

00:08:30.210 --> 00:08:36.900
这周听起来和埃里克（Eric）的听起来没什么两样，但肯定不那么强烈，

00:08:36.900 --> 00:08:45.930
认真的我花了我大部分时间，我们可以继续使用模式库，我花了很多

00:08:45.930 --> 00:08:49.440
时间，我相信它最终会得到回报，因为它没有连接到

00:08:49.440 --> 00:08:53.520
纯粹是素数，但我希望朝着它迈进，以便我们架起一座桥梁

00:08:53.520 --> 00:08:56.600
两者之间，以便您甚至可以阅读计划程序

00:08:56.600 --> 00:09:04.009
某公司与他们一起加入，它正在形成，我想是你

00:09:04.009 --> 00:09:08.600
现在两者之间的测试以及我所花费的一切都同步了

00:09:08.600 --> 00:09:12.439
一周的工作就像埃里克（Eric）所说的那样

00:09:12.439 --> 00:09:16.819
在无法做到的情况下，您必须做所有的事情

00:09:16.819 --> 00:09:23.680
因此，我重构了容纳计划者的数据结构以摆脱

00:09:23.680 --> 00:09:31.990
走地图让我很生气，所以基本上没有地图

00:09:31.990 --> 00:09:37.759
鬼模式库现在是所有列表，然后是自定义Jason编码

00:09:37.759 --> 00:09:43.009
使它们返回杰森地图的方法，所以现在一切都已定购

00:09:43.009 --> 00:09:47.870
保留订单，因此现在我可以在阅读书本的整个测试周期中进行

00:09:47.870 --> 00:09:51.589
计划者测试JSON版本，然后将其变回计划者

00:09:51.589 --> 00:09:55.819
再一次，我可以配对，我可以比较原始模式文本而不必担心

00:09:55.819 --> 00:10:01.550
类型在跑步之间跳来跳去，但我的意思是感觉很好

00:10:01.550 --> 00:10:10.309
只是为了保持稳定性，他们摆脱了，但后来我开始做一些

00:10:10.309 --> 00:10:15.790
对其他一些事情进行了额外的实验，然后激怒了

00:10:15.790 --> 00:10:26.059
其中的一部分是发现没有办法去阅读杰森并知道什么

00:10:26.059 --> 00:10:30.459
杰森·帕斯（Jason Paz）的命令是什么，事物的顺序是什么

00:10:30.459 --> 00:10:39.519
除非您编写了一个自定义的Jason拼图，而我们做的很棒，这就是为什么

00:10:39.519 --> 00:10:43.879
这就是改革我提到的图书馆的原因之一

00:10:43.879 --> 00:10:51.679
许多艰苦的教训的源Ramon是的，可能与我们使用1-up JSON有关

00:10:51.679 --> 00:10:57.199
JavaScript中的解析器，因为我们必须对键进行排序，但至少

00:10:57.199 --> 00:11:02.089
您可以获取基本信息，我可以阅读一下

00:11:02.089 --> 00:11:08.120
线程好兄弟，您可以使用任何解析器解析所有内容，但对于

00:11:08.120 --> 00:11:16.040
我们写的编码，所以我读了一个使我大怒的线程，终于可以了

00:11:16.040 --> 00:11:19.999
一些围棋作家，有人说我真的很想成为

00:11:19.999 --> 00:11:25.790
能够获得Jason路径的顺序，他们就像没有什么

00:11:25.790 --> 00:11:28.759
用例告诉我们用例，我想做的很好

00:11:28.759 --> 00:11:34.339
这不，这不是足够好的用例，不，不要自己写，我得

00:11:34.339 --> 00:11:39.199
我倾向于他们想保持简单和

00:11:39.199 --> 00:11:44.569
平易近人的，但这就是我不知道这是自大还是

00:11:44.569 --> 00:11:48.019
真的让我很烦的事情就像我有一个用例，我有一个用例

00:11:48.019 --> 00:11:50.720
情况下，你告诉我，我基本上是说不，你需要他妈的

00:11:50.720 --> 00:11:55.939
打电话过来自己动手做，这会让你觉得

00:11:55.939 --> 00:11:59.430
被问到的人曾在Google工作过

00:11:59.430 --> 00:12:06.439
[笑声]显然有一些扩展

00:12:06.439 --> 00:12:11.689
即将成为Jason核心编码库的核心

00:12:11.689 --> 00:12:19.699
一些钩子可以进入这个过程，但是无论如何我还是带着不好的味道离开了

00:12:19.699 --> 00:12:23.870
在一周结束时，最重要的是，我正在和一个花了

00:12:23.870 --> 00:12:27.529
一点点的时间，我们也可以去，最后我们也有同样的事情要发怒。

00:12:27.529 --> 00:12:36.829
有点，但是就像我，我不会说这是我对……的最终评估

00:12:36.829 --> 00:12:40.879
去吧，因为我完全了解我在那个阶段是的，是的，我们还没有

00:12:40.879 --> 00:12:44.959
好吧，我对这种语言没有完全的同情，所以像我这样的事情

00:12:44.959 --> 00:12:48.679
想做更多像我想使用继承的面向对象的样式

00:12:48.679 --> 00:12:51.620
正确地不要你不要那样做，所以你必须思考

00:12:51.620 --> 00:12:57.319
完全不同，因此完全不会像go程序员那样思考

00:12:57.319 --> 00:13:03.139
所以我的愤怒更多是因为饮食不按照我想要的方式工作

00:13:03.139 --> 00:13:08.449
而不是我想它想要我的方式，所以无论如何这是一个积极的

00:13:08.449 --> 00:13:14.509
经验，因为这都是学习和一切，所以只是一点点的愤怒

00:13:14.509 --> 00:13:16.720
我

00:13:19.079 --> 00:13:27.250
谢谢迈克尔，您的更新好吧，是的，所以上周在本周结束时，我

00:13:27.250 --> 00:13:31.959
最好的所有jsut都停止工作了，我一直在努力

00:13:31.959 --> 00:13:39.100
现在几个月了，这就像您可以基本编码目录文件并

00:13:39.100 --> 00:13:44.649
数据，我们就可以利用数据进行各种大麻烦的探索

00:13:44.649 --> 00:13:52.750
它的数据方面最终变得如此复杂但也相当公平

00:13:52.750 --> 00:13:56.980
可重用和相当普遍的问题，所以我将其分解为自己的规范，

00:13:56.980 --> 00:14:02.279
已发送到规格仓库，称为数据，我现在仅称其为数据

00:14:02.279 --> 00:14:07.149
我不受任何名字的束缚，所以如果有人对这些名字有所了解

00:14:07.149 --> 00:14:12.550
改变它们我改变它们在开发过程中我改变了很多

00:14:12.550 --> 00:14:16.779
其实对所有人都很不满意，所以我就像一次全面推翻

00:14:16.779 --> 00:14:20.890
就像第一个决定这些名称应该是

00:14:20.890 --> 00:14:27.250
赢了，但底层架构真的很好，因为这意味着我们

00:14:27.250 --> 00:14:33.880
是不是我们不再需要采用某种布局并将其绑定为实际的布局

00:14:33.880 --> 00:14:38.769
就像阅读代码一样，因此您基本上可以为三门高级课程的读者写书

00:14:38.769 --> 00:14:42.790
布局，然后我们想要对dag的实际方式进行任何更改

00:14:42.790 --> 00:14:46.720
在将来构建并更改算法并进行平缓或trick流乞讨或

00:14:46.720 --> 00:14:50.440
人们想做什么，或者喜欢随着时间的流逝而发生的变化

00:14:50.440 --> 00:14:53.560
可能有一个非常平坦的袋子，然后您对其进行了一些改动

00:14:53.560 --> 00:14:57.670
像那样，所有这些都将与同一个读者一起使用，所以这真的

00:14:57.670 --> 00:15:00.310
很好，这意味着我们不必去更新每个版本中的读者

00:15:00.310 --> 00:15:04.329
实现，因为有人决定使用

00:15:04.329 --> 00:15:09.160
不同的算法um，当然您仍然可以像对名称进行编码

00:15:09.160 --> 00:15:12.100
您使用的算法之类的东西，我们可以尝试使其兼容

00:15:12.100 --> 00:15:17.769
无论如何，两者之间都会重建相同的数据，因此这是真正的工作

00:15:17.769 --> 00:15:23.170
由于眼睛脱皮而造成的疼痛非常接近图像库中的图像

00:15:23.170 --> 00:15:26.410
完全根据功能完成了um

00:15:26.410 --> 00:15:30.279
未来的完整架构，在

00:15:30.279 --> 00:15:33.290
重写，所以我真的很满意

00:15:33.290 --> 00:15:38.960
我觉得我现在对人们如何消费也有了一个更好的主意

00:15:38.960 --> 00:15:42.410
将来通过不同的编程环境实现高级布局，因此

00:15:42.410 --> 00:15:45.200
有很多东西可以学习，就像我认为你最终得到的东西

00:15:45.200 --> 00:15:49.940
从您的库中导出的是类型，我们不是真的，并且喜欢什么

00:15:49.940 --> 00:15:54.140
将会发生的是，如果您有一个用于生成API的库，

00:15:54.140 --> 00:16:00.020
然后，人们将使用该库来创建一些类型，然后

00:16:00.020 --> 00:16:03.470
将它们交给其他在其架构中使用这些类型的人，这样您就可以

00:16:03.470 --> 00:16:06.530
最后以引用架构中未包含的类型的架构为结尾

00:16:06.530 --> 00:16:09.800
但他们需要先存在，然后才能实际生成API

00:16:09.800 --> 00:16:15.290
其实是因为，而您实际上并没有真正依赖的架构，因为它们

00:16:15.290 --> 00:16:19.010
取决于代码和最终使用的生成器，如果这样做的话

00:16:19.010 --> 00:16:22.820
在您将代码注入到此刻的感觉

00:16:22.820 --> 00:16:27.920
这样您就无法摆脱仅仅依赖于最终的依赖模式

00:16:27.920 --> 00:16:31.970
无论如何都需要依赖的代码，因此如果您在使用代码，则可能

00:16:31.970 --> 00:16:35.630
以及使用它们的类型，然后您的库用于生成新的

00:16:35.630 --> 00:16:41.600
api只能使用您之前会生成的其他类型的文件

00:16:41.600 --> 00:16:46.880
很有道理，我真的很想看到Eric参与这一实验

00:16:46.880 --> 00:16:53.210
放手，看看那里有什么教训重叠，但似乎这是一个

00:16:53.210 --> 00:16:59.360
有点距离是的，我的意思是你知道看到这样的感觉会很高兴

00:16:59.360 --> 00:17:03.590
他们两个最终降落的地方，因为它们肯定会有一些大的不同

00:17:03.590 --> 00:17:07.640
但我认为这就像是外卖，我有我不需要的地方，我不需要

00:17:07.640 --> 00:17:11.270
从其他地方导入模式的方法实际上是没有用的

00:17:11.270 --> 00:17:17.209
因为无论如何我都必须获取代码，并且那样会变得超级依赖

00:17:17.209 --> 00:17:20.209
在您使用的Pergamon语言上，并且如果有人写了一个

00:17:20.209 --> 00:17:23.300
与我的API生成库不同，那么它们将具有不同的

00:17:23.300 --> 00:17:29.330
共享类型和导入代码的方法，所以无论如何，但最终都是

00:17:29.330 --> 00:17:31.910
其中的也将在一个单独的模块中，因此所有数据都将在

00:17:31.910 --> 00:17:38.870
一个单独的模块，所以无论如何这都很好，我认为这对于

00:17:38.870 --> 00:17:45.470
接下来的几周，我可能会写更多的测试，并使用我现有的

00:17:45.470 --> 00:17:50.840
凤凰城的一个小项目，以便把它

00:17:50.840 --> 00:17:54.679
在我向ipfs专家咨询之前，先了解一下进度，因为它有点领先

00:17:54.679 --> 00:18:00.620
现在的时间表，然后我去写em FS的总和

00:18:00.620 --> 00:18:06.020
最重要的原语我想处理很多这样的东西，就像我不打算实现

00:18:06.020 --> 00:18:11.960
来自ipfs的em FS API，但有很多类似的需求，例如您需要一个智能图

00:18:11.960 --> 00:18:16.370
为了处理对em FS的并发更改的构建器，这就是

00:18:16.370 --> 00:18:20.390
我们需要处理的问题，并且喜欢一种非常通用的方式，我觉得P和

00:18:20.390 --> 00:18:24.140
弄清楚这些东西，反正我对这个东西有足够的经验，

00:18:24.140 --> 00:18:28.929
可以把它写出来，从时间上移到情节上

00:18:28.929 --> 00:18:35.419
无论如何，这很好，哦，我所做的另一件事我认识到了，这

00:18:35.419 --> 00:18:39.950
实际上有点烂，因为它的通知很好，所以在先前的迭代中

00:18:39.950 --> 00:18:44.840
UNIX best.i的书，我希望您像一个生成器，所以您会说go and

00:18:44.840 --> 00:18:47.570
给我这个目录，我们回到生成器中，成为所有这些块，

00:18:47.570 --> 00:18:51.679
然后在最后，您将获得根块，因此这真的很干净

00:18:51.679 --> 00:18:58.720
只会一直愈合的发电机，无法再使用的发电机

00:18:58.720 --> 00:19:04.970
因为您所创造的东西根本就不一定是

00:19:04.970 --> 00:19:08.840
不同的块，所以最终创建的是一个生成器

00:19:08.840 --> 00:19:13.630
阻塞直到产生根节点，然后实际上将您还给您

00:19:13.630 --> 00:19:18.440
本质上是schema gen的实例化类型，但它可以

00:19:18.440 --> 00:19:21.200
如果我们想写的话，可能是那个的编码版本，但是有效

00:19:21.200 --> 00:19:24.620
就像您实际上需要一些可以内联的东西

00:19:24.620 --> 00:19:29.900
其他的东西真的改变了EP眼睛看起来像他们多长时间

00:19:29.900 --> 00:19:34.850
现在产生对象是块或根，看起来更像其他对象

00:19:34.850 --> 00:19:39.230
具有类似类型变化的高级生成器，但这是一个

00:19:39.230 --> 00:19:42.320
有趣的事情要学习，例如我们如何构建事物而不是构建事物

00:19:42.320 --> 00:19:46.940
总是像打扫一样清理，只是总是给我块，因为在一些

00:19:46.940 --> 00:19:50.270
我说的范围还可以，您可以弄清楚块边界在哪里

00:19:50.270 --> 00:19:54.350
子平台，但是您需要给我一个根节点，我可以直接内联

00:19:54.350 --> 00:19:59.409
变成某种东西，因为它不一定会成为一个明显的障碍

00:19:59.409 --> 00:20:04.130
所以这也是我学到的有趣的事情

00:20:04.130 --> 00:20:08.860
然后我认为就是这样

00:20:10.210 --> 00:20:14.690
是的，有些东西不在架构中，因为我不是

00:20:14.690 --> 00:20:19.520
使用它们，并且仅支持重命名之类的功能，但尚不支持

00:20:19.520 --> 00:20:24.230
支持杂志上的代表作品，但是那里有地方

00:20:24.230 --> 00:20:28.610
对于他们来说，这是一种架构上的理解，即

00:20:28.610 --> 00:20:34.159
天哪，我只是没有做过把它们放进去的工作，是的，就是这样

00:20:34.159 --> 00:20:41.510
对我来说，迈克尔，您有三种不同外观的编码

00:20:41.510 --> 00:20:47.120
编码正在进行的事情，我认为它只是在播放字节，但Lister

00:20:47.120 --> 00:20:51.590
而不是嵌套但列表，因此从技术上讲是de Bourgh，因为它是一个

00:20:51.590 --> 00:21:00.320
内联字节链接到原始块，因为它是链接列表，这是一个内联列表

00:21:00.320 --> 00:21:04.880
没有链表，那么还有什么嵌套的袋子

00:21:04.880 --> 00:21:09.980
那是更复杂的，然后那个更复杂的东西

00:21:09.980 --> 00:21:16.520
您最终指向的叶子是指向该联合的指针，因此在

00:21:16.520 --> 00:21:21.049
今天这么大的混乱，你可能只想知道一个字节列表就更简单了

00:21:21.049 --> 00:21:25.100
对，您有启发性的建议吗？

00:21:25.100 --> 00:21:30.710
是什么会让兰斯与众不同，就像我在说，是的，这应该是

00:21:30.710 --> 00:21:34.190
灵活性应该以不同的方式做到这一点，但这是否太多了

00:21:34.190 --> 00:21:40.730
灵活性，所以在我弄清楚这一点之前，它太过灵活性了

00:21:40.730 --> 00:21:46.429
递归联合的东西，这实际上简化了它，因为一旦你

00:21:46.429 --> 00:21:49.970
将其包装在高级布局中，您只需执行以下递归读取调用即可：

00:21:49.970 --> 00:21:55.520
发生在整个堆栈中，它实际上非常简单，而且它

00:21:55.520 --> 00:21:58.880
不管您使用哪种布局算法，它的外观都将看起来完全一样

00:21:58.880 --> 00:22:03.380
最终使用，因此，如果您只有一个，那么这实际上是一种理想的选择，

00:22:03.380 --> 00:22:07.070
如果您有其他算法，您可以将其插入，但是，是的，我们的意思是

00:22:07.070 --> 00:22:10.370
有一些来自ipfs的例子，它们在乌龟袋中有平整的负子

00:22:10.370 --> 00:22:13.580
用图认为我们可能不在乎

00:22:13.580 --> 00:22:18.560
但您仍然有问题，我会创建扁平的dag或某种

00:22:18.560 --> 00:22:22.580
我想要的平衡标签，然后像这样发生变异，实际上是所有

00:22:22.580 --> 00:22:26.000
就像有个电话和ipfs电话一样，您只需编写一个

00:22:26.000 --> 00:22:29.750
夫妇在那里咬人，所以您最终要做的是遍历其中，

00:22:29.750 --> 00:22:35.540
然后只是变异那些最后的一点点，所以如果你是

00:22:35.540 --> 00:22:42.230
如果您正在阅读，请假设是版式，而不是对不起，请假设

00:22:42.230 --> 00:22:46.250
布局算法，而不是假设它们绑定到您的类型

00:22:46.250 --> 00:22:49.340
最终出现此问题，其中每个布局必须具有不同的读取

00:22:49.340 --> 00:22:54.350
方法嗯，但如果您只说没有布局就使用这些相同的类型

00:22:54.350 --> 00:22:58.640
我相信方法的类型，那么您就不需要这样做，并且您可以

00:22:58.640 --> 00:23:03.110
您可以进行变异，也可以进行真正谨慎的变异，具体取决于

00:23:03.110 --> 00:23:06.770
那些突变很大，他们也许你知道，他们创造了另一个巨大的部分

00:23:06.770 --> 00:23:10.040
带着另一个嵌套的袋子，或者他们可能就像你知道你带了一个

00:23:10.040 --> 00:23:13.610
列表并弹出一些内容，或在分钟内指出一个或

00:23:13.610 --> 00:23:21.410
是的，然后一旦您开始针对不同类型的广告进行优化

00:23:21.410 --> 00:23:24.800
我认为，突变会导致许多不同的布局

00:23:24.800 --> 00:23:27.200
那就是真正要像当前图层一样爆炸它们的东西

00:23:27.200 --> 00:23:31.700
算法只是围绕我们只有那个交换然后

00:23:31.700 --> 00:23:36.290
将这些往返行程分成几段，确实很昂贵，但我

00:23:36.290 --> 00:23:39.980
以为您看的很好，我有一个文件只附加到

00:23:39.980 --> 00:23:44.600
而且我希望经常添加到它的后面，只是您会想要一个

00:23:44.600 --> 00:23:47.990
不同的布局，我想我想更改数据布局的方式

00:23:47.990 --> 00:23:51.080
真正有效地行使这些权利并最大程度地减少您的垃圾

00:23:51.080 --> 00:23:56.780
创建，我们不想让读者被换掉，因为您有

00:23:56.780 --> 00:23:59.890
他们不同的布局

00:24:06.350 --> 00:24:12.510
好吧，我有一个内部项目，只是在这次会议的时间

00:24:12.510 --> 00:24:18.870
因为像在欧洲，夏令时很快结束，但是在我看来

00:24:18.870 --> 00:24:22.560
所以对我个人而言，如果我们只保留UTC时间，那将是很好的

00:24:22.560 --> 00:24:29.040
因为那对我来说可能要早一小时，可能在美国

00:24:29.040 --> 00:24:38.820
好吧，但是那是在一天当中，所以我不在乎我不在乎

00:24:38.820 --> 00:24:45.870
一个小时前，只是我不知道当夏令时结束时会发生什么

00:24:45.870 --> 00:24:51.030
也会在这里结束，所以他们会在一个星期后看到，所以基本上当你

00:24:51.030 --> 00:25:01.380
夏令时结束，这将是一小时的提早费用，并且已经有

00:25:01.380 --> 00:25:09.060
改变了分布的含义，就像遍布全球一样

00:25:09.060 --> 00:25:13.080
这只会使固定到UTC变得更容易，所以没有

00:25:13.080 --> 00:25:19.230
论点是的，没有任何偏好，是的，让我们固定一下，然后

00:25:19.230 --> 00:25:22.770
在其他会议上，我可能会意识到我们并没有固定住，我必须改变

00:25:22.770 --> 00:25:27.690
他们，但是是的，如果我们可以将现有会议更改为UTC

00:25:27.690 --> 00:25:34.890
而不是在特定时区，让我们做到这一点，是的，然后我

00:25:34.890 --> 00:25:41.460
认为这意味着您需要将其更改为雷克雅未克时间，不知道

00:25:41.460 --> 00:25:48.720
它已经是您可以看到的了，所以我将它固定到UTC，还可以，是的，您可以这样做

00:25:48.720 --> 00:25:59.310
它花了一段时间，但在我身上，所以

00:25:59.310 --> 00:26:05.550
应该很好，如果不是这样的话，那么我下次会照顾它的

00:26:05.550 --> 00:26:13.530
在接下来的两周内，我们将保持在相同的UTC时间内，区域发生变化

00:26:13.530 --> 00:26:16.920
为你变得更好，那不行，你早点走吧，我认为这会更好

00:26:16.920 --> 00:26:22.230
是的，所以是哟，所以基本上是冬天，所以我们喜欢

00:26:22.230 --> 00:26:29.040
欧洲冬季，所以10月至3月对欧洲人来说更容易澳大利亚是的

00:26:29.040 --> 00:26:32.370
更容易的第一个摄像头，然后我们是的，因为我们一起去我们那里，然后我们去

00:26:32.370 --> 00:26:43.920
我们他妈的时区，然后只是一个一般的注意，嗯，我下周在这里，但是

00:26:43.920 --> 00:26:50.670
那之后的一周我就整整整整一周了，是的，另外一件事

00:26:50.670 --> 00:26:55.440
我回到实验周前一周的一周后的一周是这样的

00:26:55.440 --> 00:27:00.480
他们正在做的计划周，所以我要有一个模板，有一个模板

00:27:00.480 --> 00:27:03.570
我将努力解决这个问题，并尝试弄清楚我们的2020年计划是什么，

00:27:03.570 --> 00:27:06.630
然后本周有时我会和大家分享，我只需要你

00:27:06.630 --> 00:27:10.280
在接下来的几周内获得您的反馈，以便我可以稍作定稿

00:27:10.280 --> 00:27:16.170
但这会非常简单，基本上是说我们看起来像我们

00:27:16.170 --> 00:27:19.920
努力使事情发展到可以直接接受的地步

00:27:19.920 --> 00:27:25.140
协议内部的依赖关系以及文件硬币中的ipfs，然后您知道我们

00:27:25.140 --> 00:27:29.910
将从中吸取教训，然后从中吸取我们对飞利浦之外的依赖

00:27:29.910 --> 00:27:35.220
但我不会将我们锁定在特定的时间范围内，因为我们需要

00:27:35.220 --> 00:27:44.090
有学习和整合的能力，我们将看到如何变酷

00:27:44.090 --> 00:27:59.110
我别的什么都很棒，然后我结束了会议，大家再见，

00:27:59.110 --> 00:28:02.790
 [音乐]

