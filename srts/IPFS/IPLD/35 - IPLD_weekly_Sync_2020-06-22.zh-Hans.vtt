WEBVTT
Kind: captions
Language: zh-Hans

00:00:01.280 --> 00:00:06.000
好的，我们应该现在开始录音

00:00:06.960 --> 00:00:15.440
是的，我们还好，所以大家好，今天工人和钓竿不在这里，所以

00:00:15.440 --> 00:00:20.240
我将作为ipod团队于6月22日召开这次会议的主持人

00:00:20.240 --> 00:00:28.160
嗯，是的，所以我们有普通的hack md pad

00:00:28.160 --> 00:00:33.360
即使我不太擅长我也会尝试做笔记

00:00:33.360 --> 00:00:37.680
那个很酷

00:00:37.680 --> 00:00:44.480
更新它实际上很短，上个星期的大部分时间都花在了外面

00:00:44.480 --> 00:00:49.360
如何运行猎鹰节点并进一步进行存储交易

00:00:49.360 --> 00:00:55.280
和其他不好的东西

00:00:55.360 --> 00:00:58.640
希望我们能真正达成协议

00:00:58.640 --> 00:01:05.840
明天我在等待正在工作的团队

00:01:05.840 --> 00:01:12.560
检索市场上的东西以将其放入测试测试网络中，然后

00:01:12.560 --> 00:01:17.759
我们将看看我们是否确实可以通过电线发送选择器，

00:01:17.759 --> 00:01:23.759
拿回零件，就像哈娜说的那样，应该工作，但是

00:01:23.759 --> 00:01:28.880
没有人尝试过，但这就像代码中的类型一样

00:01:28.880 --> 00:01:31.040
据说在那里，但是没人读过

00:01:31.040 --> 00:01:39.280
所以我们会看看情况如何，除此之外，我还有一点点

00:01:39.280 --> 00:01:43.840
越靠近呃，距离匕首流光越近

00:01:43.840 --> 00:01:49.840
文件系统几乎可以完成我想要的操作，但是

00:01:49.840 --> 00:01:54.399
好像还是不完全正确

00:01:54.399 --> 00:01:59.520
太多太多的内存试图一遍又一遍地做事情

00:01:59.520 --> 00:02:08.239
另一件事，顺便说一句，我有一点时间尝试新

00:02:08.239 --> 00:02:12.640
他们发布的新的基于Arm的uh aws实例

00:02:12.640 --> 00:02:15.840
我相信11日将全面上市

00:02:15.840 --> 00:02:19.040
和他们

00:02:19.760 --> 00:02:27.360
练习时可以实际到达amd r9

00:02:27.360 --> 00:02:32.400
流中的内容，这样我就可以进入该手臂实例

00:02:32.400 --> 00:02:36.800
就像一个月40 40块钱，我能够获得大约1G的存储空间，

00:02:36.800 --> 00:02:40.640
每秒有一半的吞吐量与实际哈希和

00:02:40.640 --> 00:02:44.400
一切，所以这是一件有趣的事情

00:02:44.400 --> 00:02:47.840
考虑像dumbo这样的东西往下走

00:02:47.840 --> 00:02:50.959
越走越远，而不是lambdas实际拥有你

00:02:50.959 --> 00:02:56.959
我知道钻石盒上的东西，这几乎就是我所拥有的

00:02:56.959 --> 00:02:59.360
本星期

00:03:01.360 --> 00:03:07.200
接下来我有很多笔记的埃里克

00:03:07.920 --> 00:03:11.760
好吧，我讲话时没有短期记忆，所以我必须喜欢预先写

00:03:11.760 --> 00:03:16.840
整件事，或者我只是发出很多声音，嗯，是的

00:03:16.840 --> 00:03:22.720
所以上周我尝试实施

00:03:22.720 --> 00:03:27.840
高级数据布局，因为我们最近进行了一些讨论，

00:03:27.840 --> 00:03:30.959
听起来有些担心，我们只是没有足够的证据

00:03:30.959 --> 00:03:34.239
我们知道我们正在用这些计划做什么，实际上是

00:03:34.239 --> 00:03:39.519
格式正确，所以我尝试做这件事，看看我是否遇到麻烦

00:03:39.519 --> 00:03:44.799
所以我一开始我会试图做些困难，但是我想是的

00:03:44.799 --> 00:03:48.640
那是一堆东西，所以我只是

00:03:48.640 --> 00:03:52.879
勾勒出制作假人的最简单方法

00:03:52.879 --> 00:03:57.920
示例高级数据布局，因此我发明了扇出图的概念

00:03:57.920 --> 00:04:01.760
并开始实施，这就是

00:04:01.760 --> 00:04:06.000
对于地图中的每个值，我们只是将其编码在一个新块中

00:04:06.000 --> 00:04:09.519
并将其链接放在地图内部，然后

00:04:09.519 --> 00:04:14.720
就是这样，这好像是一个完全无用的数据

00:04:14.720 --> 00:04:19.040
结构，您将不太可能使用此功能，但应该

00:04:19.040 --> 00:04:23.359
界面工作正常的证明

00:04:23.360 --> 00:04:28.400
到目前为止，没有任何主要障碍可以使仅遵从节点的策略成为可能

00:04:28.400 --> 00:04:31.120
界面似乎至少在此过程中起作用

00:04:31.120 --> 00:04:33.360
代码

00:04:33.600 --> 00:04:37.040
我可能遇到的最大问题是事实证明

00:04:37.040 --> 00:04:40.160
我需要写一些这样的东西

00:04:40.160 --> 00:04:43.759
编写另一个节点实现结果相当高

00:04:43.759 --> 00:04:46.880
这开始吸引我，因为

00:04:46.880 --> 00:04:50.479
不是阻碍者，但对代码生成的工作也很烦人，因此请看它的裁剪

00:04:50.479 --> 00:04:57.440
在另一个例子中，是让我稍后再讨论

00:04:57.440 --> 00:05:01.120
尝试做adl界面的另一件事很有趣

00:05:01.120 --> 00:05:05.039
一直有很多事情要做

00:05:05.039 --> 00:05:10.400
很好地设置其中之一，您需要所有这些指针

00:05:10.400 --> 00:05:14.320
需要指向链接加载器函数的指针以使您的内容可读

00:05:14.320 --> 00:05:17.360
嗯，您可能有很多配置资料

00:05:17.360 --> 00:05:24.240
那将是特定于adl um我想放入的一件事

00:05:24.240 --> 00:05:26.000
在那里，但我可能会退缩

00:05:26.000 --> 00:05:31.360
您可能需要一个指向内部的节点原型的指针

00:05:31.360 --> 00:05:35.440
您将要使用的结构节点，我想我是

00:05:35.440 --> 00:05:39.199
将其淘汰掉，因为那只是一种可配置性

00:05:39.199 --> 00:05:43.840
我认为你不需要像adl内部一样应该被允许

00:05:43.840 --> 00:05:48.479
考虑到他们在运行时使用的内存结构

00:05:49.360 --> 00:05:54.720
是的，第一稿是要找出各种各样的东西，例如

00:05:54.720 --> 00:05:58.319
是的，您可以使它可配置，但是如果我们不这样做的话

00:05:58.319 --> 00:06:02.160
嗯，对此可能需要做更多的工作

00:06:02.160 --> 00:06:05.759
即将到来，我想产生一些设计决策

00:06:05.759 --> 00:06:10.160
关于这个文档的好消息是

00:06:10.160 --> 00:06:13.759
所有主要接口似乎都在该节点上工作

00:06:13.759 --> 00:06:20.160
引入的原型概念有时也称为节点样式

00:06:20.160 --> 00:06:23.680
确实在这里确实有帮助，因为这给了我放置空间

00:06:23.680 --> 00:06:26.800
所有这些针对ado的配置

00:06:26.800 --> 00:06:31.199
在内存中的一个位置，然后您就可以使用普通的节点构建器来

00:06:31.199 --> 00:06:34.400
实际填写的内容，而这些都不是

00:06:34.400 --> 00:06:37.039
功能签名必须有所不同，因为所有

00:06:37.039 --> 00:06:40.720
巧妙地为adl进行了任何内部配置

00:06:40.720 --> 00:06:45.199
原型出现了，这是一个很大的缓解

00:06:45.199 --> 00:06:52.880
工作真的很好哦，是的，我可能不会说太多

00:06:52.880 --> 00:06:57.360
关于我的样板问题，但长话短说，我必须补充很多

00:06:57.360 --> 00:07:01.599
我制作的每个新注释实现中的样板方法

00:07:01.599 --> 00:07:04.960
就像如果我正在做这个新的事，它将像地图一样

00:07:04.960 --> 00:07:08.240
我必须添加所有这些方法以匹配界面，例如

00:07:08.240 --> 00:07:12.880
我可以转向字符串吗，答案是否定的

00:07:12.880 --> 00:07:20.560
尝试使这个简洁对我没有帮助

00:07:21.199 --> 00:07:25.360
嵌入并不能完全让我去做我想做的事情，或者至少他们做不到

00:07:25.360 --> 00:07:30.000
使我能够处理包含以下内容的错误消息：

00:07:30.000 --> 00:07:34.479
在其中键入信息，因为仅当您嵌入信息时

00:07:34.479 --> 00:07:37.360
认为自己无法引用

00:07:37.360 --> 00:07:42.479
它嵌入其中的东西，所以它实际上无法做到这一点

00:07:42.479 --> 00:07:45.599
在许多其他语言中，这应该很容易，就像扩展

00:07:45.599 --> 00:07:48.639
几乎每种面向对象语言中的关键字，但我只是

00:07:48.639 --> 00:07:53.759
做不到，我去尝试了越来越喜欢的东西，如使用

00:07:53.759 --> 00:07:56.800
运行时技巧以窥探调用堆栈信息并查看是否

00:07:56.800 --> 00:08:03.759
我可以从那里提取相关名称，但我行不通

00:08:03.759 --> 00:08:08.960
关于它在这里使用的逻辑非常一致

00:08:08.960 --> 00:08:13.120
不是我今天想要的，这让我有点发疯

00:08:13.120 --> 00:08:16.879
因为我也深入了汇编程序，并且喜欢这些信息

00:08:16.879 --> 00:08:21.280
是否有一个自动生成的方法存根

00:08:21.280 --> 00:08:24.720
是的，正是我想要的相关信息

00:08:24.720 --> 00:08:28.160
在嵌入另一件事的界面上

00:08:28.160 --> 00:08:32.800
但我看不到没有接口让我得到这个

00:08:32.800 --> 00:08:37.039
我发现如果互联网上有人在看这个谁知道

00:08:37.039 --> 00:08:42.080
很酷的地鼠把戏，请与我联系并解决我的问题

00:08:42.080 --> 00:08:46.080
问题同时让我难过和样板

00:08:46.080 --> 00:08:50.800
很丰富，但是一切正常，很烦人

00:08:51.360 --> 00:08:54.959
芬兰人，我最近真的很沮丧，我不知道那件事是否会出现，但是

00:08:54.959 --> 00:08:58.640
是的，你考虑过吗，你知道这个

00:08:58.640 --> 00:09:02.399
他们发布的具有遗传学的实验性实现

00:09:02.399 --> 00:09:08.240
恰好反对它，一年半之后，我们只是

00:09:08.240 --> 00:09:11.839
是的，我想让事物更快地进入人们的手中，我也不想建立

00:09:11.839 --> 00:09:17.920
在这样的沙子上我也不确定这会有所帮助

00:09:18.240 --> 00:09:23.839
好吧，我认为锅炉方法不会有帮助

00:09:26.720 --> 00:09:29.680
我看上去还不足以自信地说这无关紧要，但我

00:09:29.680 --> 00:09:34.640
如果它像我想要的其他语言一样相关，将会感到惊讶

00:09:34.640 --> 00:09:38.160
不会是泛型，就像特质或

00:09:38.160 --> 00:09:43.279
子类化或类似其他虚拟类型继承的东西

00:09:43.279 --> 00:09:47.760
然后，如果golang对泛型的定义如此，我将感到非常惊讶

00:09:47.760 --> 00:09:50.640
有趣的是，它实际上适用于此

00:09:50.640 --> 00:09:55.200
可能我根本不知道这听起来像是您当时的东西

00:09:55.200 --> 00:09:59.600
谈论它将浮出水面，以便遗传

00:09:59.600 --> 00:10:03.760
按照博客文章中所述的方式工作，正是您缺少的此信息

00:10:03.760 --> 00:10:07.040
对于错误等等等等需要

00:10:07.040 --> 00:10:11.040
运输到可见的地方，这样您就不会再有这个问题了

00:10:11.040 --> 00:10:19.839
但我知道

00:10:20.160 --> 00:10:27.200
好吧，我想我起来了，是的，所以我做了很多事情，将其移植到

00:10:27.200 --> 00:10:33.680
esm模块标准版，我开始这样做，但我没有意识到

00:10:33.680 --> 00:10:38.240
我做这个事情有多早，我的意思是人们一直在使用esm

00:10:38.240 --> 00:10:42.720
例如整个js生态系统的五年时间，但嗯

00:10:42.880 --> 00:10:48.079
在仍然需要使用nade的节点程序中使用它

00:10:48.079 --> 00:10:52.800
使用本机节点esm之类的东西几乎没有人没有

00:10:52.800 --> 00:10:56.560
做的人很少，所以写它的人正在使用它

00:10:56.560 --> 00:11:00.800
一包um，有一个例子

00:11:00.800 --> 00:11:04.480
仍然允许仍然能够使用commonjs require并且它要求您

00:11:04.480 --> 00:11:11.760
编译需要的软件包版本

00:11:11.760 --> 00:11:14.959
这就是我们在所有工作中都在做的事情

00:11:14.959 --> 00:11:20.240
模块，现在有所有入口点文件的压缩版本

00:11:20.240 --> 00:11:24.399
用户需要的，我也想出了如何交叉

00:11:24.399 --> 00:11:28.079
编译所有测试，以便针对

00:11:28.079 --> 00:11:32.240
这也需要，所以真的很好，所有这些

00:11:32.240 --> 00:11:35.200
现在已经更新了所有多种格式，几乎所有

00:11:35.200 --> 00:11:38.160
我认为我需要去依赖一个散列函数

00:11:38.160 --> 00:11:41.519
就像整个生态系统中的许多项目一样

00:11:41.519 --> 00:11:46.000
嗯，我还将所有发布自动化更新到了我的最新版本

00:11:46.000 --> 00:11:49.360
自动化的东西嗯，我现在有一个脚本来更新它

00:11:49.360 --> 00:11:54.000
在未来，这很好，区块api也是最新的

00:11:54.000 --> 00:11:58.160
现在有一个公关需要审查，我需要杆，并在我合并之前穿上它

00:11:58.160 --> 00:12:00.959
嗯，然后迁移终于结束了

00:12:00.959 --> 00:12:05.279
完成，真棒

00:12:05.279 --> 00:12:08.320
然后整个星期我做了很多管理工作

00:12:08.320 --> 00:12:14.480
嗯，上个季度我需要大家的赞誉，所以如果您有赞誉，我认为

00:12:14.480 --> 00:12:19.120
埃里克（Eric）现在在这里，所以给您的Okrs Bro打分，那里有一个公关

00:12:19.120 --> 00:12:22.560
在路线图存储库中，您已经可以打分了

00:12:22.560 --> 00:12:27.760
然后我正在为下个季度工作

00:12:27.760 --> 00:12:31.040
我认为对每个人来说最重要的是我要裁掉

00:12:31.040 --> 00:12:34.000
文档周，这实际上是eric的建议

00:12:34.000 --> 00:12:37.279
我要继续使用它，但是我们要剪掉一个星期，每个人都在

00:12:37.279 --> 00:12:41.279
团队写了文件um，我和特里谈过，她

00:12:41.279 --> 00:12:45.440
同意每天预留时间对所有文档进行同步审核

00:12:45.440 --> 00:12:50.480
我们整个星期都在建立，所以我们可以得到imp的输入

00:12:50.480 --> 00:12:53.680
一个对艺术一无所知的人，她对自己的艺术知识很了解，但是

00:12:53.680 --> 00:12:58.639
她喜欢从这种外部保持很好的视野

00:12:58.639 --> 00:13:00.639
的东西，所以她非常擅长查看文档

00:13:00.639 --> 00:13:07.920
嗯，是的，这太棒了，请记住这一点，

00:13:07.920 --> 00:13:14.079
嗯，这就是我所拥有的全部，我认为是公开的，是的

00:13:14.079 --> 00:13:18.839
我一周只发表评论可能还不够，但这是一个

00:13:18.839 --> 00:13:22.639
如果我们在那个星期都这样做的话，我想

00:13:22.639 --> 00:13:27.200
我们会得到所有主要的东西，就像最主要的是

00:13:27.200 --> 00:13:31.440
当前的资源很差，所以我们至少会把它们拆掉

00:13:31.440 --> 00:13:35.040
或用更糟的东西代替它们，它们不会是完整的

00:13:35.040 --> 00:13:38.560
但他们会不会像狗屎一样令人困惑

00:13:38.560 --> 00:13:43.600
这就是现在的情况，是的，文档不应该让人

00:13:43.600 --> 00:13:47.120
不太像那样理解

00:13:47.120 --> 00:13:52.000
我把门槛调低了

00:13:52.000 --> 00:13:55.680
是的，那是因为在一周中

00:13:56.079 --> 00:13:59.760
是的，我希望做的很多事情都像是确保高

00:13:59.760 --> 00:14:02.399
存在层次结构，因为即使我们所做的事情

00:14:02.399 --> 00:14:06.320
记录下来，他们就像有时候我们有一个小的角落

00:14:06.320 --> 00:14:10.079
像是有据可查的东西，但它并没有连接到更大的东西

00:14:10.079 --> 00:14:15.040
以足够导航的方式来显示图片，就像任何人都喜欢

00:14:15.040 --> 00:14:19.839
找到那些股票，您必须详尽阅读所有内容，然后也许

00:14:19.839 --> 00:14:21.839
您意识到自己找到了想要的部分

00:14:21.839 --> 00:14:27.519
但就像进入和导航的障碍只是目前

00:14:27.519 --> 00:14:31.839
很多，该网站只会让您对它的了解减少

00:14:31.839 --> 00:14:36.399
是的，该网站的网站就像是几乎是错误的信息

00:14:36.399 --> 00:14:39.839
就像不是不真实，就像没有用

00:14:39.839 --> 00:14:45.680
它是为非常陌生的观众设计的，我什至不确定是否存在

00:14:45.680 --> 00:14:49.279
实际上，在我们像扑自己的克里斯一样走得更远之前，你是什么

00:14:49.279 --> 00:14:51.839
接受我们的文件，您有点像

00:14:51.839 --> 00:14:55.040
外部消费者

00:14:56.839 --> 00:15:01.440
嗯，我认为

00:15:02.240 --> 00:15:08.320
我正在尝试思考我该怎么说，我的意思是我认为整个项目

00:15:08.320 --> 00:15:12.959
所以有很多好的文档在某些方面有些误导

00:15:12.959 --> 00:15:16.240
因为似乎事情更被思考

00:15:16.240 --> 00:15:18.480
比他们想象的要大，一旦你有点像回皮

00:15:18.480 --> 00:15:22.079
像有些东西还在不断变化的层

00:15:22.079 --> 00:15:26.639
我想我被误导了几次，就像他们已经弄清楚了所有这些东西一样

00:15:26.639 --> 00:15:28.480
出去，而你有很多东西

00:15:28.480 --> 00:15:30.560
弄清楚有些东西不是

00:15:30.560 --> 00:15:34.720
他们仍然在不断变化，或者你知道，我认为那是很难的

00:15:34.720 --> 00:15:39.440
一部分是要知道什么是完全完整的，并且喜欢

00:15:39.440 --> 00:15:42.720
去与什么是全新的和你

00:15:42.720 --> 00:15:45.839
如果您确实需要，可以触摸一下

00:15:45.839 --> 00:15:49.440
也许是避免它与我们只是不知道的事情相比，但是

00:15:49.440 --> 00:15:53.680
我们有一些想法，所以我想以某种方式进行布局，以便作为消费者

00:15:53.680 --> 00:15:59.759
您知道什么可以安全使用，什么不可以使用

00:16:00.000 --> 00:16:04.639
是的，我想我不记得是谁的建议

00:16:04.639 --> 00:16:09.839
杆或实际上是一个杆，但嗯，我们真的应该有一个条目

00:16:09.839 --> 00:16:13.040
指向每种语言堆栈，例如您实际要去的地方

00:16:13.040 --> 00:16:17.440
编写代码，然后可以更好地将您指向

00:16:17.440 --> 00:16:20.160
就像那些真正牢固的东西和你应该真正做到的东西

00:16:20.160 --> 00:16:22.800
依靠并转移其他一些

00:16:22.800 --> 00:16:26.800
一点点，因为它现在确实改变了我的语言，就像您应该的一样

00:16:26.800 --> 00:16:30.959
弄得乱七八糟，你应该怎么做，是的，我想这也像我

00:16:30.959 --> 00:16:34.800
从javascript的角度来看

00:16:34.800 --> 00:16:37.519
后来我发现，很快就可以意识到

00:16:37.519 --> 00:16:42.320
有点像你知道最成熟的高级

00:16:42.320 --> 00:16:46.399
嗯，实际上有点丢了一步，先在那完成

00:16:46.399 --> 00:16:51.199
并滴流下来，但实际上可能不是

00:16:51.199 --> 00:16:56.880
完全正确，我认为一般而言ipfs通常是工作方式

00:16:56.880 --> 00:17:05.199
是的，可以肯定的是，实际上去不是

00:17:06.240 --> 00:17:13.120
新的好像还没完成，但肯定是个头，然后是旧的

00:17:13.120 --> 00:17:16.160
一个比所有的javascript东西都老

00:17:16.160 --> 00:17:20.400
但后来javascript的东西就像一堆仍然需要依靠的东西

00:17:20.400 --> 00:17:26.480
在ipfs中，这是老东西了，是的

00:17:29.120 --> 00:17:34.799
是的，如果你是我的话，嗯，也许我会说，我不知道该怎么做。

00:17:34.799 --> 00:17:36.880
处理另一种语言的东西，因为它将

00:17:36.880 --> 00:17:40.799
它们之间在成熟度和就绪性等方面的差异

00:17:40.799 --> 00:17:44.400
但我确实知道我想为人们做的一件事

00:17:44.400 --> 00:17:48.000
只是想让自己的头缠住它

00:17:48.000 --> 00:17:54.480
也许一个指针说，呃，就像你所知道的，我试图像

00:17:54.480 --> 00:17:58.240
使用这种语言，您就可以成功地使用它

00:17:58.240 --> 00:18:01.600
嗯，因为你知道他们可能会生锈或其他东西

00:18:01.600 --> 00:18:04.960
而且你知道他们被卡住是因为

00:18:04.960 --> 00:18:08.400
流量很大，所以我认为有一个你知道自己可以去的地方，

00:18:08.400 --> 00:18:13.039
你可以指望的东西会很好，我不知道我以为是

00:18:13.039 --> 00:18:16.720
我认为一些lupita p项目有

00:18:16.720 --> 00:18:21.200
也参与了很多，因为他们肯定有

00:18:21.600 --> 00:18:26.559
类似的问题，就像那个项目存在于

00:18:26.559 --> 00:18:29.679
最初两种语言真的很繁重，现在就像我不知道有多少种

00:18:29.679 --> 00:18:32.640
他们现在有许多不同的语言

00:18:32.640 --> 00:18:34.960
嗯，他们肯定有同样的事情

00:18:34.960 --> 00:18:37.440
就像是dht模块之类的东西

00:18:37.440 --> 00:18:41.280
在这种语言下效果很好，并且在其他语言下也非常实验性

00:18:41.280 --> 00:18:44.559
只是这四种新语言不存在

00:18:44.559 --> 00:18:49.280
但是，他们有整个网站页面，我记得您可以

00:18:49.280 --> 00:18:53.760
向下滚动很长一段时间，它会想要很多的列表

00:18:53.760 --> 00:18:58.640
成熟度分数嗯，我想我记得那个项目的人说

00:18:58.640 --> 00:19:01.520
他们也以这种方式吃了一些牛肉

00:19:01.520 --> 00:19:06.799
所以我不知道也许我们应该问他们最后的感受是什么

00:19:07.600 --> 00:19:12.480
是的，就像我认为是因为

00:19:12.480 --> 00:19:15.440
当您确定某件东西成熟时，网守会继续工作

00:19:15.440 --> 00:19:20.320
因此，他们有很多东西是由许多类似的人建造的

00:19:20.320 --> 00:19:26.559
来自以太坊的其他补助金，例如您在哪里对亲戚进行排名

00:19:26.559 --> 00:19:30.320
rustac的成熟度（与js甲板相比）

00:19:30.320 --> 00:19:34.400
人们只是不从事任何一项工作，所以他们如何相互比较

00:19:34.400 --> 00:19:37.120
是的，因为其余的举止就像很多工作一样

00:19:37.120 --> 00:19:41.200
像这样的实现的休息，但谁会说相对

00:19:41.200 --> 00:19:44.880
成熟是没有人足够了解这两个代码库的

00:19:44.880 --> 00:19:48.880
您知道您需要的是什么，但是当他们在javascript世界中拥有它时

00:19:48.880 --> 00:19:52.960
喜欢做你用不同语言实现的应用程序

00:19:52.960 --> 00:19:58.320
和框架抱歉，谢谢[音乐]

00:19:58.320 --> 00:20:03.039
然后您实际上可以看到um这样的内容

00:20:03.039 --> 00:20:08.480
帮助是针对ipld的新应用程序，我不知道我认为

00:20:08.480 --> 00:20:12.240
我只是在想这个，我在新js中所做的一件事

00:20:12.240 --> 00:20:15.200
您可以检出的多格式库

00:20:15.200 --> 00:20:18.320
是因为您必须去实现所有这些插件以进行哈希处理

00:20:18.320 --> 00:20:21.679
我开始将函数和编解码器实际放在表格中

00:20:21.679 --> 00:20:25.200
所有已知的东西，实际上看起来真的很好，

00:20:25.200 --> 00:20:27.679
所以我认为在新网站和新文档中

00:20:27.679 --> 00:20:31.600
我们可以用每种语言来做到这一点，它们都将具有相当的可比性

00:20:31.600 --> 00:20:34.960
像是多格式的东西，就像这里所有的哈希函数

00:20:34.960 --> 00:20:38.159
然后就像哦，您会看到一种语言可能没有

00:20:38.159 --> 00:20:41.280
另一个um，当我们进入ipld时，您可以

00:20:41.280 --> 00:20:43.919
甚至对某些高级数据结构也是如此，就像这是我们的

00:20:43.919 --> 00:20:46.080
像这样的障碍是在

00:20:46.080 --> 00:20:48.000
这些不同的语言，例如哦，你知道了

00:20:48.000 --> 00:20:51.919
像那门语言没有的那可能有点落后于um

00:20:51.919 --> 00:20:54.880
或者您知道这里就像架构验证库之类的东西

00:20:54.880 --> 00:21:05.360
就像每一个都不错，好东西，嗯，好吧

00:21:05.360 --> 00:21:10.000
我没有其他人做过，是的，我猜嘿，克里斯，我要走了

00:21:10.000 --> 00:21:12.480
让你再当场

00:21:12.480 --> 00:21:15.600
我们与迈克尔进行的这次谈话

00:21:15.600 --> 00:21:22.720
嗯，灵活字节格式的成熟度是这个

00:21:22.720 --> 00:21:26.400
像这样的东西现在可以帮助您

00:21:26.400 --> 00:21:31.200
或从您的角度来看基本上缺少一些东西

00:21:31.200 --> 00:21:34.720
或您没有机会阅读，但我却没有机会

00:21:34.720 --> 00:21:38.000
我有点在等待尘埃落定，但

00:21:38.000 --> 00:21:42.880
我真的很接近真正开始对自己的锈蚀实施

00:21:42.880 --> 00:21:46.799
这就是我要看的东西

00:21:46.799 --> 00:21:51.360
离开，所以明天我会很忙，但是星期三我又有时间

00:21:51.360 --> 00:21:56.000
所以我可能会四处看看，看看我能满足我的要求

00:21:56.000 --> 00:22:00.799
可能不是um，您知道我所看到的最新更新方式可能不是

00:22:00.799 --> 00:22:05.200
最适合我想要的东西，所以我不知道呃，也许

00:22:05.200 --> 00:22:07.520
一组不同的要求，但我一定会看一看，以便我可以

00:22:07.520 --> 00:22:11.600
在星期一或ipld上报告

00:22:11.600 --> 00:22:16.960
无论哪种方式都很棒，是的，这是一个艰难的两个星期

00:22:16.960 --> 00:22:21.679
进入生锈行动，因为扑克整整两个星期都没了

00:22:21.679 --> 00:22:26.880
好吧，你知道我是的，但是我很乐观，我能够

00:22:26.880 --> 00:22:31.440
弄清楚，嗯，我们会看看情况如何，我认为我喜欢

00:22:31.440 --> 00:22:35.520
喷出的俄罗斯很好，嗯，我可能实际上是他问的好

00:22:35.520 --> 00:22:39.760
多种格式的东西的代码审查的一部分，所以我可能只是开始

00:22:39.760 --> 00:22:43.280
深入研究代码并寻找一种感觉

00:22:43.280 --> 00:22:46.559
我在使用什么防锈剂？

00:22:46.559 --> 00:22:50.640
你知道东西的布局，所以我们会看到

00:22:50.640 --> 00:22:54.000
javascript实现不是很大，就像一个漂亮的

00:22:54.000 --> 00:22:57.760
简单的数据结构来实现，我会说，虽然像

00:22:57.760 --> 00:23:01.520
锈中还没有一个模式验证库，所以可能是

00:23:01.520 --> 00:23:04.880
只是您需要小心并喜欢得到的东西

00:23:04.880 --> 00:23:07.840
得到很多很好的评价，以确保您没有破坏架构

00:23:07.840 --> 00:23:10.080
在任何地方，因为我不认为有任何要检查的东西

00:23:10.080 --> 00:23:12.880
现在为你

00:23:14.960 --> 00:23:18.640
或者您可以仅发送短信，而um可以使用

00:23:18.640 --> 00:23:22.320
是的，如果您只是想将一堆积木倒入汽车文件中，那么

00:23:22.320 --> 00:23:25.360
您可以加载它们并在javascript中对其进行测试

00:23:25.360 --> 00:23:27.840
会没事的

00:23:31.440 --> 00:23:34.799
是的，汽车文件实际上就像跨堆栈一样工作

00:23:34.799 --> 00:23:42.320
是的，太棒了，所以我从我这边再来一件

00:23:42.320 --> 00:23:46.880
呃，就像我刚刚说的克里斯

00:23:46.880 --> 00:23:53.840
对不起，我提出了关于这个问题。

00:23:53.840 --> 00:23:58.000
 ins in schemas，我们有点说得好

00:23:58.000 --> 00:24:03.120
只是个数字而已，实际上这是怎么回事

00:24:03.120 --> 00:24:06.320
凝胶和灵活的字节布局

00:24:06.320 --> 00:24:12.880
它的大小非常重要，该大小有多宽

00:24:14.960 --> 00:24:19.440
很抱歉，我又说了，我以某种方式错过了第一部分，

00:24:19.440 --> 00:24:22.720
所以在模式中，当我们说int时，我们有点说

00:24:22.720 --> 00:24:28.799
并没有真正说出什么样的接口，但是在灵活的字节布局中，我们确实

00:24:28.799 --> 00:24:34.240
不得不说尺寸是什么样的ins，那么我们该如何调和

00:24:34.240 --> 00:24:37.760
好吧，我的意思是，如果它是一个负数，它将完全无法正常工作

00:24:37.760 --> 00:24:42.799
所以是的，我的意思是失败，是的，我是说我开始了

00:24:42.799 --> 00:24:47.440
朝着组成部分的六个四位[音乐]

00:24:47.440 --> 00:24:52.559
好的，是的，所以，男人编号eric的最爱主题

00:24:52.559 --> 00:24:58.720
嗯，就像，基本上我们不能讨论这个

00:24:58.720 --> 00:25:00.880
上次，我们说是的，有点

00:25:00.880 --> 00:25:04.400
实施特定的呃，我的问题是现在是否实施

00:25:04.400 --> 00:25:07.039
具体如何处理灵活的字节布局

00:25:07.039 --> 00:25:11.360
那么，如果您查看数据模型规格数据

00:25:11.360 --> 00:25:14.640
型号规格说，您的约会日期是

00:25:14.640 --> 00:25:19.679
兼容，您必须像您一样支持64位整数um

00:25:19.679 --> 00:25:22.960
您很抱歉，您必须支持像这样的大整数

00:25:22.960 --> 00:25:26.159
它说，在规格不损失精度

00:25:26.159 --> 00:25:30.960
所以这意味着像json这样的实例实际上没有问题

00:25:30.960 --> 00:25:34.080
用大整数um javascript有一个大问题

00:25:34.080 --> 00:25:37.360
整数，所以我们不能像常规的那样使用

00:25:37.360 --> 00:25:41.200
javascript解析器，我们必须使用一个可以识别它并使用大字体的解析器

00:25:41.200 --> 00:25:45.919
出于这个原因，整数或我认为只使用一个

00:25:45.919 --> 00:25:50.240
更新，我认为最新的虚拟机有

00:25:50.240 --> 00:25:53.760
会检测到并使用大量数字的json实现

00:25:53.760 --> 00:26:00.240
这样现在就可以了，但是无论如何，是的，这有点像

00:26:00.240 --> 00:26:04.000
编解码器实现，以确保在变大时

00:26:04.000 --> 00:26:08.720
数字，以使其成为该语言的正确大数字格式

00:26:08.720 --> 00:26:11.840
好的，就模式而言，基本上

00:26:11.840 --> 00:26:18.080
整数本质上是任意精度

00:26:18.080 --> 00:26:20.640
好的，那是缺少的部分，因为我们实际上不说

00:26:20.640 --> 00:26:26.000
在数据模型中的任何地方，是的，我认为

00:26:26.000 --> 00:26:33.120
我认为合并的存货不足以维持这个数量

00:26:33.120 --> 00:26:36.240
我认为我们的协议基本上是，是的，我们将把事物视为

00:26:36.240 --> 00:26:40.240
几乎无限的精度，我们一直在努力

00:26:40.240 --> 00:26:47.120
这个短语，也许我们应该只说它，我使用的一些说明

00:26:47.120 --> 00:26:51.440
使这不让我晚上熬夜是

00:26:51.440 --> 00:26:57.760
嗯，我们不在ipld中做数学，感谢上帝，因为那意味着我们

00:26:57.760 --> 00:27:00.799
开始关心这个事情，少得多的麻烦了

00:27:00.799 --> 00:27:04.320
我们可以放心地针对具体实施

00:27:04.320 --> 00:27:07.919
更加可靠，因为我们正在努力推动的所有事情

00:27:07.919 --> 00:27:12.799
具体实现是可行的还是应该出错

00:27:12.799 --> 00:27:19.120
真的很难，没有像数学一样的未定义过渡

00:27:19.120 --> 00:27:23.440
发生并且做一些奇怪的事情

00:27:23.440 --> 00:27:28.399
否则它会停下来

00:27:28.399 --> 00:27:33.279
所以我认为那将继续只适用于内部

00:27:33.279 --> 00:27:36.960
灵活的字节布局规范（如果您开始处理其中的某些规范）

00:27:36.960 --> 00:27:40.640
库不支持足够大的整数的数据的东西

00:27:40.640 --> 00:27:45.840
你正在处理，那么它应该保持

00:27:47.440 --> 00:27:51.600
对，所以基本上我们几乎需要定义

00:27:51.600 --> 00:27:58.960
呃保持已知的界限值对事物的要求。

00:27:58.960 --> 00:28:02.159
我认为我们也应该写的图书馆

00:28:02.159 --> 00:28:04.799
是的，因为我无法想象还有什么

00:28:04.799 --> 00:28:10.000
我们会做的，最好说而不是暗示

00:28:11.840 --> 00:28:14.960
不，那实际上是很棒的，那是我会做的

00:28:14.960 --> 00:28:18.480
以及我只是不确定是否足够

00:28:18.480 --> 00:28:23.760
是的，我想不起来我们做的那样

00:28:23.760 --> 00:28:28.000
那是因为我们我们所以我们有两个我们

00:28:28.000 --> 00:28:31.360
基本上有两种类型的编解码器，我们有ipld本机编解码器，然后

00:28:31.360 --> 00:28:33.840
拥有已经存在的东西的法典，我们只是

00:28:33.840 --> 00:28:38.559
解析um并转换为数据模型以处理我们正在解析和转换的事物

00:28:38.559 --> 00:28:42.960
进入数据模型，就像我们读的规范一样

00:28:42.960 --> 00:28:45.520
就像我们正在采用这种价值，然后在我们的业务中代表它一样

00:28:45.520 --> 00:28:47.679
数据模型，我们的数据模型说任意

00:28:47.679 --> 00:28:51.039
位置um，所以每种语言都会

00:28:51.039 --> 00:28:54.240
必须支持每个规格中的任何精度，如果不能，

00:28:54.240 --> 00:28:59.840
支持它，那么它将不得不导致我们规格的例外

00:28:59.840 --> 00:29:03.440
我们确实说您必须支持任意大型编辑器

00:29:03.440 --> 00:29:08.880
对于我们的食典规范，我们说您需要任意支持大型

00:29:08.880 --> 00:29:12.559
像数字，基本上是um，并且不会丢失

00:29:12.559 --> 00:29:15.200
精度，我的意思是我们应该说，如果我们

00:29:15.200 --> 00:29:18.080
不好吧，我不知道我是否同意

00:29:18.080 --> 00:29:22.320
因为从字面上看，我们的法典都不会添加其中一个

00:29:22.320 --> 00:29:26.159
好吧，什么不会更新支持号码

00:29:26.159 --> 00:29:30.159
是的，不，我是说道格·杰森（Jason）的杰森（Jason）可能有问题

00:29:30.159 --> 00:29:33.760
如果我们不竭尽全力去解决它

00:29:34.799 --> 00:29:39.440
我的意思是肯定不会

00:29:39.600 --> 00:29:46.240
从来没有任何版本支持大量

00:29:48.159 --> 00:29:52.240
不，不，等待，等待，等待，等待，等待，就像javascript一样

00:29:52.240 --> 00:29:56.080
不支持他们开箱即用，您必须做一些像您必须做的事

00:29:56.080 --> 00:30:02.559
用最大的力量，没有普遍的社区同意

00:30:02.559 --> 00:30:06.240
根据大端的定义，就像我所知道的没有很大的互联网标准

00:30:06.240 --> 00:30:10.559
的确有哦，好

00:30:10.559 --> 00:30:14.240
我知道那是一个重要的预选赛

00:30:14.240 --> 00:30:17.279
我现在可能错了，因为我需要看看他们写了什么

00:30:17.279 --> 00:30:20.799
像什么基地58

00:30:20.880 --> 00:30:25.440
东西是公民，呃，我会尽快回复你

00:30:26.559 --> 00:30:30.799
也许我实际上不知道x系列软件包中的某些内容

00:30:30.799 --> 00:30:35.600
嗯，但是我绝对可以告诉你，我们的任何东西都没有我们的编解码器

00:30:35.600 --> 00:30:41.279
现在支持那个，是的，我的意思是

00:30:41.279 --> 00:30:46.159
因为最终发生的事情是这变成了确定性问题

00:30:46.159 --> 00:30:53.279
um正确的读写权限，因为您没有读取数据就将其解析为

00:30:53.279 --> 00:30:56.640
没有足够的能力进行整数精度运算

00:30:56.640 --> 00:30:59.840
然后您重新序列化它，而实际上您不是

00:30:59.840 --> 00:31:02.559
序列化正确的数据，因为您现在已经突变了您所处的整数

00:31:02.559 --> 00:31:05.840
不想，除非您使用when的定义

00:31:05.840 --> 00:31:09.279
你溢出你停下来，那么你就没有那个

00:31:09.279 --> 00:31:12.559
问题，这就是为什么这很奇怪是的，我的意思是，如果你想

00:31:12.559 --> 00:31:14.960
丢掉那个地方，就像你的语言只是

00:31:14.960 --> 00:31:18.320
不支持您的语言，例如um

00:31:18.320 --> 00:31:21.120
我认为，尽管如果您要编写代码以停止运行，您也可能会

00:31:21.120 --> 00:31:25.120
只需编写代码以放入一个大整数

00:31:25.760 --> 00:31:29.279
是的，我刚刚将其粘贴在聊天室中，黄金绝对有一个核心

00:31:29.279 --> 00:31:34.960
质量大端我不知道哪个版本，但是肯定从11开始

00:31:34.960 --> 00:31:39.840
对，这很酷，是的，嗯

00:31:40.640 --> 00:31:46.880
好吧，如果我们假设我们所使用的每种语言

00:31:46.880 --> 00:31:51.519
要定位到具有某种类型的纯素食库，然后

00:31:51.519 --> 00:31:55.600
其余的变成一个问题或仍然存在

00:31:55.600 --> 00:32:00.960
边缘案例，这就是我们需要担心的事情清单

00:32:00.960 --> 00:32:04.720
每次我们处理编解码器时，每次我们都想像

00:32:04.720 --> 00:32:07.279
现有格式并弄清楚如何表示

00:32:07.279 --> 00:32:10.960
就像每当我们做这项工作时，我们都需要喜欢

00:32:10.960 --> 00:32:13.840
就像我们需要去的所有东西一样，我们需要开始写下来的地方

00:32:13.840 --> 00:32:16.960
担心，就像您需要担心地图排序，也需要担心

00:32:16.960 --> 00:32:20.159
像这样，这就像您需要做的一件事

00:32:20.159 --> 00:32:25.039
担心嗯，我基本上就像我了解

00:32:25.039 --> 00:32:28.480
这是一个很大的问题，我特别想将其范围

00:32:28.480 --> 00:32:32.880
fbl像僵硬的管道

00:32:33.760 --> 00:32:38.559
感觉就像fbl一样，不必说任何特别的东西，例如

00:32:38.559 --> 00:32:42.640
就像它在栈顶一样，表示我们正在为您处理此问题，或者

00:32:42.640 --> 00:32:47.120
扔了，嗯，是的，所有那些

00:32:47.120 --> 00:32:50.640
就像您知道的所有这些担忧都属于那里

00:32:50.640 --> 00:32:54.159
嗯，我认为我们可能需要考虑的唯一一件事

00:32:54.159 --> 00:32:58.399
就像如果我们想将特征引入架构中

00:32:58.399 --> 00:33:06.159
允许您在架构中说添加一些特定性给您

00:33:06.159 --> 00:33:10.399
像这样的数字必须是负数或

00:33:10.399 --> 00:33:15.440
这样的东西，然后呢，或者你知道这不可能是负面的

00:33:15.440 --> 00:33:18.640
数字，如果我们想添加类似的东西，那仍然会是

00:33:18.640 --> 00:33:21.840
架构功能和编解码器具有fbl功能

00:33:21.840 --> 00:33:25.279
首先要像架构功能，然后我们可以在fbl中使用它

00:33:25.279 --> 00:33:31.600
嗯，但您知道这是关于类似架构功能的另一种对话

00:33:31.600 --> 00:33:38.720
是的，这不对，这很酷。是的，这可以帮助我们所有的事情，这就是我的全部。

00:33:38.720 --> 00:33:44.880
好酷

00:33:44.880 --> 00:33:53.679
很好，然后大家再见，下周再见

00:33:53.679 --> 00:33:58.480
停止录音

