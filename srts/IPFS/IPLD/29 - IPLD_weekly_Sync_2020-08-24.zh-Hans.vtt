WEBVTT
Kind: captions
Language: zh-Hans

00:00:12.799 --> 00:00:16.880
欢迎大家参加本周的ipld同步会议

00:00:16.880 --> 00:00:25.119
2020年8月24日，每周我们都在聊

00:00:25.119 --> 00:00:28.880
关于我们上周已经完成并计划在下周完成的工作

00:00:28.880 --> 00:00:32.640
然后我们执行可能具有的所有引擎项目，我已经看到我们

00:00:32.640 --> 00:00:38.399
有一个很棒的天线，嗯，嗯

00:00:38.399 --> 00:00:42.719
我从我自己开始，我没有什么要报告的

00:00:42.719 --> 00:00:46.239
我在星期五有一点时间在锈ipld上工作

00:00:46.239 --> 00:00:51.840
我不是真的在研究任何新东西，而只是查看您的公关

00:00:51.840 --> 00:00:57.039
嗯，但这是一个很大的重构，因为它使用了

00:00:57.039 --> 00:01:02.079
不是um堆分配而是坚持分配的东西

00:01:02.079 --> 00:01:06.720
CD和Multihash的内容以及其他一些更改

00:01:06.720 --> 00:01:14.159
对其他实施者来说是一件有趣的事

00:01:14.159 --> 00:01:19.840
也许很酷，所以让大卫成为一个在俄罗斯iPhone上工作的家伙

00:01:19.840 --> 00:01:22.910
d关于um有个主意

00:01:22.910 --> 00:01:28.400
[音乐]抄本，所以在生锈的时候会很好

00:01:28.400 --> 00:01:33.040
或者我们要做的是您可以直接从本机rust进行序列化

00:01:33.040 --> 00:01:36.640
键入编解码器，所以从本地讲

00:01:36.640 --> 00:01:41.439
直接将类型推向dexibor，也可以直接转到甲板

00:01:41.439 --> 00:01:46.560
json或任何您喜欢的um，但问题是有时您

00:01:46.560 --> 00:01:48.880
不知道你真正想去哪里，所以你

00:01:48.880 --> 00:01:53.040
首先要去ipald，所以大多数实现首先来自本机

00:01:53.040 --> 00:01:56.159
类型转换为ipld类型，然后从ipld转换为

00:01:56.159 --> 00:02:01.360
无论何时何地，您可能都想使用此快捷方式

00:02:01.360 --> 00:02:04.880
但是有时候你没有，问题是

00:02:04.880 --> 00:02:08.160
过去，我们使用不同的API来执行这些操作，因此

00:02:08.160 --> 00:02:12.480
直接进行或通过ipald中间步骤

00:02:12.480 --> 00:02:17.440
他的想法是我们创建一种类似于界面的交易

00:02:17.440 --> 00:02:21.280
用其他语言，您要做的就是实现这一点

00:02:21.280 --> 00:02:25.120
换编码解码器本身，但您也可以

00:02:25.120 --> 00:02:30.239
实现包含多个编解码器的枚举交易

00:02:30.239 --> 00:02:36.480
这样一来，您现在就可以直接从一种规格的本机类型转换为一种

00:02:36.480 --> 00:02:40.800
特定的编解码器，或者您为ipld实现此枚举，因此

00:02:40.800 --> 00:02:46.400
您基本上具有从本机类型到ipld的相同api

00:02:46.400 --> 00:02:50.480
来回，或者您直接从本机类型转换为编解码器

00:02:50.480 --> 00:02:55.840
我认为这很聪明，可能效果很好，也可能是

00:02:55.840 --> 00:02:58.480
您喜欢的其他语言的想法

00:02:58.480 --> 00:03:02.239
是的，结合了一个可以被多个编解码器使用的接口

00:03:02.239 --> 00:03:09.440
或通过单一编码，它有点整齐，好吧，是的，接下来我要尝试

00:03:09.440 --> 00:03:12.400
要做的是从微小的多哈希中获取更改

00:03:12.400 --> 00:03:14.800
这是锈多哈希的叉子

00:03:14.800 --> 00:03:18.720
将上游的这些变化转化为适当的变化

00:03:18.720 --> 00:03:27.120
嗯，是的，这就是我在名单上的下一个。

00:03:27.120 --> 00:03:31.440
是的，我仍然不知道这个特定的更新，然后到这次会议，我要

00:03:31.440 --> 00:03:35.599
我们正在与猎鹰网络上的许多其他人一起太空

00:03:35.599 --> 00:03:39.040
午夜太空竞赛

00:03:40.560 --> 00:03:48.640
好的，接下来是克里斯，嘿，伙计们，我没有死

00:03:48.640 --> 00:03:53.519
所以我从休假长假中回来了

00:03:53.519 --> 00:03:56.799
如果您想知道一些要点，我可以为您提供更多信息

00:03:56.799 --> 00:04:03.599
嗯，我有个迹象要建立一个javascript图形同步库嗯

00:04:03.599 --> 00:04:06.879
所以这就是我今天开始工作的地方，如果有

00:04:06.879 --> 00:04:10.080
你很感兴趣，嗯，我不知道我不知道

00:04:10.080 --> 00:04:13.040
你们是如何正常进行开发流程的，或者您是如何完成的，但是我做到了

00:04:13.040 --> 00:04:16.239
实际创建需求文档和Google文档

00:04:16.239 --> 00:04:19.519
如果您有时间和兴趣，可以看看并提供

00:04:19.519 --> 00:04:23.759
反馈um，如果您认为有缺失的地方，特别是如果您

00:04:23.759 --> 00:04:28.960
呃，我对图同步很熟悉，我确实与michael和

00:04:28.960 --> 00:04:32.560
嗯今天擦洗了一点，所以在那里，我确实开始实施一些

00:04:32.560 --> 00:04:35.360
我可以做的事情我可以使用一些帮助UM只是为了

00:04:35.360 --> 00:04:39.520
在几个问题上进行图形同步方面的引导

00:04:39.520 --> 00:04:45.840
我知道迈克尔说也许彼得或呃埃里克可以填写几件事，所以

00:04:45.840 --> 00:04:48.960
如果你们有时间我会在日历上做些事情

00:04:48.960 --> 00:04:52.240
嗯，因为汉娜（Hannah）就像是超级忙碌，现在很难降下来

00:04:52.240 --> 00:04:57.840
所以无论如何这是我的更新，我确实有一个关于此的议程项目

00:04:57.840 --> 00:05:00.960
每个块有多个cid

00:05:00.960 --> 00:05:04.800
有争议和关闭相信某人理解

00:05:04.800 --> 00:05:12.400
我们待会儿再说吧，谢谢，接下来是eric

00:05:13.039 --> 00:05:16.960
嗨，你好

00:05:18.240 --> 00:05:21.440
抱歉，我已经发现我的电脑无法正常工作，已经太迟了

00:05:21.440 --> 00:05:26.800
网络时间同步，今天要休息七分钟，因为石英钟

00:05:26.800 --> 00:05:29.360
显然

00:05:31.120 --> 00:05:35.120
技术很棒，所以我这周写了一些文档

00:05:35.120 --> 00:05:39.600
我写了一个新的入门文档，试图成为

00:05:39.600 --> 00:05:42.560
多合一的尝试

00:05:42.560 --> 00:05:48.000
连续页面，只需滚动链接参考材料即可获得

00:05:48.000 --> 00:05:50.800
ipld里面所有这些东西是什么

00:05:50.800 --> 00:05:54.400
嗯，这目前位于一种hackindy便签本中，因此

00:05:54.400 --> 00:05:59.440
每个人都可以编辑它，如果您太喜欢了，那就疯了

00:05:59.440 --> 00:06:01.840
我实际上不确定我是否要尝试将此工作纳入我们的正式工作

00:06:01.840 --> 00:06:09.039
文档或它的一些分支，或者像这个um的轨迹是什么

00:06:09.039 --> 00:06:13.520
因为我想保持简洁，我不一定要发展这个

00:06:13.520 --> 00:06:15.840
特定文件并为每个人做一个文件

00:06:15.840 --> 00:06:19.520
我想我在初稿中的写法实际上已经太久了

00:06:19.520 --> 00:06:25.120
嗯，所以有些自以为是的东西可能是其未来的一部分

00:06:25.120 --> 00:06:28.479
但我不确定我是否只是想充实这些不同种类的

00:06:28.479 --> 00:06:33.440
我们可能需要的文档，我们有很多丰富的东西，但是我

00:06:33.440 --> 00:06:36.479
认为我们也需要更多简洁的东西，所以我拍了一下

00:06:36.479 --> 00:06:42.080
无论如何，所以反馈很欢迎，嗯，我已经为增加一堆而准备了一份公关

00:06:42.080 --> 00:06:45.520
的新测试和固定装置

00:06:45.520 --> 00:06:50.880
模式和余生的东西，我开始使用json作为速记

00:06:50.880 --> 00:06:53.280
测试一方面给了我

00:06:53.280 --> 00:06:57.840
heebie-jeebies，因为那是其他东西的大依赖树

00:06:57.840 --> 00:07:00.840
您假设要为测试工作

00:07:00.840 --> 00:07:05.120
但是我们所有json内容的um测试确实已经存在

00:07:05.120 --> 00:07:08.880
直接依赖于基本节点的实现等等

00:07:08.880 --> 00:07:13.440
所有这些东西都可以被测试而没有这种依赖性的循环

00:07:13.440 --> 00:07:16.160
图，所以如果我必须引导整个事情

00:07:16.160 --> 00:07:18.240
一遍又一遍，仍然像

00:07:18.240 --> 00:07:21.360
进步，所以我认为这会没事的

00:07:21.360 --> 00:07:27.599
而且节省了大量的线数，所以这些灯具也

00:07:27.599 --> 00:07:30.880
就像一次探测所有东西，所以你给它像

00:07:30.880 --> 00:07:35.199
语义结构类型的json片段，然后转到另一篇

00:07:35.199 --> 00:07:38.319
表示形式的json，并希望确保它们都产生

00:07:38.319 --> 00:07:40.479
相同的数据在内存中，并可以进入每个

00:07:40.479 --> 00:07:45.360
不同的方向，所以这将以更少的成本实现更有效的覆盖

00:07:45.360 --> 00:07:47.680
混合代码，我已经发现了两个错误

00:07:47.680 --> 00:07:54.160
如此，嗯，遍历包

00:07:54.160 --> 00:07:57.680
在Glenfield Prime中终于有了git功能

00:07:57.680 --> 00:08:01.599
只是简单地为您提供了您所要求的东西

00:08:01.599 --> 00:08:04.639
而不是让您经历整个回调广告素材模型

00:08:04.639 --> 00:08:08.720
所以人们一直在要求它，而我终于做到了

00:08:08.720 --> 00:08:13.280
迟到了，那是正确的

00:08:13.680 --> 00:08:18.319
谢谢，名单上的下一个是罗恩

00:08:18.879 --> 00:08:24.160
你好，我的假期很轻松，我休息了一段时间

00:08:24.160 --> 00:08:30.639
一些健康问题，但我把它绑起来了

00:08:30.639 --> 00:08:35.839
汉普顿amt工作以远的硬币，并将其移交给

00:08:35.839 --> 00:08:40.080
嗯，那是我的手，他们显然已经

00:08:40.080 --> 00:08:45.680
嗯，分配了一个将负责这些库的人，这很棒

00:08:45.680 --> 00:08:50.320
正如您从我的链接中看到的那样，我也已将链接放在注释中，这是

00:08:50.320 --> 00:08:54.720
我在请求请求表格中完成的工作

00:08:54.720 --> 00:08:58.080
终于搬到了farcoin org

00:08:58.080 --> 00:09:02.399
它应该生活在哪里以消除对此的任何误解

00:09:02.399 --> 00:09:06.640
东西是通用的东西

00:09:07.760 --> 00:09:11.279
所以那是一件好事，因为这需要很多工作

00:09:11.279 --> 00:09:16.800
嗯，嗯，他们说他们不会

00:09:16.800 --> 00:09:21.120
不会接受中断代码块格式的更改um

00:09:21.120 --> 00:09:25.200
嗯，我反对上链

00:09:25.200 --> 00:09:28.560
因为离发布太近了，这很公平

00:09:28.560 --> 00:09:33.040
我认为最大的担忧之一就是他们正在努力建立

00:09:33.040 --> 00:09:36.959
还有更多的集成类型测试

00:09:36.959 --> 00:09:43.120
整个系统，您会在其中获得不同操作的一致性ID

00:09:43.120 --> 00:09:46.800
他们是他们已经在处理实时数据，所以

00:09:46.800 --> 00:09:51.120
打破阻滞的块格式更改

00:09:51.120 --> 00:09:57.760
所以无论如何，我做那件事是因为

00:09:57.760 --> 00:10:02.320
这样做会很好，但这就是全部，我知道这是在他们的

00:10:02.320 --> 00:10:07.040
手，那很好，但是这些变化可能会得到

00:10:07.040 --> 00:10:11.120
在下一次主要网络升级期间（如果有的话）进行操作

00:10:11.120 --> 00:10:14.399
谁知道该过程将如何滚动会发生

00:10:14.399 --> 00:10:18.720
看着会很有趣，但是对他们来说，嗯，我认为

00:10:18.720 --> 00:10:24.480
这将是一个很好的变化，虽然它确实使我们陷入了麻

00:10:24.480 --> 00:10:27.519
这项工作的目标之一是

00:10:27.519 --> 00:10:33.040
嗯，只是想改善它，就是将其拉近一点

00:10:33.040 --> 00:10:38.320
会像普通大麻到ipld产品一样生产

00:10:38.320 --> 00:10:44.240
这样我们的工作可以更轻松地与他们的工作重叠，因此

00:10:44.240 --> 00:10:47.839
对我们来说很简单

00:10:48.000 --> 00:10:52.399
拥有一些可能对他们以及其他任何人都有效的代码

00:10:52.399 --> 00:10:56.240
在我们和他们之间不会有太大的飞跃

00:10:56.240 --> 00:11:00.640
所以，这意味着现在他们正在生产积木，

00:11:00.640 --> 00:11:05.200
看起来不太像我们要生产的东西

00:11:05.200 --> 00:11:09.440
但这不是距离不算大

00:11:09.440 --> 00:11:16.880
有点烦人，所以我全部花了一些时间在javascript es中

00:11:16.880 --> 00:11:20.560
模块的东西um转换一些代码并尝试

00:11:20.560 --> 00:11:25.040
了解迈克尔的新堆栈和嗯

00:11:25.040 --> 00:11:28.560
是的，那里有很多痛苦，但是

00:11:28.560 --> 00:11:32.800
它们是本周我的主要亮点

00:11:33.839 --> 00:11:38.000
所以要感谢一个没有把任何东西放在边缘的人

00:11:38.000 --> 00:11:42.800
在清单上，但迈克尔，您有任何更新吗

00:11:42.800 --> 00:11:45.680
是的，是的，对不起，我就像是在一个

00:11:45.680 --> 00:11:49.360
百万，所以在本周早些时候早些时候

00:11:49.360 --> 00:11:54.959
一周我真的完成了所有的esm迁移工作，所以我们

00:11:54.959 --> 00:11:57.279
那里实际上有很好的工具

00:11:57.279 --> 00:12:00.480
就像真的做对了，使用起来很愉快

00:12:00.480 --> 00:12:04.959
嗯，我基本上迁移了我们在esm上拥有的每个模块

00:12:04.959 --> 00:12:08.320
到那么多的格式，一直到块，然后是所有东西

00:12:08.320 --> 00:12:11.839
也会阻塞依赖块，而所有这些

00:12:11.839 --> 00:12:14.720
到对角线的路，基本上，所以道格迪现在有一个分支

00:12:14.720 --> 00:12:18.320
我在做我正在做的事情，然后在

00:12:18.320 --> 00:12:21.040
星期四，我对这种块格式有了想法

00:12:21.040 --> 00:12:25.279
然后整个周末都吸引了我的全部注意力

00:12:25.279 --> 00:12:28.800
而且我现在不会进入那一吨，因为我实际上已经准备了一些幻灯片

00:12:28.800 --> 00:12:30.880
过去，只是在电话中谈论它

00:12:30.880 --> 00:12:34.160
稍等一下，让我让所有其他人完成更新，

00:12:34.160 --> 00:12:39.839
然后说说块格式

00:12:41.279 --> 00:12:47.279
好吧，我想是的，所以最重要的是我

00:12:47.279 --> 00:12:52.320
刚开始忘记的是，有任何新手想介绍吗

00:12:52.320 --> 00:12:56.079
自己[音乐]

00:12:56.079 --> 00:13:01.839
我可能今天应该开始我的名字叫丹尼尔，我加入了ipld小组

00:13:01.839 --> 00:13:06.079
只是简要介绍一下我主要做什么

00:13:06.079 --> 00:13:08.720
来源，所以我知道你们中的大多数来自其他人

00:13:08.720 --> 00:13:12.079
背景，所以我实际上对学习一点锈也许感兴趣

00:13:12.079 --> 00:13:16.560
总有一天，但无论如何，我今天到目前为止所做的一切真的刚刚开始

00:13:16.560 --> 00:13:20.800
记账和阅读东西，明天我希望能真正进入

00:13:20.800 --> 00:13:23.440
一些代码，但仅此而已

00:13:23.440 --> 00:13:28.560
对我来说很酷，谢谢

00:13:28.560 --> 00:13:32.880
好的，嗯，是的，所以我们有一个引擎项目

00:13:32.880 --> 00:13:39.199
所以我想我们应该先做什么，我首先要猜测议程项目，然后再讨论

00:13:39.199 --> 00:13:45.199
我的点击可以进行演示或任何偏好

00:13:46.000 --> 00:13:52.880
是的，让我们做到这一点，好吧，克里斯，是的，所以

00:13:52.880 --> 00:13:56.000
嗯，我知道我们有点谈论嗯

00:13:56.000 --> 00:14:00.079
过去的压缩和加密以及主要反对意见之一

00:14:00.079 --> 00:14:03.760
它破坏了内容的可寻址性

00:14:03.760 --> 00:14:07.279
所以很好地提出了一个问题，为什么没有

00:14:07.279 --> 00:14:11.199
你知道我猜我们可以与一个块关联的多个cid

00:14:11.199 --> 00:14:15.600
就像语义cid这样的东西

00:14:15.600 --> 00:14:19.279
未压缩的呃未加密的，但是你可能有

00:14:19.279 --> 00:14:22.000
引用同一块的其他cid，因为它就像一个查找

00:14:22.000 --> 00:14:26.720
实际加密的机制

00:14:26.720 --> 00:14:34.399
或压缩版本，所以如果您从呃想起它

00:14:34.399 --> 00:14:38.320
从现有工具的角度来看，您知道很多ipfs可以与

00:14:38.320 --> 00:14:41.760
基本上每个块只有一个cid，所以如果您

00:14:41.760 --> 00:14:44.639
做位交换或图形同步之类的

00:14:44.639 --> 00:14:49.920
可以使用我想存储的um，但是我可以

00:14:49.920 --> 00:14:52.639
实际上我不确定这样做的最佳方法，但是

00:14:52.639 --> 00:14:55.760
只是这个想法是允许不同

00:14:55.760 --> 00:14:59.440
标识符种类破坏了内容的可寻址性，但它确实允许

00:14:59.440 --> 00:15:02.959
从本质上说，存储格式根据um而有所不同

00:15:02.959 --> 00:15:07.040
独立于内容，但在某种意义上仍保持内容的可寻址性

00:15:07.040 --> 00:15:13.839
现在有任何意义，但这是高级问题的想法

00:15:19.760 --> 00:15:23.519
好的，没有人有任何评论，因为像我一样，老实说，

00:15:23.519 --> 00:15:27.839
像这样想想

00:15:29.680 --> 00:15:33.360
是的，有人有吗

00:15:33.680 --> 00:15:36.639
现在有什么想法

00:15:37.120 --> 00:15:41.360
我们现在还没有办法使用cid来在该级别上进行区分

00:15:41.360 --> 00:15:44.959
那将是我最大的担忧，好吧，我有个CID

00:15:44.959 --> 00:15:49.839
它是做什么用的，而艾滋病应该有这些信息

00:15:49.839 --> 00:15:54.240
也许cid有某种机制，或者我们使用不同的编解码器

00:15:54.240 --> 00:15:59.680
说这个东西是另一个东西的压缩容器

00:15:59.680 --> 00:16:03.360
也许这是合理的，因为如果您只是

00:16:03.360 --> 00:16:09.040
带有编解码器，仅用于压缩或压缩某些内容

00:16:09.040 --> 00:16:15.040
那也许就这些了，但是

00:16:15.839 --> 00:16:25.759
我不知道是什么让你买的，比如像画图形

00:16:25.759 --> 00:16:33.120
并没有像每次CID往返那样真正地以um为中心

00:16:33.120 --> 00:16:36.399
批处理，你知道的，诸如此类的东西

00:16:36.399 --> 00:16:39.519
从理论上讲还不错，它确实喜欢

00:16:39.519 --> 00:16:43.120
去作图现在可以用了，比这还原始一些，但是

00:16:43.120 --> 00:16:46.880
那是行不通的，所以我想回声

00:16:46.880 --> 00:16:50.000
布拉德的问题，它基本上能给您带来什么

00:16:50.000 --> 00:16:54.800
有一个巨型块或某种意义上的东西

00:16:54.800 --> 00:17:00.160
在某种程度上让你感到湿sorry的抱歉，就像一个巨大的障碍

00:17:00.160 --> 00:17:03.839
系列是中间

00:17:05.520 --> 00:17:10.799
嗯，所以我想我在想的是，如果你

00:17:10.799 --> 00:17:14.480
将一个块链接到另一个块

00:17:14.480 --> 00:17:18.319
因此，让我们只听一下，以便我们都了解用例或

00:17:18.319 --> 00:17:22.480
加密压缩权，我想再次得到的反馈总是

00:17:22.480 --> 00:17:25.679
这样就破坏了内容的可寻址性，因此，如果您

00:17:25.679 --> 00:17:30.720
从一个块链接到另一个um，如果您这样做的话，请考虑一下

00:17:30.720 --> 00:17:32.559
比方说今天人们所做的是

00:17:32.559 --> 00:17:35.840
他们会加密内容，然后将其粘贴到ipfs中

00:17:35.840 --> 00:17:39.280
好吧，那么你就失去了所有的联系能力，因为现在你的

00:17:39.280 --> 00:17:42.720
链接在该块中被加密并实际遍历它们

00:17:42.720 --> 00:17:45.120
您必须解密该块，因为它无法与类似的东西一起使用

00:17:45.120 --> 00:17:50.480
图形同步或其他真正的数字等等

00:17:50.480 --> 00:17:54.480
你知道这个主意很好，如果我们有一个语义

00:17:54.480 --> 00:17:57.760
就像今天这样，没有加密或压缩的一切，

00:17:57.760 --> 00:18:03.280
因此，如果您从一个块链接到另一个块，则实际上仍会使用

00:18:03.280 --> 00:18:08.400
未加密的未压缩cid链接到块之间

00:18:08.400 --> 00:18:12.799
但是然后嗯，所以你可以那样遍历图

00:18:12.799 --> 00:18:17.200
但是，在下面，它实际上可以压缩或加密存储

00:18:17.200 --> 00:18:21.760
因此从一微米移到

00:18:21.760 --> 00:18:26.080
ipfs节点或一个节点到另一个节点，保留该压缩或

00:18:26.080 --> 00:18:29.919
加密不必实际撤消它或解压缩解加密

00:18:29.919 --> 00:18:34.320
通过网络发送重新加密重新压缩

00:18:35.039 --> 00:18:37.760
我知道它有点抽象，我需要多考虑一下，但我只是一种

00:18:37.760 --> 00:18:39.440
想要把它扔在那里，因为

00:18:39.440 --> 00:18:42.559
就像我说的那样，当我们过去谈论这个话题时，我一直保持不变

00:18:42.559 --> 00:18:46.880
我们破坏了内容的可寻址性，所以

00:18:46.880 --> 00:18:49.919
某种程度上保持内容可寻址性，几乎就像您需要的那样

00:18:49.919 --> 00:18:53.280
不同的标识符，以不同的方式标识相同的对象

00:18:53.280 --> 00:18:58.480
阻止一个，就像我说的是语义或未压缩的

00:18:58.480 --> 00:19:03.600
未加密的版本，然后是实际在磁盘上的版本

00:19:04.559 --> 00:19:08.720
我们谈论的方式um我们谈论的加密方式之一

00:19:08.720 --> 00:19:13.200
之前基本上是

00:19:13.200 --> 00:19:21.280
呈现为自身的不透明容器的块，以及

00:19:21.280 --> 00:19:25.440
要浏览它，您需要更多信息

00:19:25.440 --> 00:19:30.799
但是它作为一个普通的块呈现，当您阅读它时，您必须

00:19:30.799 --> 00:19:35.120
应用一些逻辑，这是高级数据所在的位置

00:19:35.120 --> 00:19:40.400
布局进来，所以如果你读一个块并且你

00:19:40.400 --> 00:19:44.080
而且您知道它需要某种逻辑

00:19:44.080 --> 00:19:50.640
它通过开始在go中存在的adl管道，然后

00:19:50.640 --> 00:19:54.240
在其中，您将应用插入密钥并进行一些加密的逻辑

00:19:54.240 --> 00:19:58.640
然后在其中呈现真实的真实块格式um，等等

00:19:58.640 --> 00:20:02.240
从这个意义上讲，您将拥有自己正在得到的东西，但是却没有

00:20:02.240 --> 00:20:06.799
需要第二个提示，提示是

00:20:06.799 --> 00:20:11.919
加密数据只是为了读入数据，您需要额外的逻辑

00:20:11.919 --> 00:20:17.039
特别是加密块的问题之一是

00:20:17.039 --> 00:20:20.400
这是因为所有链接都隐藏在里面

00:20:20.400 --> 00:20:24.400
您不加密的数据会破坏图表，除非您可以

00:20:24.400 --> 00:20:30.080
嗯，除非您可以在每个阶段解密的每个呃都对其进行加密，

00:20:30.080 --> 00:20:32.640
还有，如果您只是中间存储

00:20:32.640 --> 00:20:36.080
只是存储它们的服务，您知道并且

00:20:36.080 --> 00:20:39.760
你想做某种图同步呃交换

00:20:39.760 --> 00:20:43.440
那么除非获得钥匙，否则您将无法完成全部任务

00:20:43.440 --> 00:20:48.000
因此，我们确实提出了一些有关您可以在何处进行的想法

00:20:48.000 --> 00:20:54.320
您可以提取加密之外的不敏感链接

00:20:54.320 --> 00:20:57.280
容器呃，所以你用

00:20:57.280 --> 00:21:01.600
一些您知道一个链接部分，然后是加密的有效负载，等等

00:21:01.600 --> 00:21:04.640
您仍然可以遍历该图

00:21:04.640 --> 00:21:08.320
对于某些用例，因为链接部分

00:21:08.320 --> 00:21:11.039
只会是所有这些加密块的图形，它们只会

00:21:11.039 --> 00:21:16.159
公开足够有用的信息，但在其他一些用例中，

00:21:16.159 --> 00:21:19.679
链接将变得敏感，就像您可能链接到某些特定链接

00:21:19.679 --> 00:21:23.600
实际提供您正在加密的内容的外部资源

00:21:23.600 --> 00:21:27.760
或对此提出建议，所以这是这个

00:21:27.760 --> 00:21:32.720
信息泄漏，这是一个很难解决的问题，但

00:21:32.720 --> 00:21:36.240
就像这样，我们确实谈到了压缩方面的相同问题，但是

00:21:36.240 --> 00:21:39.760
它在压缩内变得如此草率，当您处于压缩状态时，确实会变得凌乱

00:21:39.760 --> 00:21:45.760
将压缩拉到块层中um太多了，以至于弄得一团糟

00:21:45.760 --> 00:21:48.480
特别是对于压缩算法而言

00:21:48.480 --> 00:21:51.280
确定性的，这是我们一直在做的事情

00:21:51.280 --> 00:21:55.440
真的有很多关于嗯的话题吗？

00:21:55.440 --> 00:21:59.200
固体压缩算法的算法是

00:21:59.200 --> 00:22:03.760
实际上提供了确定性的令人信服的结果

00:22:03.760 --> 00:22:08.240
呃，有很多提供的东西

00:22:08.240 --> 00:22:11.280
你知道好吧，结果是少量的压缩

00:22:11.280 --> 00:22:14.480
他们很快，他们是确定性的，但是

00:22:14.480 --> 00:22:17.840
如果您确实想要压缩，您是否会打扰使用它们？

00:22:17.840 --> 00:22:21.760
您将获得可以进行适当大小压缩的功能，其中很多

00:22:21.760 --> 00:22:26.559
不确定，您是在偷迈克尔·史坦德

00:22:26.559 --> 00:22:29.760
不，是的，是的，我只是

00:22:29.760 --> 00:22:32.799
要说就像只是显示某种数据特定性

00:22:32.799 --> 00:22:35.440
这是正确的，就像我一直在尝试新的

00:22:35.440 --> 00:22:38.720
块格式的优点之一是链接和值以及

00:22:38.720 --> 00:22:41.760
结构在不同的部分，因此您可以实际压缩它们

00:22:41.760 --> 00:22:44.799
单独地玩，你会得到的链接只是

00:22:44.799 --> 00:22:47.840
散列并且不会很好地压缩，而且您知道

00:22:47.840 --> 00:22:51.600
但是即使您看起来像文件平面链数据，也没有价值数据

00:22:51.600 --> 00:22:54.400
文件中的硬币链压缩得很好，就像

00:22:54.400 --> 00:22:57.760
我认为最多不超过百分之三

00:22:57.760 --> 00:23:01.120
所以这就像实际上不值得进行解析和解码一样

00:23:01.120 --> 00:23:02.880
时间，这可能是因为大多数

00:23:02.880 --> 00:23:06.320
这些叮咬值就像是公钥或类似的东西

00:23:06.320 --> 00:23:10.240
实际上是加密的战斗数据，所以您确实喜欢这些

00:23:10.240 --> 00:23:14.880
特定领域，例如压缩需求，然后

00:23:14.880 --> 00:23:17.600
我的意思是我将稍微谈谈我的块格式，但是您可以开始实际

00:23:17.600 --> 00:23:20.640
如果您使用具有以下格式的块格式，则将它们编程到数据结构中：

00:23:20.640 --> 00:23:23.840
自然压缩方案

00:23:25.679 --> 00:23:29.440
是的，我知道我不会用太多，我只想丢掉那个身份证

00:23:29.440 --> 00:23:32.799
在那里，但我很抱歉，我有点像在火上集思广益

00:23:32.799 --> 00:23:36.559
因为我还没有完全考虑，但是我只是

00:23:36.559 --> 00:23:40.240
接触到这个嗯，只是在我身上发生了

00:23:40.240 --> 00:23:43.520
也许解决这个问题的正确方法是

00:23:43.520 --> 00:23:48.000
传输层等等

00:23:48.000 --> 00:23:51.360
从客户的角度来看，您始终在使用cid

00:23:51.360 --> 00:23:54.640
但是如果我想基本上对传输层进行一些优化

00:23:54.640 --> 00:23:57.360
将加密的块从点a移到b或

00:23:57.360 --> 00:24:01.760
将点a到b的压缩块纯粹是传输协商，但

00:24:01.760 --> 00:24:06.480
最后，一旦我开始直接使用它，那就是

00:24:06.480 --> 00:24:10.240
完整的着装方式我认为嗯，对，我的意思是我不做一件事

00:24:10.240 --> 00:24:13.600
一定同意我认为您可以进行确定性压缩

00:24:13.600 --> 00:24:17.600
嗯，这是一个已经去过的领域，我在压缩方面做了很多工作

00:24:17.600 --> 00:24:20.720
在我的职业生涯中，所以我对此非常了解，所以我不知道为什么我们

00:24:20.720 --> 00:24:24.159
认为我理解为什么我们认为这不是确定性的，而是

00:24:24.159 --> 00:24:27.679
与其说是控制实施，不如说是

00:24:27.679 --> 00:24:32.000
是的，说像抑郁之类的算法不是确定性的，因为它

00:24:32.000 --> 00:24:35.520
因为这只是代码而已

00:24:35.520 --> 00:24:39.200
您必须对其进行控制，以确保它不会不是随机的

00:24:39.200 --> 00:24:42.880
数字是压缩的一部分，是呃，有参数，还有

00:24:42.880 --> 00:24:46.080
您可以为给定实施的策略肯定是不同的

00:24:46.080 --> 00:24:50.000
压缩格式，但都可以通过控制

00:24:50.000 --> 00:24:53.600
好吧，但是我最大的担心是我们正在尝试的这些东西

00:24:53.600 --> 00:24:59.360
甚至使dag seaboard完全确定um是

00:24:59.360 --> 00:25:02.960
您使用压缩算法通常可以为您提供

00:25:02.960 --> 00:25:08.159
有很多方法可以压缩相同的数据

00:25:08.159 --> 00:25:13.200
使用相同的算法进行解压缩，因此解压缩侧为

00:25:13.200 --> 00:25:15.440
这是不对称的事情

00:25:15.440 --> 00:25:18.880
减压会看着它，说是的，我可以解密

00:25:18.880 --> 00:25:24.240
我可以解压缩和um，而在压缩方面，您可以选择

00:25:24.240 --> 00:25:27.840
多种方式压缩数据

00:25:27.840 --> 00:25:31.440
变成减压会让um满意的格式

00:25:31.440 --> 00:25:34.480
因此，我们最终遇到了这个问题

00:25:34.480 --> 00:25:38.799
相同的数据，很多cid um，我们要做的是减少

00:25:38.799 --> 00:25:42.559
这种可能性，所以如果我们要指定压缩

00:25:42.559 --> 00:25:45.600
像迈克尔正在尝试的那样转换成我们的格式

00:25:45.600 --> 00:25:48.880
它必须是只有一种方法

00:25:48.880 --> 00:25:52.080
解压缩，对不起，一种压缩方式和一种解压缩方式

00:25:52.080 --> 00:25:55.120
并且，如果您要和在减压方面

00:25:55.120 --> 00:25:59.679
理想情况下，您应该应该能够验证它是否以这种方式压缩了

00:25:59.679 --> 00:26:03.360
是否有相同的字典

00:26:03.360 --> 00:26:07.440
或与您希望能够说出的算法相同的参数

00:26:07.440 --> 00:26:10.720
这已经通过了一种方式，而不是

00:26:10.720 --> 00:26:14.159
这是我压缩之前就没有见过的一些相同数据

00:26:14.159 --> 00:26:18.000
参数um稍有不同，我们希望将其最小化

00:26:18.000 --> 00:26:20.640
可能，以便使您知道我们实际上想消除

00:26:20.640 --> 00:26:23.600
如果可能的话，但是我们发现这很难做到

00:26:23.600 --> 00:26:27.520
只是dag cbo，这就像一个不错的过渡点，但是

00:26:27.520 --> 00:26:31.520
我会介绍一下我一直以来最酷的事情之一

00:26:31.520 --> 00:26:35.039
注意，嗯，所以首先，因为我一直在编写这种块格式

00:26:35.039 --> 00:26:38.240
为了确定性，您只需要一种方法

00:26:38.240 --> 00:26:41.039
正确的事情，例如您不能拥有可变性，您不能拥有可选择性

00:26:41.039 --> 00:26:45.840
它必须始终采用相同的方式um，但这就像

00:26:45.840 --> 00:26:49.360
结构以及结构本身是否支持

00:26:49.360 --> 00:26:52.559
压缩的某种形式最终要做的就是调整

00:26:52.559 --> 00:26:56.559
您的数据结构来适应它，然后您最终就不会

00:26:56.559 --> 00:27:00.080
改变确定性表示的算法

00:27:00.080 --> 00:27:03.440
正确，因为您吐出的表示将被分块

00:27:03.440 --> 00:27:06.080
不同，因此实际上是不同的数据，例如

00:27:06.080 --> 00:27:09.760
不同的字节数组，实际上是不同的数据

00:27:09.760 --> 00:27:12.799
它在确定性上有所不同，这些算法有多少

00:27:12.799 --> 00:27:15.600
要做的是弄清楚数据的布局应该是什么，以便

00:27:15.600 --> 00:27:20.080
将其压缩到一个表中，如果分开

00:27:20.080 --> 00:27:24.320
根据实际格式，您会说，哦，不，我们只有一种方法可以编码

00:27:24.320 --> 00:27:27.760
字节数组，它是确定性的，但我们将

00:27:27.760 --> 00:27:30.320
压缩，我们是否会复制其中的每一个

00:27:30.320 --> 00:27:33.120
个字节现在一下子就可以写多个

00:27:33.120 --> 00:27:36.480
全部吐出来的减压算法

00:27:36.480 --> 00:27:39.600
不同的数据结构，但是这些数据结构中的每一个都可以是

00:27:39.600 --> 00:27:41.840
确定性地序列化和反序列化

00:27:41.840 --> 00:27:44.559
那有意义吗

00:27:46.000 --> 00:27:48.960
这实际上是个好地方，这是真正开始的好地方

00:27:48.960 --> 00:27:51.520
说话，因为然后在这里我会告诉你，我会告诉你这个

00:27:51.520 --> 00:27:55.039
新的块格式，因为到最后都有意义

00:27:55.039 --> 00:28:00.080
一个快速的评论，这是真正的快速，所以我认为一般的事情之一是

00:28:00.080 --> 00:28:03.840
做一些压缩比做任何压缩都好

00:28:03.840 --> 00:28:07.760
零压缩我认为这是我赖以生存的一种经验法则

00:28:07.760 --> 00:28:11.840
嗯，听到很多人说，所以我认为这并不是要拥有最多的

00:28:11.840 --> 00:28:15.039
有效的压缩算法，但实际上做了一些

00:28:15.039 --> 00:28:18.880
聘请非常快速的压缩算法

00:28:18.880 --> 00:28:25.039
像放气一样快，几乎可以做到MEM复制速度UM，所以

00:28:25.039 --> 00:28:27.520
呃，比起那样做会更好

00:28:27.520 --> 00:28:31.760
gzip 9级只是做耶稣一级，总比没有好，所以

00:28:31.760 --> 00:28:36.240
无论如何，我会把它交给我，我认为那些简单的格式往往是

00:28:36.240 --> 00:28:39.279
也是最确定的，因为它们实际上是简单的算法

00:28:39.279 --> 00:28:42.880
是的，但还是像我针对文件硬币链数据测试了这一点

00:28:42.880 --> 00:28:46.159
甚至只有百分之三，因为该数据不是

00:28:46.159 --> 00:28:49.039
实际上是可压缩的，因为它们都是加密的

00:28:49.039 --> 00:28:51.760
生成的，所以它不是，实际上不是

00:28:51.760 --> 00:28:55.600
值得，它实际上比不做任何事都要好，因为它花费了两倍

00:28:55.600 --> 00:28:58.960
需要序列化才能序列化，这不值得三分钱

00:28:58.960 --> 00:29:03.600
获得块格式是的，我只是一件事而已

00:29:03.600 --> 00:29:06.720
在评论中，有些比较总比没有压缩要好

00:29:06.720 --> 00:29:12.960
如果执行deflate或gzip，则无法执行gzip九

00:29:12.960 --> 00:29:19.600
除此之外，所以绝对有一个折衷点，如果

00:29:19.600 --> 00:29:21.360
压缩后，可以按一次

00:29:21.360 --> 00:29:25.120
双重压缩或类似的方法是的，您不会双重压缩，但

00:29:25.120 --> 00:29:28.880
我的意思是说我实际上会与迈克尔·乌姆（Michael um）争论

00:29:28.880 --> 00:29:32.080
您的文件投币观看数据已被压缩

00:29:32.080 --> 00:29:35.760
所以我说的基本上是不，我到处都用var end所以

00:29:35.760 --> 00:29:39.200
好像压缩得很好，不，不，不，我在说，我在

00:29:39.200 --> 00:29:41.840
谈论的只是原始数据，例如文件中的硬币

00:29:41.840 --> 00:29:45.440
解码成海带，然后划入我的东西，就像我刮胡子一样

00:29:45.440 --> 00:29:48.720
由于我在其他地方做了其他事情，因此它的字节数多于三个

00:29:48.720 --> 00:29:51.840
块格式我只是说当我取值数据时的区别

00:29:51.840 --> 00:29:55.440
并压缩它，就像将它减少了三倍

00:29:55.440 --> 00:29:58.960
是的，这是，这是

00:29:58.960 --> 00:30:02.399
将取决于用例，例如，如果您采用平均ipfs数据，

00:30:02.399 --> 00:30:05.840
是一个网站，那么您实际上会得到一些

00:30:05.840 --> 00:30:11.360
从那里受益嗯，好吧，好吧

00:30:11.360 --> 00:30:15.200
我什至还没有命名这个，好吧，zdag好吧，所以

00:30:15.200 --> 00:30:18.240
我在星期四有这个主意，然后我没有

00:30:18.240 --> 00:30:23.120
自从um以来就停止了工作，但是有效，所以这是一个障碍

00:30:23.120 --> 00:30:27.200
看起来像这样的结构，您有一个链接标题和一个值

00:30:27.200 --> 00:30:29.440
标头，然后是数据的实际结构

00:30:29.440 --> 00:30:33.200
因此，您可以预先加载链接，然后基本上就可以获得所有值信息

00:30:33.200 --> 00:30:36.640
然后只是打印出结构，所以链接

00:30:36.640 --> 00:30:40.240
编码看起来像这样，所以您首先对其进行排序

00:30:40.240 --> 00:30:44.080
基于像cid一样的特定排序算法，这样我们就可以

00:30:44.080 --> 00:30:48.480
嗯，首先，这些之间没有定界符，因为我们知道

00:30:48.480 --> 00:30:52.320
解码规则适用于cid，因此我们唯一需要的定界符是一个空字节

00:30:52.320 --> 00:30:55.919
链接设置程序的最末端，然后

00:30:55.919 --> 00:30:59.279
因为我们以这种方式对它们进行分类，然后我们就可以剃

00:30:59.279 --> 00:31:03.200
所有不同cid类型的所有前缀字节

00:31:03.200 --> 00:31:06.720
因为你只把它们放在这里一次

00:31:06.720 --> 00:31:10.720
这实际上是一个压缩表，所以现在每当您引用这些cid时

00:31:10.720 --> 00:31:13.840
而该结构的其余部分仅占用一个或两个字节，具体取决于

00:31:13.840 --> 00:31:16.840
在容器格式上，因为它可能需要也可能不需要输入

00:31:16.840 --> 00:31:20.080
信息，我们用价值观来做同样的事情

00:31:20.080 --> 00:31:22.880
取所有值，我们应该先按长度对它们进行排序

00:31:22.880 --> 00:31:26.640
然后通过字节比较，然后当我们存储它们时

00:31:26.640 --> 00:31:31.600
在这个值标题中，我们将长度放在前面，但是我们把增加值放在前面

00:31:31.600 --> 00:31:34.159
在长度上，所以如果你看这是四个

00:31:34.159 --> 00:31:37.760
因为它从零开始增加，然后又是零，因为这一个

00:31:37.760 --> 00:31:40.960
又是四个，然后六个长度变成两个

00:31:40.960 --> 00:31:45.600
um，这将实际长度整数保留在values标头中

00:31:45.600 --> 00:31:49.440
低，实际上甚至压缩了表中的表示

00:31:49.440 --> 00:31:54.320
一点点，嗯，你解析这个的时候，你需要

00:31:54.320 --> 00:31:57.440
验证其确定性的长度很容易，但是您还需要通过

00:31:57.440 --> 00:32:00.000
比较，因为您将依靠

00:32:00.000 --> 00:32:02.960
稍后对值标头进行确定性排序

00:32:02.960 --> 00:32:06.559
嗯，还有一些我们将要介绍的东西，所以，如果您看一下结构，这是

00:32:06.559 --> 00:32:11.519
就像一个简单的列表um，所以100以下的数字不会冲突

00:32:11.519 --> 00:32:15.600
与我的令牌空间，所以他们基本上只是内联，

00:32:15.600 --> 00:32:20.000
那么超过127的数字也是贫瘠之地

00:32:20.000 --> 00:32:23.200
基本上，所以您可以内联大多数数字而无需

00:32:23.200 --> 00:32:26.880
任何其他类型的信息，只有令牌空间中的一些东西是

00:32:26.880 --> 00:32:29.519
占用了um，这就是列表的样子

00:32:29.519 --> 00:32:32.640
当它是根结构时，我们省略尾随定界符

00:32:32.640 --> 00:32:37.120
也没有链接或值的时候

00:32:37.120 --> 00:32:40.399
我们还可以使用一些额外的规则删除空字节

00:32:40.399 --> 00:32:44.000
所以我一直在削减这种格式的很多字节，如您所见

00:32:44.000 --> 00:32:47.519
嗯，这就像是列表右边的列表，所以109

00:32:47.519 --> 00:32:51.120
一个109，然后是两个3，然后是定界符，然后我们

00:32:51.120 --> 00:32:54.320
同样，我们可以省略尾部定界符，因为我们知道根结构

00:32:54.320 --> 00:32:56.720
是一个列表，所以就像我们得到的那样，这非常好

00:32:56.720 --> 00:32:58.799
就像这里的带有三个值的嵌套列表

00:32:58.799 --> 00:33:05.360
嗯，六个字节，嗯，你也看到null tr​​ue false

00:33:05.360 --> 00:33:08.320
这里显示的常量就是序列化的样子

00:33:08.320 --> 00:33:13.120
像这样的清单，好吧，让我们看看一些足迹

00:33:13.120 --> 00:33:15.760
嗯，其中没有链接，所以我们得到一个零字节

00:33:15.760 --> 00:33:20.080
um分隔链接um此标头值是错误的，抱歉不应该

00:33:20.080 --> 00:33:24.480
是12而不是10。嗯，那么我们看到偏移量是5，那么我们得到

00:33:24.480 --> 00:33:28.159
用二进制而不是零打招呼，因为下一个也是5

00:33:28.159 --> 00:33:31.519
在世界上，那么我们说那是一张地图

00:33:31.519 --> 00:33:35.200
我现在正在玩耍并在地图上戳

00:33:35.200 --> 00:33:39.360
补偿规则，因此本示例中的某些规则可能略有不同um

00:33:39.360 --> 00:33:45.360
所以这基本上是地图首先是地图中键的偏移量

00:33:45.360 --> 00:33:48.880
所以那是一个人，是一个人

00:33:48.880 --> 00:33:52.720
我待会儿再说，但是就像地图上的第一个钥匙

00:33:52.720 --> 00:33:56.480
总是偏移一个，而你有一个单独的

00:33:56.480 --> 00:34:00.320
空地图的令牌，这就是um

00:34:00.320 --> 00:34:05.440
每个后续密钥或对不起每个后续密钥参考

00:34:05.440 --> 00:34:09.200
是相对于第一个偏移量的增加

00:34:09.200 --> 00:34:14.079
因此与结尾的空定界符确实存在冲突，以结束地图

00:34:14.079 --> 00:34:19.280
因此实际上不可能写出您依赖的不确定地图

00:34:19.280 --> 00:34:22.960
确定表的顺序，然后您只看到此处的增加

00:34:22.960 --> 00:34:26.159
实际上，您有一条规则意味着您甚至无法解析

00:34:26.159 --> 00:34:29.839
嗯，在确定性地图中，这很棒，那么您会发现您也拥有

00:34:29.839 --> 00:34:33.520
值索引显然这是实际上这个例子是错误的

00:34:33.520 --> 00:34:36.000
因为这是一个无类型的地图，所以应该

00:34:36.000 --> 00:34:41.520
应该在那里有一个尾随的um uh字符串，所以它应该有

00:34:41.520 --> 00:34:43.919
是103之类的东西

00:34:43.919 --> 00:34:47.679
然后很抱歉，我的字面意思是深夜写的

00:34:47.679 --> 00:34:50.879
嗯，但是在这里，这就像你知道的

00:34:50.879 --> 00:34:53.119
什么是具有更多值的更复杂的对象，以及

00:34:53.119 --> 00:34:56.320
您会看到压缩开始在此处进行设置

00:34:56.320 --> 00:34:59.680
你知道我再次指的是相同的字符串，所以他们只是去

00:34:59.680 --> 00:35:02.240
在这里进行重复数据删除，他们不会占用大量额外资源

00:35:02.240 --> 00:35:04.480
空间，但这就是我

00:35:04.480 --> 00:35:08.880
现在就在工作，所以这是类型化的列表和地图，所以当您有一个

00:35:08.880 --> 00:35:13.119
您可以输入打字清单或地图

00:35:13.119 --> 00:35:18.800
从中删除它的键入的um前缀，然后您会得到很多

00:35:18.800 --> 00:35:23.040
更紧凑的空间，所以这里有一个字符串类型列表，因此

00:35:23.040 --> 00:35:24.560
这就像所有的价值观一样

00:35:24.560 --> 00:35:27.920
我没有新的呃哦，不，这是一个列表，所以它总是

00:35:27.920 --> 00:35:34.000
嗯，它始终是索引加1，所以您可以使用

00:35:34.000 --> 00:35:37.599
尾随零以将其限制为这些类型的列表，但这意味着

00:35:37.599 --> 00:35:40.800
现在就像一个类型列表的压缩空间

00:35:40.800 --> 00:35:42.960
当您不改变类型，列表和地图时

00:35:42.960 --> 00:35:46.240
其实真的很小，就像我们可以变得非常有效

00:35:46.240 --> 00:35:50.160
表示um和我谈话后的想法

00:35:50.160 --> 00:35:54.000
其实是那个规则集的那个

00:35:54.000 --> 00:36:00.560
对于解析这些引用，我们实际上可以说

00:36:06.240 --> 00:36:11.040
他只是杀死了自己的人，你永远不知道我们该怎么说

00:36:19.119 --> 00:36:22.720
好的，好的，对不起，对不起，ii，搞砸了，对不起

00:36:22.720 --> 00:36:26.560
嗯，是的，所以我喜欢我按了错误的按钮来结束演示，

00:36:26.560 --> 00:36:29.280
实际上退出那件事，所以无论如何我说得太快了

00:36:29.280 --> 00:36:33.920
因为我对此感到非常兴奋，但是无论如何，你最终会得到什么

00:36:33.920 --> 00:36:36.480
就像这些非常有效的表示，所以

00:36:36.480 --> 00:36:40.480
我在文件硬币链上的测试是，它将像

00:36:40.480 --> 00:36:43.119
当我都说完了大约百分之十时，我想我想我们要走了

00:36:43.119 --> 00:36:45.599
将度海鲈鱼削掉约10％

00:36:45.599 --> 00:36:49.200
嗯，这并没有真正利用任何重复数据删除的优势

00:36:49.200 --> 00:36:53.359
就像什么都没有一样，没有任何重复的CID或

00:36:53.359 --> 00:36:56.320
二进制值，就像您真正获得的唯一节省一样

00:36:56.320 --> 00:36:59.359
那10就是效率更高

00:36:59.359 --> 00:37:03.599
链接的表示以及其他一些

00:37:03.599 --> 00:37:07.599
我能够利用确定性来消除格式的字节

00:37:07.599 --> 00:37:12.480
嗯，但是您现在可以知道此功能存在

00:37:12.480 --> 00:37:18.000
对，如果您知道您总是可以重复进行UM，那么您可以做一些事

00:37:18.000 --> 00:37:22.000
就像呃写特定领域的压缩算法

00:37:22.000 --> 00:37:25.520
这样您就可以开始喜欢整理数据并更改数据结构

00:37:25.520 --> 00:37:29.440
这样您就可以利用适当的重复信息，因为您知道

00:37:29.440 --> 00:37:33.040
因此，如果您保留ta，则保留值表和

00:37:33.040 --> 00:37:38.400
或链接表低于100 um，或者遗憾的是，链接表不低于255，低于100。

00:37:38.400 --> 00:37:42.320
整个表的所有地址都将是一个字节

00:37:42.320 --> 00:37:46.640
一旦您超过255，那便是一个远端，因此它可能会更大一些

00:37:46.640 --> 00:37:49.680
但是我们基本上有该表的最大空间

00:37:49.680 --> 00:37:55.119
当您通过它自己的方式工作时，就可以真正开始设计一些

00:37:55.119 --> 00:37:59.760
um之所以疯狂的数据结构是超级紧凑的，因为

00:37:59.760 --> 00:38:03.680
以及他们如何利用块格式内部的这种压缩

00:38:03.680 --> 00:38:07.280
有趣的是，像所有这些特定于域的算法一样

00:38:07.280 --> 00:38:11.520
有关如何布置算法的方法特定于应用程序，

00:38:11.520 --> 00:38:14.400
块格式将一直解码

00:38:14.400 --> 00:38:18.079
嗯，就像不知道这些算法中的任何一个一样，另一个很酷的事情是

00:38:18.079 --> 00:38:22.079
那是因为您将所有这些都放在一个常量表中

00:38:22.079 --> 00:38:27.200
呃，缩小块的大小

00:38:27.200 --> 00:38:31.520
重复数据删除时的时间也会转换为内存开销

00:38:31.520 --> 00:38:34.320
您解析结构，因为当您解析它们时，它们也是

00:38:34.320 --> 00:38:36.880
会以常量形式出现，然后返回引用，因此它们总是

00:38:36.880 --> 00:38:39.760
将成为指针，不像当您像json或

00:38:39.760 --> 00:38:42.720
每次看到一个字符串时，总是将其变成一个新的字符串，然后

00:38:42.720 --> 00:38:45.680
那么您就有两个记忆，除非您想去检查

00:38:45.680 --> 00:38:50.880
那些，然后对它们进行重复数据删除，嗯，是的，这有点疯狂

00:38:50.880 --> 00:38:53.680
因为它真正是它是一个街区

00:38:53.680 --> 00:38:58.560
格式作为压缩表，就像块格式一样

00:38:58.560 --> 00:39:01.680
您可以使用ipld进行编程以压缩数据

00:39:01.680 --> 00:39:04.960
代表性，所以您可以非常喜欢

00:39:04.960 --> 00:39:09.119
与我们过去考虑过的事情不同

00:39:09.119 --> 00:39:12.800
嗯，当我像原始人给我的优化一样

00:39:12.800 --> 00:39:16.320
嗯，还有其他一些想法，比如你可以

00:39:16.320 --> 00:39:21.200
取一个子集，然后说，好吧，我们有一个字节类型列表，然后

00:39:21.200 --> 00:39:24.880
对该表的引用，所以现在它就像一个非常好的

00:39:24.880 --> 00:39:29.119
适用于任何域特定压缩的通用容器格式

00:39:29.119 --> 00:39:31.680
完全可交易的算法，因此您

00:39:31.680 --> 00:39:34.960
如果您不打算使用流算法进行压缩，则不需要

00:39:34.960 --> 00:39:39.040
您几乎总是可以编写更有效的压缩算法

00:39:39.040 --> 00:39:42.800
使用这种块结构，然后您就像字节数组一样返回

00:39:42.800 --> 00:39:45.440
你放在一起，所以你可以从字面上

00:39:45.440 --> 00:39:47.760
就像写一个标准的词，现在只是一般的

00:39:47.760 --> 00:39:51.280
压缩格式，然后您就可以正确解码峰值信号，然后为我们

00:39:51.280 --> 00:39:54.560
这些东西总是会被解码成有效的fbl段

00:39:54.560 --> 00:39:58.000
因此您可以将它们用作fbl，可以将它们粘贴到其他fbl中，并且它们

00:39:58.000 --> 00:40:00.960
他们只是工作而已

00:40:05.760 --> 00:40:10.000
很高兴看到更多示例，我认为

00:40:10.000 --> 00:40:13.119
只是为了通过一件事而努力

00:40:13.119 --> 00:40:16.560
我一直在做的是叫做sebor ld的东西，所以cbor

00:40:16.560 --> 00:40:22.880
将数据链接到您在哪里使用jsonld的数据透视表

00:40:22.880 --> 00:40:26.720
根据外部库将int创建为键

00:40:26.720 --> 00:40:30.640
在IETF工作组海滨工作中对此进行了很好的讨论

00:40:30.640 --> 00:40:32.960
就像两三个星期前一样

00:40:32.960 --> 00:40:38.079
挑战是您需要具有加密散列

00:40:38.079 --> 00:40:42.079
外部库，然后立即订购

00:40:42.079 --> 00:40:46.000
属性的关键基本上是ins的

00:40:46.000 --> 00:40:49.200
由序列化算法确定

00:40:49.200 --> 00:40:53.280
因此，如果您在其中放置其他字典，则实际上可以抵消它，

00:40:53.280 --> 00:40:56.480
因为我们正在处理的是加密材料，实际上您在大多数情况下都可以喜欢

00:40:56.480 --> 00:41:00.800
密码库采用null并将null验证为true或

00:41:00.800 --> 00:41:03.680
有效，所以现在存在很大的漏洞

00:41:03.680 --> 00:41:06.800
我们正在尝试通过某种方式工作，我建议使用CID

00:41:06.800 --> 00:41:11.599
作为外部库的链接

00:41:12.240 --> 00:41:16.240
是的，我的意思是那是一个非常好的主意，我不喜欢其中一件

00:41:16.240 --> 00:41:19.359
这让我对外部表有些困惑

00:41:19.359 --> 00:41:22.880
是他们真的搞砸了数据结构的确定性

00:41:22.880 --> 00:41:25.440
正确显示出来是因为您可以采用相同的数据结构，然后应用

00:41:25.440 --> 00:41:27.599
不同的表，然后您将有效地结束

00:41:27.599 --> 00:41:31.440
相同的语义数据输出，但对于块格式而言将是不同的哈希

00:41:31.440 --> 00:41:35.520
是的，所以这方面的好处是，唯一的信息是

00:41:35.520 --> 00:41:38.640
压缩是在块中，所以它是完全

00:41:38.640 --> 00:41:42.160
确定性的块数据，所以您无法采取不同的方法

00:41:42.160 --> 00:41:47.200
阻止数据并从中获取不同的哈希值

00:41:47.200 --> 00:41:49.839
正确的

00:41:51.200 --> 00:41:54.640
但这是压缩的限制，因为

00:41:54.640 --> 00:42:00.319
您可能不想要所有的压缩表，或者您的低端

00:42:00.319 --> 00:42:04.000
压缩表是真的很小的字符串

00:42:04.000 --> 00:42:06.800
诸如效率之类的原因，为什么您可能不想做正确的事

00:42:06.800 --> 00:42:09.200
而且您实际上没有能力对其进行调整，因为它是

00:42:09.200 --> 00:42:11.520
确定性排序，所以它不像

00:42:11.520 --> 00:42:16.800
总是最好的压缩表，但是就像最好的一样

00:42:16.800 --> 00:42:20.079
确定性转换表

00:42:21.280 --> 00:42:24.240
我一直在尝试一些有趣的属性

00:42:24.240 --> 00:42:29.200
考虑一下，需要对此进行更多的思考

00:42:29.200 --> 00:42:34.480
一个就是如果您跳到

00:42:34.480 --> 00:42:38.319
结构部分，我认为有足够的信息

00:42:38.319 --> 00:42:40.880
在那里验证我们的任何计划

00:42:40.880 --> 00:42:44.319
我们的任何ipld模式um，如果您是

00:42:44.319 --> 00:42:47.839
如果您是中间人，不关心内容

00:42:47.839 --> 00:42:50.480
阻止，但需要执行某种验证

00:42:50.480 --> 00:42:53.760
呃，也许你是一个需要

00:42:53.760 --> 00:42:57.440
将数据输入到某些adl或其他内容中

00:42:57.440 --> 00:43:02.400
这是有效的东西，那么你应该可以跳到

00:43:02.400 --> 00:43:08.960
结构部分，只要通过它，就不会有多余的东西被咬

00:43:08.960 --> 00:43:11.760
您需要跳过所有的结构

00:43:11.760 --> 00:43:15.520
然后应该能够与模式匹配

00:43:15.520 --> 00:43:19.359
并且您应该能够进行相当快速的架构验证，如果您

00:43:19.359 --> 00:43:22.640
在最底层建立的是

00:43:22.640 --> 00:43:25.839
这种验证需要建立在最低级别，即您

00:43:25.839 --> 00:43:28.640
可以很好地进入那里

00:43:28.640 --> 00:43:31.200
机会，尽管这样做是对的，因为您想要做的一件事

00:43:31.200 --> 00:43:33.520
要做的就是你想要像你想要的那样

00:43:33.520 --> 00:43:37.200
在不解析所有内容的情况下验证该块是否有效

00:43:37.200 --> 00:43:40.720
是的，所以像这样，您实际上可以跑过去

00:43:40.720 --> 00:43:44.480
结构并进行验证只是为了确保它像一个有效的

00:43:44.480 --> 00:43:48.240
um z-dag可以阻止您就知道它现在可以阻止它了

00:43:48.240 --> 00:43:50.880
实际上正确解析的任何错误，

00:43:50.880 --> 00:43:54.560
然后，如果您在该结构内部拥有您关心的输入信息

00:43:54.560 --> 00:43:58.160
您可以在那时进行验证，而无需获取任何字节值，并且

00:43:58.160 --> 00:44:02.400
转换为字符串um，除非您特别需要

00:44:02.400 --> 00:44:06.240
通过字符串映射键遍历，那么您将

00:44:06.240 --> 00:44:09.839
不得不解析的那个，但是大多数

00:44:09.839 --> 00:44:13.119
验证实际上可以做到这一点，还有其他一些

00:44:13.119 --> 00:44:17.040
您也可以做一些疯狂的事情，例如，如果您要检查路径是否在

00:44:17.040 --> 00:44:21.760
在那里，地图上没有任何键

00:44:21.760 --> 00:44:24.800
它与第一个的长度相匹配，您甚至不必解析

00:44:24.800 --> 00:44:27.520
像您一样将其拔出，您已经知道了

00:44:27.520 --> 00:44:30.079
它不在那个街区，所以你有很多类似的东西

00:44:30.079 --> 00:44:33.440
走出um，如果您正在阻止逆转

00:44:33.440 --> 00:44:37.280
而您只是为了获得价值而四处走动，您可以做到这一点而无需

00:44:37.280 --> 00:44:41.520
像您最喜欢的解析一样，您可以通过路径进行解析

00:44:41.520 --> 00:44:44.720
嗯，那么您最终只会转换

00:44:44.720 --> 00:44:47.760
值表外的任何字符串

00:44:47.760 --> 00:44:53.680
um，如果它们是您遍历的地图键，或者它们是最终值

00:44:55.760 --> 00:45:00.960
对于我们的计划者而言，另一个有趣的属性是

00:45:00.960 --> 00:45:08.319
该格式使我认为我们所有的工会类型都相当便宜

00:45:08.319 --> 00:45:12.400
与我们现在拥有的特别是json和cbore相比

00:45:12.400 --> 00:45:19.520
这样您就可以节省使用某种工会的费用，但其余的则是

00:45:19.520 --> 00:45:22.560
没有比工会贵得多的了

00:45:22.560 --> 00:45:25.599
之所以使用这种格式，是因为您将其刷掉了

00:45:25.599 --> 00:45:29.839
键联会喜欢的很多无关数据

00:45:29.839 --> 00:45:32.880
关键的种类刷在其他地方

00:45:32.880 --> 00:45:36.480
它的关键是多少，甚至都没有关系

00:45:36.480 --> 00:45:40.480
这就是为什么您仍然拥有钥匙的故事的原因，尽管我是说您知道

00:45:40.480 --> 00:45:43.599
必须扔给他们，但与

00:45:43.599 --> 00:45:46.880
工会，你往往有重复的键，就像在

00:45:46.880 --> 00:45:51.359
您拥有多达32个具有完全相同密钥的uh元素

00:45:51.359 --> 00:45:55.119
在带键的工会中，您不必将其存储一次

00:45:55.119 --> 00:46:00.800
嗯，而对于dag cbo和jason，您必须重复它，但是，如果可以的话

00:46:00.800 --> 00:46:04.240
只需将其提取出来就可以保存，因为和

00:46:04.240 --> 00:46:08.000
这就是工会的本质，因为它们往往是您可以重复的结构

00:46:08.000 --> 00:46:11.599
一次又一次地在您的数据中使用

00:46:11.599 --> 00:46:15.680
我绝对会在这里碰到的一件事是，因为我们没有

00:46:15.680 --> 00:46:18.960
输入我们要保存该字节的映射键

00:46:18.960 --> 00:46:25.359
因此，对于我们来说，映射uh键（作为字符串）与该键相同

00:46:25.359 --> 00:46:28.079
是一个字节或整数，它不会占用任何多余的空间

00:46:28.079 --> 00:46:31.599
空格，因为我们实际上没有中继任何键入信息

00:46:31.599 --> 00:46:36.720
所以这实际上很好，我们没有碰到任何东西

00:46:36.720 --> 00:46:40.640
但是我要提到的一件事是，这确实给了您激励

00:46:40.640 --> 00:46:48.079
使用总是相同类型的地图或列表，所以是的

00:46:48.079 --> 00:46:51.920
例如当您在进行地图或元组表示时

00:46:51.920 --> 00:46:55.200
对于结构体，并且您有混合类型，我们肯定会减少它的大小

00:46:55.200 --> 00:46:58.960
并使其具有可比性，但是如果您使用的是元组

00:46:58.960 --> 00:47:02.160
表示结构及其中的所有内容

00:47:02.160 --> 00:47:04.400
相同的类型，它将变得更小

00:47:04.400 --> 00:47:10.480
实际上是因为我们从字面上理解了所有这些类型前缀

00:47:10.480 --> 00:47:14.160
我也只是看到一些例子，因为我认为这个例子你

00:47:14.160 --> 00:47:17.520
所显示的基本上是您在说列表的开始列表的结尾

00:47:17.520 --> 00:47:22.079
因此，但我认为在适当的海上航行中，

00:47:22.079 --> 00:47:25.760
原始块存储基本上必须说明

00:47:25.760 --> 00:47:29.040
它实际上已经转换为数组，并且要前置

00:47:29.040 --> 00:47:34.240
是的，阵列的大小是多少，是的，我们不，是的，我不这样做，因为嗯

00:47:34.240 --> 00:47:37.440
出于几个原因，但有一个原因是它较小

00:47:37.440 --> 00:47:43.200
um，因为长度通常会大于零，因此如果为零或

00:47:43.200 --> 00:47:45.359
一个字节的字段将成为我的定界符

00:47:45.359 --> 00:47:48.559
那么输入长度会更大，所以没有意义

00:47:48.559 --> 00:47:52.160
是的，但我认为实际上您的ipld规范指出

00:47:52.160 --> 00:47:57.839
基本上不必声明无限大或不确定的列表大小

00:47:57.839 --> 00:48:03.839
这是一个大小为10的int数组。

00:48:03.839 --> 00:48:07.359
是的，但是我们不强制执行

00:48:07.359 --> 00:48:10.720
不，不保留数据模型的工作方式是因为数据模型只是来了

00:48:10.720 --> 00:48:14.000
在解析完编解码器后开始播放

00:48:14.000 --> 00:48:18.240
解析器始终可以告诉您数组的长度有多大，因为

00:48:18.240 --> 00:48:21.520
它将在不需要在块中的末尾完成解析

00:48:21.520 --> 00:48:25.359
格式正确，就像我们知道我们知道不是，我们知道这不是

00:48:25.359 --> 00:48:27.280
无限长，因为块有末端

00:48:27.280 --> 00:48:31.359
因此，我们肯定知道这一点，并且等到您从解析器取回它时

00:48:31.359 --> 00:48:36.800
它肯定有固定的长度，是的，这可以回溯到那个

00:48:36.800 --> 00:48:38.960
压缩之前我正在谈论的事情

00:48:38.960 --> 00:48:46.400
恩，约翰尼，我们目前使用的Seaborg Uh解码器，我对此一无所知

00:48:46.400 --> 00:48:50.559
也许eric的限制更严格，但他们会接受

00:48:50.559 --> 00:48:56.319
无限大小的长度，然后在最后给你东西，而

00:48:56.319 --> 00:48:59.280
当我们编码时，编码器会预先确定大小

00:48:59.280 --> 00:49:03.920
所以编码器总是做同样的事情，但是解码器草率，所以他们

00:49:03.920 --> 00:49:07.200
他们会为您提供看起来完全一样的数据，但其中有一个

00:49:07.200 --> 00:49:09.839
不同的CID，因为它的编码略有不同，所以

00:49:09.839 --> 00:49:13.520
如果有人产生一个编码器说

00:49:13.520 --> 00:49:16.960
生锈，您知道自己正在进行调查，而婴儿调查的确不确定

00:49:16.960 --> 00:49:20.160
大小长度元素，它们将被正确解码

00:49:20.160 --> 00:49:23.280
但是如果我们来回旅行，我们会得到一个不同的cid，这就是我们要解决的问题

00:49:23.280 --> 00:49:27.280
继续与海滨作战，有很多方法可以做到

00:49:27.280 --> 00:49:32.079
简单的事情，只是它变得疯狂，所以

00:49:32.079 --> 00:49:35.359
定义新格式的一件好事是，我们不得不说没有

00:49:35.359 --> 00:49:38.160
只有一种做那件事的方法，你知道你做不到，没有

00:49:38.160 --> 00:49:40.480
可变性在这里你不能做不同大小的ins

00:49:40.480 --> 00:49:46.160
不，这都是一种方法，所以这是一个机会，呃

00:49:46.160 --> 00:49:50.000
还有一个点，再加上一个点，就无限期地

00:49:50.000 --> 00:49:52.640
尺寸列表（如果将它们与

00:49:52.640 --> 00:49:55.200
压缩你实际上不知道你有多大

00:49:55.200 --> 00:50:01.119
是的，但是像呃，我的意思是好东西

00:50:01.119 --> 00:50:03.680
关于只有一种做事的方式是，你会喜欢

00:50:03.680 --> 00:50:07.599
只是残酷地刮掉了格式，因为您不需要，因为

00:50:07.599 --> 00:50:11.359
缺乏可变性意味着更少的代币和更少的差异

00:50:11.359 --> 00:50:14.640
恩，我也喜欢疯狂的事情

00:50:14.640 --> 00:50:22.720
是它还允许更少的与有效数据的令牌冲突，所以

00:50:22.720 --> 00:50:26.480
嗯，就像一个例子，在我看来

00:50:26.480 --> 00:50:32.240
能够编码0.0浮点数是确定性中的错误，因为

00:50:32.240 --> 00:50:36.400
实际上是与整数相同的值，并且在很多动态情况下

00:50:36.400 --> 00:50:39.520
语言无法正常往返，因为就像您一样

00:50:39.520 --> 00:50:42.640
谈论您刚刚以块格式键入的内容

00:50:42.640 --> 00:50:45.920
而不是像在块格式上方的数据模型层中那样输入

00:50:45.920 --> 00:50:49.040
如果需要浮子或图像或其他任何东西，请转换它

00:50:49.040 --> 00:50:52.240
嗯，很像varance像avara

00:50:52.240 --> 00:50:55.599
它是在任何最小空间中进行编码的，并且如果需要它是64位的

00:50:55.599 --> 00:50:58.800
您将其转换为64位整数，就像我们在

00:50:58.800 --> 00:51:01.520
在这里编码同样的东西，我们就像

00:51:01.520 --> 00:51:06.400
您不允许进行0.0 um的浮动，实际上它们会

00:51:06.400 --> 00:51:10.240
无法解析或验证，因为我们需要将该零字节用于其他

00:51:10.240 --> 00:51:15.200
嗯，就像是

00:51:15.200 --> 00:51:20.400
这就是为什么是的，我只想提及我也

00:51:20.400 --> 00:51:24.000
今天早些时候向迈克尔提到过，因为有一个

00:51:24.000 --> 00:51:27.599
Fi已经存在一种格式，几乎是同一回事

00:51:27.599 --> 00:51:33.520
它被称为跳蚤，我发布了一个链接um，并且它在我的待办事项列表中以实现

00:51:33.520 --> 00:51:36.400
就像过去一样，这让我不知所措，六年了，或者

00:51:36.400 --> 00:51:39.119
东西，但现在迈克尔想出了这个

00:51:39.119 --> 00:51:42.800
我认为我必须这样做，因为我很确定它已经

00:51:42.800 --> 00:51:48.480
几乎相同的属性，所以它当然不能存储cid，因为

00:51:48.480 --> 00:51:51.920
它不是内置的，因此基本上是一种已制成的格式

00:51:51.920 --> 00:51:56.559
用于一般的json数据，但效率更高，而且也像

00:51:56.559 --> 00:52:00.319
稍有不同的目标是您可以轻松遍历数据

00:52:00.319 --> 00:52:03.200
无需反序列化所有内容

00:52:03.200 --> 00:52:06.880
您可以轻松地从根本上跳到数据深处

00:52:06.880 --> 00:52:10.240
快速嵌套事物，而无需对所有事物进行分割

00:52:10.240 --> 00:52:13.760
嗯但是是的

00:52:13.920 --> 00:52:17.680
是的，所以我不认为那是

00:52:17.680 --> 00:52:21.440
该功能的必要性仅仅是因为它是如此

00:52:21.440 --> 00:52:25.599
便宜地解析结构，因为您遇到的所有事情

00:52:25.599 --> 00:52:29.119
是您要检查所有令牌空间的即时变体，并且

00:52:29.119 --> 00:52:32.000
任何可能产生的东西，然后您实际上就可以跳过

00:52:32.000 --> 00:52:35.760
对任何你不在乎的事情都没错，所以实际上就像

00:52:35.760 --> 00:52:39.520
真的很简单，因为它的成本不是很高

00:52:39.520 --> 00:52:42.240
从0到100在索引中，所以您实际上不需要

00:52:42.240 --> 00:52:47.200
就像跳过列表功能一样，是的，我可以看到效果如何

00:52:47.200 --> 00:52:52.240
如果您要内联um之类的任何正确的东西（仅ii），则非常有用

00:52:52.240 --> 00:52:54.160
那样只有那样高效，因为我们

00:52:54.160 --> 00:52:57.359
我们永远不会有一个不会被解析的大值

00:52:57.359 --> 00:53:02.240
靠自己，但无论如何我都期待做一个比较，因为现在我

00:53:02.240 --> 00:53:06.480
有理由在锈病中真正实现这一目标

00:53:06.800 --> 00:53:09.760
也喜欢我认为非常重要的另一件事，就像我们有很多

00:53:09.760 --> 00:53:12.240
数据中遍布他妈的位置的数字

00:53:12.240 --> 00:53:15.359
结构，所以我真的很希望数字格式为

00:53:15.359 --> 00:53:19.680
尽可能紧凑，以便在任何地方解析值var

00:53:19.680 --> 00:53:22.480
基本结束内联，然后令牌空间只是

00:53:22.480 --> 00:53:26.000
如果您做一个可以用标记空间轻弹一些变量的变量，那么您

00:53:26.000 --> 00:53:30.480
得到一个惩罚字节，但是大多数整数是完全整数

00:53:30.480 --> 00:53:33.280
内联而不需要任何其他键入信息

00:53:33.280 --> 00:53:35.440
他们

00:53:38.960 --> 00:53:43.839
好吧，我们快没时间了

00:53:44.079 --> 00:53:47.440
任何人的其他任何东西

00:53:48.240 --> 00:53:52.000
我想在我必须运行呃之前先对迈克尔提出一个真正的快速问题

00:53:52.000 --> 00:53:57.359
下一步是什么，您知道该如何准备实施

00:53:57.359 --> 00:53:59.440
在放进猎鹰的所有东西中

00:53:59.440 --> 00:54:04.960
[音乐]否否它需要测试和

00:54:04.960 --> 00:54:08.720
像在开始说别人应该

00:54:08.720 --> 00:54:12.640
用它来做实物嗯，我们不想采用黑色形式

00:54:12.640 --> 00:54:15.040
那是费力的，也就像我不想稳定

00:54:15.040 --> 00:54:18.640
在此之前，直到我们完成了对格式um的实际工作为止，所以我

00:54:18.640 --> 00:54:22.960
至少有几个星期只是在戳它并进行调整

00:54:22.960 --> 00:54:25.520
看看我可以从不同的地方刮掉多少个字节

00:54:25.520 --> 00:54:29.760
并尝试不同的数据结构和类似的东西

00:54:29.760 --> 00:54:33.119
像ii有一些我想碰到的东西

00:54:33.119 --> 00:54:37.920
在我前进之前，看看很多桌子上的东西效率如何，所以

00:54:37.920 --> 00:54:41.599
还有很多我主要想上的

00:54:41.599 --> 00:54:44.720
桥梁雷达，因为它改变了我们思考如何创建雷达的方式

00:54:44.720 --> 00:54:47.839
我们的数据结构，如果我们可能有这种压缩

00:54:47.839 --> 00:54:51.280
在未来的嗯，就像它是一个它是一个

00:54:51.280 --> 00:54:54.319
在人们的视野中是一件好事，但是我不认为我们会成为

00:54:54.319 --> 00:54:56.720
准备好一段时间将其实际移动到其中

00:54:56.720 --> 00:55:02.240
嗯，我想大概一个月左右，所以我们可能想看看再做一次

00:55:02.240 --> 00:55:06.079
届时实现UM，就像我应该拥有的

00:55:06.079 --> 00:55:09.440
像稳定格式，我的意思是就像我只是在努力

00:55:09.440 --> 00:55:12.720
三天，所以我每天都破坏格式，喜欢改变事物，

00:55:12.720 --> 00:55:15.520
将它们移动到um附近，您会发现类似

00:55:15.520 --> 00:55:18.720
令牌空间不在我想要的确切位置

00:55:18.720 --> 00:55:21.520
在某个时候，我必须决定要拥有多少个代币，

00:55:21.520 --> 00:55:24.000
然后我会喜欢将其固定在那个空间上

00:55:24.000 --> 00:55:27.119
我将决定我想要令牌的位置，以便我可以做更好的数学运算，

00:55:27.119 --> 00:55:29.599
像这样的东西

00:55:30.480 --> 00:55:36.400
好的，然后我结束了会议，所以谢谢大家的参与并看到

00:55:36.400 --> 00:55:47.680
大家下周再见大家再见

