WEBVTT
Kind: captions
Language: zh-Hans

00:00:11.120 --> 00:00:14.559
欢迎大家参加本周的ipld同步会议

00:00:14.559 --> 00:00:20.640
2020年10月5日，每周我们都会浏览

00:00:20.640 --> 00:00:23.439
我们在上周所做的，并计划在下周进行

00:00:23.439 --> 00:00:30.400
然后讨论所有未解决的议程项目，当然我还没有解决这个问题

00:00:30.400 --> 00:00:33.760
帕德姆，但我记得我上周做了什么

00:00:33.760 --> 00:00:38.559
所以我还是花很多时间在

00:00:38.559 --> 00:00:42.640
生锈了multihash的东西，所以好消息是

00:00:42.640 --> 00:00:48.320
它终于合并了，所以一个很小的多哈希可能不会成为一件事情

00:00:48.320 --> 00:00:52.079
不再，但现在已经完全进入了锈杂散

00:00:52.079 --> 00:00:55.840
因此，这种微小的，多哈希的东西是一件工作

00:00:55.840 --> 00:01:01.039
每四个或五个月的编码，原型制作和更改

00:01:01.039 --> 00:01:05.840
api几乎每周都有，但我认为现在已经足够稳定，可以上游使用

00:01:05.840 --> 00:01:10.000
这样就完成了，还没有发布，但是仍然有

00:01:10.000 --> 00:01:13.520
我想在实际修复之前要修复的小物件

00:01:13.520 --> 00:01:16.960
发布以确保我们不中断

00:01:16.960 --> 00:01:23.360
rust multihash上的任何上游用户

00:01:24.080 --> 00:01:27.280
是的，我做的另一件事是我写了

00:01:27.280 --> 00:01:33.439
有关ipld数据模型编号和ipld编解码器的探索报告

00:01:33.439 --> 00:01:38.400
这比我写它的时候想象的要简单，因为就像我的头一样

00:01:38.400 --> 00:01:42.000
有点像炸毁，因为它充满了

00:01:42.000 --> 00:01:46.720
有关数字um等的信息

00:01:46.720 --> 00:01:50.159
ii建议人们正在阅读它

00:01:50.159 --> 00:01:57.840
我认为这很有趣，因此总而言之，如果您使用

00:01:57.840 --> 00:02:01.119
您应该并且想要对其进行编码的数据模型

00:02:01.119 --> 00:02:04.399
只需对整数使用单一类型，对浮点数使用信号类型

00:02:04.399 --> 00:02:08.840
对于整数可能是方差，对于浮点数是ieee

00:02:08.840 --> 00:02:15.599
 754和双精度整数a浮点数um

00:02:15.599 --> 00:02:22.160
是的，嗯，这就是我下周要做的所有事情，我会花一些时间

00:02:22.160 --> 00:02:25.760
浪费时间的东西，也许也喜欢

00:02:25.760 --> 00:02:29.840
连接在甲板上

00:02:30.080 --> 00:02:37.120
在简单的甲板上，并期望还会有更多的公关

00:02:37.120 --> 00:02:44.720
基于我对现有规格的探索报告，那就是

00:02:44.720 --> 00:02:50.400
我清单上的下一个是

00:02:51.440 --> 00:02:55.680
假设授权窗口管理器不能很好地工作，那是错误的

00:02:55.680 --> 00:03:03.120
嗯，所以我会把它绑起来嗯dag pb

00:03:03.120 --> 00:03:06.239
那是我不知道那件事是否已经出版，迈克尔，但是那在你身上

00:03:06.239 --> 00:03:10.480
嗯，只是使用最新的js多种格式的东西

00:03:10.480 --> 00:03:13.680
和杰克·杰森（Jack jason），有一个游泳池要得到那个

00:03:13.680 --> 00:03:16.720
切换到所有这三个主要

00:03:16.720 --> 00:03:21.519
编解码器已同步并准备好用于

00:03:21.519 --> 00:03:28.400
多种格式的内容，但我花了一周的大部分时间去

00:03:29.200 --> 00:03:35.120
作为一个无用的围棋程序，我主要是在看这个

00:03:35.120 --> 00:03:39.200
Codex问题和为ipld prime编写Codex

00:03:39.200 --> 00:03:41.599
这意味着什么

00:03:41.599 --> 00:03:47.120
主要从dag pb的角度来看各种决策的含义

00:03:47.120 --> 00:03:51.440
因为那是我的头脑

00:03:52.560 --> 00:03:57.280
并在努力避免

00:03:57.280 --> 00:04:03.040
嗯，这部分是关于编程模型的关注，但是只是试图获得

00:04:03.040 --> 00:04:07.680
事情正确地分开了，就像

00:04:07.680 --> 00:04:12.640
诱惑就是把所有东西都放在一起，我就是这样

00:04:12.640 --> 00:04:17.759
我只是在一般的编程中感到非常不舒服，所以

00:04:17.759 --> 00:04:22.800
试图找到一个模型，可以将零件分开，这已经相当

00:04:22.800 --> 00:04:26.000
困难[音乐]

00:04:26.000 --> 00:04:29.360
用ipld prime查看其他编解码器创作内容

00:04:29.360 --> 00:04:38.160
参与有关um pretty printing和dag jason的讨论

00:04:38.160 --> 00:04:45.520
和clean8 um，我想埃里克会谈

00:04:45.520 --> 00:04:51.360
嗯，也是啊，所以这个星期，昨天是公众假期，所以我

00:04:51.360 --> 00:04:55.120
昨天做的很少，这是我的

00:04:55.120 --> 00:04:57.919
星期一um，这是本周的最后一周

00:04:57.919 --> 00:05:00.880
学校假期和嗯，所以我只想

00:05:00.880 --> 00:05:04.960
警告我减少的工作时间会比平时多一点

00:05:04.960 --> 00:05:09.199
嗯，这个星期，嗯，但除此之外，我想这周我会

00:05:09.199 --> 00:05:12.160
花费我继续花时间去

00:05:12.160 --> 00:05:18.400
嗯，所以我不希望有巨大的输出额，所以

00:05:18.400 --> 00:05:22.560
那只是我过去的时光的本质

00:05:22.560 --> 00:05:27.520
超级有效率的um，但我正在缩小其他编解码器的范围

00:05:27.520 --> 00:05:32.720
问题um现在看着dag p dag jason那是

00:05:32.720 --> 00:05:38.960
有点让人分心，但道格·杰森·达格（Doug jason dag pb）就是我在这里

00:05:38.960 --> 00:05:43.600
这就是我的工作，非常感谢迈克尔

00:05:43.600 --> 00:05:47.919
是的，嗯，是的，所以上周我提到我主要是花了很多时间

00:05:47.919 --> 00:05:51.039
um将块接口移植到新的多格式内容

00:05:51.039 --> 00:05:54.400
真主做了嗯，并把他所有的工作合并

00:05:54.400 --> 00:05:58.319
这就是全部，准备出发了，我打了个电话

00:05:58.319 --> 00:06:01.360
今天与哥斯拉一起，尽管它会给我更多的反馈，然后我

00:06:01.360 --> 00:06:03.840
认为将要发生的是我们将参加该模块课程，

00:06:03.840 --> 00:06:07.840
将其移动为多种格式，因为实际上

00:06:07.840 --> 00:06:13.120
您现在就可以实例化这些，而无需um

00:06:13.120 --> 00:06:16.800
像任何注册表或它们之上的任何东西

00:06:16.800 --> 00:06:19.840
所以我们只希望它像一个非常简单的类型，您可以将其拉出并

00:06:19.840 --> 00:06:22.960
实例化，以便像Rod的汽车文件之类的东西

00:06:22.960 --> 00:06:26.479
甚至不需要导入块和注册表以及所有其他内容

00:06:26.479 --> 00:06:28.639
一种东西，从字面上就可以像是“否”或“

00:06:28.639 --> 00:06:36.080
这就是我们正在做的所有事情，嗯，这很酷。

00:06:36.720 --> 00:06:41.039
很好，嗯

00:06:41.919 --> 00:06:46.160
明天就降落，我想，我想那是来自家庭的土地

00:06:46.160 --> 00:06:50.560
我还有别的东西哦，是的，我想有一个新的团队管理页面

00:06:50.560 --> 00:06:52.960
每个人都在通话中，以为嗯，但这就像

00:06:52.960 --> 00:06:55.360
至少到本季度末，我将使用什么

00:06:55.360 --> 00:06:59.039
每次有人做任何调整时都要更新

00:06:59.039 --> 00:07:03.919
嗯，为什么和嗯，如果我们没有承担您很多的维护负担

00:07:03.919 --> 00:07:07.120
否则我们就无法很好地捕捉它，就像您如何度过时光

00:07:07.120 --> 00:07:11.120
呃，请发送我们的请求，以便我们可以更准确地捕获到该请求

00:07:11.120 --> 00:07:14.720
嗯，这对某些人来说比其他人更好，因为有些人只有一个

00:07:14.720 --> 00:07:19.599
说实话，更难捕获的工作量

00:07:19.599 --> 00:07:22.960
嗯，但是无论如何，我们还是要改善一下

00:07:22.960 --> 00:07:26.240
然后，是的，审查正在发生，许多管理工作正在发生，

00:07:26.240 --> 00:07:30.319
我不得不处理，所以这是我一周的大部分时间

00:07:30.319 --> 00:07:36.880
谢谢下一个是克里斯·嘿，伙计们，所以我得到了JS穿越秒杀

00:07:36.880 --> 00:07:40.160
完成，所以主要是通过良好的工作

00:07:40.160 --> 00:07:43.919
p2p问题以及我对此的理解

00:07:43.919 --> 00:07:48.720
很好，而且一直在继续记录

00:07:48.720 --> 00:07:53.039
嗯，嗯，各种各样的起草规范问题，所以有一些问题

00:07:53.039 --> 00:07:57.440
所有这些都整合到以后的规格更新中

00:07:57.440 --> 00:08:00.639
也许一旦我以为他们都被发现了

00:08:00.639 --> 00:08:04.160
某些迭代，我确实为

00:08:04.160 --> 00:08:07.919
jslib p2p上的最终浏览器检索人员

00:08:07.919 --> 00:08:11.919
我想我现在是专家

00:08:11.919 --> 00:08:16.960
两周的接触时间，但是嗯，分享一些嗯和

00:08:16.960 --> 00:08:20.240
然后在js craftsync上写了一个设计文档

00:08:20.240 --> 00:08:22.479
并与迈克尔一起回顾了一下

00:08:22.479 --> 00:08:26.080
现在进行了一些调整，所以本周我们将

00:08:26.080 --> 00:08:29.360
基本上是因为我知道实现js草稿同步

00:08:29.360 --> 00:08:33.200
其他固定方式的工作原理，我有一个适当的设计

00:08:33.200 --> 00:08:36.560
嗯，这很酷，我认为可以很快进行

00:08:36.560 --> 00:08:39.760
嗯，这不是我可以重构的东西，

00:08:39.760 --> 00:08:43.680
确保它仍然在工作，然后我有杆的演示文稿

00:08:43.680 --> 00:08:48.399
关于可伸缩ipld ipfs数据提取的星期三

00:08:48.399 --> 00:08:52.000
对于这个Filecoin大师班，我们得

00:08:52.000 --> 00:08:55.440
为我创建一些幻灯片，我想迈克尔·迈克尔也会在那里

00:08:55.440 --> 00:08:58.800
嗯，所以我绝对认为这将是星期五

00:08:58.800 --> 00:09:02.720
所以我才意识到今天是星期三，所以我在那漂亮的东西上摇了摇

00:09:02.720 --> 00:09:06.399
很快，这就是我的一天

00:09:07.360 --> 00:09:12.320
谢谢，嗯，下一个是埃里克

00:09:12.640 --> 00:09:18.000
你好，所以我这周做了很多交流

00:09:18.000 --> 00:09:24.640
嗯，我和我之间开会了，斯科特和本丹

00:09:24.640 --> 00:09:29.600
adls和他们一起去哪里um，这样讨论就来了

00:09:29.600 --> 00:09:33.600
分为两个主要部分，并试图向中间的桥梁

00:09:33.600 --> 00:09:37.120
我们期望这些事物的界面来自我们所能理解的

00:09:37.120 --> 00:09:40.320
从图书馆设计的角度看问题

00:09:40.320 --> 00:09:44.160
然后交换很多信息，例如一个项目

00:09:44.160 --> 00:09:48.000
例如查看文件币数据的状态差异

00:09:48.000 --> 00:09:55.279
可能想实际使用这些东西，我认为幸运的是，那些融合

00:09:55.279 --> 00:10:00.640
在没有太多评论的情况下，我们在

00:10:00.640 --> 00:10:05.200
ipld团队介绍Filecoin的功能以及一些

00:10:05.200 --> 00:10:09.600
进入您的应用语义

00:10:09.600 --> 00:10:13.680
嗯，以及一些高级布局的东西，

00:10:13.680 --> 00:10:17.360
 um有点有趣，例如有一些递归的高级布局

00:10:17.360 --> 00:10:20.000
在filecoin um中，我们将了解它们的运行情况，但

00:10:20.000 --> 00:10:22.959
我希望这些实际上不会变得有趣

00:10:22.959 --> 00:10:26.959
他们应该在ipld结构中自然地工作，我们将看到

00:10:26.959 --> 00:10:30.560
我们会看到嗯，所以我们在地面上有一些笔记

00:10:30.560 --> 00:10:32.959
盖在那里，希望我们会继续

00:10:32.959 --> 00:10:36.880
慢慢地向前滚动，我真的很好奇如何实现

00:10:36.880 --> 00:10:40.800
丹·丹（mv dan）正在研究的事物的一面正​​在形成，但他不在这里，所以我

00:10:40.800 --> 00:10:46.079
不会代表那个，我们已经找到了一些新的有用工具

00:10:46.079 --> 00:10:50.160
在go ipld prime repo中，现在有一个方便的dandy函数，您可以在其中

00:10:50.160 --> 00:10:53.279
采取一些任意的走结构，你可以

00:10:53.279 --> 00:10:57.839
将其交给fluent.reflect方法，它将为您提供ipld数据模型

00:10:57.839 --> 00:11:02.720
大致匹配它充满了神奇的反射，并做了正确的

00:11:02.720 --> 00:11:07.600
事物类型逻辑，但它可能做正确的事情，所以

00:11:07.600 --> 00:11:11.120
这样做的目的基本上是在快速演示中使用它，例如

00:11:11.120 --> 00:11:15.120
提供一个入职坡道，它的速度不快，表现不佳

00:11:15.120 --> 00:11:18.640
但这确实意味着您真正的快速，所以希望对您有好处

00:11:18.640 --> 00:11:23.680
演示和内容大量内部通信内容

00:11:23.680 --> 00:11:27.279
我已经开始研究简单的dag了，但是我还没有发布关于它的笔记

00:11:27.279 --> 00:11:32.959
嗯，我不知道您是否不会在共享文档中添加任何注释，但是如果您愿意

00:11:32.959 --> 00:11:35.600
谈论状态差异的发展趋势，我认为这一直在发展

00:11:35.600 --> 00:11:41.440
真的很好，所以我会对它感兴趣，是的，我不知道不是太多

00:11:41.440 --> 00:11:46.399
那里有一个所有的模式

00:11:46.399 --> 00:11:49.680
演员状态嗯，还有很多其他的

00:11:49.680 --> 00:11:53.920
消息之类的链上事物，以及它们如何从芯片组到块再到

00:11:53.920 --> 00:11:57.279
消息和东西，所以这是ipld事情，

00:11:57.279 --> 00:12:00.320
不断发展的编解码器，可以打印漂亮的json

00:12:00.320 --> 00:12:04.720
观点比事情更有效率

00:12:04.720 --> 00:12:08.320
以前我们要做的是使事情正常进行

00:12:08.320 --> 00:12:13.680
多轮类似的界面消除了所有类型并咀嚼东西

00:12:13.680 --> 00:12:19.120
这有点讨厌，所以现在获得它是一个技巧

00:12:19.120 --> 00:12:23.360
在想要使用此数据并查看它的各个地方使用

00:12:23.360 --> 00:12:30.560
在不同的地方，是的，我们

00:12:30.560 --> 00:12:34.000
制作golang kojim的大象用法

00:12:34.000 --> 00:12:39.600
东西，以实现这一目标，这真是令人兴奋，嗯，这会给我很多

00:12:39.600 --> 00:12:43.040
修复和追逐我已经解决的一些小错误

00:12:43.040 --> 00:12:46.480
在合理的时间内，其中一些需要最终列入待办事项清单

00:12:46.480 --> 00:12:51.120
嗯，但总的来说，它是可行的，就像我认为大多数重大问题一样

00:12:51.120 --> 00:12:54.639
我们就像现在的ADL在哪里放进去了，所以

00:12:54.639 --> 00:12:59.440
那个令人兴奋

00:13:00.000 --> 00:13:03.360
所以另一件大事消耗了更多

00:13:03.360 --> 00:13:10.160
恐怕我一周的工作时间比我预期的要长

00:13:10.160 --> 00:13:14.639
字符串编码和转义问题，以及仅字符集和

00:13:14.639 --> 00:13:18.240
然后罗德在张开他的笑容的脸

00:13:18.240 --> 00:13:24.240
有几个人在拍，所以这是一个有趣的话题

00:13:24.240 --> 00:13:30.800
我试图写一个漂亮的打印工具，

00:13:30.880 --> 00:13:33.920
我认为这已经杂草丛生，我什至不打算

00:13:33.920 --> 00:13:39.440
跟进，但它打开了字符串形式的罐头

00:13:39.440 --> 00:13:42.480
转义和

00:13:45.519 --> 00:13:48.560
我们真的需要提高质量和细节

00:13:48.560 --> 00:13:53.920
以及我们在iplp中指定字符串的边缘的清晰度

00:13:53.920 --> 00:13:58.079
数据模型，但总的来说，这是我的

00:13:58.079 --> 00:14:00.959
注意，我认为有一堆字符串转义函数

00:14:00.959 --> 00:14:04.720
能够轻松处理任何事情的能力实际上不是

00:14:04.720 --> 00:14:07.839
常见的字符串转义系统，例如json

00:14:07.839 --> 00:14:10.399
实际上

00:14:11.279 --> 00:14:17.120
开箱即用真的有问题，所以我们想定义一下我要

00:14:17.120 --> 00:14:20.800
为此，可能要花一些时间

00:14:20.800 --> 00:14:24.240
如果可以定义字符串，我们希望

00:14:24.240 --> 00:14:30.720
作为8位字节的序列，因为这是一个非常

00:14:30.720 --> 00:14:34.079
简单明确的定义并不一定是

00:14:34.079 --> 00:14:38.959
当前正在渲染的地图世界，但这是一个明确的定义

00:14:38.959 --> 00:14:43.680
通常无损，它与很多东西集成在一起

00:14:43.680 --> 00:14:48.959
是的，所以我首先想到的是二进制文件和有什么不一样

00:14:48.959 --> 00:14:56.000
然后，因为像我这样，二进制文件只有八个字节，除了

00:14:56.000 --> 00:15:00.399
意图它应该是可打印的，但

00:15:00.399 --> 00:15:03.920
我认为重要的是，您仍然必须细分梦想

00:15:03.920 --> 00:15:08.560
从那是可打印的，这是实现细节

00:15:08.560 --> 00:15:13.600
只想推迟一点，所以将字符串定义为8位字节是

00:15:13.600 --> 00:15:17.199
很好，因为它很清晰，而且

00:15:17.199 --> 00:15:20.320
世界上还有其他系统将迫使我们应对

00:15:20.320 --> 00:15:23.519
不管怎么说，你们还记得所有

00:15:23.519 --> 00:15:28.399
UNIX fsv2规范草案中有关文件名的讨论

00:15:28.399 --> 00:15:32.880
它真的很毛茸茸，结果发现那里有一堆文件系统

00:15:32.880 --> 00:15:39.759
对于文件中可以结束哪些字节序列没有非常严格的意见

00:15:39.759 --> 00:15:42.880
名称，即使我们通常以字符串形式讨论

00:15:42.880 --> 00:15:46.639
当我们将其混搭时，这会特别有影响

00:15:46.639 --> 00:15:49.839
这与我们在ipld中定义的地图一起

00:15:49.839 --> 00:15:55.199
有字符串键，例如想要使用大型分片图，例如

00:15:55.199 --> 00:15:58.320
我们要在unicode v2等规范中使用的指针

00:15:58.320 --> 00:16:02.079
仍然有一个字符串键

00:16:02.240 --> 00:16:05.600
所有这些事情都非常重要

00:16:05.600 --> 00:16:09.120
如果我们有这个，那就更简单，更容易组合了

00:16:09.120 --> 00:16:13.279
将字符串定义为8位字节序列

00:16:13.839 --> 00:16:17.279
和相当多的系统都没有问题，例如sebor琴弦

00:16:17.279 --> 00:16:20.560
例如，与此即时兼容，并且没有

00:16:20.560 --> 00:16:24.560
他们是执行海滨的难点

00:16:24.560 --> 00:16:28.240
实际上，bite解析和c4字符串解析是相同的功能

00:16:28.240 --> 00:16:31.120
我有一个不同的参数我要在调用这些字节或字符串

00:16:31.120 --> 00:16:35.759
末尾相同的条非常清楚，它适用于所有

00:16:35.759 --> 00:16:38.160
字节

00:16:38.800 --> 00:16:46.320
其他一些编解码器不是那么简单um json不支持足够的转义

00:16:46.320 --> 00:16:48.720
为了这

00:16:48.959 --> 00:16:52.000
因为json仅支持斜线转义

00:16:52.000 --> 00:16:57.120
r斜线这些像超级普通的特殊情况一样

00:16:57.440 --> 00:17:04.640
它支持斜杠u，然后是四个十六进制字符

00:17:04.640 --> 00:17:11.520
从unicode表中提取的unicode转义

00:17:12.400 --> 00:17:19.600
并非所有字节都是有效的unicode序列

00:17:19.600 --> 00:17:25.280
因此，不可能在json中将其限制为斜线u

00:17:25.280 --> 00:17:28.799
逃避规则并逃脱所有可能的顺序

00:17:28.799 --> 00:17:36.160
8位字节，这非常令人沮丧

00:17:37.520 --> 00:17:41.679
我现在没有在屏幕上绘制示例，但是我写了一些测试用例来

00:17:41.679 --> 00:17:45.440
向我自己证明这实际上是有问题的，我向你发誓

00:17:45.440 --> 00:17:49.039
存在一些字节序列，您可以用十六进制转义来描述

00:17:49.039 --> 00:17:52.240
你不能完全停止翻译以削减你

00:17:52.240 --> 00:17:54.720
逃脱

00:17:58.799 --> 00:18:03.120
因此，这是我们在ipld规范中需要讨论的问题

00:18:03.120 --> 00:18:07.120
我们可能应该提出一些建议

00:18:07.120 --> 00:18:10.160
解决方法或替代品，或者一般来说，我们

00:18:10.160 --> 00:18:14.400
期望编解码器在遇到困难时尝试使这种行为表现出来

00:18:14.400 --> 00:18:20.480
8位字节序列，并在那里无损地考虑它们

00:18:20.480 --> 00:18:25.559
可能是一些很好的解决方案，那里有一个叫做utf clean 8的东西

00:18:25.559 --> 00:18:30.480
utf-8-c8的简称，据我所知是首创的

00:18:30.480 --> 00:18:32.400
完全由珍珠社区或至少由珍珠社区提供

00:18:32.400 --> 00:18:36.080
到目前为止，我所见过的所有文档都来自他们

00:18:36.080 --> 00:18:39.520
而且似乎有一种机制可以

00:18:39.520 --> 00:18:43.840
无损编码

00:18:55.039 --> 00:18:58.080
在我变得更沮丧之前把那咆哮包起来

00:18:58.080 --> 00:19:01.360
再次谈论它，但是这周发现这些东西很有趣

00:19:01.360 --> 00:19:05.679
我们应该讨论并详细说明它们

00:19:08.000 --> 00:19:11.600
我想出了一种新的集会呼声，我想针对其中的一些

00:19:11.600 --> 00:19:15.919
盯着这个，顺便讨论一下

00:19:16.080 --> 00:19:20.880
归一化是突变

00:19:22.960 --> 00:19:27.200
我喜欢它，因为如果需要的话我可以反复念诵它

00:19:27.679 --> 00:19:31.919
在ipld中，我们非常担心

00:19:31.919 --> 00:19:37.120
确保事物具有有利于融合事物的特性

00:19:37.120 --> 00:19:40.000
这使得散列数据并获得

00:19:40.000 --> 00:19:45.039
从中得出的合理一致的哈希值使它们变得更好

00:19:45.039 --> 00:19:53.200
建立内容可寻址系统，但规范化是突变

00:19:53.200 --> 00:19:56.880
例如，如果您强制将所有字符串标准化为

00:19:56.880 --> 00:20:03.760
例如utf-8 nfc归一化必然

00:20:03.760 --> 00:20:06.720
这样的规范化意味着您无视您的任何输入

00:20:06.720 --> 00:20:12.799
得到了什么，得到了什么，就产生了新的输出归一化

00:20:12.799 --> 00:20:19.200
如果我们要无损地考虑数据，那就是突变

00:20:19.360 --> 00:20:23.200
我的意思是说取一些已经序列化的数据

00:20:23.200 --> 00:20:28.400
加载它，仅出于讨论目的而对其执行无操作操作

00:20:28.400 --> 00:20:32.080
序列化它并能够再次对其进行哈希处理，而无需执行此操作

00:20:32.080 --> 00:20:38.320
损失获得相同的现金，那么我们就不能要求规范化

00:20:38.320 --> 00:20:42.000
因为归一化是突变

00:20:43.520 --> 00:20:46.960
我认为这些标准应该

00:20:46.960 --> 00:20:52.799
建议规范化，但我们不能要求它

00:20:52.799 --> 00:20:57.280
品牌完整外观，您想让麦克风远离我

00:20:57.280 --> 00:21:01.760
不，这就像它依赖于一样，因为就像该数据是否已序列化

00:21:01.760 --> 00:21:05.360
在某一时刻，它已经有一个规则，那就是

00:21:05.360 --> 00:21:10.480
需要进行标准化，您不要对其进行变异，因为它

00:21:10.480 --> 00:21:13.679
已经归一化了，但是您正在为其补充能量

00:21:13.679 --> 00:21:18.799
来自某个地方，但是就像我的意思是我完全一样

00:21:18.799 --> 00:21:22.640
理解您的观点，就像不，不，不，但我认为eric是对的

00:21:22.640 --> 00:21:26.159
就算你无损的时候

00:21:26.159 --> 00:21:30.640
您仍在对其进行突变，就像您从中获取它一样

00:21:30.640 --> 00:21:33.840
从一个状态到另一个状态，即使它丢失了，您仍然会对其进行突变

00:21:33.840 --> 00:21:38.720
这是一个无损的变异，但它来自

00:21:38.720 --> 00:21:41.600
因为你很幸运，这是一个无人操作的突变，也许我

00:21:41.600 --> 00:21:44.400
不知道，但总的来说像是

00:21:44.400 --> 00:21:49.600
正常化可能没有效果，但总的来说，您应该担心合法性

00:21:49.600 --> 00:21:52.240
规范化意味着您的功能领域

00:21:52.240 --> 00:21:55.840
和你的功能范围不一样

00:21:55.840 --> 00:22:02.640
这意味着您处于危险之中，是的，这是关于这一点的

00:22:02.640 --> 00:22:09.520
这个嗯，你在类似的东西之间有一个双射的映射吗？

00:22:09.520 --> 00:22:15.679
与数字基本相同，这是我的专长

00:22:16.080 --> 00:22:19.840
如果您有不同的流量类型，这就像您一样

00:22:19.840 --> 00:22:24.400
归一化为最小的问题与您是否遇到相同的问题

00:22:24.400 --> 00:22:27.039
你做到了，每个人都必须做，否则你就会得到

00:22:27.039 --> 00:22:32.320
相同数据的不同哈希值不同

00:22:32.320 --> 00:22:35.919
但是，是的，所以是的，我可以在那里看到问题，所以我

00:22:35.919 --> 00:22:41.840
我很高兴从数字到字符串进入下一阶段，所以

00:22:42.320 --> 00:22:46.159
但我认为我认为虽然适用相同的框架

00:22:46.159 --> 00:22:50.000
我们确实需要意识到，就像您序列化某些东西一样，您正在变异

00:22:50.000 --> 00:22:52.320
就像你一样，只是

00:22:52.320 --> 00:22:55.520
您可能已经发现了无损突变，那就太好了，我们应该尝试

00:22:55.520 --> 00:22:57.919
找到所有无损突变，但是

00:22:57.919 --> 00:23:01.520
像我们有哈希效率的情况

00:23:01.520 --> 00:23:04.960
通常是因为我们没有无损突变

00:23:04.960 --> 00:23:11.679
对，或者他们可以像彼得一样必须马上下车，彼得你有什么吗

00:23:11.679 --> 00:23:19.200
分享或说好吧，不，这一次好吧，这是启动

00:23:20.840 --> 00:23:23.840
文件币

00:23:24.080 --> 00:23:27.679
别开玩笑那样

00:23:28.480 --> 00:23:32.159
是的，应该是两周，低八天

00:23:32.159 --> 00:23:38.159
所以你知道这应该很好，我在两个星期内的新闻中读到了

00:23:38.159 --> 00:23:41.440
我在互联网上阅读

00:23:43.360 --> 00:23:45.600
好的

00:23:47.039 --> 00:23:53.679
再见，让我们看看有没有我看不到的议程项目

00:23:53.679 --> 00:23:57.600
人们想讨论的其他任何事情

00:23:57.919 --> 00:24:02.320
我认为现在只是一个半小时的弦乐而已

00:24:02.400 --> 00:24:07.520
我以为我会下车

00:24:08.960 --> 00:24:13.279
就像ii还有关于字符串的一份副本一样，因为我仍然不确定

00:24:13.279 --> 00:24:17.120
就像为什么要区分字符串

00:24:17.120 --> 00:24:22.080
和字节，您不再需要区分字符串和字节

00:24:22.080 --> 00:24:29.919
如果字符串是八位um，那么，不，不，但是，那个，

00:24:29.919 --> 00:24:32.240
数据模型应该可以帮助您

00:24:32.240 --> 00:24:39.600
就是找到一种无所事事的方法，就像世界消失了一样，这很可笑。

00:24:39.600 --> 00:24:43.440
就像今天那样，如果不是往返的话，我们需要

00:24:43.440 --> 00:24:46.480
那么我们需要使它不成为数据模型的一部分

00:24:46.480 --> 00:24:49.120
就像我们需要找到或至少有一些建议

00:24:49.120 --> 00:24:52.720
人们喜欢有办法做到这一点并正确地往返

00:24:52.720 --> 00:24:57.360
就像刚才说的那样，它现在总是字节，因为

00:24:57.360 --> 00:24:59.679
它们都是八位，就像不这样做，因为您将要拥有数据

00:24:59.679 --> 00:25:04.880
不会遍历各种呃字符串类型

00:25:04.880 --> 00:25:10.320
但是基本上，如果像例如带有文件名的东西，那么

00:25:10.320 --> 00:25:13.520
说文件名是字节而不是字符串，因为为什么

00:25:13.520 --> 00:25:18.640
音素是字符串，我们喜欢介绍它们主要是

00:25:18.640 --> 00:25:24.240
字符串，只是我们不能，所以有两个地方

00:25:24.240 --> 00:25:28.240
序列化，另一个在表示中，但是

00:25:28.240 --> 00:25:31.360
这种表示形式在我们自己的程序设计中同样适用

00:25:31.360 --> 00:25:35.440
我们想要一个字符串对象的语言

00:25:35.440 --> 00:25:39.039
然后当您将字节放入字符串中时，它们会以不同的方式进行时髦的操作

00:25:39.039 --> 00:25:43.520
语言，所以我们不能总是只保留那些东西

00:25:43.520 --> 00:25:47.200
因为那样我们就进入了深奥的土地

00:25:47.200 --> 00:25:51.840
没有人会很好地使用我们的东西，也就像我们实际上没有

00:25:51.840 --> 00:25:54.480
为任何人解决了这个问题，因为就像我们知道每个人都在做什么

00:25:54.480 --> 00:25:56.640
与名称有关的将转换为

00:25:56.640 --> 00:26:00.720
对文件名的处理方式，例如，如果文件名不是往返的话

00:26:00.720 --> 00:26:03.520
正确地通过他们的应用程序堆栈

00:26:03.520 --> 00:26:06.480
他们正在执行此转换，那么我们仍然遇到同样的问题

00:26:06.480 --> 00:26:10.880
如果正确的话，将其推入堆栈

00:26:15.760 --> 00:26:18.960
我不认为我们想像这样走得更远

00:26:18.960 --> 00:26:21.200
这个这个这个点就好了

00:26:21.200 --> 00:26:25.279
数字事物引发了关于我们的角色是什么以及我们的堆栈在哪里的问题

00:26:25.279 --> 00:26:28.240
比如我们在堆栈中的位置是什么，我们应该做什么？

00:26:28.240 --> 00:26:32.400
在那样的情况下，我们可能会花很长时间

00:26:32.400 --> 00:26:35.120
收益递减的目的是什么

00:26:35.120 --> 00:26:39.760
我们说好吧，这足够好了，我不知道

00:26:39.760 --> 00:26:43.039
我对此的看法主要是凭经验形成的

00:26:43.039 --> 00:26:45.360
什么

00:26:46.080 --> 00:26:50.400
什么让我最不高兴，答案其实很简单

00:26:50.400 --> 00:26:54.320
它以字符串为字节，并尝试

00:26:54.320 --> 00:26:56.799
渲染它们

00:26:56.880 --> 00:27:00.559
这种组合实际上是非常有效的，这就是海滨所做的

00:27:00.559 --> 00:27:04.400
而且它起作用了，人们似乎喜欢它，因为大多数时候

00:27:04.400 --> 00:27:08.480
当您指望要呈现的字符串时，您在siebel中说字符串

00:27:08.480 --> 00:27:12.240
当你知道你不是指字符串，而是指二进制字节时，你说的是字节

00:27:12.240 --> 00:27:15.840
也许您希望它不会被渲染太多

00:27:15.840 --> 00:27:20.399
因此，所有seaborg漂亮打印机都尊重这两点并强调

00:27:20.399 --> 00:27:23.440
适当地使用它们，这相当于您作为人类的意思

00:27:23.440 --> 00:27:28.559
每个人都很高兴，就像我认为那基本上就是

00:27:28.559 --> 00:27:31.120
我们应该遵循的事情，因为它

00:27:31.120 --> 00:27:36.720
像通常的讨论一样正常

00:27:36.720 --> 00:27:40.960
我已经开始着手讨论铁锈了，所以

00:27:40.960 --> 00:27:44.640
基本上，问题将是如果您以这种方式进行操作

00:27:44.640 --> 00:27:48.240
不会像你一样无法使用弦线和铁锈

00:27:48.240 --> 00:27:53.279
像锈和锈字符串严格是unicode

00:27:53.279 --> 00:27:55.600
事物

00:27:56.399 --> 00:28:00.399
um文件名很特殊，以下是路径，它们基本上很奇怪

00:28:00.399 --> 00:28:03.600
基本上可以使它工作的各种技巧

00:28:03.600 --> 00:28:08.000
平台，但由于这个原因它们不是字符串，因为像

00:28:08.000 --> 00:28:12.240
财务显然不是完全unicode，所以基本上会生锈

00:28:12.240 --> 00:28:17.120
如果我们定义，将无法使用本机字符串类型

00:28:17.120 --> 00:28:23.279
字符串是不是不是不是这不是这个

00:28:23.279 --> 00:28:27.200
事情给了我们您发现eric的地方，您实际上确实有一个

00:28:27.200 --> 00:28:31.120
会无损失去的转换坚持下去

00:28:31.120 --> 00:28:33.279
那

00:28:33.640 --> 00:28:40.080
utf-8确实提供了一种放置任意叮咬的方法

00:28:40.080 --> 00:28:43.679
在被视为etf8字符串的事物中

00:28:43.679 --> 00:28:47.440
所以在生锈的情况下，我也会认真考虑一下我不是超级

00:28:47.440 --> 00:28:51.360
对此很熟悉，但无论哪种类型，我都会考虑使用铁锈

00:28:51.360 --> 00:28:54.880
他们用于文件名使用它作为我们的字符串，听起来像

00:28:54.880 --> 00:29:01.039
没错，他们使用wtf8

00:29:01.039 --> 00:29:03.600
编码方式

00:29:05.520 --> 00:29:09.480
我将不得不阅读有关russ对此的处理方式，所以这是一个

00:29:09.480 --> 00:29:16.480
wtf8编码是一个很好的名称um，因为它基本上可以

00:29:16.480 --> 00:29:19.919
是的，它确实很奇怪，所以你可以

00:29:19.919 --> 00:29:24.080
这样做，但这不是，所以不是，它不支持

00:29:24.080 --> 00:29:30.480
我认为是任意字节，但是无论如何，是的

00:29:30.480 --> 00:29:34.159
长久以来都有一种美好，就像每一种都有美好

00:29:34.159 --> 00:29:38.320
有关它们如何处理事物名称的文档

00:29:38.320 --> 00:29:44.880
他们打电话给osgit，我们可以用它吗

00:29:46.720 --> 00:29:57.360
只是搜索wtf8编码之类的，应该

00:29:57.360 --> 00:30:00.240
提起它，我刚刚发布了一个链接，就像有一个链接

00:30:00.240 --> 00:30:03.440
在缩放聊天中，现在转到该空间，我认为这是

00:30:03.440 --> 00:30:09.200
编码他们实际上是为有趣的名字定居的，嗯，所以

00:30:09.200 --> 00:30:13.200
所以回到所以，如果我们使用，所以我没有

00:30:13.200 --> 00:30:19.840
真正地查看了一个独特的代码，它被称为c8之类的东西um

00:30:19.840 --> 00:30:22.880
 utfc8嗯，我还没有研究过

00:30:22.880 --> 00:30:28.640
表示它可能往返于或可以将其编码为适当的unicode

00:30:28.640 --> 00:30:35.679
字符串，那么您当然可以在其上使用rust字符串类型

00:30:35.679 --> 00:30:39.200
如果它正确地位于相同的地方也是如此，所以如果您没有任何奇怪的字节

00:30:39.200 --> 00:30:42.000
它仍然会像普通字符串一样

00:30:42.000 --> 00:30:46.240
那种东西，如果有什么你会

00:30:46.240 --> 00:30:49.279
有那些像是的那些奇怪的人物，但它

00:30:49.279 --> 00:30:53.039
还是可以的，那当然很好，因为

00:30:53.039 --> 00:30:56.080
就像只要我基本上不想要的一样

00:30:56.080 --> 00:31:01.120
我从ip数据模型中得到一个字符串，尝试将其转换为字符串，然后

00:31:01.120 --> 00:31:05.519
会恐慌，因为像它不是八分之一的责任，但只要

00:31:05.519 --> 00:31:08.960
只要它像有效的utf-8之类的东西

00:31:08.960 --> 00:31:14.159
那很好，我想我会说这对我来说很不幸

00:31:14.159 --> 00:31:17.360
如果内存中的数据模型必须使用此

00:31:17.360 --> 00:31:19.760
我一直希望这是我们可以使用的东西

00:31:19.760 --> 00:31:26.640
有限制的法典，但我们会

00:31:26.640 --> 00:31:30.080
我们会看到的是

00:31:30.720 --> 00:31:33.760
让我有些惊讶的是，铁锈会像我这样做出选择

00:31:33.760 --> 00:31:39.120
听到有人抱怨铁锈和文件系统，我想我现在知道为什么

00:31:41.440 --> 00:31:49.360
是的，很酷，生锈是我们的弱点

00:31:49.360 --> 00:31:53.840
这真的很令人着迷，而且锈迹斑斑是其中之一

00:31:53.840 --> 00:31:58.840
生锈的原因之一就是要处理javascript的问题

00:31:58.840 --> 00:32:04.480
字符串，因为javascript的字符串是

00:32:04.480 --> 00:32:08.960
utf-16可能格式不正确

00:32:09.679 --> 00:32:13.679
所以从字面上看就像是，您可以像任意字节一样阻塞

00:32:13.679 --> 00:32:16.640
进入他们，是的，就像我们以前那样

00:32:16.640 --> 00:32:21.200
像这样的节点就是我们在缓冲区之前有二进制节点的方式

00:32:21.279 --> 00:32:25.679
不是不是很奇怪，这只是可怕的

00:32:26.720 --> 00:32:28.960
不是

00:32:30.159 --> 00:32:38.480
也是python 3的方式否否

00:32:38.480 --> 00:32:44.480
python 3对字符串真的很严格，它

00:32:44.480 --> 00:32:49.360
现在是utf-8还是我看到的全部，是的，这太棒了

00:32:49.360 --> 00:32:53.760
有点像是unicode之一，但不是全部，不是，是python 2

00:32:53.760 --> 00:32:57.679
有所有这些变化python 3实际上就像是非常严格的

00:32:57.679 --> 00:33:00.399
就像utf-8一样，现在包括

00:33:00.399 --> 00:33:04.320
语言本身将字符串数据解释为

00:33:04.320 --> 00:33:08.000
蟒蛇，这是唯一的，但这意味着

00:33:08.000 --> 00:33:10.240
还有他们的区别

00:33:10.240 --> 00:33:13.440
之间基本上在python 2和python 3之间的问题之间

00:33:13.440 --> 00:33:16.720
在弦上有很大的不同

00:33:16.720 --> 00:33:22.320
在python 3中，它们是正确的unicode字符串，并且您有一个

00:33:22.320 --> 00:33:24.880
unicode字符串和字节之间的区别

00:33:24.880 --> 00:33:28.159
这是一样的，因为您有字节并且有字符串

00:33:28.159 --> 00:33:32.080
这就是为什么我认为我们在谈论像制作

00:33:32.080 --> 00:33:35.840
我不确定你是否在谈论这个，如果我们要去

00:33:35.840 --> 00:33:40.320
到我们的字符串不仅仅是unicode的方向

00:33:40.320 --> 00:33:45.519
超过8个，抱歉，我们的字符串比utf-8还要多

00:33:45.519 --> 00:33:49.440
我认为问题是他们已经在

00:33:49.440 --> 00:33:53.440
因为因为我们已经看到了像远投币那样的用途

00:33:53.440 --> 00:33:57.120
因此，我们将其保持打开状态[音乐]

00:33:57.120 --> 00:34:01.440
而且您知道，因为我们不愿意为此划清界限

00:34:01.440 --> 00:34:04.159
东西也许我们应该也许我们不应该但是

00:34:04.159 --> 00:34:09.040
因为人们要推动，那么我们的字符串本质上就是字节

00:34:09.040 --> 00:34:13.760
可以打印出来，所以我们有一些东西

00:34:13.760 --> 00:34:15.760
不要往返，他们也不会往返，因为

00:34:15.760 --> 00:34:18.480
这样的问题就像当您执行此操作时，他们不会往返

00:34:18.480 --> 00:34:21.599
就像我认为eric所说的是，就像有一个实用程序，我们

00:34:21.599 --> 00:34:25.599
可以像处理那样放入编码器解码器，并且

00:34:25.599 --> 00:34:28.399
总是打印出可以正确处理的内容

00:34:28.399 --> 00:34:34.079
当人们用字符串类型来做这些奇怪的事情时

00:34:34.079 --> 00:34:37.119
我们将需要生成很多有关此的文档

00:34:37.119 --> 00:34:41.839
在规格说明库中以文本形式显示，并且必须涵盖很多内容

00:34:41.839 --> 00:34:45.599
方向，我们将不得不说出我们希望字符串包含在数据中的内容

00:34:45.599 --> 00:34:49.679
模型，我们将不得不说编解码器在哪里迫使我们妥协和

00:34:49.679 --> 00:34:53.839
我们在使用时使用什么编码转义方案

00:34:53.839 --> 00:34:56.159
请记住，您逃跑与规范化是截然不同的

00:34:56.159 --> 00:35:02.160
逃避并不一定是突变，我们不得不说什么时候

00:35:02.160 --> 00:35:05.359
分解并得到图书馆作者的建议

00:35:05.359 --> 00:35:12.480
嗯，就我们而言

00:35:13.960 --> 00:35:16.960
各种语言的实施细节

00:35:16.960 --> 00:35:20.320
我们将不仅要说那些语言说的

00:35:20.320 --> 00:35:24.320
恐怕我们将不得不看看他们的行为

00:35:24.320 --> 00:35:28.800
因为那并不总是完全一对一的

00:35:28.800 --> 00:35:32.720
所以在我看来，嗯，那里的细节

00:35:32.720 --> 00:35:40.000
真的很重要，就像我几乎不在乎一种语言还是一种

00:35:40.000 --> 00:35:44.320
库或任何仅表示接受utf-8的内容

00:35:44.320 --> 00:35:47.599
我对此的反应是很酷的故事，兄弟，我不相信你

00:35:47.599 --> 00:35:51.599
告诉我遇到其他字节时该怎么办

00:35:51.599 --> 00:35:55.040
而且您必须去查看代码，看看这是什么原因，

00:35:55.040 --> 00:36:00.160
文档很少说这是到目前为止我的经验

00:36:00.160 --> 00:36:03.760
因此，例如，我发现我漫步了一堆不同的弦

00:36:03.760 --> 00:36:07.200
转义功能，我们不必保留这些功能

00:36:07.200 --> 00:36:11.520
仅仅因为我编程就可以达到完美的标准，我不希望其他人在乎

00:36:11.520 --> 00:36:15.520
但是我发现的是例如应变逃逸功能

00:36:15.520 --> 00:36:22.240
用于golang标准库中的json（如果遇到不符合要求的任何字节）

00:36:22.240 --> 00:36:27.599
 utf-8序列将其丢弃

00:36:27.599 --> 00:36:30.800
它将完全不考虑内容是什么

00:36:30.800 --> 00:36:34.240
为什么我为什么要保留数据，取而代之的是

00:36:34.240 --> 00:36:41.119
逃脱斜线u fffd这是呃

00:36:41.119 --> 00:36:44.240
Unicode中的字符

00:36:44.800 --> 00:36:48.320
但它会将原始字节丢掉

00:36:50.880 --> 00:36:55.839
是的，所以javascript可以在哪里找到这个东西

00:36:55.839 --> 00:37:00.160
您可以将一堆格式错误的字节强行插入字符串

00:37:00.160 --> 00:37:06.320
他们将在平台的某些地方而不是其他地方来回

00:37:06.320 --> 00:37:10.079
嗯，所以，如果您尝试喜欢连接字符串，而又想实际获得

00:37:10.079 --> 00:37:16.079
字符串表示形式会脱落，但是如果将其存储在索引数据库中

00:37:16.079 --> 00:37:19.839
他们会带着你忠实于他们的忠诚而回来

00:37:19.839 --> 00:37:23.200
人们实际上要做的一件事就是他们有特殊的

00:37:23.200 --> 00:37:26.560
javascript中压缩的压缩库

00:37:26.560 --> 00:37:30.880
变成不正确的字符串，因为它们是它们，所以可以将它们存储起来并

00:37:30.880 --> 00:37:36.240
是由索引数据库往返，但是，但是如果您使用其他方法

00:37:36.240 --> 00:37:39.119
他们然后他们打破了，就像我试图一次使用该压缩库

00:37:39.119 --> 00:37:42.079
我们的东西里有些东西，那不是圆的

00:37:42.079 --> 00:37:45.920
绊倒了，我想为什么会这样

00:37:45.920 --> 00:37:51.839
就像是的，这就是为什么，因为它是一个病态的字符串

00:37:52.400 --> 00:37:57.599
好吧，嗯，我看到约翰尼加入了，你有吗

00:37:57.599 --> 00:38:02.079
你想分享一些东西吗，是的，我潜伏在YouTube频道上，所以我

00:38:02.079 --> 00:38:05.680
认为这是我在努力奋斗的原因

00:38:05.680 --> 00:38:09.200
做了规范和json和之间的无损转换

00:38:09.200 --> 00:38:12.400
cbor，我们正在建立一个抽象的数据模型

00:38:12.400 --> 00:38:16.160
那只是抽象的那对我来说是波浪状的

00:38:16.160 --> 00:38:20.400
我已经提议um cddl了一段时间，所以这是简洁的数据定义

00:38:20.400 --> 00:38:24.880
语言和um jason是cbor的子集

00:38:24.880 --> 00:38:28.960
只要有一些规则，那么实际上是无损的

00:38:28.960 --> 00:38:33.839
转换，呃，他做了呃，呃

00:38:33.839 --> 00:38:39.040
RFC 7049 CBOR规范实际上谈到了这一点，我想当然可以

00:38:39.040 --> 00:38:44.079
ipld实际上主要符合此要求，但是cddl我

00:38:44.079 --> 00:38:51.520
认为这里是RFC 8610，所以如果您限制

00:38:51.520 --> 00:38:58.240
像uh整数这样的东西uh必须是uh 64位，即使使用

00:38:58.240 --> 00:39:02.000
您有约束的整数值

00:39:02.000 --> 00:39:05.520
与JSON无损兼容的设置

00:39:05.520 --> 00:39:10.960
所以与json字符串相同的事情说utf-8 um

00:39:10.960 --> 00:39:14.880
斜线u和其他东西有点

00:39:14.880 --> 00:39:18.240
细微的我不明白，但我认为

00:39:18.240 --> 00:39:21.839
我要解决的是试图说抽象数据模型是

00:39:21.839 --> 00:39:26.800
限于使用cddl来描述

00:39:26.800 --> 00:39:29.359
抽象数据模型，即使有点像

00:39:29.359 --> 00:39:35.760
更多语法，但也有一些类和类型，呃

00:39:35.760 --> 00:39:39.440
我明天要宣传它，并试图获得一些反馈

00:39:39.440 --> 00:39:43.280
不幸的是，这个西雅图人呃吉姆·谢德（Jim Shad）只是

00:39:43.280 --> 00:39:45.920
周末死了，他应该给我一些呃一些

00:39:45.920 --> 00:39:49.920
反馈给我的sibor解释和呃ii

00:39:49.920 --> 00:39:52.240
不知道他是怎么回事，我在等待反馈，

00:39:52.240 --> 00:39:55.119
然后我刚刚听到另一个同事说他死了

00:39:55.119 --> 00:39:57.839
糟透了

00:40:00.320 --> 00:40:03.680
我想知道这是科文特之类的事情还是他真的很难过

00:40:03.680 --> 00:40:07.520
是的，不知道他实际上拥有一家酿酒厂，所以实际上就像他退休了一样

00:40:07.520 --> 00:40:10.720
来自微软，他基本上是在做海味的东西，

00:40:10.720 --> 00:40:15.200
 ietf之类的东西只是出于业余爱好，他在俄勒冈州经营着一家酿酒厂

00:40:15.200 --> 00:40:18.800
所以我不知道发生了什么，只是

00:40:18.800 --> 00:40:22.480
今天早上，我的新闻消息传来了不幸的消息，

00:40:22.480 --> 00:40:26.640
真的让我震惊，现在它解释了为什么我没有收到他们的来信

00:40:28.960 --> 00:40:34.000
但是ii如此cd dl我想我又像我上周提到的那样

00:40:34.000 --> 00:40:37.119
就像您在jason ld的上下文中所做的一样

00:40:37.119 --> 00:40:41.520
就像您知道是否使用数据定义约束架构一样

00:40:41.520 --> 00:40:48.079
从这个意义上讲json是cbor的子集，您可以约束数据

00:40:48.079 --> 00:40:54.400
到在dl中定义的那些模式的类型，则无损

00:40:54.400 --> 00:40:57.200
像cddl这样的转换实际上促进了这一点

00:40:57.200 --> 00:41:01.200
但是，一旦你像呃，哦，哦，天哪，我

00:41:01.200 --> 00:41:08.800
我um eeee 754用于表示数字并尝试进行转换

00:41:08.800 --> 00:41:13.440
和64位或32位转换之间

00:41:13.440 --> 00:41:17.359
它很快就爆炸了

00:41:17.760 --> 00:41:21.920
我想我会提出

00:41:21.920 --> 00:41:28.800
明确指定此功能的特定域，例如

00:41:28.800 --> 00:41:32.640
函数具有输入域和输出范围的权利

00:41:32.640 --> 00:41:37.040
如果您指定狭窄的域，您知道事情会起作用

00:41:37.040 --> 00:41:42.319
在该子域中，您的域之间存在双射

00:41:42.319 --> 00:41:47.680
和你的范围，那么你很好，你可以使用cddl作为

00:41:47.680 --> 00:41:52.240
如果需要，用于描述这些域限制的语法

00:41:52.240 --> 00:41:57.200
我对此无动于衷，我想如果你想提出你的建议

00:41:57.200 --> 00:42:00.880
不依赖于这种复杂性的另一种规格

00:42:00.880 --> 00:42:05.040
您可能只是在周围使用更简单的语言

00:42:05.040 --> 00:42:08.079
域约束，可能会摆脱它

00:42:08.079 --> 00:42:11.280
嗯，我不知道您指定的内容有多复杂

00:42:11.280 --> 00:42:14.560
所以我真的不知道这个建议有多可行，但是那样的话

00:42:14.560 --> 00:42:18.240
如果您被迫退缩，可以尝试尝试

00:42:18.240 --> 00:42:22.000
但总的来说，约束事物是的，是的

00:42:22.000 --> 00:42:26.240
因此相对而言，它实际上只是直截了当或

00:42:26.240 --> 00:42:32.319
键值对主要与字符串有关，因此很多都类似于尝试获取jwk

00:42:32.319 --> 00:42:36.480
正确表示的um键，并明确说明了

00:42:36.480 --> 00:42:39.599
代表一个jwk，假设您知道ed25519

00:42:39.599 --> 00:42:43.520
以及rsa和uh第五节六节一等

00:42:43.520 --> 00:42:46.960
所以，我想我和吉姆以前对我提到的是

00:42:46.960 --> 00:42:50.160
就像只是在json中做一样，不要尝试

00:42:50.160 --> 00:42:56.960
使用期望的um编码以base 64为标签23进行二进制处理。

00:42:56.960 --> 00:43:00.720
就像只是将其保存在json中，这对幽默很友好，您可以进行一些压缩

00:43:00.720 --> 00:43:03.520
大约25只是将其转换为cbor

00:43:03.520 --> 00:43:04.880
因为您没有处理任何

00:43:04.880 --> 00:43:08.480
json中的字符串，因此我认为它更干净，

00:43:08.480 --> 00:43:12.000
您在其中与数据模型有重叠

00:43:12.000 --> 00:43:16.800
jason and and and seabor，然后是更复杂的东西

00:43:16.800 --> 00:43:20.319
就像您知道数字那样限制，就像在sibor规范中一样

00:43:20.319 --> 00:43:24.720
我认为ipld所遵循的是

00:43:24.720 --> 00:43:31.359
最简单的表示法胜出了，所以基础就像一切都是基础

00:43:31.359 --> 00:43:36.240
64. um bit 64位数字不要尝试做

00:43:36.240 --> 00:43:41.520
嗯，ieee 754和嗯，在这种情况下，您只有一种方法

00:43:41.520 --> 00:43:43.520
代表数字，然后基本上

00:43:43.520 --> 00:43:46.880
他们说，最主要的是我们不是在煮沸海洋

00:43:46.880 --> 00:43:50.319
就像保持简单一样，然后我认为一切都会正常进行

00:43:50.319 --> 00:43:59.920
出来就好了[笑声]

00:43:59.920 --> 00:44:03.680
这里有一个我们也要讨论的话题，这是

00:44:03.680 --> 00:44:11.040
西摩的浮动格式，试图统一我们的食典的出租车

00:44:11.040 --> 00:44:18.400
嗯，我们会做得尽可能小还是选择64位，是的，然后

00:44:18.400 --> 00:44:20.319
得到我，所以如果你们实际上是为了得到一个

00:44:20.319 --> 00:44:23.839
如果您能阅读我在规范中写的内容以确保

00:44:23.839 --> 00:44:25.680
我很顺从，因为我写了很多东西

00:44:25.680 --> 00:44:29.680
我不知道我实际上对那个dag c板到底有多准确

00:44:29.680 --> 00:44:34.960
我知道dexy board可以完成大部分操作吗，嗯，好吧，您会获得一个链接吗

00:44:34.960 --> 00:44:37.680
是的，是的，就在上面的音符上

00:44:37.680 --> 00:44:40.560
我们不一致时的数字不一致，这是

00:44:40.560 --> 00:44:46.000
我们需要解决的问题um，以便我们的规格集可以看到我们尝试了什么，

00:44:46.000 --> 00:44:50.560
就是说我们已经说过我们严格遵守Seabor

00:44:50.560 --> 00:44:54.800
我们遵循seabor规范中的准则进行操作，这意味着

00:44:54.800 --> 00:44:58.880
严格来说，这就是我们说严格的地方

00:44:58.880 --> 00:45:01.280
我们将采用他们严格的标准，并做到这一点

00:45:01.280 --> 00:45:05.680
而在我们的主要法典中，大多数我们都喜欢

00:45:05.680 --> 00:45:09.760
javascript，然后我们就这样做了，只是我们没有数字

00:45:09.760 --> 00:45:14.960
因此，在执行过程中，我们执行64位操作，而在javascript中执行的操作越小越好

00:45:14.960 --> 00:45:22.000
这使规格尽可能小，所以问题是我们

00:45:22.000 --> 00:45:27.119
遵循该规范，或者我们使javascript符合我们自己的脚本版本

00:45:27.119 --> 00:45:32.079
严格和昨天的讨论，我认为是

00:45:32.079 --> 00:45:40.240
volca um也提出了这个问题，也许64位是um的方法

00:45:40.240 --> 00:45:43.839
比愿望，因为我喜欢我喜欢64位，因为它很简单

00:45:43.839 --> 00:45:47.119
这意味着您不会这么做，因为当您做小事时，您可能不得不

00:45:47.119 --> 00:45:50.720
尝试然后失败尝试失败这两个不同

00:45:50.720 --> 00:45:55.119
例如16位，然后是32位，然后回落到64位，因此

00:45:55.119 --> 00:45:59.359
这很费力，这不简单，嗯，没有简单的算法

00:45:59.359 --> 00:46:03.680
并不是那么困难，如果您愿意的话，它只是两个位图

00:46:03.680 --> 00:46:07.599
因为我将它放入其中，所以您可以像执行位图检查一样

00:46:07.599 --> 00:46:10.640
基本上可以做一个像

00:46:10.640 --> 00:46:15.280
在原始字节上有一些类似的位掩码

00:46:15.280 --> 00:46:20.319
浮动字节，可以确定是否可以转换

00:46:20.319 --> 00:46:22.720
我认为我认为这是正确的，因为因为你与众不同

00:46:22.720 --> 00:46:25.839
尾数的长度，您不能为每个

00:46:25.839 --> 00:46:28.400
不同格式的位数不同

00:46:28.400 --> 00:46:34.480
组成了这两个部分，所以您不能只说它是

00:46:34.480 --> 00:46:37.680
绝对太忙了，您必须检查每个

00:46:37.680 --> 00:46:40.880
较小的版本，因此基本上，如果您有64位，则必须检查

00:46:40.880 --> 00:46:45.200
是32位还是16位

00:46:45.440 --> 00:46:52.160
嗯，你必须这样做，但你也可以从根本上开始

00:46:52.160 --> 00:46:58.000
是这样，您可以直接检查是否是64位

00:46:58.000 --> 00:47:04.400
像它适合16位的东西，如果不检查的话

00:47:04.400 --> 00:47:08.560
它适合32位吗，是的，所以我想我认为是

00:47:08.560 --> 00:47:10.720
可能的，所以我还没有实现它，但从喜欢

00:47:10.720 --> 00:47:14.319
我抬头看了什么，所以如果您想阅读我的笔记，我可以

00:47:14.319 --> 00:47:20.640
向您发布有关它的注释对吧，我的意思是我们在Java中完成它，在javascript中完成它

00:47:20.640 --> 00:47:25.280
但这意味着先进行编码然后再进行解码以检查是否

00:47:25.280 --> 00:47:29.520
适合，然后如果失败，则转到下一个大小调整代码，然后解码

00:47:29.520 --> 00:47:32.640
然后如果那行不通，请转到64位，以便我们在javascript中做得很好

00:47:32.640 --> 00:47:36.559
javascript可以正常工作，并且符合siebel规范

00:47:36.559 --> 00:47:39.119
我们在规格方面的严格建议

00:47:39.119 --> 00:47:42.960
二恶英或停靠它只是把这个东西扔在

00:47:42.960 --> 00:47:47.599
现在我要64位um，我真的很想统一

00:47:47.599 --> 00:47:50.400
并修复此问题，但我仍不清楚是哪一个

00:47:50.400 --> 00:47:54.400
我们应该选择，因为我一方面我只是想

00:47:54.400 --> 00:47:56.960
64位只是最简单的选择64位

00:47:56.960 --> 00:48:00.880
并以64位处理所有内容，就像这样最干净

00:48:00.880 --> 00:48:05.040
但我们有一个问题是，因为规范说

00:48:05.040 --> 00:48:08.640
严格来说应该是这样，然后更容易找到可以执行的实现

00:48:08.640 --> 00:48:11.200
例如，如果我们然后去说好，我们必须修复

00:48:11.200 --> 00:48:15.359
在javascript中，我们必须返回javascript编码器并修复

00:48:15.359 --> 00:48:19.119
它在那里，你知道不是，然后然后，然后

00:48:19.119 --> 00:48:22.319
那么每个想要用自己的语言实现这一目标的人

00:48:22.319 --> 00:48:27.119
然后将不得不去手动执行此操作，因为他们

00:48:27.119 --> 00:48:30.400
不能只是将一个严格的海滨解析器从货架上拿下来并使用它

00:48:30.400 --> 00:48:36.559
嗯，是的，但是我认为我想我们是这样，所以我认为浮动的东西是

00:48:36.559 --> 00:48:40.240
不是罐装莫妮卡的一部分

00:48:40.240 --> 00:48:46.000
看到我认为这是传统的一部分，我认为这是json安慰剂的一部分

00:48:46.000 --> 00:48:49.599
在规范中它是规范中的一部分，并且要尽可能的小

00:48:49.599 --> 00:48:55.839
好的，是的，然后，是的，但是我认为它也说你应该

00:48:55.839 --> 00:49:01.040
选择它只是您如何做事的一个例子，但这就是

00:49:01.040 --> 00:49:03.119
是的，但是规范中的整个部分是

00:49:03.119 --> 00:49:06.800
例如，这是一个你应该做的规范的事情，这里有一些想法

00:49:06.800 --> 00:49:10.160
但是然后每一个执行是的实现

00:49:10.160 --> 00:49:13.280
这就是我们做严格的方法，这样更容易

00:49:13.280 --> 00:49:17.119
嗯，如果我们可以背负一下，那就太好了

00:49:17.119 --> 00:49:22.640
是的，但无论如何不是这样，但我想尽快解决，

00:49:22.640 --> 00:49:25.839
两者都意味着走走走走，这可能会更容易，因为

00:49:25.839 --> 00:49:29.040
eric拥有该代码，很容易修复

00:49:29.040 --> 00:49:31.920
javascript有点复杂，因为即使现在

00:49:31.920 --> 00:49:35.680
在将更改从缓冲区更改为utf-8时拖延了拉取请求

00:49:35.680 --> 00:49:40.640
现在抱歉，不，你赢得了八个像这样的数组，我想即使是修改

00:49:40.640 --> 00:49:45.680
那件事变得很复杂，但是嗯

00:49:45.680 --> 00:49:49.200
无论如何，我不知道这是一个复杂的领域，约翰尼二世也不认为我们可以

00:49:49.200 --> 00:49:53.440
是的，可以帮助您浮动，所以我主要是复制和粘贴

00:49:53.440 --> 00:49:55.920
规范中的规范是什么，但是有一个

00:49:55.920 --> 00:49:58.480
作者写的更新后的草稿，我

00:49:58.480 --> 00:50:01.200
认为仍然是草案和IETF，基本上我认为

00:50:01.200 --> 00:50:06.160
扩展它，我认为，它提供了额外的指导

00:50:06.160 --> 00:50:09.440
但大多数情况下，我需要仔细检查以确保无损

00:50:09.440 --> 00:50:13.440
转换是往返的，但大多数情况下是前期的

00:50:13.440 --> 00:50:16.559
如何代表它的限制，以及

00:50:16.559 --> 00:50:20.160
这些约束在cddl方法中是明确的

00:50:20.160 --> 00:50:25.200
在jason和

00:50:25.839 --> 00:50:29.920
然后尝试像您知道的那样利用杠杆，例如uh键

00:50:29.920 --> 00:50:34.640
呃字符串，特别是在seabor中，它们必须是字节数组和json它们

00:50:34.640 --> 00:50:38.400
可能是字符串，所以嗯，但这很有趣，因为

00:50:38.400 --> 00:50:40.559
我们没有任何要代表的数字

00:50:40.559 --> 00:50:44.000
然而，这全是猜想，我认为这是

00:50:44.000 --> 00:50:48.079
所以就像试图去获得这个抽象的数据模型并沸腾大海

00:50:48.079 --> 00:50:52.000
甚至还没有成为问题，但这就是本质

00:50:52.000 --> 00:50:57.040
IATF是关于是的，是的，这恰恰是

00:50:57.040 --> 00:51:02.480
徒劳无益的痛苦过程

00:51:02.480 --> 00:51:09.280
鉴于我的探索，胡安警告了我

00:51:09.280 --> 00:51:12.720
报告，我希望我们希望就此达成共识

00:51:12.720 --> 00:51:16.880
只是使用64位浮点数，就像

00:51:16.880 --> 00:51:20.720
可能会产生类似我们可能仍会做出其他决定的结果，但我想我也是

00:51:20.720 --> 00:51:24.960
倾向于仅使用64位并完成

00:51:24.960 --> 00:51:27.200
嗯

00:51:28.559 --> 00:51:31.200
那很难

00:51:31.760 --> 00:51:38.480
所以在五分钟前，我以为使用最小的编码是

00:51:38.480 --> 00:51:42.480
内战规范没有不确定的说法，因此

00:51:42.480 --> 00:51:45.280
尽管写了代码，我还是那边

00:51:45.280 --> 00:51:48.720
用64做简单的事情

00:51:48.839 --> 00:51:53.280
我本人是在谈论这个嗯

00:51:53.280 --> 00:51:57.359
你是对的，无论谁说过海博规范的这一部分都是示例

00:51:57.359 --> 00:52:00.720
我不记得如何

00:52:02.240 --> 00:52:09.599
尊重的这一部分是的，它说如果一个协议，如果一个协议

00:52:09.599 --> 00:52:14.800
允许ieee浮动这很有趣

00:52:15.359 --> 00:52:18.720
那么其他的化学规则可能

00:52:18.720 --> 00:52:23.839
需要添加例如是的，然后是所有示例

00:52:23.839 --> 00:52:27.520
没有伪代码，没有固定装置，没有

00:52:27.520 --> 00:52:32.720
是的，但是没有任何其他指导，每个人的

00:52:32.720 --> 00:52:36.000
只是拿了足够公平的东西，只是他们应该走了一点

00:52:36.000 --> 00:52:40.079
进一步说，好吧，这是规范的，这就是您实现的方式

00:52:40.079 --> 00:52:43.599
规范的，但他们没有，所以每个人都只是

00:52:43.599 --> 00:52:49.040
就这样吧，是的，我正要伸出手来

00:52:49.040 --> 00:52:53.280
博尔曼（Borman）是他的作者，我是在德国，在

00:52:53.280 --> 00:52:57.760
大学，只是针对我特定的大学获得有关此大学的一些反馈

00:52:57.760 --> 00:52:59.280
协议以确保实际上我是

00:52:59.280 --> 00:53:02.640
在没有吉姆死的情况下符合它

00:53:02.640 --> 00:53:06.640
我想他会对我有些同情，我希望正确的寻找一些

00:53:06.640 --> 00:53:12.720
智慧um ii与他进行了一些电子邮件交换以获取标签42

00:53:12.720 --> 00:53:16.720
保留给ipld并将内容移出边界，所以他真的很喜欢

00:53:16.720 --> 00:53:20.480
容易和喜欢的人交谈超级好人，是的

00:53:20.480 --> 00:53:26.079
这是超级平易近人的，是的，我认为这样会使

00:53:26.079 --> 00:53:30.240
如果您想拥有最小的浮动，我认为这是必要的

00:53:30.240 --> 00:53:34.720
规范的电子人，但仍支持所有浮动

00:53:34.720 --> 00:53:41.680
点类型，那么您需要它，但是如果我们在dag cbo中说，我们只有

00:53:41.680 --> 00:53:47.920
64漂浮在seaborn中，那么我们的规范复制就很好

00:53:47.920 --> 00:53:53.520
足以使人基本上平等

00:53:53.920 --> 00:53:58.319
只是意味着选择一种干净的往返方式，仅此而已

00:53:58.319 --> 00:54:01.680
实际上选择一种一致的方式

00:54:01.680 --> 00:54:05.200
这样是可以的，但是如果您想获得支持，可以说它是32位的

00:54:05.200 --> 00:54:10.079
漂浮着你，但是同样的道理

00:54:10.079 --> 00:54:14.000
我们可以做64位整数um，然后在语言领域中

00:54:14.000 --> 00:54:15.520
就像埃里克在做什么

00:54:15.520 --> 00:54:17.839
apld-prime你不是他在做数据模型

00:54:17.839 --> 00:54:22.319
这只是数字的一种类型，所以当您达到相等的水平时，

00:54:22.319 --> 00:54:24.319
只是用它要做的任何事情编码，如果有的话

00:54:24.319 --> 00:54:28.480
如果我们在cbore中说您只有64位整数

00:54:28.480 --> 00:54:31.599
那也行得通，这仅意味着在语言层面上我们必须处理

00:54:31.599 --> 00:54:35.920
它以任何有意义的方式表示，数据模型表示数字为整数

00:54:35.920 --> 00:54:39.119
没有说什么尺寸，所以您只使用适合的尺寸

00:54:39.119 --> 00:54:42.160
你的东西，通常应该是我会的

00:54:42.160 --> 00:54:47.119
说这应该是您语言中最大的可能，尽管它们会生锈

00:54:47.119 --> 00:54:52.799
可能会变大吗，不是吗128是的，但只是像

00:54:52.799 --> 00:54:58.480
您可以使用它，但通常使用34。是的，对不起54

00:54:58.480 --> 00:55:05.040
是的，您可以使用128，但不会

00:55:05.040 --> 00:55:08.640
数字是有道理的，因为对不起整数是有道理的

00:55:08.640 --> 00:55:11.839
因为它很容易检查，因为

00:55:11.839 --> 00:55:14.559
仍然可以下注并进行边界检查，但需要花车

00:55:14.559 --> 00:55:18.240
因为每个表示形式的尾数都不同

00:55:18.240 --> 00:55:22.400
只是变得复杂而已

00:55:23.440 --> 00:55:26.319
然后您可以通过执行不同的编码来获得相同的数字

00:55:26.319 --> 00:55:32.240
只是因为现在已经很有价值而疯狂

00:55:32.240 --> 00:55:36.400
摆得太简单是正确的，并且总是做64位

00:55:36.400 --> 00:55:40.799
浮动是因为它不直接

00:55:40.799 --> 00:55:47.119
与苛刻的规格作斗争，这是简单性的争论让我震惊

00:55:47.119 --> 00:55:50.559
它具有成为您无论如何都会做的事情的好处

00:55:50.559 --> 00:55:54.160
如果您只是想将其完成，这将使其更具弹性

00:55:54.160 --> 00:55:59.680
所以是吗，是的，但是就像我希望

00:55:59.680 --> 00:56:02.240
剩下的经典西摩就是这样，

00:56:02.240 --> 00:56:05.839
没有像这些复杂的规则一样

00:56:05.839 --> 00:56:09.280
人们会出错的变化

00:56:09.280 --> 00:56:12.240
就像只是去

00:56:14.000 --> 00:56:17.119
没事，特别是如果没有逃跑的惩罚，例如

00:56:17.119 --> 00:56:20.880
仍然解码，你弄错了，这很好，好像没人在乎

00:56:20.880 --> 00:56:23.520
除了我们

00:56:24.319 --> 00:56:26.960
好吧，我正在尝试使其正确，因为他们正在尝试完成并获得此结果

00:56:26.960 --> 00:56:29.440
进入候选人推荐，所以我想

00:56:29.440 --> 00:56:32.400
确保实际上我做对了，我需要做一堆测试用例，但是

00:56:32.400 --> 00:56:37.119
嗯，以确保我写的内容适合我在聊天中添加的内容

00:56:37.119 --> 00:56:41.040
博尔曼（Borman）撰写的有关其他注意事项的草稿

00:56:41.040 --> 00:56:44.960
确定性规范化的半机械人，所以有一些

00:56:44.960 --> 00:56:49.440
其他要考虑的事情很酷哦，这是另一个

00:56:49.440 --> 00:56:51.760
赞成只做64位的论点

00:56:51.760 --> 00:56:55.359
我要粘贴这个这个东西在这个是JavaScript的

00:56:55.359 --> 00:56:58.480
这就是它如何做到最小的可能

00:56:58.480 --> 00:57:01.200
疯狂的另一种观点赞成

00:57:01.200 --> 00:57:06.000
仅使用64位是大多数现代语言都没有

00:57:06.000 --> 00:57:11.280
甚至包括16位浮点编码类型，因此必须编写它们

00:57:11.280 --> 00:57:14.480
所以你可以做单精度和双精度，但不能做一半

00:57:14.480 --> 00:57:19.920
许多语言的精度，所以像javascript一样，

00:57:19.920 --> 00:57:22.000
实现自己的半精度编码器

00:57:22.000 --> 00:57:26.000
只是为了获得一半精度的浮子

00:57:26.000 --> 00:57:29.440
就像您要处理的是手动写出float格式

00:57:29.440 --> 00:57:32.960
在那时，不仅复杂

00:57:32.960 --> 00:57:37.040
算法上做到这一点，以获得正确的编码

00:57:37.040 --> 00:57:39.119
您必须编写自己的手册的最小的一本

00:57:39.119 --> 00:57:44.400
编码器，所以效果不好，就像可以做的那样

00:57:44.400 --> 00:57:46.880
工作不是因为你是否能做到

00:57:46.880 --> 00:57:50.720
工作就是这是一条复杂的道路，如果

00:57:50.720 --> 00:57:53.280
与已经非常严格的seaborn编码器一起工作

00:57:53.280 --> 00:57:56.000
他们这样做，然后变得很容易，但是我们越来越

00:57:56.000 --> 00:57:58.319
到现在我们开始说的地步

00:57:58.319 --> 00:58:01.040
你真的应该实现自己的海滨解析器，如果

00:58:01.040 --> 00:58:06.079
你要去打出租车，是的，我是说所以我们不得不留下来

00:58:06.079 --> 00:58:08.960
一段时间，这就是为什么就像

00:58:08.960 --> 00:58:12.319
这不是最好的，我的意思是这就是我们所处的境地

00:58:12.319 --> 00:58:15.280
记录下来，我们将不得不说所有我们不想要的东西

00:58:15.280 --> 00:58:20.720
超级面对的战争不会消失，但是是的，

00:58:20.720 --> 00:58:24.960
我们在这里可以做些什么以及我们可能会推荐什么

00:58:27.040 --> 00:58:30.640
好吧，我们已经开会了

00:58:30.640 --> 00:58:36.880
非常感谢大家的参与，下周再见

00:58:36.880 --> 00:58:39.989
[音乐]

00:58:41.880 --> 00:58:44.880
每个人

