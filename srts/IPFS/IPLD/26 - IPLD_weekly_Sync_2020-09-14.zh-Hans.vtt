WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.679 --> 00:00:21.840
欢迎大家参加9月14日举行的本周ipld同步会议

00:00:21.840 --> 00:00:25.199
每周我们都会回顾一下

00:00:25.199 --> 00:00:32.000
在过去一周工作，然后讨论了我们可能拥有的所有行动项目，以及

00:00:32.000 --> 00:00:38.960
是的，请将您的名字添加到与会者列表中，我将发布

00:00:38.960 --> 00:00:44.399
聊天室里的茄子也适合那些没有链接的人

00:00:44.399 --> 00:00:48.960
如果我们有讨论的话，我们也会做笔记，是的，我

00:00:48.960 --> 00:00:56.480
从我自己开始，所以在过去的一周里，我又在rust multi上工作了

00:00:56.480 --> 00:01:02.879
散列的东西和是的东西擦亮一点，所以嗯

00:01:02.879 --> 00:01:07.119
目前我在做小巧的工作

00:01:07.119 --> 00:01:10.320
多哈希，这是生锈的多哈希的叉子

00:01:10.320 --> 00:01:14.960
我试图通过rust multihash和

00:01:14.960 --> 00:01:18.159
现在是这样，所以今天我已经在实际制作

00:01:18.159 --> 00:01:22.479
合并请求比我想象的要平滑，并且

00:01:22.479 --> 00:01:26.240
唯一缺少的是blake 3支持

00:01:26.240 --> 00:01:30.159
在生锈的多重对冲中，这还不是很小

00:01:30.159 --> 00:01:34.079
多哈希，是的，我们很快就会来，所以这是丢失的那一部分，然后是

00:01:34.079 --> 00:01:37.920
准备合并，然后我们又有一个上游

00:01:37.920 --> 00:01:42.320
希望每个人都可以使用的版本，这也是我的那种

00:01:42.320 --> 00:01:45.759
集中精力于本周以使其实际合并，然后

00:01:45.759 --> 00:01:52.000
也真的使用它的p2p和使用它的ipl等

00:01:52.000 --> 00:01:55.119
是的，这几乎是我名单上的下一个

00:01:55.119 --> 00:02:00.719
丹妮尔（Danielle）很酷，所以上周我起床了

00:02:00.719 --> 00:02:05.280
上周初规格上的码头速度我也提出了一个要求

00:02:05.280 --> 00:02:08.160
一份关于我的经历的探索报告

00:02:08.160 --> 00:02:12.000
加快速度，这主要是我发现令人困惑的部分

00:02:12.000 --> 00:02:16.480
而且我还在松弛状态下在go通道中启动了一个线程

00:02:16.480 --> 00:02:21.120
关于从github.com移动go导入路径

00:02:21.120 --> 00:02:26.319
ipld到我们自己的ipld.io域，该域具有一些优势，例如

00:02:26.319 --> 00:02:30.640
为了将来的证明，所以我开始了一个更正式的草案

00:02:30.640 --> 00:02:33.360
讨论我们如何去做这个和那个

00:02:33.360 --> 00:02:38.239
链接到黑客端，或者在eric的帮助下，我也

00:02:38.239 --> 00:02:42.400
开始看卡哇伊pld adl手

00:02:42.400 --> 00:02:46.959
这应该像是新手的实现

00:02:46.959 --> 00:02:50.239
ypld Prime图书馆，所以我在那里没有很多需要报告的地方

00:02:50.239 --> 00:02:54.480
但是因为我主要是阅读现有代码并继续阅读

00:02:54.480 --> 00:02:59.040
这种数据结构，但我进展缓慢，但这是

00:02:59.040 --> 00:03:05.840
这个礼拜

00:03:05.920 --> 00:03:10.959
谢谢，我的清单上的下一个是正确的

00:03:11.519 --> 00:03:15.599
我这周没有很多要向我报告的，我身体不好，嗯

00:03:15.599 --> 00:03:19.840
所以不是一个高生产率的星期，主要是

00:03:19.920 --> 00:03:23.519
在此块存储API上工作

00:03:23.760 --> 00:03:28.159
这意味着基本上重写卡库

00:03:28.159 --> 00:03:32.080
将其拉成碎片，然后再放回去嗯

00:03:32.080 --> 00:03:38.480
具有更现代的感觉api并非没有

00:03:38.480 --> 00:03:45.040
从一些旧的um宿醉中解脱出来

00:03:45.040 --> 00:03:49.440
在没有人记得的地方拥有它的历史

00:03:49.440 --> 00:03:55.760
所以嗯，这很好，嗯，我是说我对简单感到满意

00:03:55.760 --> 00:03:59.760
api um的内容，但与gaza的对话

00:03:59.760 --> 00:04:04.720
关于块的呃依赖注入

00:04:04.720 --> 00:04:10.000
和多种格式的东西，这很有趣，并且确实会对其产生影响

00:04:10.000 --> 00:04:13.360
好吧，我真的不知道要去哪里

00:04:13.360 --> 00:04:19.199
尽管他似乎对终点有个想法并尝试

00:04:19.199 --> 00:04:24.720
恩与他交往，我们已经

00:04:24.720 --> 00:04:26.800
一直在谈论其他一些话题

00:04:26.800 --> 00:04:32.240
我们希望看到的其他JavaScript API

00:04:32.240 --> 00:04:36.560
但除此之外，没有什么要报告的

00:04:37.680 --> 00:04:45.840
谢谢，下一个是埃里克，我本周还没有准备好笔记

00:04:45.840 --> 00:04:48.400
所以我一直在想着到底是什么

00:04:48.400 --> 00:04:52.160
嗯，这是本周，我认为主要是码头，规格和会谈

00:04:52.160 --> 00:04:55.199
以及有关文档和规范的交流，以及

00:04:55.199 --> 00:05:01.520
嗯，我刚刚大喊了一堆文档

00:05:01.520 --> 00:05:06.639
进入有关um的文档存储库中，我终于将

00:05:06.639 --> 00:05:10.880
我在那里做了一些法典对话

00:05:10.880 --> 00:05:14.240
高层次的结构设计，并为其他事情留出一些存根

00:05:14.240 --> 00:05:17.919
包括一堆东西的目录

00:05:17.919 --> 00:05:22.400
所以还有很多事情要做，但是

00:05:22.400 --> 00:05:25.520
我希望这个骨架是我们可以在

00:05:25.520 --> 00:05:29.919
未来，我又进行了几次对话

00:05:29.919 --> 00:05:33.600
与um ian和同伴高尔夫乡亲们这最后一刻

00:05:33.600 --> 00:05:36.800
一周，他们真的在做一些事情

00:05:36.800 --> 00:05:40.639
令人着迷的东西，其中一些当然会发展为

00:05:40.639 --> 00:05:43.680
特定于应用程序的方式是

00:05:43.680 --> 00:05:48.160
非常多的同行的逻辑和嗯，而不是我们

00:05:48.160 --> 00:05:50.560
可能会单独在ipld中做，因为它只是

00:05:50.560 --> 00:05:54.560
积累意见，尤其是在涉及密码学时

00:05:54.560 --> 00:05:58.319
想像一下，但他们对制作感兴趣

00:05:58.319 --> 00:06:03.199
他们的更多库可围绕ipld数据重用

00:06:03.199 --> 00:06:05.440
处理这将真的很酷，因为它们

00:06:05.440 --> 00:06:10.080
当然是用Java编写的，但我认为其他人都不会

00:06:10.080 --> 00:06:12.960
呼叫目前正在维护Java库，因此

00:06:12.960 --> 00:06:16.639
如果有人接受它会很棒

00:06:16.639 --> 00:06:21.680
谈到了那里的挑战

00:06:21.680 --> 00:06:26.880
java有一个强大的类型系统，需要进行设计讨论

00:06:26.880 --> 00:06:33.280
嗯，那是足够的细节了，我一直在努力让我的头更紧

00:06:33.280 --> 00:06:35.759
围绕高级数据布局的东西adl

00:06:35.759 --> 00:06:39.360
东西，所以既和丹妮尔谈论这件事，也

00:06:39.360 --> 00:06:43.600
我试图建立一个演示adl，这是最简单的方法

00:06:43.600 --> 00:06:50.880
我尝试制作腐烂的13串adl um，所以有一个分支

00:06:50.880 --> 00:06:54.720
甚至没有公关，但我应该将其转换为更多的对话形式，但是有

00:06:54.720 --> 00:06:57.280
可引导性主要仓库中的一个分支

00:06:57.280 --> 00:07:03.840
在这以及如何使界面正常工作以及如何称呼这些东西

00:07:04.240 --> 00:07:08.639
嗯，我做了一些工作，向下游传播了图书馆的变化

00:07:08.639 --> 00:07:14.880
所以um go graph sync和我们基于protobuf的仓库

00:07:14.880 --> 00:07:18.240
因为goyim pld prime都在他们之后有prs，以使他们了解最新信息

00:07:18.240 --> 00:07:23.199
接口的主要版本uh和sp2的unix得到了

00:07:23.199 --> 00:07:26.160
我几乎忘记了另一轮起草，直到我看到迈克尔

00:07:26.160 --> 00:07:29.199
把它打入他的鼻子，所以谢谢迈克尔

00:07:29.199 --> 00:07:34.160
嗯，是的，试图推动讨论的进行

00:07:34.160 --> 00:07:38.639
现在我们已经越来越多了

00:07:38.639 --> 00:07:43.599
像adls一样扎根，它们如何适应这张图片，就像是

00:07:43.599 --> 00:07:48.960
目录实际上只是带有这个用于处理分片的黑匣子的地图

00:07:48.960 --> 00:07:52.720
我认为每次我们使用sp2规范的UNIX时，它们都会变得简单一些

00:07:52.720 --> 00:07:57.039
每次我们这样做时，这就是我认为这是迄今为止最简单的一种，我猜

00:07:57.039 --> 00:07:59.039
也许我会让迈克尔谈论更多

00:07:59.039 --> 00:08:02.080
这样就可以了

00:08:02.319 --> 00:08:07.759
谢谢，下一个是michael hey um yeah，让我实际上把它拉起来

00:08:07.759 --> 00:08:10.080
因为这里有很多东西我已经忘记了

00:08:10.080 --> 00:08:14.240
是的，我修复了块api中的一些错误

00:08:14.240 --> 00:08:17.680
在我们的一堆小javascript库中

00:08:17.680 --> 00:08:20.720
我进去并更新了fbl实施

00:08:20.720 --> 00:08:24.800
js中的最新规范以及我们所有的最新步骤

00:08:24.800 --> 00:08:29.280
嗯，然后我实现了eric的新unix，因此是v2

00:08:29.280 --> 00:08:35.680
嗯，实际上是非常愉快和容易实现的草稿，例如

00:08:35.680 --> 00:08:38.839
高度一致的版本，因为我们没有做任何

00:08:38.839 --> 00:08:42.240
内联，它实际上组成得很好，看起来真的

00:08:42.240 --> 00:08:45.279
好吧，关于它的一件好事是

00:08:45.279 --> 00:08:51.920
一个文件只是一个fbl，所以它只是我们灵活的字节布局

00:08:51.920 --> 00:08:53.920
这真的很适合重用，这意味着

00:08:53.920 --> 00:08:58.560
您可以采用任何具有的二进制对象，因为

00:08:58.560 --> 00:09:01.920
fbl模式也允许您内联字节

00:09:01.920 --> 00:09:05.519
所以您真的可以像任何二进制表示形式一样，现在这只是一个

00:09:05.519 --> 00:09:08.240
文件，所以如果您想像我们

00:09:08.240 --> 00:09:13.040
在网关中实现该功能，您便可以将其提供给任何cid

00:09:13.040 --> 00:09:14.800
 fbl，它将能够将其读取为

00:09:14.800 --> 00:09:19.920
文件以及um，然后您知道在文件顶部，我们添加了

00:09:19.920 --> 00:09:23.519
属性是目录结构的一部分，也是组的一部分

00:09:23.519 --> 00:09:26.160
当我们保持它真正的一致性时

00:09:26.160 --> 00:09:28.320
而我们只是增强了所有目录并

00:09:28.320 --> 00:09:32.560
然后将所有文件都打包，实际上非常容易实现，

00:09:32.560 --> 00:09:36.800
一直到处都是哈希，所以很好，嗯，有一堆

00:09:36.800 --> 00:09:38.880
我们可能会终止自行车停驶的地方

00:09:38.880 --> 00:09:42.399
但我认为规范是一个很好的方向

00:09:42.399 --> 00:09:45.760
嗯，我真的很满意我所做的很少的实现

00:09:45.760 --> 00:09:50.080
嗯，然后在周末，我开始在播客上闲逛

00:09:50.080 --> 00:09:53.920
客户端，我想写一个基本上可以直播的小播客客户端

00:09:53.920 --> 00:10:00.720
在github中，因此它使用dagdb和新的github git lfs内容

00:10:00.720 --> 00:10:05.440
dagdb，所以基本上每小时都会去

00:10:05.440 --> 00:10:09.760
查看您所有的播客，然后将所有元数据提取到数据库中

00:10:09.760 --> 00:10:14.240
然后它将为整个应用程序生成html，然后是

00:10:14.240 --> 00:10:18.320
这是静态网站，您需要先下拉然后再进入

00:10:18.320 --> 00:10:20.880
您可以在服务人员中拉出的静态网站

00:10:20.880 --> 00:10:26.480
收集所有数据，然后将其实际映射到

00:10:26.480 --> 00:10:28.800
你在你的球员和所有类似的东西中，所以就像

00:10:28.800 --> 00:10:32.480
这是一种有趣的方法，就像生活中的分布式应用一样

00:10:32.480 --> 00:10:34.560
在github中，并利用了一些

00:10:34.560 --> 00:10:37.680
github的行为就像一种云服务，但是更加个性化

00:10:37.680 --> 00:10:40.880
每个人都可以和他一起玩很有趣

00:10:40.880 --> 00:10:44.800
嗯，我最终为dagdb添加了一堆功能

00:10:44.800 --> 00:10:47.760
只是使用dag就像现在浮出水面一样，很多事情可能

00:10:47.760 --> 00:10:50.480
更好，所以我一直在解决这个问题

00:10:50.480 --> 00:10:53.519
嗯，我想谈的最后一件事

00:10:53.519 --> 00:10:56.880
我们可能需要像一个小组一样讨论这些问题

00:10:56.880 --> 00:11:00.160
最后，但是我一直在和一些人聊天

00:11:00.160 --> 00:11:03.760
人们喜欢团队的结构和我们所做的工作

00:11:03.760 --> 00:11:06.560
可能是在Filecoin启动之后

00:11:06.560 --> 00:11:09.680
嗯，即将来临的是

00:11:09.680 --> 00:11:14.399
项目框架对于我们团队的工作不是很好

00:11:14.399 --> 00:11:17.680
嗯，我们只处理数据结构，而我们致力于

00:11:17.680 --> 00:11:21.360
ipld和多种格式以及ipld上的内容

00:11:21.360 --> 00:11:23.760
而我们正在做的很大一部分工作就像建立这些数据结构，

00:11:23.760 --> 00:11:26.000
然后通过跟踪数据结构来弄清楚发生了什么，然后

00:11:26.000 --> 00:11:28.399
与其他需要数据结构的团队合作

00:11:28.399 --> 00:11:33.839
嗯，是的，很多其他人都在类似的船上，就像项目一样

00:11:33.839 --> 00:11:36.399
框架对他们不起作用，但我认为这是对的

00:11:36.399 --> 00:11:40.880
将我们推向错误的方向，或者将我们推向某个方向太远

00:11:40.880 --> 00:11:43.839
就像我们过分专注于实现和

00:11:43.839 --> 00:11:46.399
对协议没有给予足够的重视

00:11:46.399 --> 00:11:49.680
就像我们是协议实验室，我们不是项目实验室

00:11:49.680 --> 00:11:54.959
嗯，我们拥有所有这些规格，但是我们周围没有出色的工具

00:11:54.959 --> 00:11:59.120
遵守法规方面，我们做得并不出色，就像每个人都喜欢新的一样

00:11:59.120 --> 00:12:02.240
我们喜欢的东西的实现哦，为什么他们不使用我们的东西或

00:12:02.240 --> 00:12:04.000
不管我们不是真的在考虑

00:12:04.000 --> 00:12:06.639
就像没有，这些真的很容易实现

00:12:06.639 --> 00:12:10.320
协议，当人们实施像

00:12:10.320 --> 00:12:13.279
另一种多格式的东西或另一种ipld的东西

00:12:13.279 --> 00:12:16.880
嗯，只是将其更好地整合到我们对项目的看法中

00:12:16.880 --> 00:12:20.320
如果他们有问题，例如我们已经看到人们有问题，例如

00:12:20.320 --> 00:12:24.240
对Seabor进行编码，例如um，因为dag cbor的限制如此严格

00:12:24.240 --> 00:12:28.240
我们应该优先考虑为他们构建更好的工具和更好的规格

00:12:28.240 --> 00:12:31.839
um处理这些合规性问题um而不是仅仅尝试

00:12:31.839 --> 00:12:34.880
将每个人集中到我们编写的几个实现中

00:12:34.880 --> 00:12:38.240
嗯，是的，我只是有点放松并思考

00:12:38.240 --> 00:12:41.200
那对团队来说就像一个框架

00:12:41.200 --> 00:12:43.839
在那个我认为我们可以做的项目中

00:12:43.839 --> 00:12:48.800
至少在接下来的几周内会进行一些讨论

00:12:51.120 --> 00:12:56.959
这是我的更新，谢谢，我认为更新就是这样

00:12:56.959 --> 00:13:00.320
约翰尼，你想说点什么吗

00:13:03.680 --> 00:13:07.600
哦，我认为您仍然处于静音状态，它表示变焦，表示您未静音，但是我

00:13:07.600 --> 00:13:10.880
听不到你，我看到你在说话

00:13:16.880 --> 00:13:21.760
你被设置成一个完整的播客，我不知道为什么我们听不到你的声音

00:13:21.760 --> 00:13:25.760
是的，有时当我睡觉时，它会使麦克风进入睡眠状态，因为它会

00:13:25.760 --> 00:13:29.519
通过枢纽，但嗯，所以只是关于什么的一个细节

00:13:29.519 --> 00:13:32.720
您只是说我认为嗯，所以我对

00:13:32.720 --> 00:13:36.079
规范，因此它主要与分散标识符有关

00:13:36.079 --> 00:13:39.040
seabor，所以他们威胁要丢下seabor

00:13:39.040 --> 00:13:43.760
规范中的支持，因为我不能代表

00:13:43.760 --> 00:13:49.199
seabor cose钥匙正确，挑战在于它是一种混合媒体

00:13:49.199 --> 00:13:52.160
类型，所以我无法完全表达出来

00:13:52.160 --> 00:13:56.079
西伯恩嗯，我不能，因为我们没有

00:13:56.079 --> 00:13:59.760
完整的int作为关键代表

00:13:59.760 --> 00:14:03.600
数字表示

00:14:03.600 --> 00:14:08.000
以及我认为的挑战和我们之前谈过的3块钱之类的东西

00:14:08.000 --> 00:14:13.519
关于这个的使用呃ipld链接，实际上基本上是使用

00:14:13.519 --> 00:14:17.120
cid或那个cid可能像是带有一个

00:14:17.120 --> 00:14:23.120
ed 2 5 5 1 9公钥多重编解码器，然后是

00:14:23.120 --> 00:14:25.680
实际上是紧随其后的，所以面临的挑战是

00:14:25.680 --> 00:14:27.839
实际上需要包装的更多元数据

00:14:27.839 --> 00:14:34.320
包括id字段和type字段，所以它也像自行车一样进入

00:14:34.320 --> 00:14:37.680
脱落的命名问题，就像您如何称呼此属性

00:14:37.680 --> 00:14:43.839
该链接是公开的dag cos，也是

00:14:43.839 --> 00:14:48.800
挑战是在紧身胸衣和海鸟中，甚至在粗斜纹棉布中

00:14:48.800 --> 00:14:52.639
c板签名和加密没有

00:14:52.639 --> 00:14:58.800
公钥标签，它实际上是特定于应用程序的，因此像您一样

00:14:58.800 --> 00:15:02.000
必须在您的应用程序中定义它，所以

00:15:02.000 --> 00:15:05.440
实际上没有关键节点标签说“嘿，这是

00:15:05.440 --> 00:15:08.399
cbor，这部分实际上是

00:15:08.399 --> 00:15:13.279
x和曲线等，所以嗯

00:15:13.279 --> 00:15:16.480
这主要与我要提倡的混合媒体类型有关

00:15:16.480 --> 00:15:21.360
让我们将其保留在json中序列化为cbore

00:15:21.360 --> 00:15:25.519
在这种情况下，它只是键值对，而键可以是字符串

00:15:25.519 --> 00:15:32.000
基本上你可以做jw键jason webb键像jason

00:15:32.000 --> 00:15:37.040
对接序列化到seabor，让我们从这一点开始，所以我

00:15:37.040 --> 00:15:41.440
像dag seabor这样的东西，我得到了很大的支持

00:15:41.440 --> 00:15:44.480
放在um中，它基本上是ipld，我写了一个

00:15:44.480 --> 00:15:49.759
一堆只是普通海鲈的东西，并解释了事情可能是什么

00:15:49.759 --> 00:15:53.199
使用标签进行了扩展，但它们就像这样

00:15:53.199 --> 00:15:56.480
就像没有人真正使用它，而您至少需要三个

00:15:56.480 --> 00:16:00.079
实现，就像嘿，听着我很高兴

00:16:00.079 --> 00:16:03.360
我创建了我自己写的规范

00:16:03.360 --> 00:16:08.480
葡萄牙的人记得那些人，嗯，所以

00:16:08.480 --> 00:16:11.199
然后还有另一个像德国或奥地利那样的人

00:16:11.199 --> 00:16:15.199
就像一个实际上正在使用ipid的vr应用程序一样创建

00:16:15.199 --> 00:16:18.160
但这是关于自行车脱落和

00:16:18.160 --> 00:16:22.959
就像标准流程一样，就像我一样，令人沮丧

00:16:22.959 --> 00:16:26.880
那你们怎么能好

00:16:26.880 --> 00:16:31.279
给我一些帮助，所以我想备份一点，

00:16:31.279 --> 00:16:32.959
确保我理解问题，这样

00:16:32.959 --> 00:16:39.680
如果我记得我们登陆dag cose的地方是当您使用dag coset时

00:16:39.680 --> 00:16:47.199
编解码器，这只是您要签名的带有二进制字段的常规cosa

00:16:47.199 --> 00:16:51.279
并且binary字段是假定为cid的二进制表示

00:16:51.279 --> 00:16:55.920
像这样的一个cid，那是我们准确地降落的地方，

00:16:55.920 --> 00:16:57.600
然后，如果您想做其他事情

00:16:57.600 --> 00:17:01.440
因为您只是使用kosei编解码器而不是dag

00:17:01.440 --> 00:17:06.000
 coseco对，嗯，所以他们说

00:17:06.000 --> 00:17:09.120
他们想要更多，所以他们需要能够签名

00:17:09.120 --> 00:17:13.760
不止如此，实际上是整个

00:17:13.760 --> 00:17:17.520
关于加密敏捷性的事情是您想代表您的密钥

00:17:17.520 --> 00:17:20.480
所以规格说明基本上只是发布您的

00:17:20.480 --> 00:17:25.120
公钥，所以有一个像图书馆这样的整体

00:17:25.120 --> 00:17:29.600
命名，就像描述呃呃

00:17:29.600 --> 00:17:36.400
真实的验证方法jwk 2 2020，基本上就像我们创建的

00:17:36.400 --> 00:17:39.480
这个东西我们称之为特殊，我们将其命名为

00:17:39.480 --> 00:17:42.640
2020年，它有一个非常具体的目标

00:17:42.640 --> 00:17:47.520
是呃进行身份验证和呃，并表示为jwk和

00:17:47.520 --> 00:17:53.440
他们希望我在seabor中对这完全相同的东西进行一对一映射

00:17:53.440 --> 00:17:56.559
代表关键，是的，是的，最终是关于

00:17:56.559 --> 00:18:00.000
使用键对其进行签名，但使用did方法

00:18:00.000 --> 00:18:03.039
关于发布您的公钥数据

00:18:03.039 --> 00:18:08.480
整个加密敏捷领域都宣称

00:18:08.480 --> 00:18:12.559
密钥类型的um在密钥类型中的um

00:18:12.559 --> 00:18:15.039
密钥，从而真正进入链接的数据签名

00:18:15.039 --> 00:18:20.160
rdf对um进行建模，并通过命名事物来调用它

00:18:20.160 --> 00:18:26.320
它有特殊的含义，所以这听起来像是陪同的问题

00:18:26.320 --> 00:18:30.000
不仅仅是dag案件发行权，因为那是kosei

00:18:30.000 --> 00:18:33.520
基本上是说您不能在密钥中拥有所有这些元数据

00:18:33.520 --> 00:18:37.440
是的，所以你需要把它包起来，所以挑战是你实际上可以

00:18:37.440 --> 00:18:42.000
基本上创建一个密钥，一个cos，一个密钥表示形式

00:18:42.000 --> 00:18:45.520
舒适的密钥格式，但是那很好，基本上就是您要做的

00:18:45.520 --> 00:18:50.000
作为带有uh参数等的intes键以及x和y和

00:18:50.000 --> 00:18:53.600
而且不要使用d，因为d用于私钥

00:18:53.600 --> 00:18:57.520
好吧，所以你现在有了这个斑点

00:18:57.520 --> 00:19:01.280
说嘿，我代表的这件事

00:19:01.280 --> 00:19:05.280
在海港，因为这实际上有

00:19:05.280 --> 00:19:08.320
一些特殊的含义，基本上是我和

00:19:08.320 --> 00:19:12.559
他们建议的是公共密钥多编解码器

00:19:12.559 --> 00:19:16.000
我认为那可能是我们登陆的地方

00:19:16.000 --> 00:19:19.600
但挑战在于，多编解码器确实

00:19:19.600 --> 00:19:24.080
这是一个多基多编解码器，因为实际上一个公钥多基就像

00:19:24.080 --> 00:19:32.760
嘿，这是以a的base 64编码

00:19:32.760 --> 00:19:40.559
ed25519公钥，这是在其中表示的公钥字节

00:19:40.720 --> 00:19:44.559
我只是禁不住觉得这里需要一些层次，

00:19:44.559 --> 00:19:48.240
您不能解决所有问题并将其放在同一规格的同一层中

00:19:48.240 --> 00:19:55.520
这似乎是他们想要做的，就像这样，这就是为什么

00:19:55.520 --> 00:19:58.880
是的，关注点分离是的，我想所以我主要是想

00:19:58.880 --> 00:20:02.320
像嘿一样安定下来，你们想做杰森·ld，好吧

00:20:02.320 --> 00:20:06.880
很好，我们可以做到，我可以在ipld上做json ld，基本上可以添加

00:20:06.880 --> 00:20:09.520
一个广告上下文，它具有神奇的目的

00:20:09.520 --> 00:20:13.039
并且属性中的内容即使突然之间实际上像是从

00:20:13.039 --> 00:20:18.159
密码学的观点就像突然变得可变一样，这是可变的

00:20:18.159 --> 00:20:21.280
外部字典，这意味着我要做的就是

00:20:21.280 --> 00:20:23.440
一个在中间攻击的人，基本上是在欺骗你

00:20:23.440 --> 00:20:27.039
将签名重新路由到其他字段或空字段

00:20:27.039 --> 00:20:30.640
在许多密码库中，null等于true

00:20:30.640 --> 00:20:36.000
所以像从现在起将会有这么大的呃安全漏洞

00:20:36.000 --> 00:20:40.000
嗯，无论如何，那很好，这将是我的话题

00:20:40.000 --> 00:20:46.480
我的defcon明年开会，但与此同时，这是您如何破解它的方法

00:20:46.480 --> 00:20:50.640
是的，那正是我要做的

00:20:51.760 --> 00:20:55.600
我不知道他们为什么要破坏自己的规格，就像我不那样

00:20:55.600 --> 00:21:00.640
了解标准机构，否，当我实际上警告我

00:21:00.640 --> 00:21:03.840
我就像两年前的三年前一样，他说您确定要这么做吗？

00:21:03.840 --> 00:21:06.640
甚至实际上愿意付钱给我

00:21:06.640 --> 00:21:09.919
支持我这样做，我说不，不，我明白了

00:21:09.919 --> 00:21:12.400
蛋糕人

00:21:12.720 --> 00:21:19.600
著名的最后一句话对，是的，哦，天哪，我的意思是

00:21:19.600 --> 00:21:23.840
我不明白为什么我喜欢我仍然不明白为什么墨水键

00:21:23.840 --> 00:21:27.360
成为某个地方的要求，例如为什么做得这么好

00:21:27.360 --> 00:21:31.520
压实我想压实，我认为确实做到了

00:21:31.520 --> 00:21:33.600
真的不需要压缩，我认为他们正在关注

00:21:33.600 --> 00:21:37.520
他们的员工需要为每个显式命名所有显式名称

00:21:37.520 --> 00:21:40.880
用例担心操他妈的剃须被咬掉

00:21:40.880 --> 00:21:45.919
他妈的地图告诉我关于它的什么

00:21:45.919 --> 00:21:49.760
所以我想我主要是在安定下来，你们想做杰森

00:21:49.760 --> 00:21:53.679
杰森·拉德（Jason ld）很好，我要做一个更坚固的

00:21:53.679 --> 00:21:56.720
理想情况下是因为我主张

00:21:56.720 --> 00:22:01.679
它必须是URI，而不仅仅是URL，基本上

00:22:01.679 --> 00:22:08.000
留下um ipfs冒号斜杠或理想ipld的足迹

00:22:08.000 --> 00:22:10.080
冒号，但你会喜欢生根

00:22:10.080 --> 00:22:14.080
问题就好像您分支一样，因为您知道自己会收到此问题，

00:22:14.080 --> 00:22:16.320
尽可能地命名约定

00:22:16.320 --> 00:22:20.799
我添加了一个中间名，并且您的架构只有第一个和最后一个

00:22:20.799 --> 00:22:24.240
我们在谈论与您谈论的相同的中间名吗？

00:22:24.240 --> 00:22:27.440
但这是更多的根本问题，但是

00:22:27.440 --> 00:22:30.880
在at上下文中，我认为我实际上有一种基本的方法来创建um

00:22:30.880 --> 00:22:35.600
 ipfs或ipld，他们添加联系人，基本上就是现在

00:22:35.600 --> 00:22:41.039
对字典um的不可变引用，它决定了我认为我在

00:22:41.039 --> 00:22:46.640
至少在我的图书馆里，我实际上很满意，但这是

00:22:46.640 --> 00:22:50.080
所以大多数情况下，我只是在处理这种混合媒体类型，我可以

00:22:50.080 --> 00:22:56.159
恩字符串恩字节字符串恩作为键，实际上我把它留在了

00:22:56.159 --> 00:23:01.840
规范，这件事叫做uh cbor ld

00:23:01.840 --> 00:23:05.840
 cbor链接数据，基本上，您描述了一个外部字典，并且

00:23:05.840 --> 00:23:10.240
基本上是一个属性图

00:23:10.240 --> 00:23:15.280
并暗示，或者您知道还有一种算法

00:23:15.280 --> 00:23:20.159
基本上是用魔术对那些地图进行排序的方法

00:23:20.159 --> 00:23:24.400
然后基本上这个是零这个是一个这个

00:23:24.400 --> 00:23:27.760
它基于您的排序算法，但最终还是一样

00:23:27.760 --> 00:23:31.120
这很容易受到伤害，您如何对其进行分类

00:23:31.120 --> 00:23:34.640
您实际上是否获得了正确的外部词典，在这种情况下，您

00:23:34.640 --> 00:23:39.120
可能击中的漏洞

00:23:39.919 --> 00:23:43.440
好吧，只是我很感谢你们听我的bit子

00:23:43.440 --> 00:23:47.840
是的，这听起来像是一场灾难

00:23:47.840 --> 00:23:50.400
是的，我真的很沮丧，因为我实际上终于把它放进了

00:23:50.400 --> 00:23:54.320
带有标签的描述海港的规范，然后专门

00:23:54.320 --> 00:23:58.320
dagsebor与呃cids，我指向标签42

00:23:58.320 --> 00:24:02.159
我说嘿，我们基本上可以做签名

00:24:02.159 --> 00:24:06.799
我们可以用这种方式来做dag cos签名

00:24:06.799 --> 00:24:12.880
密钥ID也是密钥ID的网址，它将指向您并说出您的名字

00:24:12.880 --> 00:24:15.120
实际上可以去获取公钥等

00:24:15.120 --> 00:24:17.760
但这是我坚持的最后一件事，那是他们给我的

00:24:17.760 --> 00:24:21.440
像是两个星期，否则会被拉走

00:24:21.440 --> 00:24:25.919
因为他们想去cr不，我有一个候选版本

00:24:27.039 --> 00:24:30.480
你能为我澄清一些事情吗，因为我不喜欢我不喜欢

00:24:30.480 --> 00:24:36.720
关于所有这里发生的事情的日期大部分是

00:24:36.720 --> 00:24:40.320
挂在他们需要键入所有内容的事实上，并且没有

00:24:40.320 --> 00:24:45.520
像固有的，就像我们没有像

00:24:45.520 --> 00:24:48.720
就像哦，这里是引用此数据的架构

00:24:48.720 --> 00:24:53.200
他们都非常高兴能够使用类似html的链接进行操作

00:24:53.200 --> 00:24:56.799
而且我们没有cid，就没有办法使用cid

00:24:56.799 --> 00:25:00.880
描述一个模式，然后打电话说那是一天

00:25:00.880 --> 00:25:04.960
是什么阻碍了事情的发展，主要是因为实际上

00:25:04.960 --> 00:25:11.120
像这样对ujason ld的依赖，这都是可变的

00:25:11.120 --> 00:25:17.520
um http链接和um，那就是语义网的网络

00:25:17.520 --> 00:25:19.440
分崩离析基本上是因为他们不是

00:25:19.440 --> 00:25:22.559
坚持不懈，他们真的不是乌里斯

00:25:22.559 --> 00:25:25.760
描述了仅仅找到它的标识符的原因

00:25:25.760 --> 00:25:32.799
一件事情，等等，当那个那个UM描述离线时

00:25:32.799 --> 00:25:37.120
那么你的语义本体就不可能有逻辑

00:25:37.120 --> 00:25:41.679
嗯，所以我认为ipld世界已经进行了一些讨论

00:25:41.679 --> 00:25:47.279
以及与rdf模型的对话，我认为甚至

00:25:47.279 --> 00:25:51.360
实际上是为rdf建议的多编解码器

00:25:51.360 --> 00:25:54.720
但挑战在于rdf本质上实际上具有循环，因此

00:25:54.720 --> 00:25:58.880
就我们而言，它引起了一些关注，这不是不是一个a

00:25:58.880 --> 00:26:04.480
 rdf模型是循环rdf模型，因此许多这样的循环实际上具有

00:26:04.480 --> 00:26:07.120
再次是你，你可能会迷失在一个

00:26:07.120 --> 00:26:11.120
就像这个循环中的um，否则他们会改变

00:26:11.120 --> 00:26:15.120
他们是易变的，不是持久的，我的意思是

00:26:15.120 --> 00:26:19.200
他们应该有周期，或者这像是人工制品，因为

00:26:19.200 --> 00:26:23.520
一切都是可变的，他们可能会有周期

00:26:23.520 --> 00:26:27.039
后者他们可以，或者他们应该……他们可以拥有

00:26:27.039 --> 00:26:31.679
他们不应该循环，但很多人都在自我描述你

00:26:31.679 --> 00:26:35.120
基本上你会喜欢这个东西，它说哦，因为我在谈论自己

00:26:35.120 --> 00:26:38.640
为此，它使用片段标识符

00:26:38.640 --> 00:26:43.679
在我自己的文档中描述ID

00:26:45.520 --> 00:26:50.720
所以我记得在讲像是关于单声道的故事，大概一年零一个

00:26:50.720 --> 00:26:55.840
一半以前，他的回答很喜欢，但是它是可变的

00:26:55.840 --> 00:27:00.000
网站消失时会发生什么，就像哦，不，我们发誓每个人都有

00:27:00.000 --> 00:27:05.039
网站在本地缓存了，这似乎不行吗？

00:27:05.039 --> 00:27:08.799
使用静态标识符，那将是

00:27:08.799 --> 00:27:12.400
并喜欢使用cid并称其为是，我想我实际上已经

00:27:12.400 --> 00:27:16.000
建议，就像我实际上所做的像json模式一样

00:27:16.000 --> 00:27:18.880
这很像只是对文档和json的验证

00:27:18.880 --> 00:27:22.320
json模式标识符为

00:27:22.320 --> 00:27:25.279
删除了标识符的文档的哈希

00:27:25.279 --> 00:27:28.320
所以基本上就像你在创建一个新的哈希，但是没关系

00:27:28.320 --> 00:27:30.960
因为您基本上可以自行验证该文档

00:27:30.960 --> 00:27:36.159
是标识符，只是假设是这样，但在这里我可以告诉你分享我的

00:27:36.159 --> 00:27:40.799
屏幕，然后向您显示文档

00:27:40.799 --> 00:27:48.399
嗯，也许给你一个我分享的例子

00:27:48.399 --> 00:27:51.520
这是我创建的seabor部分

00:27:51.520 --> 00:27:55.440
这是um cddl标记语言符号

00:27:55.440 --> 00:27:59.440
嗯，但基本上我所做的是

00:27:59.440 --> 00:28:06.640
嗯，在seabor中打印得很漂亮嗯，基本上就是出口的嗯

00:28:06.640 --> 00:28:10.000
文件基本上只是字符串而已

00:28:10.000 --> 00:28:14.640
这些是文本um，您知道创建的字段带有

00:28:14.640 --> 00:28:21.440
um date timestamp and in the seaboard这可能

00:28:21.440 --> 00:28:24.799
更加简洁的标签

00:28:24.799 --> 00:28:27.760
特定于日期

00:28:28.000 --> 00:28:32.159
和相同的东西，例如公共密钥，所以在这里

00:28:32.159 --> 00:28:37.200
无论标识符是什么，在这里实际上是他们喜欢这样做的地方

00:28:37.200 --> 00:28:40.000
是我实际上认为的e dsa公钥类型

00:28:40.000 --> 00:28:45.279
有一个更好的例子，所以这里基本上是json

00:28:45.279 --> 00:28:49.520
所以嗯，是的，这是数组的验证方法

00:28:49.520 --> 00:28:56.640
这是一个对象，基本上是明确说明类型信息

00:28:56.640 --> 00:29:04.000
然后我想在这个中使用um uh链接，基本上是uh uh

00:29:04.000 --> 00:29:10.840
可能是dag um coz sibor的孩子，因为dag cos a是关于

00:29:10.840 --> 00:29:14.720
它的签名方面

00:29:15.520 --> 00:29:18.799
无论如何，但这实际上是我在其中放置像uh这样的uh标签的地方

00:29:18.799 --> 00:29:24.080
这是一个带有标签42的舒适签名，其字节基本上是

00:29:24.080 --> 00:29:29.200
CID，这就是它所在的位置

00:29:39.120 --> 00:29:43.679
iii。像呃一样不知道任何想法

00:29:43.760 --> 00:29:47.120
我也很孤单，因为就像他们说的那样，没有人真正地

00:29:47.120 --> 00:29:51.120
实现这一点，所以这个方法与dag

00:29:51.120 --> 00:29:58.159
嗯，尽管很简单

00:30:01.120 --> 00:30:05.760
是的，不幸的是，我的意思是我知道有些人正在使用

00:30:05.760 --> 00:30:09.440
乔斯和科塞（Jose and Kosei）以及我们的一些东西，这正在推动

00:30:09.440 --> 00:30:13.760
dag jose cosey对话，但我具体不认识任何人

00:30:13.760 --> 00:30:18.799
做一堆的东西，嗯

00:30:19.840 --> 00:30:24.399
我的意思是不，那是不正确的，所以

00:30:24.799 --> 00:30:28.480
有人把做过的信息放入ipfs

00:30:28.480 --> 00:30:31.919
但我认为他们实际上是将它们放入文件或其他内容中

00:30:31.919 --> 00:30:36.159
看起来像是离子或元素正在使用中

00:30:36.159 --> 00:30:39.679
与一大堆斑点，他们有一个算法要经历，这是

00:30:39.679 --> 00:30:43.919
我认为ipld实际上更优雅地存储了json数据

00:30:43.919 --> 00:30:46.960
而且我认为是的，这是解决方案，也是

00:30:46.960 --> 00:30:50.880
这是我，我真的是想成为所有不变的哈希

00:30:50.880 --> 00:30:54.320
里面没有能力，甚至有

00:30:54.320 --> 00:30:58.240
上下文实际上是不可变的，我想

00:30:58.240 --> 00:31:02.320
只是为了澄清微软人喜欢离子

00:31:02.320 --> 00:31:07.360
我认为人们非常愿意做ipld的事情，我认为他们只是

00:31:07.360 --> 00:31:12.080
并没有真正接触过它，就像exfs只是

00:31:12.080 --> 00:31:15.200
使任何事物四处移动的最简单方法

00:31:15.200 --> 00:31:18.880
嗯，他们以最简单的方式完成了所有工作，然后他们一直在进行调整

00:31:18.880 --> 00:31:21.840
他们已经在制作上了，所以是的，我们指出了他们的方向

00:31:21.840 --> 00:31:25.279
ipld的，他们很喜欢它，所以如果我不感到惊讶

00:31:25.279 --> 00:31:28.240
他们朝那个方向移动

00:31:30.240 --> 00:31:36.159
是的，除此之外，我只是不知道我不知道我在

00:31:36.159 --> 00:31:41.039
嗯，语义网人们之所以这么做，部分原因是因为我浪费了一堆我的

00:31:41.039 --> 00:31:44.880
时间在2000年代，所以我不喜欢

00:31:44.880 --> 00:31:48.480
关于它的一些ptsd或其他东西，但这仅仅是

00:31:48.480 --> 00:31:52.880
我对网络的数据层有这种愿景

00:31:52.880 --> 00:31:58.880
在某些时候，他们不是在网络的数据层上妥协，而是在

00:31:58.880 --> 00:32:02.240
Web语义数据的序列化层

00:32:02.240 --> 00:32:06.799
因此他们对数据库将要存在的想法感到非常满意

00:32:06.799 --> 00:32:09.440
他们将获得孤岛信息，但我们始终

00:32:09.440 --> 00:32:12.720
我们将要拥有呈现所有内容的序列化层

00:32:12.720 --> 00:32:15.679
以语义方式将这些信息发布到网络上，以使人们获得更多

00:32:15.679 --> 00:32:19.519
从中有价值，我不认为那个模型是

00:32:19.519 --> 00:32:22.000
真的将重塑网络，这不是真正的数据

00:32:22.000 --> 00:32:24.640
网络层，如果您要构建真实的数据层并构建真实的

00:32:24.640 --> 00:32:27.440
数据结构，数据库和文件系统以及这些东西

00:32:27.440 --> 00:32:30.640
然后需要更稳定的结构

00:32:30.640 --> 00:32:33.600
比起这些具有可变链接的json文档

00:32:33.600 --> 00:32:37.519
在他们那可以他妈的循环像那样疯狂

00:32:37.519 --> 00:32:39.840
你只是不能，不能建立稳定的结构

00:32:39.840 --> 00:32:44.240
嗯，但是如果你生活在那个世界里，

00:32:44.240 --> 00:32:46.720
他们在那个世界上真的很舒服，那么很难拥有这些

00:32:46.720 --> 00:32:51.840
我不知道的对话，但是他们很难

00:32:51.840 --> 00:32:54.799
让你喜欢我也许我

00:32:54.799 --> 00:32:59.120
误会，但只要他们给你一个uri

00:32:59.120 --> 00:33:02.799
只要他们每次有一个可变链接，就可以将其替换为

00:33:02.799 --> 00:33:06.000
不变的链接，然后您就可以致电

00:33:06.000 --> 00:33:11.360
在你的小小世界里，他们所有的东西都是无效的

00:33:11.360 --> 00:33:15.279
只要你的东西是他们的一部分，那还不够吗

00:33:15.279 --> 00:33:18.960
是的，所以它仍然进入这个嗯

00:33:18.960 --> 00:33:22.159
一个命名问题，所以我想我在这里放了一些东西

00:33:22.159 --> 00:33:25.840
嗯

00:33:26.799 --> 00:33:30.080
让我们看看你是否能读懂

00:33:34.159 --> 00:33:38.080
哦，它可能格式不正确，但基本上在这里，我们说它是一个对象

00:33:38.080 --> 00:33:42.640
这是did文档的一部分，它是一种验证方法

00:33:42.640 --> 00:33:46.559
并且有一个数组，它是对象，而那个对象是

00:33:46.559 --> 00:33:51.200
在这种情况下，它是一个验证密钥，只是通用类型，它有一个控制器

00:33:51.200 --> 00:33:54.320
现在我说这是公钥

00:33:54.320 --> 00:33:58.720
假设是以32为基数的编码

00:33:58.720 --> 00:34:04.399
链接CID，它是ed255公共编解码器，基本上遵循

00:34:04.399 --> 00:34:07.679
实际上，公共字节基本上是内联的

00:34:07.679 --> 00:34:13.919
很抱歉，如果很难阅读是的

00:34:15.280 --> 00:34:21.119
哦，是的，因为它是呃，所以这是它的伪造版本

00:34:21.119 --> 00:34:23.839
嗯

00:34:29.440 --> 00:34:33.760
我们去了，所以我认为这最终只是为了命名它

00:34:33.760 --> 00:34:36.320
自行车脱落，这是我们有一些特别

00:34:36.320 --> 00:34:42.639
此um类型的名称以及此公钥的名称

00:34:42.639 --> 00:34:48.720
基本上想说的是

00:34:48.720 --> 00:34:55.839
这是一个公钥um编解码器2020

00:34:55.839 --> 00:35:03.839
还有特殊目的的东西

00:35:04.560 --> 00:35:08.800
嗯，基本上就像是通过某种方式将其注册到注册表中

00:35:08.800 --> 00:35:14.480
那说哦，接下来将是这个类型的um，我想但是

00:35:14.480 --> 00:35:18.000
成为一场永无休止的战斗，要真正保持和保持

00:35:18.000 --> 00:35:21.760
这些注册表是最新的，谁坚持认为这不是真正的一种

00:35:21.760 --> 00:35:27.839
在这种情况下，它也是非常集中的

00:35:27.839 --> 00:35:31.839
在at上下文中描述

00:35:33.359 --> 00:35:36.560
好吧，我想我终于明白了，基本上

00:35:36.560 --> 00:35:41.680
键名定义了什么类型，并且您想拥有其他类型

00:35:41.680 --> 00:35:45.040
比他们想要的地方要多，所以他们说你需要一个不同的地方

00:35:45.040 --> 00:35:49.119
名称，因为它的类型不一样

00:35:49.119 --> 00:35:54.079
可以在广告上下文中完成，所以我想像um

00:35:54.560 --> 00:36:00.720
这样就可以了，我实际上想拥有这个

00:36:00.720 --> 00:36:05.280
作为ipld，实际上不，这将是嗯，嗯

00:36:05.280 --> 00:36:08.160
因为它必须是可互操作的，所以他们不让我做

00:36:08.160 --> 00:36:14.560
像这样用cid链接对象，所以我实际上有

00:36:14.560 --> 00:36:18.800
将其创建为必须的字符串并

00:36:18.800 --> 00:36:22.800
嗯，就像我现在建议的那样

00:36:22.800 --> 00:36:30.079
支持是ipfs，但我认为ipld然后实际上是cid

00:36:31.760 --> 00:36:34.960
然后在该文档中，上下文描述了

00:36:34.960 --> 00:36:40.000
这些公钥多编解码器2020是什么

00:36:40.000 --> 00:36:45.920
然后有一个人类的描述，然后可以将其解析并

00:36:48.320 --> 00:36:52.160
哎呀，你明白了

00:36:53.359 --> 00:36:56.400
那有点合理

00:37:01.920 --> 00:37:05.200
但是大多数情况下，这只是经历，实际上他们必须要

00:37:05.200 --> 00:37:08.480
在seabor中所有这些的例子，我就像哇

00:37:08.480 --> 00:37:12.079
c板很好，我们不需要这样做inte键是

00:37:12.079 --> 00:37:16.000
很适合压缩，但让我们开始吧

00:37:16.000 --> 00:37:20.880
协议，但现在像jws一样有其自己的公钥机制

00:37:20.880 --> 00:37:28.000
ipld会有自己的机制呃cwts实际上会有自己的机制

00:37:28.000 --> 00:37:33.440
pem那些公钥pem uh编码将拥有自己的一个

00:37:33.440 --> 00:37:37.839
对于x509

00:37:39.839 --> 00:37:42.960
而且大部分是我降落的地方，基本上我必须

00:37:42.960 --> 00:37:48.880
将它们创建为json ld describe description或将其添加到注册表

00:37:48.880 --> 00:37:51.599
他们有特殊的意义，因为

00:37:51.599 --> 00:38:00.560
链接将是一个cid um，而这个cid我认为是um

00:38:02.000 --> 00:38:06.800
是的，让我再次分享我的屏幕

00:38:08.160 --> 00:38:12.400
所以一个快速的问题是我什么我不明白

00:38:12.400 --> 00:38:19.599
不是您可以解释的上下文的全部要点

00:38:19.599 --> 00:38:23.599
内容与我的意思不同

00:38:23.599 --> 00:38:27.520
所以你有上下文，所以拥有相同的上下文是没有意义的

00:38:27.520 --> 00:38:32.640
键名，因为上下文定义了如何解释键名

00:38:32.640 --> 00:38:41.680
那么为什么特定于上下文的键名是这个问题呢？很抱歉

00:38:41.680 --> 00:38:45.280
是的，所以主要是，嗯，有点

00:38:45.280 --> 00:38:48.560
试图给海洋煮沸，就像只是命名事物一样

00:38:48.560 --> 00:38:52.800
我指责的是这种密码go，基本上就像你在

00:38:52.800 --> 00:38:56.160
您正在调用它的名称，它赋予了它生命，所以我认为

00:38:56.160 --> 00:38:59.760
但这就是全部，就像您基本上只是在声明它一样，因为

00:38:59.760 --> 00:39:01.680
宪章说他们不是

00:39:01.680 --> 00:39:04.240
允许创建新的密码算法

00:39:04.240 --> 00:39:08.520
这就是它变得有趣的地方，例如声明es256

00:39:08.520 --> 00:39:13.359
 kr定义恢复签名恢复

00:39:13.359 --> 00:39:19.040
以太坊签名的机制，所以这基本上是新事物

00:39:19.040 --> 00:39:21.839
是在以太坊世界里，但基本上

00:39:21.839 --> 00:39:24.560
它会额外恢复签名

00:39:24.560 --> 00:39:28.400
未在iana中注册的字节，不是

00:39:28.400 --> 00:39:33.599
在jwts或java json网络签名中注册的，所以嗯

00:39:33.599 --> 00:39:38.480
基本上是这个新事物，嗯，嗯

00:39:38.480 --> 00:39:42.320
所以，但是他们通过命名事物来解决这个问题

00:39:42.320 --> 00:39:48.400
然后嗯，这种通过加密获得敏捷性的能力

00:39:48.400 --> 00:39:51.359
说有验证方法

00:39:51.359 --> 00:39:56.960
密钥类型仅用于身份验证，不用于

00:39:56.960 --> 00:40:01.760
例如用于签署证书

00:40:05.200 --> 00:40:10.480
我知道我花太多时间谈论它

00:40:10.480 --> 00:40:14.960
但是我很感谢你们大多数听我bit子的家伙

00:40:19.119 --> 00:40:22.480
但是这个底部的例子基本上是我，这基本上就是

00:40:22.480 --> 00:40:27.119
密钥值对，因此公共密钥多编解码器中的cid

00:40:27.119 --> 00:40:31.680
基本上只是描述曲线的关键类型

00:40:31.680 --> 00:40:36.560
在这种情况下，和的x坐标

00:40:36.839 --> 00:40:39.839
ed25519

00:40:41.760 --> 00:40:45.520
在这种情况下，我只是在json中这样做，因此实际上没有理由

00:40:45.520 --> 00:40:49.359
这样做基本上可以基本上是

00:40:51.040 --> 00:40:54.240
做得更简单，更优雅，但是我们必须

00:40:54.240 --> 00:40:57.599
就语义而言达成一致

00:40:57.599 --> 00:41:04.000
的，如果我只是在此给曲线ed25519的对象

00:41:04.000 --> 00:41:07.920
像这样的信息，我们需要知道那是一个

00:41:07.920 --> 00:41:10.960
公钥格式

00:41:17.440 --> 00:41:22.319
嗯嗯嗯嗯[音乐]

00:41:22.319 --> 00:41:26.960
人们还有什么要讨论的吗？

00:41:26.960 --> 00:41:31.920
或只是提供更新或数字

00:41:32.400 --> 00:41:36.560
我的意思是，如果人们很酷，我可以告诉他们一些关于我的事情

00:41:36.560 --> 00:41:42.079
我环顾四周是什么导致我发送该消息的原因

00:41:42.079 --> 00:41:47.280
呃，你知道你可能会有替代证明

00:41:47.280 --> 00:41:53.680
除了只是散列什么是um的数据

00:41:53.680 --> 00:41:57.280
基本上只有很多内容已经存在

00:41:57.280 --> 00:42:03.440
在网络上，人们发现人们已经通过其他方式找到了

00:42:03.440 --> 00:42:06.400
他们通过网站找到他们的正确机制

00:42:06.400 --> 00:42:10.960
不管在哪里，甚至在哪里

00:42:10.960 --> 00:42:16.720
已经像文件的256张照片一样，我无法知道如何

00:42:16.720 --> 00:42:22.400
在ipfs um上找到它

00:42:22.400 --> 00:42:27.280
同样，我们拥有一些我们称之为的东西

00:42:27.280 --> 00:42:33.359
我们有一些与我们完全不兼容的编解码器

00:42:33.359 --> 00:42:37.760
你知道git对象很高兴成为100兆，但是

00:42:37.760 --> 00:42:41.280
如果我们拒绝发送超过兆的块，则

00:42:41.280 --> 00:42:46.000
事情停止了，不一定有什么容易的事

00:42:46.000 --> 00:42:50.079
回答这个问题，但是即使你要经历所有的事情

00:42:50.079 --> 00:42:54.880
寻找类似替代加密证明的工作

00:42:54.880 --> 00:42:58.000
使这个东西自我证明说

00:42:58.000 --> 00:43:03.440
这个旧事物也可以表示为这个新事物

00:43:03.440 --> 00:43:07.200
我不知道我们将其粘贴在堆栈中的什么位置

00:43:07.200 --> 00:43:12.000
您可以将其粘贴为特殊的多哈希，也可以将其粘贴为

00:43:12.000 --> 00:43:18.079
编解码器，您可以将其粘贴为adl尚不清楚这些东西在哪里

00:43:18.079 --> 00:43:22.800
会适合你，所以我想这个问题可以解决

00:43:22.800 --> 00:43:27.680
如果我有一个很长的自我认证的东西，那么

00:43:27.680 --> 00:43:31.440
不是散列，而是类似256位散列的东西

00:43:31.440 --> 00:43:36.079
但是比我们打电话给我们的感觉还长的时间

00:43:36.079 --> 00:43:42.160
我们有什么兴趣来代表这些东西，以及如何

00:43:42.160 --> 00:43:45.359
我们考虑这样做

00:43:47.280 --> 00:43:51.119
他们需要成为标识符的原因是什么

00:43:51.119 --> 00:43:55.839
我发现我去了ubuntu网站我发现了iso的256张照片

00:43:55.839 --> 00:44:00.000
我想知道ipfs上是否存在数据

00:44:00.000 --> 00:44:05.119
好的，好的，是的，嗯

00:44:07.680 --> 00:44:10.720
所以我不明白什么是密码学证明

00:44:10.720 --> 00:44:17.920
被断言是我们可以做的原始

00:44:17.920 --> 00:44:22.319
我们想做的事情我想这里是两个例子

00:44:22.319 --> 00:44:26.720
两个例子，我给你一个神奇的证明，证明

00:44:26.720 --> 00:44:30.640
那个你拍了256个文件

00:44:30.640 --> 00:44:34.480
等于

00:44:34.960 --> 00:44:40.079
cid引用的所有叶块的256个镜头

00:44:40.079 --> 00:44:44.160
对，就像魔术一样，另一种方法是

00:44:44.160 --> 00:44:48.640
听起来像我想要的东西，但听起来却不像

00:44:48.640 --> 00:44:53.119
嗯，我怎么组成它，这东西要花多少钱

00:44:53.119 --> 00:44:57.040
有人要撒谎有多难

00:44:57.040 --> 00:45:00.400
为了做到这一点与我想要做的相反

00:45:00.400 --> 00:45:03.839
就像我该如何防止我不了解如何撰写任何此类内容，或

00:45:03.839 --> 00:45:07.599
如果这个原语甚至存在的很好，也许这就像一个

00:45:07.599 --> 00:45:12.400
有点容易，有点像它有问题，但喜欢

00:45:12.400 --> 00:45:16.480
我想你可以将您的思想包扎更多

00:45:16.480 --> 00:45:21.920
我可以慢慢地建造我可以像另一棵梅克尔树一样建造

00:45:21.920 --> 00:45:25.920
而我正在慢慢地将这件事一直展开到根源

00:45:25.920 --> 00:45:30.319
到叶块，我还包括中间

00:45:30.319 --> 00:45:36.160
射出256个散列值正确，因为该事物是呃，该事物是一个

00:45:36.160 --> 00:45:40.240
奇迹般的该死的守卫建筑，我可以将这些东西粘合在一起

00:45:40.240 --> 00:45:44.640
而且你知道暴露中间状态不是很好

00:45:44.640 --> 00:45:49.440
但您可能可以使用它来获得一些信心，

00:45:49.440 --> 00:45:54.640
这个新的数据代表旧数据中的相同数据

00:45:56.319 --> 00:46:00.240
所以现在我有两个引用相同内容的cid

00:46:00.240 --> 00:46:04.560
只要我愿意对它有某种了解

00:46:04.560 --> 00:46:08.560
并不意味着相同的dag而是相同的叶子节点粘合在一起，因为我有

00:46:08.560 --> 00:46:12.960
对我来说很重要的上下文定义

00:46:13.200 --> 00:46:17.119
对，我相信有人可以进行这样的哈希运算，然后产生

00:46:17.119 --> 00:46:23.680
这样的树嗯，然后我相信你可以撰写另一个文件

00:46:23.680 --> 00:46:27.359
指这两个哈希，然后我当然可以哈希一下

00:46:27.359 --> 00:46:32.000
因为我可以哈希任何东西，而这始终是我们拥有的原始数据

00:46:32.000 --> 00:46:35.359
但我不明白该文件应如何让任何人

00:46:35.359 --> 00:46:39.920
否则，请相信我的主张，就像我只是散列了我所做的这个随机的屁股主张

00:46:39.920 --> 00:46:46.880
对，所以我不喜欢我是否要查找ii

00:46:46.880 --> 00:46:50.400
并在我说嘿有人做广告时做广告

00:46:50.400 --> 00:46:55.119
嗯，有人用sha256哈希有这个东西吗

00:46:55.119 --> 00:47:00.720
他们回应，他们说，嗯，我确实做到了这一点

00:47:00.720 --> 00:47:03.839
dag，在这里我提交了这个证明

00:47:03.839 --> 00:47:10.480
表明，这个嗯这一半的dag

00:47:10.480 --> 00:47:13.359
有喜欢

00:47:15.040 --> 00:47:21.359
这一半的dag需要部分

00:47:21.359 --> 00:47:26.400
就像中间的哈希，然后你知道这一半就需要

00:47:26.400 --> 00:47:30.480
这些，我可以用相同的方式将它们粘合在一起

00:47:30.480 --> 00:47:34.960
嗯，就像我可以尝试我明白这很难描述

00:47:34.960 --> 00:47:38.000
我可以尝试将其更正式地写出来，以便我们讨论

00:47:38.000 --> 00:47:42.000
后来，但重点是，即使这种魔术，即使建设

00:47:42.000 --> 00:47:45.599
存在权，它需要一个可能，它可能需要

00:47:45.599 --> 00:47:50.160
像梅格来代表我在哪里塞这东西，即使它

00:47:50.160 --> 00:47:53.680
应该存在的很好，但我认为就像用例一样

00:47:53.680 --> 00:47:55.599
对于您想去的地方真的很重要

00:47:55.599 --> 00:47:59.440
坚持下去，就像为什么要这样做，实际上在以下方面确实很重要

00:47:59.440 --> 00:48:03.280
您想将其放在堆栈中的位置，我认为原因之一

00:48:03.280 --> 00:48:06.720
为什么我在这方面有点困难

00:48:06.720 --> 00:48:10.800
嗯，如果您要从中构建某些内容，则有更好的方法来执行此操作

00:48:10.800 --> 00:48:15.119
从头开始，这样的内在含义就是

00:48:15.119 --> 00:48:18.800
如果您正在执行此操作，那么您正在执行此操作以与某种

00:48:18.800 --> 00:48:23.119
就像一群人一样拥有这些同位素

00:48:23.119 --> 00:48:26.640
他们身上有这种影子，所以我们想与

00:48:26.640 --> 00:48:30.880
像所有这些外部系统或您所知道的

00:48:30.880 --> 00:48:34.079
那些存储系统或它们可能是的任何东西，所以我们构建了这个

00:48:34.079 --> 00:48:37.920
将它们桥接在一起的方法，因为如果您只是这样做的话

00:48:37.920 --> 00:48:40.400
从头开始，如果您只是在建立一个用例，例如

00:48:40.400 --> 00:48:44.160
嘿，我希望拥有部分内容的人能够分享它，我想要

00:48:44.160 --> 00:48:48.000
能够知道他们什么时候基本拥有相同的数据，如果

00:48:48.000 --> 00:48:52.960
您正在使用fbl嗯无字节的东西，您可以重复使用每个

00:48:52.960 --> 00:48:56.559
字节列表中的部分非常容易，然后您就有了哈希

00:48:56.559 --> 00:49:00.240
对于它的每个部分，所以您基本上喜欢

00:49:00.240 --> 00:49:04.400
具有理想的散列值，可用于验证数据中各部分的内容

00:49:04.400 --> 00:49:07.280
网络，而无论您将其从哪里拉出来的任何人都不必

00:49:07.280 --> 00:49:11.040
在此之上映射一些外部上下文，然后为一些重建一个哈希

00:49:11.040 --> 00:49:14.559
就像随机表示的数据片段一样，

00:49:14.559 --> 00:49:17.359
一种更好的方法来利用我们已经拥有的原语

00:49:17.359 --> 00:49:19.760
嗯，所以如果您正在构建您正在谈论的内容，它将

00:49:19.760 --> 00:49:22.240
字面上是因为像哦，人们已经有了这个iso

00:49:22.240 --> 00:49:25.680
 iso，他们已经通过某种哈希将其安置

00:49:25.680 --> 00:49:29.440
嗯，但是即使是在达成会议预先协议的情况下，也不需要

00:49:29.440 --> 00:49:33.760
就像预先达成协议一样，让我说我走了

00:49:33.760 --> 00:49:38.160
恩，我不知道npm有一个清单

00:49:38.160 --> 00:49:41.599
列出了他们分发的所有二进制文件的哈希值

00:49:41.599 --> 00:49:48.720
是的，但我不是，我不能说服所有人，我不能说服所有人

00:49:48.720 --> 00:49:54.640
在npm上发布的um还发布了ipfs哈希

00:49:54.640 --> 00:50:01.119
和bi不能说服我，我不能说服npm喜欢

00:50:01.119 --> 00:50:04.720
一切然后将ipfs哈希转储在那里

00:50:04.720 --> 00:50:08.880
我的意思是，您信任npm，而您

00:50:08.880 --> 00:50:12.400
因此，请相信此哈希是您要查找的文件

00:50:12.400 --> 00:50:15.839
有没有更有效的方法可以像点对点的方式找到

00:50:15.839 --> 00:50:18.960
这件事是对的，但是你现在在说什么

00:50:18.960 --> 00:50:23.440
是内置的，您正在为要构建的分布式网络构建google

00:50:23.440 --> 00:50:26.240
您正在建立元数据索引的索引

00:50:26.240 --> 00:50:29.839
其他人都在用这些标签做些什么

00:50:29.839 --> 00:50:34.160
就像这样有效

00:50:34.160 --> 00:50:39.119
您知道ipfs上的Google for npm，就像您只是索引一些索引一样

00:50:39.119 --> 00:50:42.640
这些结构内部存在的数据，以便您可以

00:50:42.640 --> 00:50:45.920
就像访问实际的cid，然后他们就可以将数据从

00:50:45.920 --> 00:50:50.240
网络（不受信任的权利除外）

00:50:50.240 --> 00:50:54.720
就像我们为什么没有块大小的原因一样

00:50:54.720 --> 00:50:57.760
技嘉是这样，所以我不必下载超过一百万的东西

00:50:57.760 --> 00:51:00.240
不知道是垃圾然后禁止码头

00:51:00.240 --> 00:51:05.280
是的，其他类似的方法，哦，我只是在宣传这样的

00:51:05.280 --> 00:51:08.800
顺便说一下，这个图恰好等于

00:51:08.800 --> 00:51:12.800
我发誓100 GB的文件不会这样做，因为我必须下载

00:51:12.800 --> 00:51:16.800
整个东西，然后将其哈希以查看是否匹配

00:51:17.599 --> 00:51:24.400
是的，我的意思是我知道你可以再做一次，就像我一直在努力

00:51:24.400 --> 00:51:29.760
时间，因为像我知道这些证明可以做什么

00:51:29.760 --> 00:51:33.359
但是它们的用例太窄了

00:51:33.359 --> 00:51:35.680
没有真正了解他们正在使用什么，我很难

00:51:35.680 --> 00:51:40.800
弄清楚我们适合它的时间，我想发表一个比

00:51:40.800 --> 00:51:45.200
并要求更多信息，我不明白这些证明是做什么的

00:51:45.200 --> 00:51:48.839
证明一词已被使用，对我而言，这极具魔力

00:51:48.839 --> 00:51:54.240
对话，我想设置这个

00:51:54.240 --> 00:51:58.400
信任是这项权利的一部分，对拒绝服务的信任是其中的一部分

00:51:58.400 --> 00:52:01.599
但是我不知道什么样的证明可以给我这个

00:52:01.599 --> 00:52:07.200
我想要的东西，我已经听过其他人在我们的

00:52:07.200 --> 00:52:11.119
外围说，例如，哦，zk snarks可以做我这个神奇的事情

00:52:11.119 --> 00:52:15.040
绝对想要，这就是信息量

00:52:15.040 --> 00:52:18.400
我从提出该要求的人那里收到的

00:52:18.400 --> 00:52:24.160
嗯，如果没有更详细的证据，我不相信

00:52:24.160 --> 00:52:28.319
这是一个非常不希望的事，我不相信

00:52:28.319 --> 00:52:30.839
它没有很多详细的内容

00:52:30.839 --> 00:52:36.559
证明是的，所以我不是我可以尝试写

00:52:36.559 --> 00:52:39.359
多一些我所熟悉的事物的想法

00:52:39.359 --> 00:52:44.400
反对我想在密码学方面需要帮助的事情

00:52:44.400 --> 00:52:48.480
机制是有道理的，但就证明的定义而言

00:52:48.480 --> 00:52:53.680
我指的是我想要的一种方法

00:52:53.680 --> 00:52:58.400
以特定的解释证明陈述

00:52:58.400 --> 00:53:02.640
这两个图表的相关数据

00:53:02.640 --> 00:53:06.000
等同于我，我想要这样一个

00:53:06.000 --> 00:53:10.559
这样的声明可以通过在以下位置下载不超过1兆字节来解释

00:53:10.559 --> 00:53:14.079
在知道整个事情都是垃圾之前的一段时间

00:53:14.079 --> 00:53:17.760
这些是我的两个要求，我不知道您是否一定能做到

00:53:17.760 --> 00:53:21.680
一兆字节，但就像假装种子文件一秒钟一样

00:53:21.680 --> 00:53:27.359
从字面上说是蛇人权利

00:53:27.359 --> 00:53:30.480
就像这里是文件的所有切片，这是它们的所有哈希

00:53:30.480 --> 00:53:34.960
然后，如果您要求人们提供该文件，他们就像哦，是的，我有我

00:53:34.960 --> 00:53:38.000
具有不同的数据结构这是一些数据

00:53:38.000 --> 00:53:42.400
只要您在torrent文件中获得每条数据

00:53:42.400 --> 00:53:46.400
您可以重建并重新哈希以找出它是否与这些哈希值中的每个哈希值匹配

00:53:46.400 --> 00:53:48.640
正确的

00:53:48.800 --> 00:53:52.960
然后它的破损文件将小于一个兆，以下载证明

00:53:52.960 --> 00:53:57.040
然后您将拥有足够的数据，是的，我的意思是您可能要

00:53:57.040 --> 00:53:59.920
下载多于一个的数据1兆字节的数据

00:53:59.920 --> 00:54:05.040
从人那里来，但是如果有的话，我们会打电话给他们

00:54:05.040 --> 00:54:08.640
让我们说整个事情有点像您知道滚动哈希

00:54:08.640 --> 00:54:11.760
在这里我可以像将它们加在一起一样将它们加在一起

00:54:11.760 --> 00:54:16.559
你知道我是否以正确的顺序添加它们，它们加起来就是正确的哈希值

00:54:16.559 --> 00:54:20.000
对，然后确定我能做到，你可以给我一个洪流文件，

00:54:20.000 --> 00:54:23.040
表现出子事物，我以正确的顺序将它们加起来

00:54:23.040 --> 00:54:26.880
有效，但是我们的原始函数却不太像

00:54:26.880 --> 00:54:29.520
洪流中没有每一个子事物

00:54:29.520 --> 00:54:33.839
文件中有一个散列，它将文件分解为

00:54:33.839 --> 00:54:38.240
每个哈希值，因此对于每个切片，您都会有一堆哈希值

00:54:38.240 --> 00:54:40.480
文件，那些将不完全匹配

00:54:40.480 --> 00:54:44.079
就像s文件的unix一样，但是您可以下载

00:54:44.079 --> 00:54:47.280
该文件的unix，然后将其散列并散列，然后

00:54:47.280 --> 00:54:53.119
看看它是否与此哈希匹配，但它们与我下车的东西不匹配

00:54:53.119 --> 00:54:59.040
就像我的意思是从地方来的，是的，这就是你

00:54:59.040 --> 00:55:02.880
知道我是否要去随机的地方，我喜欢这些反病毒人员之一

00:55:02.880 --> 00:55:09.839
而且我知道他们已经发布了该文件的256张照片是不错的

00:55:09.839 --> 00:55:14.480
好的，很酷，所以唯一的标识符是基于内容的，而不是基于网站的

00:55:14.480 --> 00:55:19.040
我拥有的这东西是整个文件的sha-256

00:55:19.040 --> 00:55:22.640
这就是我所拥有的，我需要以某种方式将其转变为

00:55:22.640 --> 00:55:26.640
我可以在对等网络上搜索的东西

00:55:26.640 --> 00:55:31.680
我们只剩下两分钟的会议时间，以防万一

00:55:31.680 --> 00:55:39.760
有人还有别的机会，或者我也看到了新面孔，所以

00:55:39.760 --> 00:55:43.359
万一有人想很快地自我介绍

00:55:43.359 --> 00:55:49.200
在会议结束时，对不起，我较早之前的意思是

00:55:49.200 --> 00:55:55.839
嗨，你能听到我吗，是的，所以我实际上是

00:55:55.839 --> 00:56:01.599
麻省理工学院的人类学研究中心，我不是一个人，但是我一直在追随

00:56:01.599 --> 00:56:04.480
旨在以某种方式下放权力的项目

00:56:04.480 --> 00:56:07.680
网络和嗯，我来了，每个人都告诉所有人

00:56:07.680 --> 00:56:12.559
我可能告诉过我的人，而我和大学认识的人

00:56:12.559 --> 00:56:16.559
您的项目我决定先参加您的会议，这是

00:56:16.559 --> 00:56:20.000
对于一个不懂编码但又很懂的人来说，很难遵循

00:56:20.000 --> 00:56:23.280
我一直在努力，基本上就像是

00:56:23.280 --> 00:56:26.559
听一门你不知道的新语言我正在尝试学习

00:56:26.559 --> 00:56:31.440
只是听着就可以了，但是嗯，是我

00:56:31.440 --> 00:56:35.920
谢谢，是的，我也不得不说，特别是今天的这次会议是

00:56:35.920 --> 00:56:39.040
像往常一样极端，我希望

00:56:39.040 --> 00:56:43.200
会议会更容易跟进，以防万一您

00:56:43.200 --> 00:56:47.040
想在下周再次鸣响，请随时加入

00:56:47.040 --> 00:56:49.920
再次，嗯，这周可能会更容易

00:56:49.920 --> 00:56:53.599
真的像是的，谢谢您向所有人开放

00:56:53.599 --> 00:57:01.760
公众感谢嗯非常感谢嗯好吧

00:57:01.760 --> 00:57:05.440
嗯，我们在会议结束时

00:57:05.440 --> 00:57:08.480
谢谢大家参加。

00:57:08.480 --> 00:57:13.839
下周再见

