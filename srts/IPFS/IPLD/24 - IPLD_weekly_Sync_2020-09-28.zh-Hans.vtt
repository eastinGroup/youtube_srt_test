WEBVTT
Kind: captions
Language: zh-Hans

00:00:09.360 --> 00:00:13.679
欢迎大家参加本周的ipld同步会议

00:00:13.679 --> 00:00:21.039
2020年9月28日，每周我们都会讨论

00:00:21.039 --> 00:00:23.519
我们在上周所做的，并计划去做

00:00:23.519 --> 00:00:30.720
并讨论别人可能有的其他项目，所以我从

00:00:30.720 --> 00:00:35.200
我自己又从铁锈一面的消息来了

00:00:35.200 --> 00:00:39.760
所以我在过去几年中谈论的主要是多阴影的锈

00:00:39.760 --> 00:00:42.399
几周终于合并了，这有点像

00:00:42.399 --> 00:00:46.719
大重构现在有点回到它的意义了

00:00:46.719 --> 00:00:53.120
最初是在第一个重构中，而在最后一个，但最后还是现在，如果您想

00:00:53.120 --> 00:00:58.079
将它集成到当前的rast cd um中，这非常好，因为它确实

00:00:58.079 --> 00:01:01.600
只是很小的变化，我认为

00:01:01.600 --> 00:01:06.159
好迹象，是的，我没事了

00:01:06.159 --> 00:01:13.520
嗯，这使我们更接近上游并入生锈的multihash

00:01:13.520 --> 00:01:17.600
而我目前所从事的工作是

00:01:17.600 --> 00:01:21.520
尽管这个重构现在降落了

00:01:21.520 --> 00:01:24.640
分配的，您需要做的是定义自己的

00:01:24.640 --> 00:01:27.920
您需要定义带有散列的代码表

00:01:27.920 --> 00:01:34.880
放样位置实际有多大，我们决定将其放置

00:01:35.119 --> 00:01:38.560
明确的，所以您真的必须设置一些值

00:01:38.560 --> 00:01:41.680
但仍然可能是您使用的哈希器会产生

00:01:41.680 --> 00:01:45.920
更大的数字，然后很明显，您的工作将陷入恐慌

00:01:45.920 --> 00:01:50.399
嗯，计划是在编译时说出更好的错误报告，嘿

00:01:50.399 --> 00:01:56.399
嗯，您的一种散列可能想要分配比您更多的散列

00:01:56.399 --> 00:02:01.520
已经指定了，所以您可能要增加它的数量

00:02:01.520 --> 00:02:04.479
我们不自动执行此操作的原因是

00:02:04.479 --> 00:02:09.440
可悲的是，所有这些都在生锈，没有类型，所以它是

00:02:09.440 --> 00:02:16.640
纯粹是基于语法，这有点令人恐惧，但我希望人们

00:02:16.640 --> 00:02:20.480
如果他们以正常方式使用它，一切都会好起来的

00:02:20.480 --> 00:02:25.920
而且他们甚至都没有注意到，这只是类型事物中的一种语法事物

00:02:25.920 --> 00:02:30.319
是的，至少它应该可以使人们感到顺畅

00:02:30.319 --> 00:02:33.920
实施一些事情和其他需要做的事情

00:02:33.920 --> 00:02:37.760
发生在我们可以合并到上游的最后一个多显示器3中之前

00:02:37.760 --> 00:02:42.239
最终由社区成员启动的支持

00:02:42.239 --> 00:02:46.640
所以我只是在做评论，但它正在慢慢到达那里

00:02:46.640 --> 00:02:52.720
嗯，嗯，其他事情是，接下来我要研究

00:02:52.720 --> 00:02:56.720
一些很棒的东西嗯，我会更详细地介绍

00:02:56.720 --> 00:03:01.200
下个礼拜我想知道我更多的时候

00:03:01.200 --> 00:03:09.440
我名单上的下一个是丹妮尔·酷（Danielle Cool），所以我继续做汉普特

00:03:09.440 --> 00:03:12.640
我花了很多时间尝试更新架构和代码

00:03:12.640 --> 00:03:16.480
哈希图文档中的Rods模式生成

00:03:16.480 --> 00:03:20.319
现在完成了，嗯，我们还讨论了许多可以简化的方法

00:03:20.319 --> 00:03:24.879
该模式主要是那些已经考虑过的东西嗯

00:03:24.879 --> 00:03:28.239
但这可能对您了解结局很有帮助

00:03:28.239 --> 00:03:33.040
在我编写更多代码之前，您知道在这些方面取得了一些共识

00:03:33.040 --> 00:03:37.680
也很好，我也把书呆子剪成一个样子

00:03:37.680 --> 00:03:41.920
莲花一周前发生的json恐慌或

00:03:41.920 --> 00:03:44.879
所以事实证明我非常

00:03:44.879 --> 00:03:46.799
对此感到困惑，因为我开始研究它

00:03:46.799 --> 00:03:50.879
上周三星期三开始，我最初以为这只是一个json包错误

00:03:50.879 --> 00:03:54.640
但今天我在进一步研究它，到现在为止，我认为

00:03:54.640 --> 00:03:58.400
某个地方有语言错误，因为方法

00:03:58.400 --> 00:04:03.760
没有得到持续的提升，这很可怕，因为莲花

00:04:03.760 --> 00:04:07.360
项目隐藏了一种方法并替换为

00:04:07.360 --> 00:04:10.879
另一种方法，但那只是行不通

00:04:10.879 --> 00:04:14.560
替换无法按预期工作，所以如果有人愿意，我会弄虚作假。

00:04:14.560 --> 00:04:18.479
看一下，我也帮助了进行中的评论

00:04:18.479 --> 00:04:21.840
奇迹dag um，所以我想我会遵循大多数杆

00:04:21.840 --> 00:04:24.960
在那里做，所以希望我的评论对您有所帮助

00:04:24.960 --> 00:04:28.000
最后似乎每个人都还好

00:04:28.000 --> 00:04:32.160
和我一起更新，采用go multi编解码器

00:04:32.160 --> 00:04:35.520
回购，然后将其替换为生成的一堆代码

00:04:35.520 --> 00:04:39.440
去常数，所以我现在就尽快做

00:04:39.440 --> 00:04:42.880
我有点像每个人都还好

00:04:42.880 --> 00:04:45.520
就是这样

00:04:47.919 --> 00:04:57.759
谢谢，接下来是埃里克，我这个星期在整个地方都挺好

00:04:57.759 --> 00:05:02.479
嗯，回答很多问题，嗯，我正在积累一些积压的东西

00:05:02.479 --> 00:05:06.080
我现在发现我们确实需要多一点

00:05:06.080 --> 00:05:10.560
api文档以及我们通常需要

00:05:10.560 --> 00:05:16.800
doc对rob正在研究的deck pb内容进行了一些回顾

00:05:16.800 --> 00:05:20.560
我真的很高兴他正在为此做

00:05:21.440 --> 00:05:27.919
我本周必须在果阿ipld仓库中做一些工作才能开始添加资源

00:05:27.919 --> 00:05:31.360
预算编解码器，这是因为我们想要这些

00:05:31.360 --> 00:05:34.080
可以抵抗拒绝服务攻击的事物

00:05:34.080 --> 00:05:37.759
即使是相当恶意的输入，所以我们

00:05:37.759 --> 00:05:40.240
开始在事情上大惊小怪，这是

00:05:40.240 --> 00:05:44.080
发现需要精打细算的事物，以确保更多价值

00:05:44.080 --> 00:05:46.800
分配是合理范围内的，像这样的东西

00:05:46.800 --> 00:05:52.880
所以我已经开始了一些公关活动，这些公关活动确实使预算保持了平衡，所以

00:05:52.880 --> 00:05:58.240
让这些事情变得完全很令人兴奋

00:05:58.240 --> 00:06:04.000
一致很有趣，但是在这一点上

00:06:04.000 --> 00:06:06.880
合理合理的核算和其他一些愿意的事情

00:06:06.880 --> 00:06:09.680
让您喜欢以固定预算超支预算

00:06:09.680 --> 00:06:15.280
数量，我认为这总的来说会很好，嗯

00:06:15.280 --> 00:06:21.520
它可能更纯净，但它应该可以做，我一直在做一些工作

00:06:21.520 --> 00:06:24.800
本周将描述更多的

00:06:24.800 --> 00:06:29.600
通过他的项目使用ipld和ipld模式的Filecoin系统

00:06:29.600 --> 00:06:36.639
这是一项计划性的项目，这确实令人振奋，嗯，我不

00:06:36.639 --> 00:06:39.280
知道他是否愿意为此做更多的准备，但基本上这会产生很多

00:06:39.280 --> 00:06:44.479
经验点，我们可能会继续这样做

00:06:44.479 --> 00:06:48.639
我们发现我们可以毫不奇怪地描述很多文件硬币结构

00:06:48.639 --> 00:06:53.039
使用ipld模式um，因为其中很多最初是

00:06:53.039 --> 00:06:56.560
在与架构语言相同的顶部空间起草，例如

00:06:56.560 --> 00:07:01.520
可以说，有几件事以有趣的方式发展了，

00:07:01.520 --> 00:07:05.440
描述起来有些棘手，而其中的几件事就落在了

00:07:05.440 --> 00:07:10.240
我在架构cogent系统的各个部分的角落

00:07:10.240 --> 00:07:12.080
尚未实施，因为它们更少了

00:07:12.080 --> 00:07:16.880
常用功能，因此可以从中获得很多待办事项清单

00:07:16.880 --> 00:07:20.560
嗯，我们对如何

00:07:20.560 --> 00:07:23.840
开发人员有时可能想制作自定义编解码器

00:07:23.840 --> 00:07:28.160
嗯，有几个有趣的小东西

00:07:28.160 --> 00:07:35.199
Filecoin中的棘手位，其中有序列化为

00:07:35.199 --> 00:07:39.039
像它这样的二进制协议有特定的规定

00:07:39.039 --> 00:07:41.759
将在dagsebor中编码的结构

00:07:41.759 --> 00:07:45.599
所有树木的哈希都是野猪，所以这显然是

00:07:45.599 --> 00:07:50.960
这个东西被序列化了，但是这是目标的一部分

00:07:50.960 --> 00:07:54.720
说明正在处理的项目是否具有人类可读的

00:07:54.720 --> 00:07:59.759
这些东西，以便我们可以创建视觉差异和

00:07:59.759 --> 00:08:04.160
在大多数情况下，

00:08:04.160 --> 00:08:07.599
交换编解码器就是它们的重点，所以您就像

00:08:07.599 --> 00:08:11.520
停止使用dijkstra或开始使用json代替，然后您

00:08:11.520 --> 00:08:16.000
得到相当困难的东西

00:08:16.000 --> 00:08:19.280
嗯，在某些情况下，filecoin项目已经做出了一些

00:08:19.280 --> 00:08:22.240
应该选择某些结构的其他选择

00:08:22.240 --> 00:08:29.120
以自定义方式jsonned，通常这不是我们建议的方式

00:08:29.120 --> 00:08:34.479
如果它正在ipld Universe中进行新工作，则应执行此操作，因为

00:08:34.479 --> 00:08:36.640
它是

00:08:37.120 --> 00:08:40.719
甚至可能是相反的方式，那就是您已经拥有了

00:08:40.719 --> 00:08:44.560
字符串表示形式，例如您将使用的字符串表示形式

00:08:44.560 --> 00:08:49.279
在任何地方都用作地图键，在json中，您需要使用字符串作为地图

00:08:49.279 --> 00:08:54.320
键，这就是您所期望的，但是在cbore中，您可以使用字节

00:08:54.320 --> 00:08:57.519
更加紧凑的表示形式，所以他们做到了

00:08:57.519 --> 00:09:01.680
我们要说的是，这是基于sebor编码的字节，

00:09:01.680 --> 00:09:06.160
是我们的规范编码um，但是如果我想要一个json，我可能

00:09:06.160 --> 00:09:11.920
想要字符串而不是不可打印的unicode映射键um

00:09:11.920 --> 00:09:14.959
所以说你知道我们有相同的

00:09:14.959 --> 00:09:18.800
基础数据，但带有某种字符串表示形式，这很可能是

00:09:18.800 --> 00:09:22.080
您将在json中做的最好的事情和更紧凑的二进制表示形式

00:09:22.080 --> 00:09:28.640
当你要去西雅图的时候，这不是一件非常适合的事情

00:09:29.519 --> 00:09:33.839
是的，我还想着奇怪的恶作剧与

00:09:33.839 --> 00:09:37.200
地址字段似乎需要自定义，但是有

00:09:37.200 --> 00:09:41.680
我们也正在查看字节键并再次映射情况，

00:09:41.680 --> 00:09:45.920
地址和地图中的键无处不在

00:09:45.920 --> 00:09:50.160
是的，是的，然后弄清楚如何

00:09:50.160 --> 00:09:55.279
漂亮的印刷品，就像是嗯，只是不清楚

00:09:55.279 --> 00:10:00.720
应该在那里完成，通常只需用json编解码器替换sigma即可

00:10:00.720 --> 00:10:04.399
不完全可以，但感觉并不好，但它可以

00:10:04.399 --> 00:10:06.640
不

00:10:06.880 --> 00:10:10.000
无论如何，所以我们将来会有更多的报告

00:10:10.000 --> 00:10:15.519
我希望是的，就是这样

00:10:15.519 --> 00:10:22.240
嗯，我最近写了一份有关地图订购文档的新文档

00:10:22.240 --> 00:10:26.480
我们真正需要确定的整个项目的规格和规格

00:10:26.480 --> 00:10:29.680
嗯，我是作为客人发起的，所以有一个链接

00:10:29.680 --> 00:10:34.720
在我们将发布到团队的文档中的小组聊天中

00:10:34.720 --> 00:10:37.360
稍后回购

00:10:38.079 --> 00:10:43.120
我想简要提及一下，我将再次以客人身份发布此信息，

00:10:43.120 --> 00:10:46.480
我这样做是因为我发现这是完成工作的有效方法

00:10:46.480 --> 00:10:50.160
但我也想大声自省一下，因为我不是

00:10:50.160 --> 00:10:54.640
我发现我发现完成工作的好方法感到非常兴奋

00:10:54.640 --> 00:10:58.560
我们真的需要敲定一种可靠地降落东西的方法

00:10:58.560 --> 00:11:02.320
我正在发布东西作为礼物，因为我很难忘记它们

00:11:02.320 --> 00:11:08.959
而且对我来说很容易将它们链接起来，我希望我能够掌握要点，

00:11:08.959 --> 00:11:13.760
稍后以某种方式对他们进行复习

00:11:13.760 --> 00:11:20.560
但是我们需要开发一种以一致的速度降落码头物品的流程

00:11:20.560 --> 00:11:24.320
有某种节奏，因为现在真的很难

00:11:24.320 --> 00:11:30.959
嗯，差不多了，我在牛仔方面有点支持丹尼尔

00:11:30.959 --> 00:11:33.519
我做了一个新的问题，正在写

00:11:33.519 --> 00:11:36.560
获得自托管代码生成的剩余路线图

00:11:36.560 --> 00:11:41.120
对描述模式的类型进行说服力，以便我们可以使用这些类型来

00:11:41.120 --> 00:11:43.839
驱动力

00:11:44.160 --> 00:11:47.279
那是一条相当长的路，但是我想我现在分解了所有步骤

00:11:47.279 --> 00:11:49.680
所以这是入门的第一步

00:11:49.680 --> 00:11:53.440
就是这样[鼓掌]

00:11:53.440 --> 00:12:01.040
谢谢，下一个是罗德，对不起，我会很高兴

00:12:01.040 --> 00:12:05.440
移动一个小时，我想这是下周

00:12:05.440 --> 00:12:13.360
结束夏令时，好吧，嗯，我上周说过

00:12:13.360 --> 00:12:20.480
我正要逃脱dag ppe土地，而我完全没有逃脱标签pb

00:12:20.480 --> 00:12:23.360
土地几乎是我上周所做的一切，但我

00:12:23.360 --> 00:12:28.560
在其中很深，我觉得我已经掌握了它，但我不会做任何事情

00:12:28.560 --> 00:12:31.440
承诺，本周我不会逃避，因为

00:12:31.440 --> 00:12:39.120
可能会有一些整理工作，所以我更深入地进行了解码

00:12:39.120 --> 00:12:43.120
并确定了三种单独的方法

00:12:43.120 --> 00:12:49.839
改变字节并仍然获得有效的dag pb，您可以表示

00:12:49.839 --> 00:12:53.760
相同数据，但格式不同

00:12:53.760 --> 00:12:57.760
由于方式给您无限的变化

00:12:57.760 --> 00:13:03.839
他们堆叠起来，这是因为pb确实

00:13:03.839 --> 00:13:08.079
专为协议而设计，不适用于内容寻址

00:13:08.079 --> 00:13:11.920
就像我们所做的所有其他事情一样，这连接到了

00:13:11.920 --> 00:13:14.079
迈克尔也一直在谈论它，只是

00:13:14.079 --> 00:13:18.800
它不是一个，就像一种方便的以二进制形式表示事物的方式

00:13:18.800 --> 00:13:21.760
一致或规范地做到这一点的方法

00:13:21.760 --> 00:13:28.399
因此在pb中，解码器甚至会接受乱序字段

00:13:28.399 --> 00:13:32.800
虽然pb模式会告诉您命令

00:13:32.800 --> 00:13:36.560
他们只是接受他们进来的任何订单，我们会建立起来的

00:13:36.560 --> 00:13:39.279
但是，您希望他们也接受重复的字段，因此

00:13:39.279 --> 00:13:43.199
如果它接收到具有不同字节的相同字段，它将

00:13:43.199 --> 00:13:46.320
说哦，好吧，就覆盖以前的内容

00:13:46.320 --> 00:13:50.959
而不是抱怨或任何完全没有声音的东西

00:13:50.959 --> 00:13:54.800
然后它还将接受有效的pb的无关字节，但

00:13:54.800 --> 00:13:59.040
对于您提供的架构无效，因此将跳过它们

00:13:59.040 --> 00:14:03.760
并说，嘿，这看起来像协议爱好者，但是protobox，但是我

00:14:03.760 --> 00:14:07.920
我不知道那是什么，我要忽略它

00:14:07.920 --> 00:14:11.040
呃，里面有一个很好的机制，他们走了

00:14:11.040 --> 00:14:15.680
um protobuf koji和收集这些东西的东西

00:14:15.680 --> 00:14:19.040
并将其附加到结构的一部分，以便您可以验证

00:14:19.040 --> 00:14:22.720
至少在[音乐]中

00:14:22.720 --> 00:14:26.560
所以我为js实现了超级严格的解码器

00:14:26.560 --> 00:14:33.440
它在jsjp库中，我还是很感兴趣

00:14:33.440 --> 00:14:37.199
看看它对现实世界数据有什么作用，因为

00:14:37.199 --> 00:14:42.480
在野外有很多标签pb，但是

00:14:42.480 --> 00:14:46.639
你知道收入编码器是很好的编码器都很好，他们会做的

00:14:46.639 --> 00:14:49.199
他们认为应该是灵活的解码器

00:14:49.199 --> 00:14:53.680
所以除非在野外某个地方有特别糟糕的编码器

00:14:53.680 --> 00:14:58.480
这应该很好，但是这是实现了

00:14:58.480 --> 00:15:02.240
单向一对一，这是必须的方式

00:15:02.240 --> 00:15:06.800
进进出出的方式，我想我再次回顾了规范

00:15:06.800 --> 00:15:09.519
它准备从昨天起降落

00:15:09.519 --> 00:15:12.560
呃，我不介意一对眼睛，否则，如果我再也看不到了

00:15:12.560 --> 00:15:18.560
评论我要降落它我把一些

00:15:18.560 --> 00:15:23.440
关于模式和约束的更多清晰度

00:15:23.440 --> 00:15:27.199
在eric的输入之后，我认为还不错

00:15:27.199 --> 00:15:32.639
um links字段现在不是可选的，它必须始终存在

00:15:32.639 --> 00:15:37.759
即使它是空的，并且它的参数是因为

00:15:37.759 --> 00:15:42.959
您无法区分空白链接的权重率和

00:15:42.959 --> 00:15:50.800
um二进制格式的缺少链接数组，使其成为可选的介绍

00:15:50.800 --> 00:15:55.279
另一个陈述了您必须处理的基数，这就是

00:15:55.279 --> 00:15:58.240
作为程序员，有一些人体工程学

00:15:58.240 --> 00:16:02.560
可能会令人讨厌，因为那时您就是与您互动的人

00:16:02.560 --> 00:16:05.920
这个对象需要做检查做这个事情

00:16:05.920 --> 00:16:10.240
存在，嗯，那我就去看看，但是如果你

00:16:10.240 --> 00:16:13.519
使它不是可选的，并使其始终存在

00:16:13.519 --> 00:16:16.399
那么您可以认为它存在是理所当然的，然后说我不需要

00:16:16.399 --> 00:16:19.839
检查此编码解码器是否存在

00:16:19.839 --> 00:16:22.560
正确实施，它将永远存在

00:16:22.560 --> 00:16:26.240
嗯，那就是现在的规格，那是

00:16:26.240 --> 00:16:31.680
无论如何，在编解码器中是js编解码器，所以当您构造其中之一时

00:16:31.680 --> 00:16:34.079
你总是必须拥有那个数组的东西，当它们

00:16:34.079 --> 00:16:39.120
以二进制形式出现，并且它们始终解码，因此始终

00:16:39.120 --> 00:16:43.759
那里，而在javascript中的这种准备方法是

00:16:43.759 --> 00:16:46.800
在那里也可以帮助您，所以您不必

00:16:46.800 --> 00:16:50.800
如果您手动丢弃这些链接或链接数组

00:16:50.800 --> 00:16:53.839
有一个用例，那是没有意义的，这是

00:16:53.839 --> 00:16:58.470
通常不做很多事情，例如创建一个空数组

00:16:58.470 --> 00:17:02.639
[音乐]，然后我在其中添加了一些其他注释

00:17:02.639 --> 00:17:06.079
围绕解码的严格性的规范，所以我这些东西

00:17:06.079 --> 00:17:08.720
上面详细介绍了，我将它们写进了规范中并说

00:17:08.720 --> 00:17:12.400
这些是这些应该是他们不是必须的，但他们应该是

00:17:12.400 --> 00:17:16.480
嗯，他们不是必须的，因为不是那样的

00:17:16.480 --> 00:17:19.600
你不是，这不是你通常不怎么处理原生动物的方式

00:17:19.600 --> 00:17:23.600
编写自己的解码器，但如果您愿意的话

00:17:23.600 --> 00:17:28.240
那么您应该确保严格执行这些操作

00:17:28.240 --> 00:17:32.000
嗯，所以现在我们已经用javascript了，我做了

00:17:32.000 --> 00:17:36.400
版本也是如此，所以在我的电脑中有一个go dag pb回购

00:17:36.400 --> 00:17:41.440
反映了javascript的github，它具有所有的严格性

00:17:41.440 --> 00:17:45.840
解码后，它在编码器中的所有内容都会干净利落

00:17:45.840 --> 00:17:48.400
也尝试处理这个数据模型

00:17:48.400 --> 00:17:52.559
代表性方面以及您所提供的东西必须属于

00:17:52.559 --> 00:17:57.760
正确的形状um，这只是低层部分

00:17:57.760 --> 00:17:59.679
它就像是替代品的下降

00:17:59.679 --> 00:18:03.600
至少不要破坏protobuf版本的

00:18:03.600 --> 00:18:08.960
go merkeldag的protobuf部分，因此可以放入ipld prime proto中

00:18:08.960 --> 00:18:13.280
或者我们可以制作一个具有此功能的新ipld原始协议，而我

00:18:13.280 --> 00:18:18.000
我对um感兴趣，但我仍然不清楚

00:18:18.000 --> 00:18:22.400
构建器界面是您拥有自定义编解码器时

00:18:22.400 --> 00:18:27.520
在ipld prime中，汉娜（Hannah）从未用ipld prime proto充实它

00:18:27.520 --> 00:18:30.640
因为该用例更多地是关于拉动

00:18:30.640 --> 00:18:36.480
数据输出给您，以便在其上使用选择器，所以ii不要

00:18:36.480 --> 00:18:39.600
真的很了解当您拥有非常严格的编解码器时的外观

00:18:39.600 --> 00:18:44.400
关于它接受您的构建者最终看起来像什么的形式

00:18:44.400 --> 00:18:47.360
如何从那东西中导出汇编程序

00:18:47.360 --> 00:18:50.320
这对我来说是完全模糊的，我不介意理解

00:18:50.320 --> 00:18:55.039
因为所有的东西都出现了同样的事情

00:18:55.039 --> 00:18:57.200
我们尚未实现的其他编解码器，例如

00:18:57.200 --> 00:19:01.840
um bitcoin和git以及所有其他这些东西，

00:19:01.840 --> 00:19:05.360
你的形状必须特别，你不能只是

00:19:05.360 --> 00:19:08.960
自由形式构建这些动态的东西，不，您只能在这个非常复杂的范围内构建它们

00:19:08.960 --> 00:19:12.400
狭窄的方式在iple prime中看起来像什么

00:19:12.400 --> 00:19:15.679
很想知道不一定，因为我想

00:19:15.679 --> 00:19:19.600
实施一些东西，但是当我看着时，我不断听到

00:19:19.600 --> 00:19:22.840
此代码，也许我应该尝试并实现

00:19:22.840 --> 00:19:27.760
嗯，但我不会抱抱我，我不会，抱抱自己

00:19:27.760 --> 00:19:31.200
那可能是我本周去的某个地方

00:19:31.200 --> 00:19:34.960
看看，另一件事是我在本周结束时发表了演讲。

00:19:34.960 --> 00:19:38.640
关于它的speakeasy.js的标题为内容地址数据结构

00:19:38.640 --> 00:19:42.480
嗯，我决定回到最开始，因为有一堆

00:19:42.480 --> 00:19:46.720
包括michael的umm在talkeasy.js上的演讲直接进行了

00:19:46.720 --> 00:19:50.960
内容的可寻址性和数量

00:19:50.960 --> 00:19:54.240
而且你甚至知道那些做超核的人，

00:19:54.240 --> 00:20:00.000
嗯，什么是浏览器烧杯浏览器，这些家伙根本不

00:20:00.000 --> 00:20:03.440
直接跳入内容寻址能力和数据结构，以及

00:20:03.440 --> 00:20:06.960
我们来谈谈b树，这就是分布式的

00:20:06.960 --> 00:20:10.080
数据结构，就像我为观众感到难过

00:20:10.080 --> 00:20:13.679
因为大部分这些东西在我们的行业中并没有很好的社交化

00:20:13.679 --> 00:20:16.720
这有点像我们还有些边缘

00:20:16.720 --> 00:20:20.400
即使当您这样做很简单

00:20:20.400 --> 00:20:24.159
当您深入研究时尝试一下，所以我的演讲针对的是

00:20:24.159 --> 00:20:27.520
初学者级的东西，所以我介绍了内容寻址哈希

00:20:27.520 --> 00:20:31.840
然后非常迅速地进入我们如何使用它来构建

00:20:31.840 --> 00:20:37.760
具有这种超级链接能力的数据结构

00:20:38.000 --> 00:20:43.440
所以我对谈话的进行并不满意，主要是因为我当时

00:20:43.440 --> 00:20:48.000
真的很累，但我要从中摘取那段话

00:20:48.000 --> 00:20:52.720
该东西，并把它作为一个单独的视频嗯，我有

00:20:52.720 --> 00:20:54.720
幻灯片，如果有人想带他们

00:20:54.720 --> 00:20:59.600
并使用它们并改进它们，我不介意尝试改进

00:20:59.600 --> 00:21:02.080
这是我自己，如果我有机会对其进行迭代，但是

00:21:02.080 --> 00:21:06.960
嗯，我认为顺序很顺利

00:21:06.960 --> 00:21:13.840
这就是我，谢谢，接下来是克里斯·海耶，所以那是

00:21:13.840 --> 00:21:17.600
有趣的罗恩，我很高兴您发布了我想来的视频

00:21:17.600 --> 00:21:22.400
听您的演讲，但当时我可以，但我想我会

00:21:22.400 --> 00:21:24.320
把我的最后一件事留给你，我去过

00:21:24.320 --> 00:21:29.280
向ipld和内容视觉存储中的人传福音

00:21:29.280 --> 00:21:33.280
医疗医学影像社区，这很艰难

00:21:33.280 --> 00:21:36.960
我的意思是你说的没错，这仍然像是很边缘的事情

00:21:36.960 --> 00:21:39.120
而且您知道我的挑战是尝试

00:21:39.120 --> 00:21:41.039
弄清楚如何以某种方式进行交流

00:21:41.039 --> 00:21:45.600
那个你知道它带领他们，因为

00:21:45.600 --> 00:21:48.960
您不可能在一个小时内就喜欢在自己喜欢的人身上树立品牌

00:21:48.960 --> 00:21:53.039
得到它，除非你像超级天才一样，你知道这是时候了

00:21:53.039 --> 00:21:58.640
但是我取得了很好的成功，我只是让你们很好奇

00:21:58.640 --> 00:22:00.640
我的人民引起了一些非常强烈的兴趣

00:22:00.640 --> 00:22:05.840
在微软和其他主要医疗系统（例如，永久性医疗服务中心）

00:22:05.840 --> 00:22:09.440
我不知道也许在欧洲，你不知道他们是谁，但是

00:22:09.440 --> 00:22:13.520
一些相当大的公司认为这是一个好主意，所以

00:22:13.520 --> 00:22:17.360
嗯，要花一点时间，但是我一直在做

00:22:17.360 --> 00:22:25.200
就我的日常工作而言，到目前为止，这是一个很好的成功

00:22:25.200 --> 00:22:28.320
终于开始在上个星期再次开始工作了

00:22:28.320 --> 00:22:32.640
因此在处理Java JS穿越高峰时

00:22:32.640 --> 00:22:35.760
而且令人沮丧的是进展缓慢

00:22:35.760 --> 00:22:39.919
嗯，只是想弄清楚p2p的内容，而这确实是我的阻碍

00:22:39.919 --> 00:22:44.320
缺乏流利度，呃，你知道的图书馆

00:22:44.320 --> 00:22:47.440
所有的库都在那里，所以我可以阅读代码

00:22:47.440 --> 00:22:51.120
但有时我不一定能找到我想要的代码

00:22:51.120 --> 00:22:55.120
除其他外，上个周末我做了

00:22:55.120 --> 00:22:59.440
实际成功获取连接到ipfs的javascript请求程序

00:22:59.440 --> 00:23:03.520
graphsync好的，响应者连接到ipfs

00:23:03.520 --> 00:23:08.880
 graphsync获取测试应用程序，然后他们彼此交谈，所以至少我有

00:23:08.880 --> 00:23:13.039
有点像基本的pdp连接功能，并且

00:23:13.039 --> 00:23:15.679
对于那些您知道为什么如此困难的人

00:23:15.679 --> 00:23:17.440
因为它真的不应该很好

00:23:17.440 --> 00:23:22.559
pdp决定将默认的加密提供程序从secio更改为noise

00:23:22.559 --> 00:23:26.320
而且我只是不知道这一点，所以我得到了各种奇怪的加密

00:23:26.320 --> 00:23:30.240
我没有想到的错误，因为就像一件事正在使用旧的

00:23:30.240 --> 00:23:33.440
具有原始secio默认值的版本

00:23:33.440 --> 00:23:36.400
然后我的代码正在使用带有噪音默认值或类似内容的较新版本

00:23:36.400 --> 00:23:39.200
那然后还有一个

00:23:39.200 --> 00:23:41.200
草原规范中未记载的内容

00:23:41.200 --> 00:23:44.960
实际消息的框架，因此很明显它的大小和前缀

00:23:44.960 --> 00:23:49.279
酒吧的消息在流中结束，所以我发现了一个

00:23:49.279 --> 00:23:52.480
关于的问题，我要更新那个，否则我将更新规格

00:23:52.480 --> 00:23:57.840
通过此和其他更改进行回购，我发现我认为图形检查可以

00:23:57.840 --> 00:24:01.520
使用一点爱，因为它是现在写的，所以我会尝试

00:24:01.520 --> 00:24:04.559
我会做，我不会说大修，但我会做

00:24:04.559 --> 00:24:08.799
稍后对目前正在通过的um进行更大的更新

00:24:08.799 --> 00:24:12.240
所以我现在在p2p上还不是很杂草，嗯，有某种

00:24:12.240 --> 00:24:16.720
使用它的怪异流媒体问题

00:24:16.720 --> 00:24:23.679
我和um交谈过的烟斗和家人可能会发生并有一个新的

00:24:23.679 --> 00:24:27.679
解决这个问题的策略，我还计划使用您的新dag

00:24:27.679 --> 00:24:34.320
铅库棒所以我只是知道那是未来，但

00:24:34.320 --> 00:24:38.159
我确定一切都会在第一次

00:24:38.159 --> 00:24:41.039
我希望在本周初或者明天就完成这项任务

00:24:41.039 --> 00:24:42.880
周三，我将开始重构

00:24:42.880 --> 00:24:46.159
代码到库中，做一些快速的事情

00:24:46.159 --> 00:24:52.640
与js ipfs集成，以允许um浏览器扩展人员喜欢

00:24:52.640 --> 00:24:54.880
前进，然后完成其余的

00:24:54.880 --> 00:25:02.080
功能性，嗯，接下来是我的更新

00:25:02.799 --> 00:25:09.919
谢谢，接下来是michael yeah um yeah，所以新doc的网站开通了

00:25:09.919 --> 00:25:14.240
嗯，主要网站的伯爵现在正在重定向到它，仅此而已

00:25:14.240 --> 00:25:21.360
嗯，我和gozala一起完成了他的大型js多种格式重构工作

00:25:21.360 --> 00:25:26.400
api真的很好，看起来真的很不错

00:25:26.400 --> 00:25:29.760
很好的实现不是我会怎么做，而是

00:25:29.760 --> 00:25:33.039
就像你知道的那样，我认为打字稿要好很多

00:25:33.039 --> 00:25:39.919
人们，所以不管那个人和工人喜欢那个那个人

00:25:39.919 --> 00:25:44.640
是的，所以那是我想谈的主要内容，

00:25:44.640 --> 00:25:50.880
棒暗示了这个嗯，这只是情况

00:25:50.880 --> 00:25:57.120
像我们的编解码器这样的格式以及一般的um格式

00:25:57.120 --> 00:26:00.799
上周与Rod和其他一些人的对话，特别是

00:26:00.799 --> 00:26:04.480
与raul um在点燃的p2p中，他们只想

00:26:04.480 --> 00:26:08.000
发送一些消息，但他们正在对这些消息进行签名，

00:26:08.000 --> 00:26:12.159
他们可能会在某个时候对它们进行哈希处理，因此即使他们没有在其中添加链接

00:26:12.159 --> 00:26:16.799
他们，他们不需要像ipld这样的dag功能，只要他们确实有

00:26:16.799 --> 00:26:19.440
它们最终将具有很多相同的哈希一致性

00:26:19.440 --> 00:26:23.919
担心我们有嗯，并试图倡导像什么

00:26:23.919 --> 00:26:27.279
他们应该做的很清楚，就像我们不

00:26:27.279 --> 00:26:31.600
有他们想要使用um的东西，我们需要

00:26:31.600 --> 00:26:35.440
像是一种更简单的格式，供他们在这样的简单情况下使用

00:26:35.440 --> 00:26:38.880
所以这是我的想法，我会

00:26:38.880 --> 00:26:43.200
把它带给一些人，他们可以告诉我他们的想法，但嗯

00:26:43.200 --> 00:26:46.720
当我们看看这些是如何实际实施的

00:26:46.720 --> 00:26:52.000
并采用了我们采用和使用这项技术的方式

00:26:52.000 --> 00:26:55.520
而不是大多数消费者使用它的方式

00:26:55.520 --> 00:26:59.039
我们正在尝试创建库和数据结构

00:26:59.039 --> 00:27:02.640
还有一个用于存储的区块链和一个用于存储的网络

00:27:02.640 --> 00:27:07.039
这就像人们在做什么以及他们如何产生数据一样不可知

00:27:07.039 --> 00:27:11.120
因此，我们生活在这个必须创建堆栈的世界中

00:27:11.120 --> 00:27:14.480
所有这些不同的选择都是选项um

00:27:14.480 --> 00:27:17.200
最后我们就像你知道的那样

00:27:17.200 --> 00:27:20.159
处理所有这些东西的非常好的抽象

00:27:20.159 --> 00:27:23.279
但实际上大多数应用程序都在与

00:27:23.279 --> 00:27:26.960
所有这些选择都作为常量的一种类型的数据不是

00:27:26.960 --> 00:27:31.279
不作为变量，而是简单得多

00:27:31.279 --> 00:27:36.399
对于他们来说，他们基本上只是实施协议

00:27:36.399 --> 00:27:39.200
嗯，如果您看一下我们的很多协议

00:27:39.200 --> 00:27:42.480
他们真的很好，他们被这种方式采用，因为他们是如此

00:27:42.480 --> 00:27:45.360
很简单，我们实际上并没有

00:27:45.360 --> 00:27:48.880
就像学到的一样，只是不必担心他们这样做正确，就像

00:27:48.880 --> 00:27:52.880
很多认识的人生产多种格式的东西

00:27:52.880 --> 00:27:56.720
他们有点像您知道他们只是将缓冲区粘在一起

00:27:56.720 --> 00:28:00.159
并把二进制位粘在一起并加上前缀，就像嘿，它起作用并且

00:28:00.159 --> 00:28:02.640
这真的很明显，就像我们不担心他们把它弄乱了一样，

00:28:02.640 --> 00:28:07.760
写入错误的数据，而我们看到编解码器已被采用

00:28:07.760 --> 00:28:10.559
就像您浏览filecoin一样，以及filepoint如何采用它，以及

00:28:10.559 --> 00:28:12.799
就像我们刚刚听说过很多额外的事情

00:28:12.799 --> 00:28:16.320
并在bagpv中归档一堆额外的东西，就像你知道你一样

00:28:16.320 --> 00:28:19.440
你可以做到，人们在野外做这些事

00:28:19.440 --> 00:28:22.240
他们不在数据模型之外的实现

00:28:22.240 --> 00:28:24.799
就像他们是他们没有拿起所有

00:28:24.799 --> 00:28:28.480
哈希保证我们在董事会中并不是真正的生产日

00:28:28.480 --> 00:28:33.919
坦率地说支持数据，就像没有发生什么一样

00:28:33.919 --> 00:28:36.399
与多种格式，这不是你会怎么做

00:28:36.399 --> 00:28:39.520
真的想设计一个弹性协议

00:28:39.520 --> 00:28:43.919
如果您放松一下，我们从这一点开始一直在做的事情

00:28:43.919 --> 00:28:48.080
的观点是，最好以现有格式为基础

00:28:48.080 --> 00:28:51.840
然后没有真正检查这可能是为什么，通常是您为什么的原因

00:28:51.840 --> 00:28:54.320
想要使用现有格式是

00:28:54.320 --> 00:28:57.520
已经有很多图书馆，很多人已经知道了

00:28:57.520 --> 00:29:01.039
而且有很多思想分享，所以您需要在此基础上进行引导

00:29:01.039 --> 00:29:07.840
生态系统，而不是编写新格式，但自从我们成为第一关注对象以来

00:29:07.840 --> 00:29:11.760
这些哈希一致性往返是否跳到了堆栈的顶部，并且

00:29:11.760 --> 00:29:14.399
我们不想为此进行任何其他权衡

00:29:14.399 --> 00:29:18.559
因此，我们以现有格式实现该功能的方法是库

00:29:18.559 --> 00:29:21.919
所以我们并不是真的在写像我这样的协议

00:29:21.919 --> 00:29:25.360
我真的不喜欢适应它的方式

00:29:25.360 --> 00:29:28.640
以及我们要求人们像道格·海伯（Doug Seabor）那样采用的方式是一种协议

00:29:28.640 --> 00:29:31.279
就像一个图书馆，就像我们写了一堆需要人的图书馆

00:29:31.279 --> 00:29:33.919
使用，因为它真的很容易搞砸

00:29:33.919 --> 00:29:37.679
所以就像自己不要写它一样，不要写的部分实现

00:29:37.679 --> 00:29:40.880
只是您需要的东西，如果您只需要序列化一个

00:29:40.880 --> 00:29:44.559
整数列表，对不起，您需要使用整个库才能做到这一点

00:29:44.559 --> 00:29:49.039
嗯，这不会对我们试图建立的生态系统具有弹性

00:29:49.039 --> 00:29:52.159
建立像我们应该期望人们将继续做自己的事

00:29:52.159 --> 00:29:55.120
到目前为止，已经做了部分实现

00:29:55.120 --> 00:29:58.000
单一性实现，我们可能实际上需要的是一种格式

00:29:58.000 --> 00:30:00.880
可以抵御那不存在的事物

00:30:00.880 --> 00:30:04.080
我们认为这将是有益的生态系统，但这实际上是我们的第一

00:30:04.080 --> 00:30:06.159
问题是因为当人们刚抓起西摩时

00:30:06.159 --> 00:30:10.960
库，并与它们一起做事，因为它们倾向于写入不良数据，因为我们

00:30:10.960 --> 00:30:16.399
确实需要他们不要那样做，所以无论如何

00:30:16.399 --> 00:30:19.440
在一个下午，我写了一个非常简单的格式

00:30:19.440 --> 00:30:22.399
我很高兴它用了很短的时间，因为它应该很简单

00:30:22.399 --> 00:30:25.679
实施，因为那意味着人们不会操之过急

00:30:25.679 --> 00:30:32.000
嗯，看起来很像ipld数据模型的多种格式

00:30:32.000 --> 00:30:35.440
有点像您知道在数据前面输入前缀

00:30:35.440 --> 00:30:38.960
嗯，那就是您知道，就乌龟而言，这一直都是乌龟

00:30:38.960 --> 00:30:42.960
嗯，我一直在和民俗人一起工作

00:30:42.960 --> 00:30:47.120
关于如何处理花车，那里仍然有很多问题，

00:30:47.120 --> 00:30:49.919
将会有更多的文档和东西，我们会解决的，但是

00:30:49.919 --> 00:30:53.120
这里的一件事是，我想完全实现该实现

00:30:53.120 --> 00:30:57.760
在javascript中进行了测试，并让恩民对它感到满意，还有什么

00:30:57.760 --> 00:31:02.480
锈实现可能看起来像um，然后我希望其他人都看

00:31:02.480 --> 00:31:06.159
并考虑实施它，这样我们就可以

00:31:06.159 --> 00:31:09.440
确保它真的很容易实现，并且确实可以抵抗

00:31:09.440 --> 00:31:12.799
有弹性地实施，尤其是部分实施

00:31:12.799 --> 00:31:17.120
这样我们仍然可以设计到那个数量，而我真正想要拥有的只是

00:31:17.120 --> 00:31:19.840
就像我希望能够以dag格式指向

00:31:19.840 --> 00:31:23.279
并说如果您正在做一个简单的编码，这里是

00:31:23.279 --> 00:31:27.360
这是您应该使用的，如果您只是序列化整数列表，则可以

00:31:27.360 --> 00:31:30.080
可以序列化整数列表并实现

00:31:30.080 --> 00:31:33.200
确实，这是一个非常简单的编写路径，您不会

00:31:33.200 --> 00:31:35.840
把它弄乱，我认为那只是

00:31:35.840 --> 00:31:38.720
让我们摆脱现有问题之上的许多问题

00:31:38.720 --> 00:31:41.200
格式化um特别是因为在此

00:31:41.200 --> 00:31:43.279
特别是格式，我们有点交易

00:31:43.279 --> 00:31:47.440
cbor的紧凑性只是为了易于实现

00:31:47.440 --> 00:31:51.919
um和对不同实现的适应性以及部分适应性

00:31:51.919 --> 00:31:56.480
特别是um的实现，您知道zz就像您知道我喜欢它一样

00:31:56.480 --> 00:31:58.880
我可能会继续努力

00:31:58.880 --> 00:32:02.159
几年后才可以使用，但嗯

00:32:02.159 --> 00:32:05.919
就像对某些实现没有弹性

00:32:05.919 --> 00:32:09.200
你知道必须要有一百万个呃压缩算法

00:32:09.200 --> 00:32:12.320
实施um，但是，是的，我的意思是，这有点像

00:32:12.320 --> 00:32:14.880
与我们去的地方大相径庭

00:32:14.880 --> 00:32:18.559
死海委员会再也看不到新的Subor了，要清楚，就像我们无法摆脱的一样

00:32:18.559 --> 00:32:22.720
就像文件硬币链在itlb中一样，我们必须支持

00:32:22.720 --> 00:32:25.279
只要人们链接到他们，我们就将对其进行处理

00:32:25.279 --> 00:32:28.720
永远解决问题，但我们至少需要

00:32:28.720 --> 00:32:32.240
有一些我们可以指出的话，就像这样，这是正确的道路，

00:32:32.240 --> 00:32:35.600
这就是我们认为实际上是正确的折衷方案

00:32:35.600 --> 00:32:40.240
嗯，还有像瓦松周围的民俗建筑之类的东西

00:32:40.240 --> 00:32:43.679
像他这样的只读编解码器，需要一种中间二进制格式来移动

00:32:43.679 --> 00:32:47.519
来回实现所有死海港口的数据模型是

00:32:47.519 --> 00:32:51.440
对于这种交换格式um而言，其吸引力可能不如在

00:32:51.440 --> 00:32:53.440
像这样的东西会很多

00:32:53.440 --> 00:32:57.039
这些易读的内容更易于在不同的宿主语言中实现

00:32:57.039 --> 00:33:00.640
如果人们有机会的话，是的，是的，是的

00:33:00.640 --> 00:33:02.640
他们可以查看规格或只是等到

00:33:02.640 --> 00:33:05.679
呃，民俗人，我整理了花车的东西

00:33:05.679 --> 00:33:11.840
但是，是的，我的意思是想法和评论等等

00:33:15.600 --> 00:33:18.880
所以我一直在思考这个问题，因为我的工作确实

00:33:18.880 --> 00:33:23.440
规范，尤其是挑战

00:33:23.440 --> 00:33:27.200
从seaboard转换为json，不仅是dagsebor，而且

00:33:27.200 --> 00:33:33.120
cbor，你怎么看，我认为呃数字和日期时间戳是

00:33:33.120 --> 00:33:36.399
真的很喜欢很难去做，所以我

00:33:36.399 --> 00:33:40.080
最近实际上为此，我有一个可交付成果

00:33:40.080 --> 00:33:42.240
今晚真的能像我上次提到的那样

00:33:42.240 --> 00:33:46.000
周，将dods的seabor规范纳入

00:33:46.000 --> 00:33:49.760
规范，否则它被威胁要拉它，而我实际上是

00:33:49.760 --> 00:33:53.519
使用u cddl不确定你们是否熟悉简洁的数据定义

00:33:53.519 --> 00:33:57.039
语言以及基本上也确实是

00:33:57.039 --> 00:33:59.919
一个抽象的数据模型，它实际上更像是一个

00:33:59.919 --> 00:34:05.279
界面数据语言比它是一个库，您可以在哪里

00:34:05.279 --> 00:34:08.960
明确说明抽象结构

00:34:08.960 --> 00:34:12.480
数据，并作为对象或地图，或者

00:34:12.480 --> 00:34:18.399
um数或浮点数，而且在海滨，实际上

00:34:18.399 --> 00:34:23.599
相当多的标签让您知道像什么编码

00:34:23.599 --> 00:34:26.480
如果它基本上是二进制的，则应该转换为

00:34:26.480 --> 00:34:31.359
带有标签21或23的标签应该可以进行基本转换

00:34:31.359 --> 00:34:35.599
进入相邻的对象是十六进制和呃，所以我觉得

00:34:35.599 --> 00:34:40.159
你的痛苦，我想这是嗯，但我真的很喜欢cdl

00:34:40.159 --> 00:34:44.720
尽可能明确地显示，以确保操作简便

00:34:44.720 --> 00:34:50.240
靠机械装置维持生命的人和杰森之间的转换是

00:34:50.240 --> 00:34:53.200
向后兼容，这完全是双向的，我已经做了很多工作

00:34:53.200 --> 00:34:56.639
整个周末进行测试，以确保

00:34:56.639 --> 00:35:00.800
我们在规范中拥有的所有东西主要是json

00:35:00.800 --> 00:35:03.920
中心，因为他们希望它可读

00:35:03.920 --> 00:35:07.560
很多海滨的东西不是很可读，这是机器

00:35:07.560 --> 00:35:09.680
[音乐]可处理

00:35:09.680 --> 00:35:16.560
但是使用这种抽象语言方法基本上是一个结构

00:35:16.560 --> 00:35:21.040
基本上，这是C板和json的关系，只要没关系

00:35:21.040 --> 00:35:25.760
就像您在cddl和所有内容中明确指出的那样

00:35:25.760 --> 00:35:34.720
将数组映射到呃，这非常有表现力，甚至允许很多

00:35:34.720 --> 00:35:41.760
时间戳信息的正则表达式，例如，我不得不

00:35:41.760 --> 00:35:45.359
复习我的技能和正则表达式以获得

00:35:45.359 --> 00:35:48.160
它可以充分发挥作用

00:35:49.040 --> 00:35:52.640
实际拥有一个会很有趣

00:35:52.640 --> 00:35:56.000
cddl的多编解码器，基本上

00:35:56.000 --> 00:36:01.119
显式抽象数据模型呃，基本上就像一个嵌入式的

00:36:01.119 --> 00:36:03.680
像json的at上下文，但基本上像

00:36:03.680 --> 00:36:07.760
在cddl上，您可以说，这就是结构

00:36:07.760 --> 00:36:12.880
明确地说明其中实际存在的事物的对象

00:36:12.880 --> 00:36:15.920
这是二进制的地方这里是多少

00:36:15.920 --> 00:36:19.839
成员数组，它可以是这里的正则表达式

00:36:19.839 --> 00:36:23.440
您实际上可以输入的um甚至uh标签信息

00:36:23.440 --> 00:36:26.800
这个数据必须是二进制吗

00:36:26.800 --> 00:36:33.440
前面加上标签23（十六进制），它是

00:36:33.440 --> 00:36:36.800
就表示而言，它完全是二进制的

00:36:36.800 --> 00:36:41.839
语法中的语义和结构

00:36:48.960 --> 00:36:52.880
我可以看到cvvl在规格中会是多么的好

00:36:52.880 --> 00:36:59.599
嗯，但我只是想使用现有的

00:36:59.599 --> 00:37:05.040
这些内容处理案例的格式，例如

00:37:05.040 --> 00:37:08.320
除非这种格式发生了，而且我还没有看到这种格式

00:37:08.320 --> 00:37:14.800
但是除非格式碰巧可以说哈希一致表示

00:37:14.800 --> 00:37:18.079
是最重要的事情，我们没有在其他方面做出任何取舍

00:37:18.079 --> 00:37:20.880
方向就像我很难看

00:37:20.880 --> 00:37:24.480
无论格式是什么，我们最终如何都不会处于相同的情况

00:37:24.480 --> 00:37:26.720
我们在哪里我们不是在真正描述一个

00:37:26.720 --> 00:37:32.480
协议，正如我们所说的，您必须使用此库

00:37:32.880 --> 00:37:36.960
好吧，我认为这是呃，这不是一个成熟的图书馆

00:37:36.960 --> 00:37:43.599
这是非常简洁的接口声明

00:37:43.599 --> 00:37:47.599
您正在处理的对象，我想它不会像

00:37:47.599 --> 00:37:51.839
像完整的一样，再次像你一样

00:37:51.839 --> 00:37:56.240
seabor，您在它前面添加了一个like标签，它基本上可以暗示

00:37:56.240 --> 00:38:02.960
尽可能扩展的字符串解释和插值

00:38:02.960 --> 00:38:06.800
可能用其他语言表示

00:38:06.800 --> 00:38:10.320
其他核心表示模型

00:38:13.680 --> 00:38:16.880
我觉得所有这些规格都非常重要

00:38:16.880 --> 00:38:20.240
这就是我们正在做的事情

00:38:20.240 --> 00:38:24.640
我们在规格上添加了您所知道的

00:38:24.640 --> 00:38:28.640
加上内容寻址，而且总是

00:38:28.640 --> 00:38:31.359
因为这些东西都不是为此而设计的，所以它就分解了

00:38:31.359 --> 00:38:34.880
这些规范处理器都不关心内容寻址

00:38:34.880 --> 00:38:40.160
和一致性，所以当我们最终解决它时，我们就是

00:38:40.160 --> 00:38:44.880
那些接受妥协的人，总会有这些妥协

00:38:44.880 --> 00:38:48.800
参与其中，我们对此无能为力，因为我们没有

00:38:48.800 --> 00:38:52.800
连接到规范流程，规范处理器不在乎我们

00:38:52.800 --> 00:38:57.359
用例呢，嗯，这是

00:38:57.359 --> 00:39:00.240
在与任何其他人打交道时，我们都会陷入困境

00:39:00.240 --> 00:39:04.480
这些规格我不认为我们真的了解

00:39:04.480 --> 00:39:08.960
优先考虑哈希一致性的重要性

00:39:08.960 --> 00:39:13.040
直到您以后知道我们已经在这些问题上纠缠不休

00:39:13.040 --> 00:39:16.560
像um这样的格式不像我们无法做到的特质

00:39:16.560 --> 00:39:18.800
真正权衡其他方向

00:39:18.800 --> 00:39:23.440
就像您知道的一样，即使您知道我们只是将内容映射到某种格式之上

00:39:23.440 --> 00:39:26.880
就像您拥有所有这些仍然可以摆脱困境的方式一样

00:39:26.880 --> 00:39:32.320
那就是它实际上并没有完成我们想要做的工作

00:39:35.040 --> 00:39:41.839
我仍然对挖掘感到有些震惊

00:39:41.839 --> 00:39:45.680
protobuf到底有多糟糕，因为

00:39:45.680 --> 00:39:51.040
dagpb有它真正关心的两种数据类型

00:39:51.040 --> 00:39:53.440
关于二进制文件的整个格式

00:39:53.440 --> 00:39:57.680
表示法，但仍然无法始终如一

00:39:57.680 --> 00:40:01.520
而这个规范只是它不在乎它，只是在乎这个

00:40:01.520 --> 00:40:04.640
案例，所以不，它不在乎相反的事情

00:40:04.640 --> 00:40:08.000
喜欢它，它真的很重视格式的灵活性

00:40:08.000 --> 00:40:11.040
喜欢您可以扩展它并在以后继续为其添加内容的事实

00:40:11.040 --> 00:40:14.240
在不破坏旧模式的情况下是一个不像上面这样的功能

00:40:14.240 --> 00:40:17.599
他们的设计对我们来说是另一个方向，但这

00:40:17.599 --> 00:40:22.000
但这是带有模式的格式，这是带有内置模式的格式

00:40:22.000 --> 00:40:25.839
这不像cbore，您在前面定义了一个计划器，然后您放了

00:40:25.839 --> 00:40:30.319
订购现场订单，您和您会提前定义数据类型

00:40:30.319 --> 00:40:36.880
但是对我们来说仍然很糟糕，是的

00:40:37.520 --> 00:40:44.880
好的，我有一个，上面有100个项目

00:40:44.880 --> 00:40:50.800
但我不知道是谁编辑了这个项目，所以有人添加了um选择此曝光

00:40:50.800 --> 00:40:54.560
Lotus Abr API非路径不完整的危险

00:40:54.560 --> 00:40:58.720
选择器嗯，无论谁添加了它，我都做了

00:40:58.720 --> 00:41:04.160
我做的是的，所以我想很快地谈论这个

00:41:04.160 --> 00:41:11.599
今天出现了，就像有人问到的那样，欧洲猎鹰的部分视频在哪里

00:41:11.599 --> 00:41:14.880
汉娜跳到哪去了，就像我一样，我要添加

00:41:14.880 --> 00:41:20.400
um添加了一个简单的表示形式

00:41:20.400 --> 00:41:25.920
进入api，您可以像ss一样提交整个选择器

00:41:25.920 --> 00:41:31.520
我们将尝试尝试将它与问题一起解决

00:41:31.520 --> 00:41:35.680
跟随呃，当我最初在调查

00:41:35.680 --> 00:41:40.560
要实现所有这些，很快就很清楚

00:41:40.560 --> 00:41:48.400
我们只需要允许补充，只允许某人提供路径

00:41:48.400 --> 00:41:55.599
终止于一件事，因为如果你

00:41:56.000 --> 00:42:00.160
因为整个猎鹰交易基本上都允许一个和一个

00:42:00.160 --> 00:42:05.920
仅选择器，没有别的选择，所以您要让对方

00:42:05.920 --> 00:42:09.520
从一开始就寄给你一些东西

00:42:09.520 --> 00:42:13.520
而这第一要成为一个完整的图，所以你不能喜欢

00:42:13.520 --> 00:42:20.800
跳过选择器中的内容以及此输出

00:42:20.800 --> 00:42:24.560
子图也需要

00:42:24.640 --> 00:42:28.400
本质上是一件事，因为否则就像您检索到它一样，您会怎么做

00:42:28.400 --> 00:42:33.040
之后，不，不，这是某种迟钝的东西

00:42:33.040 --> 00:42:37.359
像这样，你可以回馈说，好吧，你问我

00:42:37.359 --> 00:42:40.800
对于这个子通行证，我实际上会喜欢

00:42:40.800 --> 00:42:44.640
这个通行证选择器我要问这个

00:42:44.640 --> 00:42:48.079
选择器，再加上另一端的完全递归，他们将把它交给

00:42:48.079 --> 00:42:52.480
我，我将再次运行选择器，找出您在哪里的子路由

00:42:52.480 --> 00:42:55.920
询问，然后我将以汽车档案或

00:42:55.920 --> 00:42:59.760
嗯，直接输出是迈克尔继续否

00:42:59.760 --> 00:43:06.079
嗯，这不一定是正确的，所以就像我们在路径和

00:43:06.079 --> 00:43:11.040
我们为什么要在其中添加路径是莲花检索命令

00:43:11.040 --> 00:43:15.040
不仅是um给我这些块，实际上就像在给我这个文件

00:43:15.040 --> 00:43:17.760
这条路，所以它确实确实需要成为一条

00:43:17.760 --> 00:43:21.520
整个内容被发送到一个文件中，然后您将

00:43:21.520 --> 00:43:25.200
输出um但我们有类似um这样的情况

00:43:25.200 --> 00:43:30.400
克里斯正在为呃js图形同步进行构建

00:43:30.400 --> 00:43:35.119
通过与某些Lotus客户端um的rpc接口，然后

00:43:35.119 --> 00:43:38.480
将要执行图同步请求检索请求以及将要执行的操作

00:43:38.480 --> 00:43:41.920
从中得出的实际上是检索请求中的原始块

00:43:41.920 --> 00:43:45.920
因此，在这种情况下，如果您给它一个选择器，那就很好

00:43:45.920 --> 00:43:48.960
并且您正在选择各种不同文件中的一堆东西

00:43:48.960 --> 00:43:51.599
必然会像concat一样或成为一种语义

00:43:51.599 --> 00:43:55.280
像它这样的表示形式可以像原始图一样实际使用

00:43:55.280 --> 00:44:00.319
从选择器um yeah yeah检索数据，但它必须是第一位的

00:44:00.319 --> 00:44:06.079
需要是第二个完整的图形，如果确实流出，则为是

00:44:06.079 --> 00:44:10.160
直接阻止，如果没有，那就没问题了

00:44:10.160 --> 00:44:15.119
整个我们的麻烦

00:44:15.119 --> 00:44:20.160
有一个sub um，我想找到这个词，如果我

00:44:20.160 --> 00:44:22.319
正确理解这一点，我们基本上有一个子

00:44:22.319 --> 00:44:28.160
存储每次检索，然后将其垃圾收集

00:44:28.160 --> 00:44:31.200
当检索结束时，您将拥有整个像

00:44:31.200 --> 00:44:34.839
您需要基本保持按住，然后在它消失之前

00:44:34.839 --> 00:44:39.119
返回，如果选择器不是

00:44:39.119 --> 00:44:43.440
你知道还不完整，那你怎么还持有

00:44:43.440 --> 00:44:48.079
所以我在设计过程中说了六遍

00:44:48.079 --> 00:44:52.079
的实现，它不应在其周围保留缓冲区

00:44:52.079 --> 00:44:58.079
需要确定性排序等，而这只是被忽略了，

00:44:58.079 --> 00:45:01.680
他们保留了这个缓冲区，现在我们不知道我们是否真的

00:45:01.680 --> 00:45:05.280
在客户端和服务器之间具有确定性的顺序，因为从来没有人

00:45:05.280 --> 00:45:08.079
错误，他们把整个他妈的事情

00:45:08.079 --> 00:45:11.520
所以现在我们处于这个位置，就像哦，是的，我们必须保留整个

00:45:11.520 --> 00:45:17.040
为了做到这一点，它只是反正

00:45:17.040 --> 00:45:21.440
是的，那就像我看来只是一个bug，就像我们

00:45:21.440 --> 00:45:27.119
只是不应该允许不确定的um图形回复，例如，如果您

00:45:27.119 --> 00:45:29.920
给我我期望的积木

00:45:29.920 --> 00:45:34.079
我对选择的本地解释，那么我要给你一个错误，我是

00:45:34.079 --> 00:45:37.119
要扔掉，这就是我们应该解决的方法

00:45:37.119 --> 00:45:41.920
缓冲问题um另一个问题就像um ii

00:45:41.920 --> 00:45:44.480
看到飞过，但我想我跳了

00:45:44.480 --> 00:45:48.160
有点太快就以为这就像um连接

00:45:48.160 --> 00:45:53.920
为此和cli的rpc接口检索协议的协议

00:45:53.920 --> 00:45:59.040
为此，它们是否像原始数据一样连接

00:45:59.040 --> 00:46:01.920
会自动回到文件中

00:46:01.920 --> 00:46:08.079
还是他们有某种机制可以实际为您提供来自

00:46:08.079 --> 00:46:10.960
检索请求

00:46:11.280 --> 00:46:17.920
嗯，机制是你要车档案好吗

00:46:17.920 --> 00:46:21.599
好的，那是完全可以接受的，

00:46:21.599 --> 00:46:26.839
也许解决了一些缓冲的东西，但我不确定

00:46:26.839 --> 00:46:30.160
嗯耶

00:46:30.560 --> 00:46:33.839
我什至不是在说汉娜的提议是错误的，我只是想

00:46:33.839 --> 00:46:36.960
像突出显示存在陷阱

00:46:36.960 --> 00:46:39.839
只允许任何选择器，因为

00:46:39.839 --> 00:46:45.599
图形本身并没有为此准备，所以选择器有一堆

00:46:45.599 --> 00:46:48.720
我们应该认真对待的问题，例如

00:46:48.720 --> 00:46:52.800
潜在的dos向量，但在文件硬币检索市场中，我们

00:46:52.800 --> 00:46:56.480
不必太担心这一点，因为您必须为此付费

00:46:56.480 --> 00:46:59.680
嗯，这不是一个很好的剂量因素，如果您必须付钱给

00:46:59.680 --> 00:47:04.000
利用它，通常是您修复dos向量的方法，因此

00:47:04.000 --> 00:47:08.880
嗯，我不是，我想不出什么要担心的事情，也许是埃里克（eric）

00:47:08.880 --> 00:47:12.000
嗯

00:47:12.960 --> 00:47:17.119
在我看来，这与嗯无关

00:47:17.119 --> 00:47:20.880
与其说攻击无关，不如说与攻击有关

00:47:20.880 --> 00:47:24.960
好吧，你让我使用这个东西，但是它不起作用，现在对我有用

00:47:24.960 --> 00:47:31.520
而且它可能无法在您知道的架构水平上工作，所以

00:47:31.520 --> 00:47:33.599
那基本上就是我所关心的

00:47:33.599 --> 00:47:36.160
我们正在公开一些超级通用的东西

00:47:36.160 --> 00:47:40.160
在超级专业的东西上，它是图形计算器

00:47:40.160 --> 00:47:43.760
所以这基本上就是我喜欢我们确定要这样做的原因

00:47:43.760 --> 00:47:47.119
好吧，在检索市场上的图形资料已经

00:47:47.119 --> 00:47:50.960
非常开放，因为它确实允许您给它一个新的选择器，因此即使

00:47:50.960 --> 00:47:54.880
我们没有像有人可以写一个那样将其添加到filecoin

00:47:54.880 --> 00:47:57.920
客户并与网络交谈，然后将其发送给他们

00:47:57.920 --> 00:48:03.280
想要是的，但是没有人愿意这样做，是的，是的

00:48:03.280 --> 00:48:08.079
是的，但是就像我的意思是，如果像这样显然不是很理想，但是

00:48:08.079 --> 00:48:10.800
好像那不是理想的，因为很难写出来，那就

00:48:10.800 --> 00:48:14.079
将此功能添加到Lotus中实际上很有意义，这样您就可以

00:48:14.079 --> 00:48:16.640
随便给它就可以了，而无需编写自定义

00:48:16.640 --> 00:48:19.680
客户，我是说我们不是我们不会阻止任何东西

00:48:19.680 --> 00:48:23.680
我们实际上只是在向客户开放um

00:48:23.680 --> 00:48:26.640
网络协议

00:48:29.599 --> 00:48:35.839
埃里克，你有想法吗

00:48:36.000 --> 00:48:39.119
不，不，因为在谈话时我们做着不同的面孔

00:48:39.119 --> 00:48:42.640
关于选择器，您知道这样等等，所以我只是检查

00:48:42.640 --> 00:48:45.760
这是迈克尔说的一件事

00:48:45.760 --> 00:48:50.319
像是的，遍历顺序应该完全是确定性和协议

00:48:50.319 --> 00:48:53.839
心脏应该立即停止并且何时结实吗

00:48:53.839 --> 00:48:57.760
事情以意想不到的顺序进来，这是

00:49:00.839 --> 00:49:03.839
真的

00:49:09.040 --> 00:49:12.400
就像我一直在玩这条路一样

00:49:12.400 --> 00:49:15.359
此游戏之前，也没有令人满意的答案

00:49:15.359 --> 00:49:20.319
该缓冲区应该是多大，答案是不这样做，并且

00:49:20.319 --> 00:49:23.760
知道自己很稳定，然后喜欢

00:49:23.760 --> 00:49:26.480
当有人没有正确执行此操作时，他们会得到一个错误，他们

00:49:26.480 --> 00:49:31.839
不要试图发布该代码

00:49:33.119 --> 00:49:38.720
是否有定义的顺序，所以在图同步中说了块，因为我们

00:49:38.720 --> 00:49:43.599
在谈论这种权利，我不记得曾经读过有关该命令是

00:49:43.599 --> 00:49:47.280
定义为选择器的顺序

00:49:47.280 --> 00:49:51.119
将它们交给您，并定义选择器向您提供东西的顺序

00:49:51.119 --> 00:49:54.640
由数据的迭代顺序和数据的迭代顺序为

00:49:54.640 --> 00:49:57.280
定义为

00:49:57.520 --> 00:50:04.000
不管到底是什么，保持稳定都是编码顺序um

00:50:04.000 --> 00:50:08.079
在某些编解码器中，我们强制执行某些操作，但不强制执行，即使

00:50:08.079 --> 00:50:14.319
它被编码为错误，是您应该正确地做的所有事情，所以

00:50:14.319 --> 00:50:21.040
如果是这样，则意味着一个草木回应者，如果

00:50:21.040 --> 00:50:24.319
因为它以正确的顺序遍历图形

00:50:24.319 --> 00:50:27.839
如果一个方块挂了，它只会停止整个方块

00:50:27.839 --> 00:50:30.880
协议是正确的

00:50:33.920 --> 00:50:40.720
是的，下降到其他物体上，以随机顺序对其进行多路复用

00:50:40.720 --> 00:50:44.640
是的，理想情况下是的，因为像你一样，你必须意识到

00:50:44.640 --> 00:50:49.520
问题是如果您允许顺序有一点变化

00:50:49.520 --> 00:50:55.280
顺序变化非常快，现在只是链接顺序的变化，

00:50:55.280 --> 00:50:59.040
意味着像随后选择子

00:50:59.040 --> 00:51:02.240
图表乱序，这意味着您

00:51:02.240 --> 00:51:06.400
必须经常缓冲整个子选择

00:51:06.400 --> 00:51:08.960
除非你喜欢并发

00:51:08.960 --> 00:51:12.880
选择呃验证器，就像没人的一样

00:51:12.880 --> 00:51:16.480
然后写，那么你，你很像那时

00:51:16.480 --> 00:51:19.839
你必须缓冲一下，所以这不是像我们可以说的那样，哦，不

00:51:19.839 --> 00:51:23.599
保持周围一些障碍，就像哦，不，这样很快

00:51:23.599 --> 00:51:27.839
变成我，我正在缓冲的整个子标签

00:51:27.839 --> 00:51:31.680
无论长度如何，当有人遇到错误时，最终该链接会变得太大

00:51:31.680 --> 00:51:35.359
但是没有人注意到它，直到他们有一个很大的图形在运行

00:51:35.359 --> 00:51:39.119
在这个错误，这就是为什么不他妈的这个错误的原因

00:51:39.119 --> 00:51:40.960
当有人做错命令时就离开

00:51:40.960 --> 00:51:44.640
他们知道他们有错误，然后我们不发货

00:51:44.720 --> 00:51:48.079
好吧，我的意思是你听到了所有的道理，这是我想说的一件事，我认为

00:51:48.079 --> 00:51:50.960
关于草原的事情应该

00:51:50.960 --> 00:51:55.280
就像高性能协议，其中bitwap至少不

00:51:55.280 --> 00:51:58.640
来自点对点，所以他知道您是否要求像

00:51:58.640 --> 00:52:01.839
本来应该很快进行或良好的交换是有限的

00:52:01.839 --> 00:52:05.920
所以这可能会影响我会说的

00:52:05.920 --> 00:52:09.760
限制性能方面图形同步的目标

00:52:09.760 --> 00:52:13.839
鉴于盒装存储的速度，您可能会因为某些原因而限制自己的工作

00:52:13.839 --> 00:52:15.920
除了小盒子，你还有一些障碍吗？

00:52:15.920 --> 00:52:22.079
看看他们是否仍然没有库存，我的意思是，如果您使网络饱和

00:52:22.079 --> 00:52:28.480
从碟片中得到的东西给我留下了深刻的印象

00:52:28.720 --> 00:52:34.800
但这是非常快的，而且坦率地说，这不是

00:52:34.800 --> 00:52:39.359
我的意思是看起来它缓冲不了很多

00:52:39.359 --> 00:52:43.119
无限期地喜欢它的数据和内存

00:52:43.119 --> 00:52:47.839
没有你看到

00:52:48.319 --> 00:52:52.000
您对此有何看法，是的，这是有用的信息，尤其是因为

00:52:52.000 --> 00:52:56.480
我正在完全实施它，但这有点令人惊讶

00:52:56.480 --> 00:53:03.119
也是，因为如果他们继续沿着这个方向前进，我会再加点面条

00:53:03.119 --> 00:53:06.079
那么我们将不得不喜欢在其他任何地方重现此错误

00:53:06.079 --> 00:53:10.000
就像我们将不得不重现所有这些地图错误

00:53:11.760 --> 00:53:17.119
是的，如果有人想增加

00:53:17.119 --> 00:53:22.079
这些数据流水线的吞吐量就像大图一样

00:53:22.079 --> 00:53:24.800
选择器以及图同步应该如何快速进行

00:53:24.800 --> 00:53:28.960
您一次查询一次请求多个块

00:53:28.960 --> 00:53:32.880
然后您将它们与此流一起流回

00:53:32.880 --> 00:53:36.640
被回答的问题却有很多障碍，那就是答案

00:53:36.640 --> 00:53:42.960
因此，这确实消除了往返时间，而您却没有

00:53:42.960 --> 00:53:46.079
需要大量的认可才能像

00:53:46.079 --> 00:53:49.520
发送者可以只保留流数据块，而他们应该这样做

00:53:49.520 --> 00:53:52.559
他们可以以什么速率使管道饱和

00:53:52.559 --> 00:53:58.480
很好，并且在某种程度上，如果所有这些响应数据的接收者

00:53:58.480 --> 00:54:02.640
开始以完全错误的顺序得到东西

00:54:02.640 --> 00:54:06.079
我假设我们正在使用tcp，所以如果我们不使用它，就不会发生这种情况

00:54:06.079 --> 00:54:08.079
tcp然后在传输层进行处理

00:54:08.079 --> 00:54:11.599
应负责尽快重新安排此订单，并且

00:54:11.599 --> 00:54:13.920
我应该担心之前应该照顾好它

00:54:13.920 --> 00:54:19.119
关于它的协议嗯，是的，那么如果接收者

00:54:19.119 --> 00:54:24.319
开始以完全不正确的顺序流式传输这些块，然后它们应该

00:54:24.319 --> 00:54:27.040
发送一个像一个困难的诀窍，像这样关闭

00:54:27.040 --> 00:54:31.680
连接，因为远端没有表现

00:54:31.680 --> 00:54:34.800
完全正确，他们似乎正试图浪费我的记忆

00:54:34.800 --> 00:54:39.920
试图让我坚持我无法验证的东西

00:54:39.920 --> 00:54:44.720
嗯，我认为试图增加这种吞吐量应该差不多

00:54:44.720 --> 00:54:47.680
只专注于尝试提高运输级别的吞吐量

00:54:47.680 --> 00:54:54.720
就像我不认为有任何理由让整个街区

00:54:54.720 --> 00:54:59.280
以完全不同的顺序重新关联，除非像

00:55:00.559 --> 00:55:03.920
嗯，我不明白为什么这样做真的有必要

00:55:03.920 --> 00:55:09.440
除非您像有人添加了https 4000或Google的任何版本，

00:55:09.440 --> 00:55:12.400
到现在为止，它可以建立更多的连接，而我们整个流式传输

00:55:12.400 --> 00:55:17.359
出于某种原因，它们上有不同的障碍，所以走得更快，是的，我认为

00:55:17.359 --> 00:55:21.359
我正在考虑的是让我们看一个有相当大的图形

00:55:21.359 --> 00:55:26.480
块和一些非常小的块，我的响应者基本上意识到了哦

00:55:26.480 --> 00:55:29.760
我要去的那个有20个子块

00:55:29.760 --> 00:55:33.359
发出异步请求给所有这些请求，并在它们尽快开始发送

00:55:33.359 --> 00:55:36.160
回来，恰好发生在第一个街区

00:55:36.160 --> 00:55:40.079
这种命令是很大的命令，意味着所有其他命令都像19个块

00:55:40.079 --> 00:55:43.440
超级小，直到我读完了，我还无法发送

00:55:43.440 --> 00:55:46.960
大一个，所以那是你知道的，所以我认为这有点像

00:55:46.960 --> 00:55:50.960
在性能方面令人um舌，然后我认为与

00:55:50.960 --> 00:55:54.559
那是你知道的，但是有一些东西

00:55:54.559 --> 00:55:58.160
如果您不具备所有这些功能，那您就可以做

00:55:58.160 --> 00:56:00.720
就像您在对此执行子请求一样

00:56:00.720 --> 00:56:04.480
人的代表，如果是的话，您应该这样做

00:56:04.480 --> 00:56:07.760
因为我不知道

00:56:08.400 --> 00:56:11.440
让我说些我认为有脱节的地方

00:56:11.440 --> 00:56:18.000
克里斯似乎在图同步是这个想法之下

00:56:18.000 --> 00:56:22.400
超级并行协议，而图

00:56:22.400 --> 00:56:26.880
同步被明确设计为串行

00:56:26.880 --> 00:56:30.400
基本上只是超级高效地走图

00:56:30.400 --> 00:56:33.920
但根本无法有效地并行处理图表

00:56:33.920 --> 00:56:37.440
实际上，查询正在构建类似的内容，因为

00:56:37.440 --> 00:56:41.599
绘图不适用于他们，呃bitswap不适用于他们，但是

00:56:41.599 --> 00:56:45.359
实际上，bitswap是一种性能更好的图形同步，其实现方式如下：

00:56:45.359 --> 00:56:49.599
如果您有任何缓存日期，则设计为

00:56:49.599 --> 00:56:53.119
像bitswap这样的任何缓存日期都可以击败它

00:56:53.119 --> 00:56:55.520
因为你在做，所以要求更少

00:56:55.520 --> 00:56:59.440
您需要较少的东西um崩溃同步不是真正为您设计的

00:56:59.440 --> 00:57:02.960
嗯，就像你已经有任何

00:57:02.960 --> 00:57:06.559
像是所有自己的手工工作来弄清楚这一点

00:57:06.559 --> 00:57:09.839
然后您仍在进行子查询的往返行程

00:57:09.839 --> 00:57:13.440
你可以告诉图认为它有一个像这样的数据包

00:57:13.440 --> 00:57:17.920
告诉我我已经没有的这些哈希值，这些都不发送给我

00:57:17.920 --> 00:57:23.839
是的，问题在于您不这样做，所以您不能说这里的所有内容

00:57:23.839 --> 00:57:26.400
这样的大块商店会太大，

00:57:26.400 --> 00:57:29.440
您通常不知道直到遍历哪个

00:57:29.440 --> 00:57:32.640
您周围已经有哪些相关提示？

00:57:32.640 --> 00:57:36.400
您可以说一些小节，例如从您开始的地方开始

00:57:36.400 --> 00:57:39.119
但是如果您有一个不知道的图层，那么它会发生

00:57:39.119 --> 00:57:41.839
就像你的孙子一样

00:57:41.839 --> 00:57:45.119
那么你就无法有意义地宣布这是真的，是的

00:57:45.119 --> 00:57:48.000
就像我认为，我们一直想像人们可能会那样做的方式

00:57:48.000 --> 00:57:50.240
是他们只是在做多个查询，就像他们大喊大叫一样

00:57:50.240 --> 00:57:52.319
就像你在说他们会做浅层查询，然后是几个

00:57:52.319 --> 00:57:55.359
并行查询和um，然后在同一图形中进行查询

00:57:55.359 --> 00:58:00.319
通道，您确实会得到重复数据块的重复数据删除，但嗯

00:58:00.319 --> 00:58:05.040
但是是的，而且在猎鹰中，您无法执行任何操作，因为只有一个

00:58:05.040 --> 00:58:08.960
连接，因为它以付款为基础，所以您无能为力

00:58:08.960 --> 00:58:14.000
是的，是的，我的意思是，这里有很多注意事项，

00:58:14.000 --> 00:58:18.400
我认为，性能并不是检索市场上的顶级产品

00:58:18.400 --> 00:58:20.720
graphsync还有其他性能要求

00:58:20.720 --> 00:58:22.720
除了检索之外的其他用例

00:58:22.720 --> 00:58:27.119
使人们想要更快，但是检索不会

00:58:27.119 --> 00:58:30.240
人们将阻止像这样的连锁访问

00:58:30.240 --> 00:58:33.200
他们不是，他们不会在这些方面受到性能的限制

00:58:33.200 --> 00:58:36.640
并行性问题彼得所说的另外一个协议是什么

00:58:36.640 --> 00:58:40.799
人们喜欢他们不喜欢bitwap或graphsync，您是否有指向它的链接

00:58:40.799 --> 00:58:44.720
呃，不，我只是知道他们正在为此而努力。io查询io

00:58:44.720 --> 00:58:48.400
这是布兰登工作的公司

00:58:48.400 --> 00:58:51.920
嗯，他们应该完成它，

00:58:51.920 --> 00:58:57.839
将会以它们在各个碎片之间移动块的方式发布

00:58:57.839 --> 00:59:03.680
他们喜欢他们有半IPFS网关

00:59:03.839 --> 00:59:07.520
我不知道他们是否做过任何新的事情，但要快速回顾一下我的所作所为

00:59:07.520 --> 00:59:09.680
知道他们在历史上做过对自己满意的事情

00:59:09.680 --> 00:59:13.760
嗯，他们就像两阶段协议一样，

00:59:13.760 --> 00:59:16.799
构建数据的所有结构和大小的清单

00:59:16.799 --> 00:59:20.960
然后先发送这些内容，然后再进行流式处理

00:59:20.960 --> 00:59:26.240
以后所有的数据，这正是我在想我们应该做的

00:59:26.240 --> 00:59:32.720
好吧，如果您知道用例，那真的很好用，这很难做到

00:59:32.720 --> 00:59:37.119
像你这样的人一般不知道那有多大

00:59:37.119 --> 00:59:41.200
差异将是和信息在哪里就像

00:59:41.200 --> 00:59:45.760
Windows文件现在可以复制给您的地方

00:59:45.760 --> 00:59:48.240
棘手的进度条一段时间

00:59:48.240 --> 00:59:52.640
他们说要计算尺寸，但是之后进度条是

00:59:52.640 --> 00:59:57.280
是可以预见的，像这样的人，是吗，实际上更快，不是吗

00:59:57.280 --> 01:00:02.640
几乎可以肯定会变慢，但是非常

01:00:02.640 --> 01:00:06.160
饱和的经验，是的，我的意思是我必须考虑

01:00:06.160 --> 01:00:11.200
这是我的意思，实际上这是我需要考虑的污点

01:00:11.200 --> 01:00:14.799
对于我的用例，例如清单或类似的东西

01:00:14.799 --> 01:00:18.319
流式清单，其顶部带有字符串块

01:00:18.319 --> 01:00:22.079
可能更适合我的需求，但是还可以

01:00:22.079 --> 01:00:25.760
我认为我们只需要更多的时间来处理不同的用例，

01:00:25.760 --> 01:00:29.200
协议，以了解什么通用将需要

01:00:29.200 --> 01:00:32.880
看起来像我对任何复制都不满意

01:00:32.880 --> 01:00:35.280
说实话的协议，我什至写了几本

01:00:35.280 --> 01:00:38.960
像不同的人，他们都在

01:00:38.960 --> 01:00:42.960
特定的用例，但不是通用的，我挖掘的更多是

01:00:42.960 --> 01:00:46.640
就像您在复制时实际想要做的一样

01:00:46.640 --> 01:00:51.200
对于一般的东西来说比较复杂，特别是当您进入时

01:00:51.200 --> 01:00:54.480
就像我想保留这个部分

01:00:54.480 --> 01:00:57.599
按参考图，但我实际上并不希望移动数据

01:00:57.599 --> 01:01:01.440
这样的决定变得非常困难

01:01:01.440 --> 01:01:08.400
嵌入到通用接口中，但是无论如何，我们在当时

01:01:08.400 --> 01:01:11.520
所以我们应该是的，所以我需要每个人

01:01:11.520 --> 01:01:16.720
谁为我工作的人谁要坚持不懈，因为我们必须

01:01:16.720 --> 01:01:22.319
在通话结束时做一些计划吧，然后

01:01:22.319 --> 01:01:25.920
不，我还有另一件事要坚持到最后，是的，

01:01:25.920 --> 01:01:30.160
所以这个明显的讨论，我们只是在...

01:01:30.160 --> 01:01:33.839
我认为，如果我们能够提取出来，那将真的很酷

01:01:33.839 --> 01:01:38.559
一些温和的惯例或对这类事情的宽松规范

01:01:38.559 --> 01:01:41.920
在我看来，这完全是合理的

01:01:41.920 --> 01:01:45.520
做一些功能，大致给我你的

01:01:45.520 --> 01:01:49.440
块存储以及您的起始哈希和选择器

01:01:49.440 --> 01:01:52.640
我将应用此功能，它将给我

01:01:52.640 --> 01:01:56.799
清单，我不认为我们已经指定了

01:01:56.799 --> 01:02:00.400
但是，您可以很轻松地构建它，但是就像哦，为什么不

01:02:00.400 --> 01:02:04.079
使它变得有趣的标准

01:02:04.079 --> 01:02:06.960
真的很有趣，是的，因为您可以，然后您可以

01:02:06.960 --> 01:02:09.440
修改其形状以匹配不同的用例

01:02:09.440 --> 01:02:12.319
是的，这可能真的很有趣，是的，然后我们可以开始喜欢

01:02:12.319 --> 01:02:15.920
也许我们甚至可以接受人们所做的任何查询，就像

01:02:15.920 --> 01:02:21.920
这是一个标准，我想他们大概已经正确地做到了

01:02:21.920 --> 01:02:25.280
我的意思是说最终可能会带来一些新

01:02:25.280 --> 01:02:28.960
选择器以及我们会识别出一些我们没有的选择器，

01:02:28.960 --> 01:02:32.839
当您执行类似操作时，我们不需要的某些语法

01:02:32.839 --> 01:02:38.240
好的，谢谢，嗯，谢谢

01:02:38.240 --> 01:02:46.079
大家，下周再见

