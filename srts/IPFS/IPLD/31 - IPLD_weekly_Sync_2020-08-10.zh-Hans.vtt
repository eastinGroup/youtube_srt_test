WEBVTT
Kind: captions
Language: zh-Hans

00:00:12.639 --> 00:00:16.160
欢迎大家参加本周的ipld开发人员会议

00:00:16.160 --> 00:00:23.439
2020年8月10日，每周我们都会讨论这些内容

00:00:23.439 --> 00:00:28.080
过去一周我们一直在努力，下周我们将继续

00:00:28.080 --> 00:00:33.040
然后讨论未完成的议程项目

00:00:33.040 --> 00:00:36.480
我们可能有和

00:00:36.800 --> 00:00:41.760
这次我什至在每周开始之前都有一个一般的um部分

00:00:41.760 --> 00:00:46.480
更新，因为它也像外界参与的人一样

00:00:46.480 --> 00:00:50.160
因此，这可能并不像某人稍后播放时那样

00:00:50.160 --> 00:00:55.039
有人把它放在他的盘子上，我不知道，但是那很重要，因为嗯

00:00:55.039 --> 00:01:00.559
cid有变化，这不是重大变化，只是

00:01:00.559 --> 00:01:05.440
定义的改变ici是什么

00:01:05.519 --> 00:01:10.880
是的，所以我们没有CID的版本号了

00:01:10.880 --> 00:01:15.840
但版本号实际上也是一个多编解码器

00:01:15.840 --> 00:01:23.600
所以这意味着CID版本1是十六进制代码

00:01:23.600 --> 00:01:29.200
是的，x1现在是合适的多编解码器，将来我们还将使用智能

00:01:29.200 --> 00:01:35.280
编码，因此理论上cad版本2甚至可能不是

00:01:35.280 --> 00:01:38.840
具有字节值2，但可以是字节值

00:01:38.840 --> 00:01:44.079
无论有什么适当的支持，我们已经保留了第二版和

00:01:44.079 --> 00:01:46.960
多重编码表中的三个，因为拥有那些

00:01:46.960 --> 00:01:51.439
数字，但理论上可能是其他

00:01:51.439 --> 00:01:57.680
是的，我们甚至可以决定是否像讨论过的那样，但我不是

00:01:57.680 --> 00:02:02.240
确定定义cid版本0是否是一个好主意

00:02:02.240 --> 00:02:06.719
与相同的多编解码器相同

00:02:06.840 --> 00:02:13.680
sha2，因为实际上就是这样，所以我们可以更改定义

00:02:13.680 --> 00:02:18.560
cid版本0是什么的定义

00:02:18.560 --> 00:02:22.879
并说第一个字节实际上是多编解码器

00:02:22.879 --> 00:02:27.440
然后它包含没有哈希标识符的哈希

00:02:27.440 --> 00:02:31.120
从理论上讲，我们可以做我们可能不会做的事情，但我们只是

00:02:31.120 --> 00:02:37.440
嗯，所以无论如何，如果有人正在看的话，使用cid

00:02:37.440 --> 00:02:40.720
真的没有什么改变对你来说只是个问题

00:02:40.720 --> 00:02:43.840
用不同的方式定义它，但不是真的

00:02:43.840 --> 00:02:50.400
嗯是打破任何东西嗯酷嗯

00:02:50.400 --> 00:02:56.239
然后我继续自己，所以在锈马蒂哈希世界中，我添加了

00:02:56.239 --> 00:03:00.959
几只狗到应该在上游的小型多孵化库

00:03:00.959 --> 00:03:05.040
并且这被合并了，我也打开了一个关于

00:03:05.040 --> 00:03:09.760
在微小的multihash上我想先解决的问题

00:03:09.760 --> 00:03:13.200
我想将其上行到适当的smartyhash

00:03:13.200 --> 00:03:16.879
嗯，我上周没有那么多时间来工作，希望本周

00:03:16.879 --> 00:03:22.239
我将有更多时间，在js ipl d方面

00:03:22.239 --> 00:03:28.080
um我们使用u和八个数组而不是节点的更改

00:03:28.080 --> 00:03:33.200
缓冲区冒泡了，所以现在也在jsi面板d和

00:03:33.200 --> 00:03:38.720
像下面这样的多格式堆栈，例如um，但是这项工作基本上是由以下人员完成的：

00:03:38.720 --> 00:03:42.720
我刚刚做过的古代大脑的评论和真正的作品

00:03:42.720 --> 00:03:46.560
东西，但他做了艰苦的工作，实际上是在修改代码

00:03:46.560 --> 00:03:53.439
我唯一剩下的就是js ipld bitcoin和js

00:03:53.439 --> 00:03:59.040
 ipld以太坊，其中内部仍在使用缓冲区，因此我们

00:03:59.040 --> 00:04:04.319
在进进出出的过程中将其转换并使其正常工作

00:04:04.319 --> 00:04:10.480
但理想情况下，我们将对此进行更改，但希望它可以与

00:04:10.480 --> 00:04:14.879
Rod可能在Rod的新图书馆中使用了比特币

00:04:14.879 --> 00:04:20.079
对于以太坊以太坊，如果有人创造了一个合适的

00:04:20.079 --> 00:04:23.440
我们可能想要的js ethereum库

00:04:23.440 --> 00:04:29.199
在不久的将来可能也会腐烂的用途

00:04:29.199 --> 00:04:33.680
嗯，但我希望如此嗯，但这就像没有任何障碍或类似的东西

00:04:33.680 --> 00:04:37.600
是的，如果你想摆脱全部

00:04:37.600 --> 00:04:42.800
整个堆栈中的node.js缓冲区也需要更新它们

00:04:42.800 --> 00:04:46.160
除非我们不捆绑它们，那很好，因为如果您不捆绑它们

00:04:46.160 --> 00:04:52.639
你没有依赖性，嗯，这就是我所拥有的

00:04:52.639 --> 00:04:59.040
我名单上的下一个是彼得，是的，又是另一个令人沮丧的

00:04:59.040 --> 00:05:02.000
更新呃我主要还是在做powerpoint

00:05:02.000 --> 00:05:05.600
那些想知道他是谁的人的事情

00:05:05.600 --> 00:05:07.840
当我们拥有整个

00:05:07.840 --> 00:05:13.840
呃猎鹰oni哦团队我正在专注的是做事

00:05:13.840 --> 00:05:17.520
在实时链上，并附带所有额外的嵌套

00:05:17.520 --> 00:05:20.080
从你知道，链上有更多的人

00:05:20.080 --> 00:05:24.880
并在您的邮件接收方式上出现波动

00:05:24.880 --> 00:05:28.160
一分钟和下一分钟，什么也没发生

00:05:28.160 --> 00:05:30.639
像那个嗯，不幸的是

00:05:30.639 --> 00:05:37.039
花费大量的时间和时间在呃之间发现事物

00:05:37.039 --> 00:05:41.199
像实施团队和

00:05:41.199 --> 00:05:44.880
以及ce团队等等，依此类推

00:05:44.880 --> 00:05:50.960
很多时间去那里，我正在看的一件事

00:05:50.960 --> 00:05:54.960
并在谈话方式之后的一边

00:05:54.960 --> 00:05:57.360
回到迈克尔，我开始寻找一点

00:05:57.360 --> 00:06:02.560
嗯，这是分块器工作的wasm目标

00:06:02.560 --> 00:06:06.880
我几个月前做过的我

00:06:06.880 --> 00:06:16.000
嗯，我现在暂时还没有放弃

00:06:16.000 --> 00:06:20.319
实际生成微小的代码不适合我

00:06:20.319 --> 00:06:24.560
嗯，我知道那个人已经调查过了

00:06:24.560 --> 00:06:28.639
我认为来自直接项目，呃，有点像是的，他们是

00:06:28.639 --> 00:06:31.680
他们就像这里的残障人士，好像有些东西丢失了

00:06:31.680 --> 00:06:34.720
是的，但实际上是我忘记了你

00:06:34.720 --> 00:06:41.199
嗯，嗯，我的事情有点简单，所以我希望在另外两个

00:06:41.199 --> 00:06:44.720
三四天，我可以提出足够的问题，但没有一个可以解决，所以

00:06:44.720 --> 00:06:49.919
事情可以编译了，呃，微不足道

00:06:49.919 --> 00:06:54.000
像我们正在谈论的一个非常非常非常小的输出

00:06:54.000 --> 00:06:58.479
比正常公司生产的产品小两个数量级

00:06:58.479 --> 00:07:02.479
我仍然专注于地鼠的原因直到我完全放弃

00:07:02.479 --> 00:07:06.000
是因为多交易的生锈故事

00:07:06.000 --> 00:07:11.360
这是可行的，但没有什么比这更好

00:07:11.360 --> 00:07:16.479
多交易的故事，嗯，虽然对于wasm本身来说并不有趣

00:07:16.479 --> 00:07:20.080
拥有一个基本的代码库很有趣

00:07:20.080 --> 00:07:24.720
两者都变得很棒并保持目标不变，而一个人可以

00:07:24.720 --> 00:07:30.240
呃饱和尽可能多的CPU，你可以扔给它，如果最下面的一个

00:07:30.240 --> 00:07:34.319
本质上仅用于浏览器，嗯

00:07:34.319 --> 00:07:41.520
其余的基本上都在推动尽可能多的cpu上进行

00:07:41.520 --> 00:07:48.319
用未编组的共享内存执行操作是可行的，但

00:07:48.319 --> 00:07:55.520
这是很多工作，不是不是我可以走，所以这就是我的团队的原因

00:07:55.520 --> 00:07:58.960
就是要尝试尽可能地走下去，

00:07:58.960 --> 00:08:02.560
如果它不起作用，我们将把一些零件停下来

00:08:02.560 --> 00:08:06.319
然后整体在wassum中进行线程化实际上是实验性的

00:08:06.319 --> 00:08:11.599
是的，哦，是的，交易不是完全是实验性的，我更像是

00:08:11.599 --> 00:08:18.160
如果我切换在常规控制台上运行的部件，例如在常规cpu上运行

00:08:18.160 --> 00:08:22.240
不能因为累而生锈在那儿进行多种交易

00:08:22.240 --> 00:08:26.560
在常规编译中只是您可以做到，但是因为您

00:08:26.560 --> 00:08:29.120
本质上有posix线程，或者您喜欢

00:08:29.120 --> 00:08:35.599
你知道东京之类的东西，它的开销远不及什么

00:08:35.599 --> 00:08:40.000
目标为您提供了何时需要我真正需要的东西

00:08:40.000 --> 00:08:43.519
基本上在周围移动叮咬我猜我可以说

00:08:43.519 --> 00:08:46.640
从Diran的角度来看，只有几个像图书馆

00:08:46.640 --> 00:08:49.920
最初尝试微小的事情失败了，我们没有花太多钱

00:08:49.920 --> 00:08:53.279
时间调查它，我怀疑我们本来可以不花太多力气

00:08:53.279 --> 00:08:56.320
一个很小的go编译目标，但不是

00:08:56.320 --> 00:09:01.760
这是我们想要的一个网络演示，所以我们真的不需要它

00:09:05.279 --> 00:09:12.959
好吧，我名单上的下一个是杆

00:09:14.560 --> 00:09:21.200
好吧，我整个星期都忙个不停

00:09:21.440 --> 00:09:29.839
看着远处的硬币嗯，正在做一些工作，呃

00:09:29.839 --> 00:09:36.080
好吧，我把文档合并了我写的文档，所以实际上全部合并了

00:09:36.080 --> 00:09:39.360
Go文档现在应该起来了

00:09:43.120 --> 00:09:46.480
进入笔记

00:09:48.720 --> 00:09:52.640
很好，那是很大的工作，但这是

00:09:52.640 --> 00:09:57.120
大概是两周前

00:09:57.839 --> 00:10:00.640
好的

00:10:02.000 --> 00:10:06.720
嗯，那只是一堆要做的事情

00:10:06.720 --> 00:10:11.120
来自那个呃，你知道关于代码和一些关注

00:10:11.120 --> 00:10:16.320
关于变化的建议，所以其中之一是

00:10:16.320 --> 00:10:21.440
崩溃算法um，当您将汉普顿保持在正确的形状时

00:10:21.440 --> 00:10:26.640
删除元素um，这样的想法是，大麻应该只有一种形式

00:10:26.640 --> 00:10:30.959
对于任何给定的数据集，因此当您删除它时，需要

00:10:30.959 --> 00:10:34.959
弯回正确的形状和看上去没有的塌陷算法

00:10:34.959 --> 00:10:38.720
对我而言，这似乎既不完整，却

00:10:38.720 --> 00:10:44.079
在有点推后也有点错误和嗯

00:10:44.079 --> 00:10:46.880
你知道强迫它变成不同的

00:10:46.880 --> 00:10:49.760
情况似乎似乎是

00:10:49.760 --> 00:10:52.800
工作得很好，所以它只是以一种方式编写

00:10:52.800 --> 00:10:57.920
那不是我如何在我的概念化算法

00:10:57.920 --> 00:11:02.480
头，我认为这是一部分，只是它的方式

00:11:02.480 --> 00:11:08.240
嗯，所以无论如何都要清理代码

00:11:08.240 --> 00:11:10.880
并在其中添加一些额外的内容，以使其更加明确

00:11:10.880 --> 00:11:13.839
发生了，对此有完整的要求

00:11:13.839 --> 00:11:19.279
在呃麻麻ipld um和我

00:11:19.279 --> 00:11:23.839
嗯清理

00:11:24.240 --> 00:11:27.519
哦，你知道的，还有这个的下一个箱子

00:11:27.519 --> 00:11:31.279
对于崩溃的东西

00:11:31.440 --> 00:11:36.399
然后我大部分时间都在进行块加载时间验证工作，因此

00:11:36.399 --> 00:11:41.600
嗯，这是汉普顿接受的东西真的很松散，

00:11:41.600 --> 00:11:44.800
它会尝试通过一个块，然后尝试对其进行导航

00:11:44.800 --> 00:11:48.800
当它绝对不能做的时候就失败了，所以我把它变得更严格了

00:11:48.800 --> 00:11:54.160
现在关于何时加载该块

00:11:54.160 --> 00:11:57.839
它会检查这个区块是否符合我对什么区块的期望

00:11:57.839 --> 00:12:00.399
看起来像嗯，所以这就是我们当时的事情

00:12:00.399 --> 00:12:03.680
如果我们像我们一样准备好所有东西，就可以在模式中进行操作

00:12:03.680 --> 00:12:06.399
也许可以断言我所做的很多事情

00:12:06.399 --> 00:12:12.320
嗯，但这涉及到um做很多um产生很多手动c

00:12:12.320 --> 00:12:17.120
董事会强制其在测试中强制其失败

00:12:17.120 --> 00:12:19.519
验证一堆不同的形状

00:12:19.519 --> 00:12:26.720
嗯，所以那里有一个链接，可以拉动所有工作的请求嗯

00:12:26.720 --> 00:12:30.000
我对此感到满意，但现在非常严格

00:12:30.000 --> 00:12:33.519
不是，不是

00:12:33.600 --> 00:12:37.519
接受任何闻起来不正确的东西

00:12:37.519 --> 00:12:42.639
嗯，是的，接下来是接下来的事情

00:12:42.639 --> 00:12:46.240
现在我想我已经完成了一些有关seaboard格式的工作

00:12:46.240 --> 00:12:50.399
如此验证它接受正确的事物才是正确的事物

00:12:50.399 --> 00:12:53.680
嗯，现在有几件事会改变格式

00:12:53.680 --> 00:12:56.959
所以我现在做了一些测试，这些测试的格式

00:12:56.959 --> 00:13:00.720
明确的硬编码，现在我要更改格式

00:13:00.720 --> 00:13:03.360
我将能够通过测试做到这一点，而无需说这些事情

00:13:03.360 --> 00:13:05.839
从map从数组更改为map或其他

00:13:05.839 --> 00:13:09.200
不管我在干嘛

00:13:09.200 --> 00:13:15.200
有两件事，其中之一是，这只手的位域相当大

00:13:15.200 --> 00:13:19.440
特定的呃，因为它使用了一个大的int

00:13:19.440 --> 00:13:23.600
从中获取字节，这意味着所以你有这个

00:13:23.600 --> 00:13:26.079
字节数组，您可以在字节中打开和关闭位

00:13:26.079 --> 00:13:31.519
表示您拥有um的数组元素的数组

00:13:31.519 --> 00:13:37.040
而bigint的go实现将为您提供代表字节的字节

00:13:37.040 --> 00:13:40.720
您创建的整数仅小至

00:13:40.720 --> 00:13:45.519
它必须与大印度一样，所以你最终会

00:13:45.519 --> 00:13:51.279
在序列化格式中具有不同大小的位图，具体取决于哪个

00:13:51.279 --> 00:13:54.560
位已设置，但不一定有

00:13:54.560 --> 00:13:57.760
偏向于较小，或者是这样，实际上并没有节省

00:13:57.760 --> 00:14:00.480
你一吨，但这只会给你带来前后矛盾

00:14:00.480 --> 00:14:04.399
所以我在大多数与之相关的人中都达成了共识

00:14:04.399 --> 00:14:06.399
这个呃，我们应该把它固定

00:14:06.399 --> 00:14:10.240
宽度，然后我们可以根据它的数量来验证它的宽度

00:14:10.240 --> 00:14:13.120
数组中的元素对一对

00:14:13.120 --> 00:14:15.199
其他事情，所以那里还有额外的验证

00:14:15.199 --> 00:14:18.160
也有机会考虑将其更改为很少

00:14:18.160 --> 00:14:21.279
我会再看一看

00:14:21.279 --> 00:14:24.800
我们最终在javascript方面做了什么，

00:14:24.800 --> 00:14:29.519
我认为还有其他两个地方

00:14:29.519 --> 00:14:32.639
阻碍以及使用小尾数，所以我认为还有更多的标准化

00:14:32.639 --> 00:14:36.639
围绕小端，并且更容易与一些

00:14:36.639 --> 00:14:38.800
当你做完的时候，有多少个

00:14:38.800 --> 00:14:41.519
一点，只是因为我们有更多的工具

00:14:41.519 --> 00:14:44.720
所以也许我们会做那个，但无论如何这是一回事，而另一回事是

00:14:44.720 --> 00:14:47.600
我们将把一个关键的联合变成一个

00:14:47.600 --> 00:14:51.040
友善的联盟um，这样我们就放弃了地图和

00:14:51.040 --> 00:14:55.040
字符串键um，最后以元素结尾

00:14:55.040 --> 00:14:58.079
本身，这样就可以在另一端保存字节

00:14:58.079 --> 00:15:01.760
因此，这两种格式的更改都会使它中断

00:15:01.760 --> 00:15:07.199
嗯，但我们会使其更接近我们的现有规格

00:15:07.199 --> 00:15:13.600
所以这里有很多空间可以对齐um，这就是

00:15:13.600 --> 00:15:18.079
我们去年尝试做，但现在我们要做嗯，然后

00:15:18.079 --> 00:15:22.560
我们有阅读和写作的潜力

00:15:22.560 --> 00:15:24.959
这与我们正在为其构建的其他库一起

00:15:24.959 --> 00:15:31.040
安培，所以这都是正数，一路走来，我加了一个

00:15:31.040 --> 00:15:34.560
诊断我的打印机到我的Sea编码器解析器

00:15:34.560 --> 00:15:38.560
这真的很有趣，因此能够坚持使用cbor和

00:15:38.560 --> 00:15:43.040
打印出非常好的诊断格式，这非常令人满意

00:15:43.040 --> 00:15:47.360
嗯，那是我的一周

00:15:48.480 --> 00:15:57.040
接下来是eric是的，所以我也花了一些时间做呃

00:15:57.040 --> 00:16:01.759
谦卑的东西，并添加一些基准

00:16:01.759 --> 00:16:04.240
那些正在看的图书馆，只是试图像一个总体

00:16:04.240 --> 00:16:09.680
对他们正在发生的事情的统计了解，这就是

00:16:09.680 --> 00:16:13.120
有趣的是，我们试图了解那里的一些缓存工作，

00:16:13.120 --> 00:16:17.040
我不知道只是从性能方面得到更多图表

00:16:17.040 --> 00:16:20.839
到目前为止，还需要进行一些类似的工作，但还不算很多，所以

00:16:20.839 --> 00:16:25.600
在代码生成新闻中扩展um我总是有一点点

00:16:25.600 --> 00:16:32.160
现在go代码生成器支持联合类型

00:16:32.160 --> 00:16:36.639
如果我们对所有已完成的项目进行全面审查，那将是一件很酷的事情

00:16:36.639 --> 00:16:40.720
代码生成中的功能现在我们有了地图我们有了列表我们已经有了列表

00:16:40.720 --> 00:16:44.000
现在有键的工会和类似的工会

00:16:44.000 --> 00:16:48.240
我们已经触及了这张地图，上周说元组被触动了，我们

00:16:48.240 --> 00:16:51.279
将struxx的字符串连接一段时间，当然，我们已经

00:16:51.279 --> 00:16:57.839
标量列表中的字符串字节链接是的，这是很多事情

00:16:57.839 --> 00:17:02.560
因此，嗯，还有更多的功能可以使余热

00:17:02.560 --> 00:17:05.839
已实施，但就像我们真的要深入研究esotera一样，

00:17:05.839 --> 00:17:10.400
像很少使用的表示模式，这些都是剩下的东西

00:17:10.400 --> 00:17:12.640
现在，我开始可以使用它了

00:17:12.640 --> 00:17:17.199
以Alpha方式，这仍在产生更多的测试，

00:17:17.199 --> 00:17:21.039
修复，但我现在将其称为alpha可用

00:17:21.039 --> 00:17:25.520
开始磨碎东西，然后看看我是否可以将它们连接起来，答案

00:17:25.520 --> 00:17:30.799
就像是的，实际上，如果有人想和我一起玩，我可以

00:17:30.799 --> 00:17:36.080
阿尔法的事情，那么我会说它开始是大约那个时候

00:17:37.440 --> 00:17:41.440
就是这样，使状态报告正确无误

00:17:41.440 --> 00:17:46.810
谢谢，接下来是迈克尔·耶，让我在这里列出清单

00:17:46.810 --> 00:17:53.120
[音乐]哦，来太多东西了

00:17:53.120 --> 00:17:57.840
好的，嗯，所以我确实弄清楚了如何存储

00:17:57.840 --> 00:18:02.160
ipl d在git lfs中阻止，所以我为此写了一个存储后端

00:18:02.160 --> 00:18:05.440
为dagdb编写了一项功能以对其进行测试，这很不错

00:18:05.440 --> 00:18:11.280
您甚至可以建立资料库，并给予github动作作为

00:18:11.280 --> 00:18:13.440
数据库类型，然后它将拉动所有

00:18:13.440 --> 00:18:16.160
来自github操作的当前环境中的凭据

00:18:16.160 --> 00:18:23.039
并使用它作为其存储机制，真棒lf lfs就像

00:18:23.039 --> 00:18:26.160
就像我曾经不得不逆转的最糟糕的技术之一

00:18:26.160 --> 00:18:30.400
工程师，但是嗯，所以它很慢，但是就像

00:18:30.400 --> 00:18:34.400
有点令人惊奇，因为它只是您知道github repos及其所有内容

00:18:34.400 --> 00:18:36.640
真的很好，在github上也不是很吵

00:18:36.640 --> 00:18:42.400
回购，因为它是l和lfs嗯，我知道

00:18:42.400 --> 00:18:46.320
试图完成我真的不喜欢的工作

00:18:46.320 --> 00:18:50.160
我们现在拥有的用于尝试从esm构建东西的工具

00:18:50.160 --> 00:18:54.880
图书馆，所以我在周末坐下来尝试

00:18:54.880 --> 00:18:58.640
基本上只是真正构建了ipjs构建工具

00:18:58.640 --> 00:19:02.320
我只想要一个工作流程，就像我们编写一个非常简单的

00:19:02.320 --> 00:19:08.559
um esm文件或对不起，我们在javascript中编写了esm模块，

00:19:08.559 --> 00:19:12.880
那么我们只有一对名为export的文件，它们指向源中的任何东西

00:19:12.880 --> 00:19:15.679
或者像散货船永远想要的东西，而我们没有所有的东西

00:19:15.679 --> 00:19:21.120
这些文件放在根目录和um中，然后将生成

00:19:21.120 --> 00:19:25.200
正确的通用js和esm以及新的package.json和您将要执行的所有操作

00:19:25.200 --> 00:19:28.640
需要将其发布为一个通用模块，该模块将在任何地方都可以使用

00:19:28.640 --> 00:19:34.559
嗯，这就像现在完成了80嗯，我认为那件事真的

00:19:34.559 --> 00:19:36.559
让我绊倒了，因为我想得太多，你不

00:19:36.559 --> 00:19:39.280
实际上，大多数东西都需要一个编译器，您可以操作

00:19:39.280 --> 00:19:43.840
ast，它的速度要快得多，所以即使我也进行了ast解析操作，

00:19:43.840 --> 00:19:47.200
工人，所以它也是一个非常快的构建工具

00:19:47.200 --> 00:19:51.440
所以应该尽快完成，是的，

00:19:51.440 --> 00:19:54.640
帮助我们像现在所有模块中的所有模块一样发布

00:19:54.640 --> 00:20:01.520
新的js多种格式和块堆栈，所以嗯

00:20:01.520 --> 00:20:04.559
修复错误和js多种​​格式后，我又重新运行了测试，因为它们具有

00:20:04.559 --> 00:20:08.720
因为摩卡咖啡中的帕拉迪娜虫子而使乌龟碎了

00:20:08.720 --> 00:20:12.000
8 um，我为ipld写了更多文档

00:20:12.000 --> 00:20:16.640
在dagdb中，这就是我上周所做的

00:20:16.640 --> 00:20:22.480
任何问题，谢谢，当然，它总是像

00:20:22.480 --> 00:20:27.120
最后20个是软件中最简单的

00:20:27.120 --> 00:20:29.760
项目[笑声]

00:20:29.760 --> 00:20:33.440
否否ii我以为我认为这里的最后20％是

00:20:33.440 --> 00:20:37.200
这很容易，这是我们将要遇到的错误的百分之二

00:20:37.200 --> 00:20:41.840
以后找到，但是是的，我想我想我认为

00:20:41.840 --> 00:20:45.120
完成这项工作实际上并没有那么多工作

00:20:45.120 --> 00:20:49.840
嗯酷嗯

00:20:50.240 --> 00:20:54.159
呃应该吧，因为我想知道是否有人在抚养，但我们也有

00:20:54.159 --> 00:21:02.080
就像我们正在讨论有关jscid的东西一样

00:21:02.080 --> 00:21:06.240
我给一个更新吗，其他人也想给一个更新吗？

00:21:06.240 --> 00:21:09.280
如果您谈论像迈克尔，也许迈克尔会很好

00:21:09.280 --> 00:21:13.280
因为就像我们基本上谈到了向js的过渡计划

00:21:13.280 --> 00:21:17.120
您可以正确使用多种格式吗？

00:21:17.120 --> 00:21:22.799
基本上我认为我认为我们登陆的是

00:21:22.799 --> 00:21:25.440
我们要对js多种格式进行的更改

00:21:25.440 --> 00:21:31.919
um很快就会在jsc id um中访问，并且所有旧版本

00:21:31.919 --> 00:21:35.039
方法将显示警告，但仍然可以使用

00:21:35.039 --> 00:21:39.520
嗯，这样对人们来说就像一条不错的过渡之路

00:21:39.520 --> 00:21:43.039
嗯，有一种最终的症结，我想你们中的很多人都放弃了

00:21:43.039 --> 00:21:45.039
离开，我认为我们最终没有

00:21:45.039 --> 00:21:50.720
做那个嗯，所以我实际上支持了这个

00:21:50.720 --> 00:21:55.919
采取js多种格式的公关使其看起来像数组缓冲区视图，因此它具有

00:21:55.919 --> 00:21:59.600
就像一个点缓冲区属性，它是一个8单元数组，而不是一个新的js缓冲区，

00:21:59.600 --> 00:22:03.280
与旧的属性冲突，该属性是一个node.js缓冲区，但它仍然

00:22:03.280 --> 00:22:06.720
如果这是对的，那是可行的，但是那是因为

00:22:06.720 --> 00:22:10.000
这可能是一个视图，然后缓冲区可能会更大

00:22:10.000 --> 00:22:13.360
比实际的CID高，这是无声的不良行为

00:22:13.360 --> 00:22:16.799
该kreptan，所以我实际上将其拉出，现在没有缓冲

00:22:16.799 --> 00:22:19.120
属性，如果您尝试

00:22:19.120 --> 00:22:24.159
访问它或将其写入事物um，这就是我们将随附的内容

00:22:24.159 --> 00:22:27.200
而在js多种格式中，然后我们会看一下

00:22:27.200 --> 00:22:30.320
所有这些变化降落之后的景观

00:22:30.320 --> 00:22:34.240
在一个jsc id中，并确定我们是否要添加回去

00:22:34.240 --> 00:22:37.280
这就是所有这些的地方，但是是的，我们有一个更好的选择

00:22:37.280 --> 00:22:42.000
过渡计划实际上比我们以前拥有的净额多

00:22:42.000 --> 00:22:45.919
今天检查，我认为数组缓冲区不

00:22:45.919 --> 00:22:49.600
具有缓冲区属性

00:22:51.280 --> 00:22:54.720
现在键入的数组有，但数组缓冲区没有

00:22:54.720 --> 00:22:58.159
射线缓冲区查看它称为数组缓冲区视图

00:22:58.159 --> 00:23:04.400
并且那些具有缓冲属性，因为数组缓冲不好，是的，我知道我

00:23:04.400 --> 00:23:06.720
知道是因为它们是数组缓冲区

00:23:06.720 --> 00:23:10.240
对不起，对不起，我实际上说过，对不起，对不起，我说错了

00:23:10.240 --> 00:23:13.919
我们添加的buffer属性不是八个数组，而是一个数组

00:23:13.919 --> 00:23:16.400
缓冲区数组缓冲区没有属性

00:23:16.400 --> 00:23:20.080
因为它们是buffer属性

00:23:20.640 --> 00:23:23.840
数组缓冲区是一个内存的字面量

00:23:23.840 --> 00:23:28.080
ui数据数组是一个视图和一个人类数据射线，以及所有其他

00:23:28.080 --> 00:23:31.360
就像数组缓冲区视图一样，被认为是该视图，并且

00:23:31.360 --> 00:23:35.120
包含数据视图的属性与

00:23:35.120 --> 00:23:38.559
好吧，所以基本上，如果我们

00:23:38.559 --> 00:23:40.640
谈论你应该谈论的数组缓冲区

00:23:40.640 --> 00:23:46.559
数组缓冲区视图可能是这样

00:23:47.520 --> 00:23:52.400
这就是这太他妈的了，就像该死的可怕

00:23:52.400 --> 00:23:55.679
标准，所以您可能正在谈论打字

00:23:55.679 --> 00:23:59.039
数组，因为类型化数组都具有相同的方法，所以您去了

00:23:59.039 --> 00:24:03.200
八个数组和16个数组变成了您所知道的所有

00:24:03.200 --> 00:24:08.880
不同的视图类型um数组缓冲区视图将这些视图称为

00:24:08.880 --> 00:24:12.720
数据视图和数据视图就像一个数组的视图

00:24:12.720 --> 00:24:15.520
您可以随后对其进行操作的缓冲区

00:24:15.520 --> 00:24:20.240
每种类型的数组，所以就像另一件事一样

00:24:20.240 --> 00:24:23.600
因为我们没有足够的东西是javascript中的二进制类型，所以我们

00:24:23.600 --> 00:24:27.679
必须像另一个一样，是的，所以一个数组缓冲区视图

00:24:27.679 --> 00:24:33.840
就像所有这些标准一样

00:24:37.760 --> 00:24:41.200
我在找窗户好吧，嗯，很酷

00:24:41.200 --> 00:24:47.840
嗯

00:24:48.159 --> 00:24:51.440
我想很酷，然后我们结束本次会议

00:24:51.440 --> 00:24:55.840
一个半小时棒极了你想做你想见面吗

00:24:55.840 --> 00:24:59.520
经过这么快的真正再见之后，每个人我都停止了直播

00:24:59.520 --> 00:25:06.240
流在录音再见和我

