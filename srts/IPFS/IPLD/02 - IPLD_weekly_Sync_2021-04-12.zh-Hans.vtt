WEBVTT
Kind: captions
Language: zh-Hans

00:00:11.759 --> 00:00:15.280
欢迎大家参加本周的ipld同步

00:00:15.280 --> 00:00:19.119
满足四月

00:00:19.119 --> 00:00:25.199
2021年12月12日，每周我们都会讨论这些内容

00:00:25.199 --> 00:00:28.640
是的，人们在努力，有没有

00:00:28.640 --> 00:00:33.600
实际工作过，但有其他团队的新闻并在这里分享

00:00:33.600 --> 00:00:40.879
嗯，我从我自己开始，所以我仍在从事这个js工作

00:00:40.879 --> 00:00:48.559
js ipfs中的多种格式仍然是相同的请求请求

00:00:48.559 --> 00:00:52.480
计划看起来像这样[音乐]

00:00:52.480 --> 00:00:57.360
问题或类似的一件大事是，在js ipfs中，我们也有很多

00:00:57.360 --> 00:01:00.640
的例子，他们使用一些其他

00:01:00.640 --> 00:01:07.680
捆绑器，用于他们的工作，并全力以赴获取js

00:01:07.680 --> 00:01:12.080
多种格式的内容还与js的问题结合在一起

00:01:12.080 --> 00:01:15.840
多种格式被编写为es6模块并合并

00:01:15.840 --> 00:01:19.119
具有javascript中常见js模块的es6模块是

00:01:19.119 --> 00:01:22.000
已经很困难，如果您变得更加困难

00:01:22.000 --> 00:01:29.360
在其中输入打字稿，嗯，问题是

00:01:29.360 --> 00:01:32.560
到处都是，但肯定是

00:01:32.560 --> 00:01:39.280
捆绑器，因为它们经常支持很好的通用js或me6

00:01:39.280 --> 00:01:44.000
模块等等，所以这可能很困难，

00:01:44.000 --> 00:01:48.399
所以我的拉取要求可能已经足够了

00:01:48.399 --> 00:01:51.840
并非所有测试都通过了，但应该有可能建立

00:01:51.840 --> 00:01:57.759
示例并运行示例，这样我们至少可以尝试一下

00:01:57.759 --> 00:02:05.680
整个新系统可以一起工作，希望结果是

00:02:05.680 --> 00:02:14.000
它可以正常工作，然后我们可以再次完善这些拉取请求

00:02:14.000 --> 00:02:20.400
嗯，是的，如果我说我们，我是说其他人

00:02:20.400 --> 00:02:27.040
因为最后我将全职转移到另一个

00:02:27.040 --> 00:02:30.560
团队，所以我不会用javascript iphone这些

00:02:30.560 --> 00:02:33.200
东西了

00:02:33.519 --> 00:02:39.200
以及我已经承担的维护责任

00:02:39.200 --> 00:02:43.599
嗯，让大脑和杆都疼，我们会做的

00:02:43.599 --> 00:02:47.200
它就像持续不断地一样，所以

00:02:47.200 --> 00:02:50.080
每当有需要释放的东西时，我负责

00:02:50.080 --> 00:02:55.040
因为我会把维护费交给他们，他们会做

00:02:55.040 --> 00:02:58.959
发布，因为基本上没有必要主动进行所有操作

00:02:58.959 --> 00:03:02.959
我可能是存储库的维护者，因为有很多

00:03:02.959 --> 00:03:06.080
甚至有一些我们不发布

00:03:06.080 --> 00:03:10.560
接下来的几年，这就是方法

00:03:10.560 --> 00:03:14.159
是的，希望那两个公关最终会成为

00:03:14.159 --> 00:03:20.720
合并后，我们将看到UM可能还会收到的其他新闻

00:03:20.720 --> 00:03:26.080
谈论他是否会在那儿，他花时间去追求多种格式

00:03:26.080 --> 00:03:30.799
j堆栈bb和js x seabor

00:03:30.799 --> 00:03:34.400
使它们与整个打字稿兼容

00:03:34.400 --> 00:03:40.640
和评论，还有我六个，他们是目前的公关，我认为他们

00:03:40.640 --> 00:03:44.799
看起来不错，嗯，他们仍然需要批准，但是我

00:03:44.799 --> 00:03:48.239
想想他回来的时候，那些将被合并

00:03:48.239 --> 00:03:52.720
然后再次是pr um

00:03:52.720 --> 00:03:57.519
前面提到的也可以更新，然后我们应该

00:03:57.519 --> 00:04:01.280
为整个新的js多种格式正确键入

00:04:01.280 --> 00:04:06.080
我们拥有的堆栈[音乐]

00:04:06.080 --> 00:04:14.480
是的，所以我列表上的下一个内容是eric

00:04:14.480 --> 00:04:18.560
好吧，经过一段时间的低迷，我这周变得有点兴奋

00:04:18.560 --> 00:04:22.479
因为我找到了一些我想要的工具

00:04:22.479 --> 00:04:25.840
找到时间最长，我对此很满意

00:04:25.840 --> 00:04:28.960
我们将获得更多的文档和规格

00:04:28.960 --> 00:04:34.000
网站对我有用，我发现了一个新的静态网站生成器工具，我非常

00:04:34.000 --> 00:04:38.080
对此感到兴奋的是，它只是选中了所有复选框，

00:04:38.080 --> 00:04:40.320
的功能，它仍然是基于JavaScript的，所以我们可以

00:04:40.320 --> 00:04:44.000
在那里进行各种扩展，就像我们可以带来语法一样

00:04:44.000 --> 00:04:47.759
荧光笔扩展程序，它仍将使用高亮js

00:04:47.759 --> 00:04:52.160
但这也是10个数量级的基数

00:04:52.160 --> 00:04:56.240
快于我们之前遇到的viewpress恶作剧

00:04:56.240 --> 00:05:00.720
这让我非常高兴，而且修剪器很多

00:05:00.720 --> 00:05:05.039
输出也不会抛出一堆

00:05:06.320 --> 00:05:08.960
我不会再在相机上谈论我对Viewpress的感受了

00:05:08.960 --> 00:05:12.479
这样说，我正在检查的这个新工具称为

00:05:12.479 --> 00:05:18.479
11 tjs，这很好，我已经做了一些演示

00:05:18.479 --> 00:05:22.720
已经使用它进行了原型工作，我已经尝试了八个不同的静态站点

00:05:22.720 --> 00:05:26.800
发电机的程度，动手尝试不

00:05:26.800 --> 00:05:32.240
只是读了一下，但建立了演示八，这是一个很好的

00:05:32.240 --> 00:05:37.680
我很高兴，无论如何，所以我要做很多工作

00:05:37.680 --> 00:05:42.000
那个我的梦想仍然是统一许多不同的仓库

00:05:42.000 --> 00:05:47.039
当我经历这一过程并在一处获得更多这些内容时

00:05:47.039 --> 00:05:50.560
我仍然会将内容整理到docs目录和规范中

00:05:50.560 --> 00:05:54.800
目录，因为写作风格和受众甚至

00:05:54.800 --> 00:05:57.840
对于这些事情，贡献流可能会截然不同

00:05:57.840 --> 00:06:02.479
但我要把它们放在一个仓库中，然后还要做更多的文档

00:06:02.479 --> 00:06:05.919
我想在我们周围的所有其他东西中

00:06:05.919 --> 00:06:09.520
开始收集指向所有不同的出色工具的链接

00:06:09.520 --> 00:06:15.039
本身不在核心库中，而是在我们的生态系统中，所以我在寻找

00:06:15.039 --> 00:06:18.880
前进到那个嗯，我也将警告所有人

00:06:18.880 --> 00:06:21.120
这将使我追赶人们的领域

00:06:21.120 --> 00:06:24.400
关于合并规格库中的任何PR或

00:06:24.400 --> 00:06:28.160
文档存储库或附近的任何内容，因为

00:06:28.160 --> 00:06:32.240
我想统一所有这些回购协议，并希望将

00:06:32.240 --> 00:06:37.759
尽可能多的历史，所以我希望我们可以合并

00:06:37.759 --> 00:06:41.680
每一件东西或决定关闭它，因为我想将它们全部拖到一个

00:06:41.680 --> 00:06:44.639
如此开放的公关将成为我的敌人

00:06:44.639 --> 00:06:49.199
一段时间，所以很多人收到很多电子邮件

00:06:49.199 --> 00:06:52.880
关于github上的内容，我认为，我将继续追赶人们，

00:06:52.880 --> 00:06:55.360
这真是令人毛骨悚然的耻辱杆今天关闭了，因为

00:06:55.360 --> 00:07:03.840
他有几个，是的，这是我最大的兴奋

00:07:04.479 --> 00:07:08.080
谢谢，下一个是真实的

00:07:08.800 --> 00:07:12.560
很酷，所以我们将以较慢的方式继续

00:07:12.560 --> 00:07:17.360
在此ipld和ipfs中找到需要发生的其余事情

00:07:17.360 --> 00:07:23.120
um的工作流程和um的工作方式和代码

00:07:23.120 --> 00:07:25.840
评论等等，出现了几件事

00:07:25.840 --> 00:07:30.800
有趣的是，有一个共享测试

00:07:30.800 --> 00:07:40.400
现在我们正在使用json在ipfs中创建dag pb块

00:07:40.400 --> 00:07:44.800
ipld prime编解码器已经很明显，我们不能再这样做了

00:07:44.800 --> 00:07:49.680
因为我们的json编解码器实际上并没有实现dag的一部分

00:07:49.680 --> 00:07:54.560
json规范，您可以在其中使用字节，因此无法创建字节

00:07:54.560 --> 00:07:58.080
dagpv事物的数据密钥中的字段，然后

00:07:58.080 --> 00:08:02.000
抱怨，永远不会让你代表一个人可能会变成的模式

00:08:02.000 --> 00:08:05.199
到wpb对象

00:08:05.680 --> 00:08:08.879
如果这仍然可行，那就太好了

00:08:08.879 --> 00:08:15.759
更新后，小狗的眼睛还可以，所以要求是一微米

00:08:15.759 --> 00:08:18.560
我想指出的第二件事是，在与我们交谈时遇到了

00:08:18.560 --> 00:08:23.360
关于接口的院长是um，我们在ipld prime中有选择器

00:08:23.360 --> 00:08:29.120
像一个已编译的东西一样具有数据表示形式的斧头

00:08:29.120 --> 00:08:32.159
节点，然后从您解析此课程的节点开始

00:08:32.159 --> 00:08:36.399
你有一个选择器，嗯，这是有原因的

00:08:36.399 --> 00:08:40.000
要求根据本次演讲取回某项内容

00:08:40.000 --> 00:08:42.080
您可能想要的是它的数据表示形式

00:08:42.080 --> 00:08:45.440
因为那仍然可能会跨越网络，并且需要包含在其数据中

00:08:45.440 --> 00:08:48.240
格式，然后执行并变成一个

00:08:48.240 --> 00:08:51.040
像您这样的选择器可能需要它的数据表示形式

00:08:51.040 --> 00:08:55.040
嗯，但是您要注意的一件事是，当您这样做时，最终会得到一个界面

00:08:55.040 --> 00:08:58.080
这就像获取节点逗号节点一样

00:08:58.080 --> 00:09:03.839
您的类型签名，然后是获得该类型的人

00:09:03.839 --> 00:09:07.040
签名提示就像哪个是选择器，哪个是dag根

00:09:07.040 --> 00:09:12.240
我正在做的节点，因为这些是相同的类型，所以

00:09:12.240 --> 00:09:17.760
问题有没有办法采用选择器并返回到节点

00:09:17.760 --> 00:09:21.279
因为我们想要的是一个选择器，并且如果有一种便捷的方法

00:09:21.279 --> 00:09:24.160
回到那个选择器的节点表示，然后

00:09:24.160 --> 00:09:28.399
在我们的界面用法中可能很清楚，所以

00:09:28.399 --> 00:09:32.480
要考虑的事情，然后与之分开

00:09:32.480 --> 00:09:37.839
嗯有话要说

00:09:38.240 --> 00:09:42.720
进行数据传输斜线抓取同步土地，您将收到一堆数据块

00:09:42.720 --> 00:09:49.040
现在发生的方式是将其放入a数据存储中

00:09:49.040 --> 00:09:53.200
然后最后它遍历了

00:09:53.200 --> 00:09:59.279
将其序列化为汽车，以及将其写入badge的开销

00:09:59.279 --> 00:10:01.600
然后再次阅读所有内容并将其放入汽车中

00:10:01.600 --> 00:10:05.839
having没有清理必定会导致复杂性和

00:10:05.839 --> 00:10:09.279
人们有些不高兴，所以我们可以要求

00:10:09.279 --> 00:10:12.560
当我们收到积木时，将其直接流进汽车

00:10:12.560 --> 00:10:15.440
对它们保持索引，因为我们需要的是块存储

00:10:15.440 --> 00:10:19.360
能够获取物品的一部分，因为我们这样做，这并不是

00:10:19.360 --> 00:10:23.440
碳水化合物做的事情会带静态汽车

00:10:23.440 --> 00:10:26.000
并会在其上生成索引，以便可以将其用作只读

00:10:26.000 --> 00:10:28.800
大型商店，但我在

00:10:28.800 --> 00:10:33.200
一个东西的实现，也可以通过将它们附加到后面来支持put

00:10:33.200 --> 00:10:37.440
并附加到基于插入排序的索引um，以便

00:10:37.440 --> 00:10:41.519
你可以做到这一点，然后你可以得到一辆单车和碳水化合物

00:10:41.519 --> 00:10:44.399
确实制造了一辆无效的汽车，因为它没有放置任何

00:10:44.399 --> 00:10:49.040
根在标题中，除非您事先指定它们，所以我想您

00:10:49.040 --> 00:10:51.760
可以制造有效的汽车，但是您也可以制造无效的汽车

00:10:51.760 --> 00:10:54.959
也可以只是在任何地方都没有引用的put块

00:10:54.959 --> 00:10:58.800
所以这可能很糟糕，您也可以将它们按照某种奇怪的顺序排列，这并不是

00:10:58.800 --> 00:11:02.079
遍历最终将它们放入的顺序相同，如果

00:11:02.079 --> 00:11:05.440
所以不一定要散列同一件事

00:11:05.440 --> 00:11:10.399
因此您可能仍需要对该车进行重新读取，其索引为

00:11:10.399 --> 00:11:13.120
如果要确保您的另一辆车

00:11:13.120 --> 00:11:18.240
哈希符合您的期望，例如我们只有一个规范

00:11:18.240 --> 00:11:22.079
状态结束的事情，听起来像是当前的go数据

00:11:22.079 --> 00:11:26.399
传输确实按顺序接收块，因此

00:11:26.399 --> 00:11:28.560
您可以直接执行此操作，而跳过其他操作

00:11:28.560 --> 00:11:31.600
读写，但您可能至少要验证一下

00:11:31.600 --> 00:11:33.920
还有其他一些工作方式，例如如何使用此功能

00:11:33.920 --> 00:11:38.480
它的边缘非常锋利，但对，似乎是一件很重要的事情

00:11:38.480 --> 00:11:42.320
汽车之间一直在进行类似的对话

00:11:42.320 --> 00:11:45.360
这是否足够我们要做基于Dar的事情

00:11:45.360 --> 00:11:48.720
嗯，所有标题或汽车v2或其他内容在哪里

00:11:48.720 --> 00:11:52.320
仍然有一些关于汽车的对话，我想如果你有兴趣的话

00:11:52.320 --> 00:11:55.920
在讨论中，劳尔可能会继续

00:11:55.920 --> 00:12:00.160
对我来说很重要的人

00:12:01.360 --> 00:12:04.959
谢谢[音乐]

00:12:04.959 --> 00:12:11.120
然后我有一个议程项目并不令人兴奋，因为我们已经谈过

00:12:11.120 --> 00:12:15.760
上周简要介绍了它，但是我想正式宣布它，以便

00:12:15.760 --> 00:12:18.240
我们已经讨论过是否应该真正召开这次会议

00:12:18.240 --> 00:12:22.480
因此，如果我们仅每两周召开一次会议，我们就跳过了上周

00:12:22.480 --> 00:12:26.560
嗯，所以我现在想正式问一下，我们是否应该只参加这次会议

00:12:26.560 --> 00:12:28.880
每两周一次，因为我们没有太多更新

00:12:28.880 --> 00:12:34.560
所以这是可以的，所以我会的，所以我会确保

00:12:34.560 --> 00:12:38.959
基本上更新自述文件和日历邀请，并

00:12:38.959 --> 00:12:45.920
所有这些事情，我将每两周召开一次会议，称为制棒

00:12:45.920 --> 00:12:50.959
嗯嗯

00:12:50.959 --> 00:12:53.920
很酷的

00:12:54.560 --> 00:13:00.639
是的，这就是我所拥有的，还有其他东西吗

00:13:01.040 --> 00:13:06.160
呃，你想只谈一谈你提出的一些东西吗？

00:13:13.440 --> 00:13:17.200
我看过那个公关，那里有两种不同类型的节点

00:13:17.200 --> 00:13:22.480
它们都是goeng合同中的节点一词，

00:13:22.480 --> 00:13:25.680
我同意那令人困惑并且很烂我

00:13:25.680 --> 00:13:30.079
不知道我们应该怎么做，尽管这也是

00:13:30.079 --> 00:13:32.160
就像您拥有这两个数据模型一样

00:13:32.160 --> 00:13:35.839
树木之类的

00:13:36.320 --> 00:13:39.600
这就是您的想法，是的，这只是一种不幸

00:13:39.600 --> 00:13:44.320
嗯，我的意思是我们输入了变量的名称，这会有所帮助

00:13:44.320 --> 00:13:51.040
对，但是像golang类型检查器一样

00:13:51.040 --> 00:13:54.240
做任何有用的事情来帮助您，因为

00:13:54.240 --> 00:13:58.880
那就是那个选择器节点树

00:13:58.959 --> 00:14:01.680
您在哪里可以验证此权限，我们如何告诉编译器

00:14:01.680 --> 00:14:04.000
关于这个，我不认为我想要我不认为我

00:14:04.000 --> 00:14:08.399
关心我不是，我不是在尝试获得休息级别的堆栈输入，这要多得多

00:14:08.399 --> 00:14:10.959
对于使用它的程序员来说，就像

00:14:10.959 --> 00:14:13.760
对他们来说很清楚，当他们调用此参数时，应以哪种顺序放置参数

00:14:13.760 --> 00:14:16.000
这样的方法对于

00:14:16.000 --> 00:14:20.800
不适合的人可以使用golang类型别名

00:14:20.800 --> 00:14:25.360
功能，如果它让您感觉良好，但不会

00:14:25.360 --> 00:14:33.760
检查当当的东西，是的，是的，我不认为我们愿意

00:14:33.760 --> 00:14:36.160
解析选择器类型挂在那

00:14:36.160 --> 00:14:38.320
无条件地整棵树，因为

00:14:38.320 --> 00:14:43.279
就像我认为他们的开销通常很奇怪

00:14:43.279 --> 00:14:46.079
如果你不想

00:14:46.959 --> 00:14:51.760
um dec json字节，所以是的，肯定有一个缺少的功能

00:14:51.760 --> 00:14:54.399
在这里的全球主要编解码器实现中

00:14:54.399 --> 00:15:02.320
嗯，您是否能够缩小ipfs中的旧功能是否

00:15:02.320 --> 00:15:08.880
我们正在尝试支持它是否确实符合我们的方式

00:15:08.880 --> 00:15:12.959
更新了json规范以描述这些字节

00:15:12.959 --> 00:15:21.279
还是接近或我是说我以为有一些API

00:15:21.519 --> 00:15:25.760
拿了一些类似json的东西，它碰巧有一种表示方式

00:15:25.760 --> 00:15:28.240
个字节，但不一定与

00:15:28.240 --> 00:15:31.839
JSON规范实际上表示我没有看过

00:15:31.839 --> 00:15:35.120
我以规格说明的方式尝试过，但我没有得到字节

00:15:35.120 --> 00:15:41.440
好吧好吧，我认为这比那时要复杂得多

00:15:41.440 --> 00:15:47.360
然后我放弃并手工制作了一些鱼梨，并以海柏拉为例

00:15:47.680 --> 00:15:51.279
我想可能是这样，所以只要记住那根杆

00:15:51.279 --> 00:15:56.079
试着把它弄清楚，因为我什至像我们一样回忆

00:15:56.079 --> 00:16:01.360
同意，现在应该与多基一起使用

00:16:01.360 --> 00:16:04.800
还是没有，像这样的东西，所以我什至不确定是否有

00:16:04.800 --> 00:16:08.639
我同意我们将放弃的那部分，因为引入

00:16:08.639 --> 00:16:13.360
更多的多基变种使我们更难拥有规范的形式

00:16:13.360 --> 00:16:16.240
没有人喜欢

00:16:16.880 --> 00:16:21.360
关键不是您可以拥有不同的多库，而应

00:16:21.360 --> 00:16:26.800
因此我们同意二进制格式应为64。

00:16:26.800 --> 00:16:30.000
但是问题是基本编码的东西应该

00:16:30.000 --> 00:16:34.720
是否将第一个字节前缀作为多基数

00:16:34.720 --> 00:16:37.920
这是一次讨论，我如我所说，我不记得结果了

00:16:37.920 --> 00:16:42.320
但我认为Rod有意见，所以无论如何，只要有人

00:16:42.320 --> 00:16:45.839
实施它只是准备好您可能会

00:16:45.839 --> 00:16:52.000
一次更改此第一个字节，是的，无论我们决定还是决定

00:16:52.000 --> 00:16:58.639
um ii认为我们应该立即强制执行该决定，

00:16:58.639 --> 00:17:02.959
然后坚持下去，这也是目前开放公关的事情之一

00:17:02.959 --> 00:17:05.600
在我刚刚发现的规格回购中

00:17:05.600 --> 00:17:09.600
回顾我需要追逐哪些内容的人，以及

00:17:09.600 --> 00:17:13.439
所以是的，现在有多个原因让我想要

00:17:13.439 --> 00:17:18.799
被决定并登陆是的，但是我但是我想我会幸福的

00:17:18.799 --> 00:17:22.319
推迟这个决定，所以我不在乎这是什么，但罗杰

00:17:22.319 --> 00:17:25.360
做出决定，因为就像他在他身上花了很多时间一样，这是他的公关

00:17:25.360 --> 00:17:28.559
所以是的，我要打扰他了，所以他应该

00:17:28.559 --> 00:17:32.640
是的，所以我对他投入如此多的想法感到满意

00:17:32.640 --> 00:17:35.679
所以我很高兴，但他应该做出决定

00:17:35.679 --> 00:17:39.600
因为像是的，他花了很多时间在上面

00:17:39.600 --> 00:17:43.950
是的很酷[音乐]

00:17:45.360 --> 00:17:51.760
呃，这是什么样子，那是我们拥有的所有物品

00:17:51.760 --> 00:17:56.799
猜猜，所以我觉得还有其他

00:17:58.160 --> 00:18:03.120
您正在做的一些碳索引工作很酷，仅此而已

00:18:03.440 --> 00:18:06.559
还有可能我们应该做的另外几个实现

00:18:06.559 --> 00:18:09.760
还写，以便我们可以进行速度比较，并找出实际

00:18:09.760 --> 00:18:12.840
在如何最大程度地减少系统调用方面很有意义

00:18:12.840 --> 00:18:19.200
开销，这基本上就是索引

00:18:19.200 --> 00:18:23.679
所以这是一个汽车文件，也有一个索引

00:18:23.679 --> 00:18:31.919
好的，我应该检查一下，因为我已经花了十年时间在索引上，所以

00:18:31.919 --> 00:18:34.480
这不是一个非常

00:18:35.200 --> 00:18:38.400
是的，我要说的是外部索引，不是

00:18:38.400 --> 00:18:44.799
汽车文件本身的一部分，有一个单独的文件

00:18:44.799 --> 00:18:47.679
在点IDX中与汽车文件的名称相同

00:18:47.679 --> 00:18:52.400
并包含一个sid到其在汽车中的偏移量的地图

00:18:52.400 --> 00:18:59.520
好的，很酷，只是在偏移处坐着，所以

00:18:59.520 --> 00:19:03.039
没什么好想的

00:19:03.840 --> 00:19:08.240
它允许我制作ii，如果我不知道是否应该在多编解码器中注册

00:19:08.240 --> 00:19:11.840
或什么，但ii使用第一个字节uvarium选择

00:19:11.840 --> 00:19:15.039
这是什么类型的格式，因为我尝试了几种不同的格式

00:19:15.039 --> 00:19:19.919
嗯，我认为我没有与其他杂物重叠

00:19:19.919 --> 00:19:24.000
好的，但是就像您可以像固定的一样序列化它

00:19:24.000 --> 00:19:27.760
宽度，如果您知道所有的sid

00:19:27.760 --> 00:19:31.760
是相同的哈希，那么你知道然后你就可以说很棒

00:19:31.760 --> 00:19:35.600
对于这个文件，它将像是32个字节

00:19:35.600 --> 00:19:41.280
哈希，然后是8个字节的偏移量，现在，如果

00:19:41.280 --> 00:19:45.520
如果您有多种类型的哈希，它们就不同了，那么您就不能

00:19:45.520 --> 00:19:48.880
当然，嗯，所以它有一个选择器

00:19:48.880 --> 00:19:52.080
像这样的一开始就是您可以跨步的

00:19:52.080 --> 00:19:57.200
还是就像我们将其放在哈希映射中，然后在其上将其称为gob hash一样，

00:19:57.200 --> 00:19:59.840
这是golang决定采取的任何疯狂措施

00:19:59.840 --> 00:20:03.600
将其表示为它的记忆还是像是的，是的，我有一些

00:20:03.600 --> 00:20:08.320
我尝试获得相对大小和性能的不同

00:20:08.320 --> 00:20:13.280
好的，嗯，是的，因为我在问，因为就像我什么时候做的

00:20:13.280 --> 00:20:18.000
嗯，例如，我做的一些索引工作仅像

00:20:18.000 --> 00:20:24.880
像最小的最小不常用前缀一样

00:20:24.880 --> 00:20:30.400
的文件的cad，所以我没有做任何那样的酷

00:20:30.400 --> 00:20:33.600
是的，是的，但是另一个索引肯定可以

00:20:33.600 --> 00:20:37.120
这样做是因为随后它将在实际的汽车中进行查找和验证

00:20:37.120 --> 00:20:40.559
基于偏移量，它脱离了索引，所以可以做点什么

00:20:40.559 --> 00:20:45.280
通过做有用的前缀um可以使它变小，但我也想

00:20:45.280 --> 00:20:48.640
情况不像庞大的数据集

00:20:48.640 --> 00:20:54.880
就像用例没有哦

00:20:56.400 --> 00:20:59.679
我不会那么确定，因为就像

00:20:59.679 --> 00:21:03.280
如果存储cd和索引，则基本上存储

00:21:03.280 --> 00:21:07.760
cd两次正确，是的，可能是，但是我认为我们要去

00:21:07.760 --> 00:21:11.200
想要索引中的所有cid

00:21:11.280 --> 00:21:14.720
根据本地查询的用途，您不需要它

00:21:14.720 --> 00:21:18.080
如果这是您希望提供给其他节点以便能够执行的索引

00:21:18.080 --> 00:21:20.720
然后知道你有什么，你可能想把它全部

00:21:20.720 --> 00:21:23.200
艾滋病

00:21:23.280 --> 00:21:28.559
哦，如果您只关心cid，那么如果您要导出的话

00:21:28.559 --> 00:21:33.679
您的内容发现方面的事情，例如该节点上的内容，我可以

00:21:33.679 --> 00:21:36.480
给您一个索引，基本上在那一点上，我需要给您的是

00:21:36.480 --> 00:21:40.640
cids列表，但是嘿，我已经有了这个方便的东西，那就是

00:21:40.640 --> 00:21:43.919
cids列表，然后是一些蚂蚁，但您不在乎这些蚂蚁，但嘿

00:21:43.919 --> 00:21:45.919
这基本上是您关心的孩子清单

00:21:45.919 --> 00:21:48.720
大约

00:21:49.280 --> 00:21:52.400
所以根据目的，是的，我同意，是的

00:21:52.400 --> 00:21:58.240
是的，尽管这样我仍然不确定是否是一个简单的讨论，但是

00:21:58.240 --> 00:22:00.799
是的，但这也就像是的，你当然可以

00:22:00.799 --> 00:22:04.320
添加这些东西，以便如果您最终遇到索引太大的问题

00:22:04.320 --> 00:22:08.000
你当然可以做些什么，但是只要这不是问题

00:22:08.000 --> 00:22:15.440
完全可以，这不是问题，很酷

00:22:15.440 --> 00:22:18.960
无论如何，如果您最终想要的是

00:22:18.960 --> 00:22:22.080
最小前缀的代码已经在rust和

00:22:22.080 --> 00:22:25.200
去，真是太棒了，就像

00:22:25.200 --> 00:22:28.720
比我想象的要难，这也有测试

00:22:28.720 --> 00:22:32.480
因为我就像是的，我搞砸了好几次

00:22:32.480 --> 00:22:37.039
um well pull请求欢迎添加其他更有效的索引

00:22:37.039 --> 00:22:44.320
是的，很酷，嗯，很好，很酷，我想如果那里

00:22:44.320 --> 00:22:49.280
没什么别的了，我结束会议，大家见面

00:22:49.280 --> 00:22:54.720
再过两周，这是26日

00:22:54.720 --> 00:22:57.840
所以四月

