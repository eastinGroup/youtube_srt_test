WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.719 --> 00:00:04.080
等等你好吗

00:00:12.240 --> 00:00:19.720
欢迎大家参加本周的IPL同步会议，11月13日

00:00:19.720 --> 00:00:25.039
2020年，就像每周一样，我们回顾过去研究的内容

00:00:25.039 --> 00:00:29.439
一周，今天讨论任何未完成的议程项目

00:00:29.439 --> 00:00:35.760
我们甚至有一个很好的议程项目，但我从我自己开始

00:00:35.760 --> 00:00:40.480
没有那么多ipld，但是有点，所以我正在努力

00:00:40.480 --> 00:00:44.160
用于质量可寻址数据的存储系统

00:00:44.160 --> 00:00:47.920
目前的主要目的是Filecoin，但实际上通常用于

00:00:47.920 --> 00:00:52.000
因此，调用与ipld相关的可调数据

00:00:52.000 --> 00:00:56.399
嗯，它仍然是原型，还没有完成

00:00:56.399 --> 00:01:00.960
嗯，您目前甚至无法获取数据，您只能放置数据

00:01:00.960 --> 00:01:06.799
但这是下一步，是的，所以看起来很有希望

00:01:06.799 --> 00:01:11.360
如果您在具有700 GB内存的大型计算机上运行它

00:01:11.360 --> 00:01:17.040
它的工作原理真是太神奇了，因为打开这些机器很有趣，嗯

00:01:17.040 --> 00:01:19.680
是的，但是可能更多

00:01:19.680 --> 00:01:23.280
未来几周左右，但如果有人感兴趣的话

00:01:23.280 --> 00:01:28.560
书面的铁锈，你可以把链接放在那里，是的

00:01:28.560 --> 00:01:35.759
随时查看清单上的下一个是danielle

00:01:36.320 --> 00:01:39.600
很酷，所以我发布了multicodec标签，

00:01:39.600 --> 00:01:44.799
我说的是上个星期，所以实际上在发布时我遇到了一个错误

00:01:44.799 --> 00:01:48.399
在某些数据库上的go代理位置，就像您在中央位置

00:01:48.399 --> 00:01:51.439
可以下载go模块然后下载源代码，依此类推

00:01:51.439 --> 00:01:54.079
他们持续半个小时给我奇怪的错误，

00:01:54.079 --> 00:01:57.040
原来其他几个人遇到了同样的问题

00:01:57.040 --> 00:02:00.560
几个月前，所以我提出了关于那个商店的信息。

00:02:00.560 --> 00:02:04.240
有点像电视节目，您尝试在其中修复某件事，然后您发现

00:02:04.240 --> 00:02:06.640
另一件事坏了，然后您发现另一件事坏了，

00:02:06.640 --> 00:02:09.759
就像是一连串的原因，为什么当我尝试

00:02:09.759 --> 00:02:14.800
无论如何都要触摸它，这令人沮丧，我只是替换了旧的代码，

00:02:14.800 --> 00:02:19.599
当我使用该库时，内联常量，我们也

00:02:19.599 --> 00:02:25.440
与eric交谈，我们计划了很多ipld主要发行版，因此tltr是

00:02:25.440 --> 00:02:29.280
我们本周将做0.6，然后将0.7

00:02:29.280 --> 00:02:31.760
包括一堆向后兼容的更改

00:02:31.760 --> 00:02:37.120
我们讨论了一段时间，并且还回顾了出现的一些问题

00:02:37.120 --> 00:02:40.959
过去几周一直在飞行

00:02:40.959 --> 00:02:43.599
在过去的几天里，我一直在想如何

00:02:43.599 --> 00:02:47.200
自动执行一些较大的低级更改，例如进行

00:02:47.200 --> 00:02:50.720
像boolean这样的ass foo字符串等等

00:02:50.720 --> 00:02:53.840
方法不是返回器，因为这很容易

00:02:53.840 --> 00:02:57.519
足以在界面中进行更改，但它将触动您所知

00:02:57.519 --> 00:03:01.760
成百上千的代码行，然后手动执行，简直太可怕了

00:03:01.760 --> 00:03:04.400
所以我尝试了几种工具

00:03:04.400 --> 00:03:08.560
没用，我想我知道我想出了一种方法

00:03:08.560 --> 00:03:12.959
而且我还谈到了松弛问题，因为他提出了一个很好的观点

00:03:12.959 --> 00:03:18.959
嗯，在一行中，您可以做点小技巧

00:03:18.959 --> 00:03:22.720
索引到地图，并断言是某种类型

00:03:22.720 --> 00:03:26.879
而且这两种情况都可以返回布尔值，如果您同时在这两种情况下

00:03:26.879 --> 00:03:30.959
一旦将其弄糊涂，您会感到困惑

00:03:30.959 --> 00:03:33.760
如果您想一想，那很明显是一秒钟

00:03:33.760 --> 00:03:37.120
一个，但是如果您只是快速浏览一下代码，可能会造成混乱

00:03:37.120 --> 00:03:40.720
并去ipfs，我们发现像四个不同的错误

00:03:40.720 --> 00:03:44.400
因为有人混淆了此布尔值的语义

00:03:44.400 --> 00:03:47.920
所以我们谈论了一段时间，这是松弛的威胁，而我

00:03:47.920 --> 00:03:51.599
起草了围棋语言的提案，试图限制

00:03:51.599 --> 00:03:55.040
在单个表达式中同时做这两种事情的一种黑客手段

00:03:55.040 --> 00:03:58.720
我认为它会被拒绝，因为它感觉像

00:03:58.720 --> 00:04:02.080
不确定，但同时人们是否继续获得语义

00:04:02.080 --> 00:04:04.720
错误的，这是一个令人困惑的极端情况

00:04:04.720 --> 00:04:08.640
语言可能值得限制我不知道我可能会

00:04:08.640 --> 00:04:11.680
下周提高它，所以如果有人有任何反馈

00:04:11.680 --> 00:04:15.599
欢迎，也是我第二季度的优先事项

00:04:15.599 --> 00:04:20.320
四人正在撰写ci最佳做法文档

00:04:20.320 --> 00:04:22.720
去，我认为它可以上游

00:04:22.720 --> 00:04:25.360
因为它是通用的，而不仅仅是

00:04:25.360 --> 00:04:29.120
问题是上游有点停滞了，因为我等了一个月

00:04:29.120 --> 00:04:33.040
让他们的技术作家回应我，而他只是没有

00:04:33.040 --> 00:04:36.160
然后当其他人最后回应我时，他们说

00:04:36.160 --> 00:04:39.759
好吧，我们不知道该文档可以去哪里，所以只需将其粘贴到Wiki中即可

00:04:39.759 --> 00:04:42.800
Wiki是可怕的github Wiki

00:04:42.800 --> 00:04:46.720
原因是您知道可以在此处发布页面，但任何人都可以编辑

00:04:46.720 --> 00:04:48.560
它，我唯一能做的就是订阅

00:04:48.560 --> 00:04:53.360
进行更改，以及是否以及如果您喜欢的人知道它是垃圾邮件或删除我的内容

00:04:53.360 --> 00:04:56.560
我必须喜欢然后回去，你知道还原

00:04:56.560 --> 00:04:59.360
这真的很烦人，所以我不知道我要做什么

00:04:59.360 --> 00:05:02.240
可能只是将其作为pl文档发布

00:05:02.240 --> 00:05:05.199
这就是给我的

00:05:06.000 --> 00:05:13.600
谢谢，嗯，下一个是michael well yeah，所以

00:05:13.600 --> 00:05:17.039
感恩节是上周，所以这是一个相当短的一周

00:05:17.039 --> 00:05:23.919
但是我确实有点受够了，我正在调试cadb并意识到

00:05:23.919 --> 00:05:26.960
我实现树的方式就像抽象一样

00:05:26.960 --> 00:05:30.160
不在正确的位置上，无法对其进行良好的调试，这就像一个整体

00:05:30.160 --> 00:05:34.400
一团糟，所以我做了这些树的第三次实现

00:05:34.400 --> 00:05:37.360
哦，现在被马科拉（Makola）称为矮树

00:05:37.360 --> 00:05:41.280
只是不习惯以他的名字命名，所以它们被称为矮矮胖胖的树

00:05:41.280 --> 00:05:46.240
现在，而不是镍树，所以我做了第三次实施

00:05:46.240 --> 00:05:50.240
现在这些树的目的是使基地像基地一样

00:05:50.240 --> 00:05:55.120
抽象的类型系统有点像树木

00:05:55.120 --> 00:05:58.479
嗯，这样我就可以在上面实现cadb了

00:05:58.479 --> 00:06:02.160
任何ipld树，所以我觉得d树有点像

00:06:02.160 --> 00:06:06.400
他们基本上是像基本类一样在使用

00:06:06.400 --> 00:06:08.400
无论如何，如果您看一下实现

00:06:08.400 --> 00:06:12.080
比我说的要有意义得多，但后来有了那个库

00:06:12.080 --> 00:06:19.360
我现在已经实现了一个cid，它设置了一个稀疏数组，一个有序映射，并且

00:06:19.360 --> 00:06:26.479
数据库索引嗯，它们都工作得很好嗯，是的，树是

00:06:26.479 --> 00:06:29.360
真的举起嗯，就像我们可以把它拉出来一样

00:06:29.360 --> 00:06:33.680
这些数据结构现在在这些大块的树上，并且只是有所不同

00:06:33.680 --> 00:06:36.720
只是改变了一些关键类型和其他内容，所以实际上

00:06:36.720 --> 00:06:40.160
真的很好，所以看起来真的非常

00:06:40.160 --> 00:06:45.039
这些树很有前途，真的很好，嗯。

00:06:45.039 --> 00:06:49.520
也就像只是实现这种干净抽象的实现一样

00:06:49.520 --> 00:06:52.479
允许您就像将分支因子降低一样

00:06:52.479 --> 00:06:55.039
控制事物的位置，以便您可以

00:06:55.039 --> 00:06:58.479
编写导致正确合并的测试，诸如此类的

00:06:58.479 --> 00:07:01.680
我尝试调试时的可预测方式

00:07:01.680 --> 00:07:04.240
这些东西，并为它们写好的测试

00:07:04.240 --> 00:07:08.479
um在其顶部的一种完全物化的数据结构中

00:07:08.479 --> 00:07:11.919
嗯，由于所有散列的随机性，它太不可预测了，所以您

00:07:11.919 --> 00:07:14.240
不知道什么时候不去打的时候

00:07:14.240 --> 00:07:16.639
像很小的实现细节一样突然改变

00:07:16.639 --> 00:07:19.919
这些东西都没有了，它不再像以前那样工作了

00:07:19.919 --> 00:07:24.000
嗯，现在一切都好很多了，恩，这是给我的

00:07:24.000 --> 00:07:31.840
我不知道下一个是谁，下一个是埃里克

00:07:32.479 --> 00:07:35.759
我有一个想记住我整周所做的事情的人

00:07:35.759 --> 00:07:42.960
几周的时间，所以最大的事情之一就是我一直在尝试处理文档

00:07:42.960 --> 00:07:47.199
积累了新年的一些已知目标，因此我们可以实现这些目标

00:07:47.199 --> 00:07:50.240
写在某个地方，也许开始在任何人周围流传

00:07:50.240 --> 00:07:53.759
谁想要在那个计划规模上保持一致

00:07:53.759 --> 00:07:58.319
试图展望整个一年可能

00:07:58.319 --> 00:08:03.280
您知道我们可以尝试，我们会尝试的，但这将是一个不完善的文档，

00:08:03.280 --> 00:08:08.000
我敢肯定，我们会在当地缩小很多

00:08:08.000 --> 00:08:12.319
无论如何，全年都有时间计划，因此有指向文档的链接

00:08:12.319 --> 00:08:16.000
在那里，这个地方充满了很多人的脑力激荡

00:08:16.000 --> 00:08:19.120
我，但可以通过增加更多的脑力投入来改善

00:08:19.120 --> 00:08:23.759
其他人也是，所以我很乐意对此做一些评论

00:08:23.759 --> 00:08:29.120
嗯，我认为丹尼尔已经从风帆中抽走了大部分风，

00:08:29.120 --> 00:08:32.240
讨论我们正在计划一些新版本时，我剥了皮

00:08:32.240 --> 00:08:36.080
嗯，主要的东西已经合并了，我将成为

00:08:36.080 --> 00:08:38.479
这个星期再做几件事，基本上是想

00:08:38.479 --> 00:08:42.320
包裹并钉牢任何可能移动的东西

00:08:42.320 --> 00:08:46.000
然后我们要标记即将发布的一个版本

00:08:46.000 --> 00:08:50.640
这将是一个很小的突破性变化，几乎没有什么应该让任何人感到惊讶

00:08:50.640 --> 00:08:54.240
当他们跳到这个，然后我们尽快获得安全时

00:08:54.240 --> 00:08:58.640
检查点，然后我们将继续进行大量的api更改，

00:08:58.640 --> 00:09:02.399
将需要人工干预才能有人升级

00:09:02.399 --> 00:09:05.440
我们将尝试在一个月内迅速完成很多此类工作

00:09:05.440 --> 00:09:11.279
至少，这些基本上都有目标

00:09:11.279 --> 00:09:14.720
我们从中得出的核心接口的可用性改进

00:09:14.720 --> 00:09:18.720
随着时间的流逝，更多的使用以及到目前为止我们从集成中获得的反馈

00:09:18.720 --> 00:09:23.040
例如，其中一个大的正在使用我们的节点接口

00:09:23.040 --> 00:09:26.720
那种感觉像是一种错误的东西是

00:09:26.720 --> 00:09:33.440
嗯，这很昂贵，因为一堆读取方法都返回一个值或一个

00:09:33.440 --> 00:09:36.480
错误，这意味着您无法链接这些呼叫

00:09:36.480 --> 00:09:40.880
所以从句法上来说，这只是一个巨大的痛苦

00:09:40.880 --> 00:09:45.360
如果错误几乎在每条备用行上分支，那将是最好的代码

00:09:45.360 --> 00:09:50.480
没有人喜欢这样的惊喜，所以我们将尝试减少一些

00:09:50.480 --> 00:09:55.120
那样的事情，但是那些将有必要打破api的更改，所以

00:09:55.120 --> 00:09:57.920
我们将尝试在尽可能小的窗口中完成所有操作，然后移动

00:09:57.920 --> 00:10:00.160
并希望有人开始

00:10:00.160 --> 00:10:02.560
在新的一年里与这个图书馆互动

00:10:02.560 --> 00:10:07.519
我们将获得更少错误的全新改进体验

00:10:08.320 --> 00:10:12.480
嗯，就是这样

00:10:15.360 --> 00:10:22.240
清单上的下一个错误，答案是否定的

00:10:24.399 --> 00:10:27.200
那也是谁

00:10:27.839 --> 00:10:35.519
到钢笔上的笔记，我很赞这个的格式

00:10:35.519 --> 00:10:39.040
一点点的间隔让我醒了

00:10:39.040 --> 00:10:41.360
好的

00:10:43.440 --> 00:10:50.000
好吧，我的星期刚好是旧文件硬币而已

00:10:50.000 --> 00:10:54.959
在数据中游泳等等

00:10:55.120 --> 00:11:01.839
只是我一直在尝试解决数据量的问题

00:11:01.839 --> 00:11:07.920
在远方硬币中，从某种意义上来说，我来了

00:11:07.920 --> 00:11:13.040
我的发言方式有所不同，但遇到了彼得一直以来遇到的相同问题

00:11:13.040 --> 00:11:18.000
用这个东西的体积来处理um

00:11:18.000 --> 00:11:21.040
当您处理这么多事情时，几乎有很多事情崩溃了

00:11:21.040 --> 00:11:25.200
数量，还有事实就是如此

00:11:25.200 --> 00:11:29.279
这些小块很小，有很多这样的块

00:11:29.279 --> 00:11:32.640
浏览所有内容，这并不奇怪

00:11:32.640 --> 00:11:37.200
因为这是现实世界中大量的数据，但是

00:11:37.200 --> 00:11:41.920
嗯，这只会使所有事情变得艰难，尤其是

00:11:41.920 --> 00:11:44.320
也不是静态数据集，所以

00:11:44.320 --> 00:11:48.160
你知道它不断被添加到

00:11:48.160 --> 00:11:51.440
当您觉得自己处于某个事物之上时，就会有更多的东西

00:11:51.440 --> 00:11:56.399
掌握一切，所以我一直在编写实用程序，并试图使

00:11:56.399 --> 00:12:02.560
处理这些数据以及处理空间限制的实用方法

00:12:02.560 --> 00:12:08.320
只是变得令人沮丧而已

00:12:08.320 --> 00:12:12.000
是的，那里还有其他一些文件硬币相关的东西

00:12:12.000 --> 00:12:16.000
与规范参与者团队互动，并讨论数据结构形状

00:12:16.000 --> 00:12:21.519
以及大小和算法，我想我与你们大多数人共享了

00:12:21.519 --> 00:12:25.440
我已经从方法中浮出水面的一些东西

00:12:25.440 --> 00:12:29.200
驱动数据结构的大小和形状的动机

00:12:29.200 --> 00:12:31.600
和嗯

00:12:32.720 --> 00:12:36.320
我为此提供的一些反馈，但我也可能值得我们

00:12:36.320 --> 00:12:39.279
在某个时候讨论[音乐]

00:12:39.279 --> 00:12:47.519
只是因为他们正在尝试应用相当残酷的

00:12:47.519 --> 00:12:54.079
与apld有关的各种操作的成本核算方法

00:12:54.079 --> 00:12:57.680
当您简化时，您会知道

00:12:57.680 --> 00:13:03.279
复杂系统中的任何东西，那么您最终都会得到这些东西

00:13:03.279 --> 00:13:08.560
以意想不到的和不想要的方式爆发

00:13:08.560 --> 00:13:12.399
嗯，我想我们已经看到了一些成果，但我们会

00:13:12.399 --> 00:13:16.959
继续除非我猜我们有一些

00:13:16.959 --> 00:13:21.920
讨论不同约束条件的好方法

00:13:21.920 --> 00:13:27.760
无论如何，这是我的一周，也是

00:13:27.760 --> 00:13:33.120
只是我没什么可展示的

00:13:33.120 --> 00:13:38.800
除了挫败感，我在github上也真的落后了

00:13:38.800 --> 00:13:42.320
积压，所以如果有事情我没有回应，那么

00:13:42.320 --> 00:13:45.519
是的，我会赶上

00:13:46.320 --> 00:13:52.639
谢谢，接下来是彼得

00:13:57.279 --> 00:14:04.720
你无语，抱歉笑话是拉德在这里说的一样

00:14:04.720 --> 00:14:12.000
所以是的，基本上有多个呃请求要移动这个

00:14:12.000 --> 00:14:16.560
大量数据提供给不同方，用于不同的呃

00:14:16.560 --> 00:14:22.959
测试等等，当然我想我终于有了一个

00:14:22.959 --> 00:14:29.120
切实可行的坚实方法，只需要调整模式即可

00:14:29.120 --> 00:14:35.760
稍微多一点，原来的想法是

00:14:35.760 --> 00:14:40.639
可以通过某种方式通过呃来访问这些块

00:14:40.639 --> 00:14:44.720
同步框，或者您知道像test 3一样，或者您知道ipfs在

00:14:44.720 --> 00:14:48.480
想象一下，无论我们制造了多少块

00:14:48.480 --> 00:14:53.519
即使有任何类型的风扇，这绝对是不切实际的

00:14:53.519 --> 00:15:00.800
你能做的就是没有足够的没有没有足够的

00:15:00.800 --> 00:15:04.720
一天往返，甚至可以拉出一个州，更不用说

00:15:04.720 --> 00:15:08.880
你知道一些要分析的东西，所以

00:15:08.880 --> 00:15:14.240
嗯，那种可以解决的版本似乎行之有效，我们将

00:15:14.240 --> 00:15:18.160
其实在打这个电话之后跟我聊了一点

00:15:18.160 --> 00:15:22.480
嗯，如何将其整合到哨兵中

00:15:22.480 --> 00:15:30.079
将是一个庞大的postgres数据库，我们在该数据库中发布

00:15:30.079 --> 00:15:37.199
那是已经足够规范化，但实际上并没有涉及

00:15:37.199 --> 00:15:40.639
就像一路打破障碍

00:15:40.639 --> 00:15:45.600
像现在发送的，但实际上确实维持了关系

00:15:45.600 --> 00:15:51.600
在视觉块之间，因此实际上我拉出了我解析每个块之前

00:15:51.600 --> 00:15:55.519
我把它放出来，我拉出链接，实际上我在其中重新创建了链接

00:15:55.519 --> 00:16:02.160
在数据库本身中，这基本上可以让我做类似的事情

00:16:02.160 --> 00:16:06.240
出口及其他东西

00:16:06.480 --> 00:16:09.680
就像遍历一棵树一样

00:16:09.680 --> 00:16:13.120
与您一起使用它知道它与递归cts

00:16:13.120 --> 00:16:18.000
嗯，这显然比我们能做的任何事情都要快

00:16:18.000 --> 00:16:20.959
在旅途中，因为您知道我们必须打开一个包装块，依此类推，依此类推

00:16:20.959 --> 00:16:26.240
而如果我实际上在数据库中有图，它就可以工作

00:16:26.240 --> 00:16:31.199
而且，因为所有这些都可以充分压缩

00:16:31.199 --> 00:16:37.360
开始发布该数据库的基础备份是很实际的，例如

00:16:37.360 --> 00:16:40.800
每天大约一次，只要它正常工作，

00:16:40.800 --> 00:16:44.560
一旦我开始跑步，就被赶上了。

00:16:44.560 --> 00:16:47.600
信封背面说，要实际运行需要八天

00:16:47.600 --> 00:16:52.800
整个链，因为我不能只导入一个现有的，一个现有的

00:16:52.800 --> 00:16:55.920
数据存储，我需要重新分析每个块，并且有

00:16:55.920 --> 00:17:00.240
稍微好一点，所以基本上对于每个进入的块

00:17:00.240 --> 00:17:05.839
我找到了一种方法来记录它何时发生，所以我们也有

00:17:05.839 --> 00:17:09.679
块的时间聚类等等，等等

00:17:09.679 --> 00:17:13.839
有一些类似于文件系统的东西，所以

00:17:13.839 --> 00:17:18.079
实际上我们可以告诉一个特定的块

00:17:18.079 --> 00:17:24.720
正如您所知，航空箱一直在触摸它

00:17:24.720 --> 00:17:28.799
我正在进步，这还不清楚

00:17:28.799 --> 00:17:33.120
这将使我们将来可以做些什么，但要记录此信息

00:17:33.120 --> 00:17:36.960
一次并保持前进几乎是免费的

00:17:36.960 --> 00:17:41.520
嗯，所以我们也要单击它，

00:17:41.520 --> 00:17:48.799
您可以发布此内容的基本备份，然后发布流媒体墙

00:17:48.799 --> 00:17:55.360
写目录的本质，所以基本上任何想要获得的人

00:17:55.360 --> 00:17:59.360
这个庞大的数据库运行，他们应该能够只拉一个

00:17:59.360 --> 00:18:03.280
来自ipfs的uh最近备份

00:18:03.280 --> 00:18:08.720
然后同步到那里，必须像一系列

00:18:08.720 --> 00:18:14.320
奴隶，呃，不危及主数据库，而是

00:18:14.320 --> 00:18:17.760
如果一切正常，并且可以扩展

00:18:17.760 --> 00:18:23.840
如我最初的测试所示，这将是提供数据的一种方式

00:18:23.840 --> 00:18:27.280
谁想要它以非常便宜的价格

00:18:27.280 --> 00:18:32.559
相对分散的方式，所以应该解决这个问题

00:18:32.559 --> 00:18:36.559
当然，您不知道有多少帮助吗

00:18:36.559 --> 00:18:39.440
像您在这些表格上拥有的实际角色，依此类推等等，但是您

00:18:39.440 --> 00:18:43.520
知道那是这样，只是你知道

00:18:43.520 --> 00:18:47.760
不要选择星数，因为不能开始抱歉，因为

00:18:47.760 --> 00:18:52.320
要花很长时间嗯

00:18:52.320 --> 00:18:56.160
因此，还有另一个新闻仪式

00:18:56.160 --> 00:18:59.200
从字面上看，这就是为什么我实际上迟到了

00:18:59.200 --> 00:19:03.840
这是我们第一次与

00:19:03.840 --> 00:19:07.039
与真实的部门，与具有rio的真正的矿工

00:19:07.039 --> 00:19:12.320
一切都是事物

00:19:12.559 --> 00:19:16.000
根据我的预期，进展会比我预期的要好

00:19:16.000 --> 00:19:22.400
以前的经验，所以希望我们将有我们的第一部门

00:19:22.400 --> 00:19:25.360
密封，如果一切正常，电源显示

00:19:25.360 --> 00:19:30.160
它应该显示在哪里，这是一个简单的问题

00:19:30.160 --> 00:19:34.400
自动化在这一点上，所以是的，但愿它会过去

00:19:34.400 --> 00:19:40.240
没有障碍物，是的，那是我的弱杂种

00:19:40.240 --> 00:19:47.919
明智的，恩，下一个，克里斯，您有什么更新吗？

00:19:48.960 --> 00:19:52.640
嗯，我已经将验证插入

00:19:52.640 --> 00:19:56.559
图同步请求者，这是个好消息，我正在继续添加

00:19:56.559 --> 00:20:01.600
扩展程序，然后是响应程序，这是我的更新

00:20:02.960 --> 00:20:09.440
谢谢，嗯，好吧，我

00:20:11.200 --> 00:20:18.240
继续，所以我有一个性别项目，这也是我们最喜欢的项目之一

00:20:18.240 --> 00:20:23.760
关于嵌入式CD的主题，它再次出现在舒适的环境中

00:20:23.760 --> 00:20:30.000
乔斯的后背，所以我和乌姆聊天

00:20:30.000 --> 00:20:34.080
Drell正在从事这些工作，并且也像以前一样

00:20:34.080 --> 00:20:38.880
我有一个简短的演讲，内容是关于eric的懈怠问题，就像在ncad中，

00:20:38.880 --> 00:20:42.880
难道我们不能以不同的方式来做模式等等，如此长的故事，简而言之，就像

00:20:42.880 --> 00:20:46.080
这对我来说很有趣，因为像

00:20:46.080 --> 00:20:49.120
我在类似的内陆城市遇到过

00:20:49.120 --> 00:20:53.039
在生锈和类似的东西中实现它们

00:20:53.039 --> 00:20:57.440
并看到他们可能会崩溃，因为他们不是

00:20:57.440 --> 00:20:59.840
固定大小和其他事物，因此与我无关

00:20:59.840 --> 00:21:04.080
像这样的透视图，因为您不应该真正使用它，因为

00:21:04.080 --> 00:21:09.440
他们并不是真正满足于解决问题，而是像不同类型的

00:21:09.440 --> 00:21:11.360
的东西，你只是应该使用它们，而我当时

00:21:11.360 --> 00:21:15.520
很高兴看到您可以使用模式替代

00:21:15.520 --> 00:21:19.200
那些情况，但正如我所讲的那样

00:21:19.200 --> 00:21:21.919
有趣的是，从

00:21:21.919 --> 00:21:27.440
从应用程序开发人员的角度来看，它们只是超级有用，所以如果我

00:21:27.440 --> 00:21:29.919
不会有像如何实现它们这样的整体背景，或者

00:21:29.919 --> 00:21:34.159
不管用什么感觉都很好

00:21:34.159 --> 00:21:38.400
我最终得到的是有趣的东西，这就是我的那种

00:21:38.400 --> 00:21:41.600
想要讨论或喜欢

00:21:41.600 --> 00:21:45.600
指出那是至少我的事

00:21:45.600 --> 00:21:49.520
理解是内联cd还可以为您提供哪些您当前无法提供的功能

00:21:49.520 --> 00:21:55.039
用纯模式进行操作，您仍然可以

00:21:55.039 --> 00:21:58.799
透明地遍历整个事物，因此

00:21:58.799 --> 00:22:04.960
比方说在舒适的事物中，或者在诸如此类的事物中

00:22:04.960 --> 00:22:08.960
在所选部分的第一部分中，您有

00:22:08.960 --> 00:22:13.280
json和有效负载明确定义为cid

00:22:13.280 --> 00:22:17.440
它可能是一个内嵌的cid，甚至可以像这样导入，如果您放置一个普通的cid

00:22:17.440 --> 00:22:20.320
 cid当然在那里到另一个块

00:22:20.320 --> 00:22:23.760
而且，无论是哪种格式，您都可以

00:22:23.760 --> 00:22:28.240
遍历它的问题，内联CID的好处是

00:22:28.240 --> 00:22:31.679
您甚至可以在json中放入像cyborg这样的东西

00:22:31.679 --> 00:22:35.600
但是您仍然可以继续遍历它，因为这将是一个不同的块，并且

00:22:35.600 --> 00:22:39.280
id透明地得到解决，你可以

00:22:39.280 --> 00:22:45.440
遍历它们，您就可以了，因此，如果您显然使用架构，则您的

00:22:45.440 --> 00:22:50.799
事物将是cid或它将是字节或某个对象，或者

00:22:50.799 --> 00:22:55.280
是的，所以遍历的变化非常像你的

00:22:55.280 --> 00:22:59.520
您的遍历路径因是否内联而有所不同

00:22:59.520 --> 00:23:03.760
从应用程序的角度来看，从开发人员的角度来看，如果

00:23:03.760 --> 00:23:06.400
就像你不在乎你只是不能一样

00:23:06.400 --> 00:23:10.559
只是遍历它们，那是我想的，如果你

00:23:10.559 --> 00:23:13.520
用一个计划和一个像一个之间的结合来做到这一点

00:23:13.520 --> 00:23:17.360
那种工会，你失去了这种功能

00:23:17.360 --> 00:23:21.440
您会看到为什么人们希望遍历路径没有什么不同

00:23:21.440 --> 00:23:25.440
如果您使用相同的身体，则使用相同的对象

00:23:25.440 --> 00:23:28.960
例如，如果您使用与联合相同的已解码主体

00:23:28.960 --> 00:23:32.960
那么它不会是不变的相同遍历路径

00:23:32.960 --> 00:23:36.400
不，只有在您拥有这些字节值时，您才说的是

00:23:36.400 --> 00:23:39.600
关于你会遇到的问题是的，所以

00:23:39.600 --> 00:23:43.200
因此，一旦您使用不同的编码，就会遇到问题

00:23:43.200 --> 00:23:46.240
不，是的，是的，是的，所以是的，所以

00:23:46.240 --> 00:23:52.720
切换，是的，但是，但是那是什么

00:23:52.720 --> 00:23:55.760
发生在死去的乔塞之类的东西，就像他们在切换一样

00:23:55.760 --> 00:24:01.039
在Codex um之间，我认为至少也是如此

00:24:01.039 --> 00:24:04.640
我想有点像用ipld做广告

00:24:04.640 --> 00:24:07.760
这些事情都是可能的，例如关于ild的好处是

00:24:07.760 --> 00:24:10.159
您可以在不同的事物之间建立链接

00:24:10.159 --> 00:24:14.880
可能只是工作类型之间的链接变得很多

00:24:14.880 --> 00:24:18.720
当这些类型之一像对加密签名时更有用

00:24:18.720 --> 00:24:21.200
容器也是dag托管的情况

00:24:21.200 --> 00:24:25.440
像这样的过山车

00:24:25.440 --> 00:24:28.400
以一种更加清晰的方式呈现给人们，而像大多数人一样

00:24:28.400 --> 00:24:31.120
建立一个他们喜欢的应用程序，我只会用

00:24:31.120 --> 00:24:34.320
dag json或我只会使用xc板而不会进行切换

00:24:34.320 --> 00:24:37.039
他们之间的关系很多，但是如果你在签东西而你

00:24:37.039 --> 00:24:41.600
使用设计容器开始变得很重要

00:24:41.679 --> 00:24:46.240
是的，所以我当时也想出的是这样，因为我们有一个相似的

00:24:46.240 --> 00:24:48.880
关于在phi硬币中进行讨论的地方

00:24:48.880 --> 00:24:54.000
您还可以将um c球存储为字段中的后座球

00:24:54.000 --> 00:24:57.840
作为字节，就像又像它一样

00:24:57.840 --> 00:25:02.080
是否应该这样做不是另一个问题，但是就像

00:25:02.080 --> 00:25:06.080
确实如此，如果例如

00:25:06.080 --> 00:25:09.919
我不建议这样做的嵌入式CID

00:25:09.919 --> 00:25:13.679
那将是你可以你可以遍历它

00:25:13.679 --> 00:25:20.880
嗯，这很好，所以我的问题就像我一样

00:25:20.880 --> 00:25:24.880
认为这是一个不错的功能，就像我仍然认为内联CID是

00:25:24.880 --> 00:25:28.480
这样做的工具错误，但问题是应该有一个

00:25:28.480 --> 00:25:34.240
以某种方式在ipld中进行此类操作

00:25:34.240 --> 00:25:37.520
嗯，所以我觉得在镜头CD中是正确的

00:25:37.520 --> 00:25:44.240
东西，但这只是我的观点，我的意思是就像他们是他们有用

00:25:44.240 --> 00:25:49.600
在某些情况下，它们就像在其他地方引起很多怪异

00:25:51.360 --> 00:25:57.520
是的，所以，嗯，嗯，所以有任何人对此有任何想法，或者就像

00:25:57.520 --> 00:26:00.960
我们是否应该轻弹一下下周或下一次会议，看看是否

00:26:00.960 --> 00:26:07.039
任何人都喜欢有一些想法，是的，如果不喜欢，是的，

00:26:07.039 --> 00:26:09.679
刚在这个公关中出现，我才发现它很有趣

00:26:09.679 --> 00:26:14.159
是的，想想这应该是一等公民吗？

00:26:14.159 --> 00:26:19.440
我们还说别用其他东西吗

00:26:20.000 --> 00:26:24.400
对我来说，这很有趣，实际上以前确实使用过内联CD的人们

00:26:24.400 --> 00:26:28.320
大约六个月前就告诉你这件事，你就像没有

00:26:28.320 --> 00:26:32.000
我说这可能没用

00:26:33.200 --> 00:26:40.400
是的，是的，就像我说的那样，我好像还没有从这个角度出发

00:26:40.400 --> 00:26:44.640
应用程序开发人员的观点基本上就是我太深了

00:26:44.640 --> 00:26:47.200
细节

00:26:47.919 --> 00:26:50.960
我没有告诉过你，所以这很有趣

00:26:50.960 --> 00:26:56.080
是的，这就像是的，我认为我们仍然在做的事情

00:26:56.080 --> 00:26:59.760
推回那些线程之一不像

00:26:59.760 --> 00:27:03.440
当您认为内联Cid可能有价值时，可以使用内联Cid的想法

00:27:03.440 --> 00:27:06.720
字面上就像有一些自动魔术逻辑，

00:27:06.720 --> 00:27:10.720
每当您要编码某些东西并链接到它时，您就可以决定

00:27:10.720 --> 00:27:13.919
根据长度是否应该是内联CID

00:27:13.919 --> 00:27:17.679
实际上，您正在像将每个链接变成潜在的内联一样

00:27:17.679 --> 00:27:21.360
那样的价值才是真正的价值所在

00:27:21.360 --> 00:27:23.840
棘手的

00:27:25.840 --> 00:27:29.200
是的，我认为我们遇到的根本问题

00:27:29.200 --> 00:27:34.559
像内联cid实际上是这是更一般的示例

00:27:34.559 --> 00:27:37.919
问题是我们恰巧在大多数时间看到ID为

00:27:37.919 --> 00:27:42.159
该模式和我们其他任何描述性的

00:27:42.159 --> 00:27:47.600
技术实际上是故意通用的

00:27:47.600 --> 00:27:51.840
编解码器和其他类似这样的选择，这意味着他们不谈论它们

00:27:51.840 --> 00:27:56.399
因为谈论它们会降低灵活性和实用性

00:27:56.399 --> 00:28:01.600
这意味着如果有人在不同的编解码器之间切换，或者

00:28:01.600 --> 00:28:06.880
切换链接的其他参数，例如切换到实际链接与

00:28:06.880 --> 00:28:10.640
内联CID，那么我们几乎没有能力

00:28:10.640 --> 00:28:15.840
描述切换，这引起了很多讨论

00:28:15.840 --> 00:28:19.520
这些事情出现时，要困难得多

00:28:20.720 --> 00:28:24.480
而且在某些地方，我们的处理方式也不完全一致

00:28:24.480 --> 00:28:28.799
我们仍然不确定这辆车的东西

00:28:28.799 --> 00:28:32.000
就像斯蒂芬似乎以为他们在汽车档案中

00:28:32.000 --> 00:28:37.440
不这么认为，我不认为他们实际上不应该

00:28:37.440 --> 00:28:45.520
他们自己的价值比汽车档案像那样，只是浪费空间

00:28:45.520 --> 00:28:48.640
但我不是说像它们在某些情况下绝对有用，我是说我待命

00:28:48.640 --> 00:28:50.399
就像我最初的类比

00:28:50.399 --> 00:28:53.760
他们是数据用户，就像你拿的一样

00:28:53.760 --> 00:28:57.919
地址的值，然后将其放入地址中，然后将其设为地址

00:28:57.919 --> 00:28:59.919
而那些工作的百分之九十的时间

00:28:59.919 --> 00:29:04.960
像数据uris一样工作了90％，就像它们在工作时真的很有用

00:29:04.960 --> 00:29:08.720
我用它们来工作，但有时它们不起作用，因为

00:29:08.720 --> 00:29:11.679
有时您需要一个地址作为值类型，而他们

00:29:11.679 --> 00:29:14.880
不能很好地作为值类型使用，并且它们没有相同的保证

00:29:14.880 --> 00:29:19.679
就像地址值类型一样

00:29:21.600 --> 00:29:26.559
是的，我的意思是我在某一点上对以下事实有异议

00:29:26.559 --> 00:29:29.919
因为它不是实际哈希中的哈希，所以有一些假设

00:29:29.919 --> 00:29:32.720
你可能会做的有问题的

00:29:32.720 --> 00:29:35.919
um，如果您尝试将链接用作值类型，则为

00:29:35.919 --> 00:29:41.440
是的，但我一经思考，我认为这没有什么不同

00:29:41.440 --> 00:29:45.600
不只是不安全的哈希函数，所以如果您使用的是哈希摘要

00:29:45.600 --> 00:29:47.840
对于您需要成为实际的东西

00:29:47.840 --> 00:29:53.679
哈希摘要，无论如何，您都需要像多编解码器一样进行检查，或者

00:29:53.679 --> 00:29:56.240
多哈希，并确保它是

00:29:56.240 --> 00:29:58.720
安全的散列函数，因为它不可能，而且您可以

00:29:58.720 --> 00:30:01.520
有同样的问题

00:30:05.120 --> 00:30:08.559
所以他们例如需要什么

00:30:08.559 --> 00:30:16.159
有一天，他们充满热情和挑剔，所以他们喜欢这样的在线Cid

00:30:16.159 --> 00:30:20.880
有两个字节或者比您需要的更多两个变体

00:30:20.880 --> 00:30:23.520
因为您基本上需要的是一个标识符

00:30:23.520 --> 00:30:27.520
编码是什么长度，然后是数据，我是什么

00:30:27.520 --> 00:30:31.600
以为就像我以为我曾经在那儿一样

00:30:31.600 --> 00:30:36.000
将来是两个的CID版本

00:30:36.000 --> 00:30:40.880
是用不同的方式定义的，因此它也可能是

00:30:40.880 --> 00:30:47.200
编解码器长度数据，因此基本上，例如，如果您从

00:30:47.200 --> 00:30:53.600
多对冲，您将翻转长度和哈希函数

00:30:53.600 --> 00:30:57.440
不完全是，但是就像一个基本的想法

00:30:57.440 --> 00:31:01.760
否则就没有意义想出一些

00:31:01.760 --> 00:31:04.799
有点像CID，但不是CD

00:31:04.799 --> 00:31:09.120
再一次，这不是我要推动或提议的事情，就像

00:31:09.120 --> 00:31:14.399
是的，我认为在ipod中添加某些内容可能是一个有用的概念

00:31:14.399 --> 00:31:19.840
这只是编解码器长度数据

00:31:19.840 --> 00:31:27.200
然后基本上遵循模式，我的意思是您只保存了两个字节，

00:31:27.200 --> 00:31:30.880
如果我们做过另一个版本的CID，我们将不得不处理很多

00:31:30.880 --> 00:31:36.480
只检查第一个字节的代码，如果不是，它会吓跑

00:31:36.480 --> 00:31:40.000
到处都需要大量的工作来支持它

00:31:40.000 --> 00:31:44.960
嗯，只是说要剃掉两个字节，所以可能不值得

00:31:44.960 --> 00:31:49.200
嗯，我也认为可能不是

00:31:49.200 --> 00:31:53.840
是的，你可以想象得到像这样的事情

00:31:53.840 --> 00:31:57.840
在编解码器中，尽管它非常了解嵌入式CD

00:31:57.840 --> 00:32:03.519
它只是以这种方式塑造了咬口，因此它拥有自己的打字令牌

00:32:03.519 --> 00:32:07.519
然后可以识别它，所以你可以

00:32:07.519 --> 00:32:09.760
知道做这种减少，并有这样的类型

00:32:09.760 --> 00:32:13.440
在编解码器中作为压缩方法

00:32:13.440 --> 00:32:21.760
嗯，这可能已经足够好了，请确定应该反过来

00:32:21.760 --> 00:32:28.559
比起我们喜欢像这样，病态更像是一等公民

00:32:28.559 --> 00:32:31.760
因为像茱莉亚（Julia）嘿，如果我们觉得

00:32:31.760 --> 00:32:35.760
像对待它们一样好对待它们，我可以使用它们，但就像它们可能会破裂

00:32:35.760 --> 00:32:41.279
他们可能不会破裂，就像那样，是的，我们有没有像

00:32:41.279 --> 00:32:44.880
有计划说好吧，这是正确的事情，不是

00:32:44.880 --> 00:32:48.559
实际上是一个哈希函数，具体取决于您使用的定义

00:32:48.559 --> 00:32:52.799
头功能，但我们还是可以的，是的

00:32:52.799 --> 00:32:56.320
在我们的工具中这是非常可逆的

00:32:56.320 --> 00:32:59.279
还是我们只是一直说这个东西存在而您可以使用它，而我们

00:32:59.279 --> 00:33:03.360
会看到发生了什么事我的意思是我认为那也很好

00:33:03.360 --> 00:33:07.200
我们在该检查员上有一个停靠点，但在

00:33:07.200 --> 00:33:10.480
首先，不，我们没有停靠点，应该真的停靠一点

00:33:10.480 --> 00:33:15.360
这个我不是

00:33:15.360 --> 00:33:18.960
超级相信我们在本次电话会议之前接受的一些推理

00:33:18.960 --> 00:33:22.000
关于为什么孩子更优秀我认为很多

00:33:22.000 --> 00:33:24.080
那些事情实际上仍然是平等的

00:33:24.080 --> 00:33:29.360
就像透明路径一样，无论是否有内联cid，其工作方式都相同

00:33:29.360 --> 00:33:33.039
或到另一个块的链接或只是内联

00:33:33.039 --> 00:33:36.159
通过某种结合获得的一些附加内容

00:33:36.159 --> 00:33:40.240
这些都是透明的表示模式级别

00:33:40.240 --> 00:33:43.840
真的很喜欢，如果只是字节，你会怎么想

00:33:43.840 --> 00:33:48.880
不不不不不，但不要那样做

00:33:48.960 --> 00:33:52.000
就像内联值或内联值一样

00:33:52.000 --> 00:33:55.039
好吧，如果您正在寻找一个原始块，那将是相同的是的

00:33:55.039 --> 00:33:58.240
是的，但是像您一样，内联价值数据

00:33:58.240 --> 00:34:01.360
从数据模型中获取，但是粗俗的说是，当您

00:34:01.360 --> 00:34:05.519
需要进行编解码器切换，但就像通常不只是解码一样

00:34:05.519 --> 00:34:08.960
数据只是解码数据并将其值放入

00:34:08.960 --> 00:34:12.960
像这样，那么您就减少了需要使用的编解码器的数量

00:34:12.960 --> 00:34:16.240
就像我看到这真的有用的唯一情况是dag cose和

00:34:16.240 --> 00:34:20.079
jose的事情，因为您不想更改jose和kosei的格式

00:34:20.079 --> 00:34:23.839
所以你只想要你只想要二进制值

00:34:23.839 --> 00:34:27.200
在json中就像他妈的base64伯爵编码

00:34:27.200 --> 00:34:30.399
而您只想更改它的解释以说它是一个cid

00:34:30.399 --> 00:34:33.359
因此，您实际上没有机会参加工会或说这是

00:34:33.359 --> 00:34:36.000
任何其他类型，它只必须是一种类型，因为

00:34:36.000 --> 00:34:39.679
您必须更改格式，而我们不想更改格式

00:34:39.679 --> 00:34:43.760
我们只想更改编解码器标识符

00:34:43.760 --> 00:34:49.520
因此，您需要它，而且它也必须是一个链接，因为它总是

00:34:49.520 --> 00:34:52.159
将链接到某事或做其他事情

00:34:52.159 --> 00:34:55.760
在几乎像定义一样的不同编解码器中，所以

00:34:55.760 --> 00:34:59.680
当您需要在其中插入内容时，使用镜头CD真的很有意义

00:34:59.680 --> 00:35:04.560
我担心的是，如果您使用加密来执行此操作

00:35:04.560 --> 00:35:06.880
这取决于您使用的加密功能，但是

00:35:06.880 --> 00:35:10.720
像是高度可识别的已知字节

00:35:10.720 --> 00:35:15.280
加密数据的开始或解密的开始

00:35:15.280 --> 00:35:18.320
数据，这样您就可以用它来打破

00:35:18.320 --> 00:35:23.280
加密，我认为就像某些我认为是的算法

00:35:23.280 --> 00:35:26.560
在周围足够好而混乱的地方

00:35:26.560 --> 00:35:30.480
这不是一个大问题，但其中一些这样的问题

00:35:30.480 --> 00:35:33.680
就像他们需要担心这个

00:35:34.880 --> 00:35:38.560
好吧，所以我可以看到类似您可能不应该编写代码的观点

00:35:38.560 --> 00:35:43.520
内联交换（如果您使用）

00:35:43.520 --> 00:35:46.960
您可能不应该更改看起来很漂亮的编码

00:35:46.960 --> 00:35:50.880
对于正常使用情况是合理的，是的，您可以

00:35:50.880 --> 00:35:53.839
现在看到，好吧，那我不会有所作为好吧，我可以看到

00:35:53.839 --> 00:35:59.839
没关系

00:36:01.119 --> 00:36:04.800
那是我们应该写文件的结论了

00:36:04.800 --> 00:36:10.960
关于呃就像关于内联CID和类似的主题

00:36:10.960 --> 00:36:14.079
是的，他们也很喜欢描述什么情况

00:36:14.079 --> 00:36:18.000
我们已经看到了，因为我们已经看到了很多案例，有些我们说是的

00:36:18.000 --> 00:36:22.480
可以的情况下，有的不是什么，

00:36:22.960 --> 00:36:27.520
我不知道我们是否想这么说不对，我们要概述一下是的

00:36:27.520 --> 00:36:31.440
我同意抱歉是是的表面积

00:36:31.440 --> 00:36:34.000
决策是我们应该从事的业务

00:36:34.000 --> 00:36:39.040
是的，是的，对不起，这就是，是的，好的，你可以做到这一点，但是在这里

00:36:39.040 --> 00:36:43.280
是一些更好的方法，这是一些原因

00:36:43.280 --> 00:36:47.040
您可能不想这样做，因为它可能会咬住您

00:36:47.040 --> 00:36:49.520
稍后的

00:36:50.560 --> 00:36:54.480
我认为这就是我们要做的事情

00:36:54.480 --> 00:36:58.240
它只是在为人们映射决策空间，这样当他们来的时候

00:36:58.240 --> 00:37:01.359
可以使他们做出所有这些取舍

00:37:01.359 --> 00:37:05.920
必须使他们的系统约束

00:37:07.520 --> 00:37:12.160
我们还需要弄清楚当前的汽车实现方案对他们有何作用

00:37:12.160 --> 00:37:14.480
嗯

00:37:15.440 --> 00:37:19.839
我们在美国实际上在做什么

00:37:20.320 --> 00:37:23.920
是的，实际上，我是说彼得，因为您解析了这些汽车文件，所以您会知道

00:37:23.920 --> 00:37:27.839
就像所有时间一样，车上是否有嵌入式CID

00:37:27.839 --> 00:37:32.079
文件作为唯一条目作为唯一块否

00:37:32.079 --> 00:37:39.520
因为所有的围棋都有这种安全套

00:37:39.520 --> 00:37:42.800
基本上不允许任何的块存储

00:37:42.800 --> 00:37:47.440
任何要通过它或从中获取的身份标识

00:37:47.440 --> 00:37:51.119
你可以玩，你可以插

00:37:53.280 --> 00:37:57.680
您将其插入哪一层是的，是的，是的，我的意思是因为如果您

00:37:57.680 --> 00:37:59.760
您通过遍历汽车文件来编写汽车文件

00:37:59.760 --> 00:38:02.400
图，您仍将获得内联CID

00:38:02.400 --> 00:38:06.560
在图um中，所以块存储决定要做什么并不重要

00:38:06.560 --> 00:38:09.839
这样做是因为它们是块数据中的值

00:38:09.839 --> 00:38:12.640
嗯，如果您进行这种遍历，是的

00:38:12.640 --> 00:38:17.119
但基本上我们是从块存储中进行遍历的

00:38:17.119 --> 00:38:21.520
直接当我们写那是从那里来的卡片时

00:38:21.520 --> 00:38:25.760
但是，但是，当我们进行常规交易流程时，我们该怎么办？

00:38:25.760 --> 00:38:30.400
带你拿一个文件，你和你遍历

00:38:30.400 --> 00:38:33.359
并将其旋转到汽车文件中

00:38:33.359 --> 00:38:37.599
正常的交易流程好吧，我不知道这实际上是我认为的

00:38:37.599 --> 00:38:40.079
我们已经打开了一张票以验证有什么不同

00:38:40.079 --> 00:38:43.760
实现适用于这种特定情况，但是是的，我们还没有

00:38:43.760 --> 00:38:47.760
它会尝试并获取它，因为这一切都依赖于

00:38:47.760 --> 00:38:52.160
所谓的ID包装是什么？

00:38:52.160 --> 00:38:57.040
莲花中只有一个特定的层可以处理

00:38:57.040 --> 00:39:02.480
标识块嗯，这不是说它到处都是ipf

00:39:02.480 --> 00:39:05.200
说，那就是我在歌利亚中所要表达的意思

00:39:05.200 --> 00:39:07.920
到处都有它的每一个点

00:39:07.920 --> 00:39:11.359
这就是为什么您永远不会看到这些东西泄漏出去的原因

00:39:11.359 --> 00:39:18.079
好的，但是您不必使用该权利，是的，我的意思是我的意思是，但是在我的

00:39:18.079 --> 00:39:20.880
像我们应该只更新汽车文件的视图

00:39:20.880 --> 00:39:25.520
不写这些，并且因为就像它只是

00:39:25.520 --> 00:39:28.720
浪费空间，那才是最简单的方法

00:39:28.720 --> 00:39:30.960
一致，因为我们知道有这些

00:39:30.960 --> 00:39:35.680
到处都有其他说唱歌手，就像使他们消失一样

00:39:35.680 --> 00:39:39.599
是的，如果人们开始写dag kozai或其他东西

00:39:39.599 --> 00:39:46.000
在JavaScript中，他们得到了验证，然后我们将有不同的行为

00:39:46.000 --> 00:39:49.280
鉴于这个说唱事情

00:39:49.599 --> 00:39:53.040
因为我们不，我们不考虑这些身份哈希

00:39:53.040 --> 00:39:57.680
根本没有用javascript作为一种特殊情况，如果他们这样做了，那你就去吧

00:39:57.680 --> 00:40:01.440
好的，是的，是的，我同意需要更新规格

00:40:01.440 --> 00:40:06.640
两种方式都可以明确表示出来，以便人们制作文件硬币

00:40:06.640 --> 00:40:10.480
交易，并且它们正在另一端进行验证，是的

00:40:10.480 --> 00:40:13.839
而在javascript中，我们必须在car文件库中执行此操作，因为

00:40:13.839 --> 00:40:17.119
是的，我认为我们唯一能从中得到的东西

00:40:17.119 --> 00:40:21.119
另一方面是链接，我们只是在块数据上获得了一个链接生成器

00:40:21.119 --> 00:40:25.280
就像其他城市一样，这在我的csd中返回

00:40:25.280 --> 00:40:30.560
实际上，它也适用于他们要表达的内容

00:40:32.720 --> 00:40:36.079
因为那是你了解东西的方式

00:40:36.079 --> 00:40:42.079
莲花到莲花哦，那是对的

00:40:43.520 --> 00:40:46.160
哦耶

00:40:47.839 --> 00:40:51.680
哦，别等了，但在常规交易流程中

00:40:51.680 --> 00:40:55.920
超过图形同步，但随后它们都吐出了汽车峰值

00:40:55.920 --> 00:40:59.359
然后他们比较汽车文件上的哈希值

00:40:59.359 --> 00:41:06.560
不，不，根本不像从ipfs中拉出时，没有汽车文件

00:41:06.560 --> 00:41:08.960
您的网站

00:41:09.040 --> 00:41:13.839
对，你随便拉什么

00:41:14.079 --> 00:41:17.359
然后通过图同步将其拉出

00:41:17.760 --> 00:41:20.720
所以制图没关系，因为汽车文件需要

00:41:20.720 --> 00:41:26.640
确定性正确是的，我的意思是

00:41:26.640 --> 00:41:29.280
有没有

00:41:32.839 --> 00:41:38.160
呵呵

00:41:41.520 --> 00:41:45.119
但是，是的，你是正确的，直到今天我们都在乎什么土地

00:41:45.119 --> 00:41:49.280
在汽车档案中，嗯，几乎可以肯定

00:41:49.280 --> 00:41:52.909
[音乐]

00:41:53.520 --> 00:41:58.400
我没看到这些没有写到汽车过程中

00:42:00.400 --> 00:42:03.839
所以虽然坚持

00:42:04.240 --> 00:42:09.200
客户用什么来计算胜任力

00:42:09.920 --> 00:42:13.200
因此，即使客户端从ipfs中提取数据，然后客户端

00:42:13.200 --> 00:42:16.480
通过图同步将其发送给其他人到矿工，然后他们

00:42:16.480 --> 00:42:21.200
两者都需要获得相同的竞争继续产生的竞争

00:42:21.200 --> 00:42:24.240
客户端（如果未在本地吐出汽车文件）

00:42:24.240 --> 00:42:29.040
嗯，为此，客户我是不是说不吐

00:42:29.040 --> 00:42:32.560
像是好出来，是的，通常会吐出东西，但是，是的，不是

00:42:32.560 --> 00:42:38.240
现在我们将其流出来，并在

00:42:38.240 --> 00:42:44.800
从字面上看，汽车出口实际上是相同的汽车出口

00:42:44.800 --> 00:42:49.520
您也有ipfs，所以如果我们有内联的东西

00:42:49.520 --> 00:42:52.800
cid我们只能看到它的外观，我什么都没有

00:42:52.800 --> 00:42:56.480
方便，现在很酷，嗯，我是说我们应该做

00:42:56.480 --> 00:42:58.160
确保图同步不会将它们发送到那里

00:42:58.160 --> 00:43:00.400
嗯

00:43:05.440 --> 00:43:08.000
上帝会

00:43:08.560 --> 00:43:11.200
我正在考虑这些错误将出现在哪里，并且它们有一个

00:43:11.200 --> 00:43:15.440
固定自己的奇怪方法，因为如果您从某个地方要求他们

00:43:15.440 --> 00:43:18.640
你将永远让他们回来

00:43:18.800 --> 00:43:23.680
所以即使他们像这些之间的不一致

00:43:23.680 --> 00:43:27.119
实际不会在任何地方显示的实现

00:43:27.119 --> 00:43:31.359
嗯，然后您要对汽车文件建立索引，我们会做什么？

00:43:31.359 --> 00:43:34.560
现在，我也以自己的方式进行索引

00:43:34.560 --> 00:43:40.480
您如何为在线Cid编制索引

00:43:40.800 --> 00:43:43.760
就是这样，然后您最终说这个CID不存在

00:43:43.760 --> 00:43:46.240
这个数据存储区，而我们说的是其他数据

00:43:46.240 --> 00:43:49.680
您想退货的商店

00:43:51.040 --> 00:43:54.400
只是返回它，是的，只是返回它，我认为我认为数据存储应该

00:43:54.400 --> 00:43:58.800
总是只返回像这样的内联CID的数据

00:43:58.800 --> 00:44:02.079
可能不像商店里的那样，但是就像它在里面

00:44:02.079 --> 00:44:04.319
不代表

00:44:04.400 --> 00:44:08.160
它存在于每个商店中的内联CID的整个点是

00:44:08.160 --> 00:44:11.440
每个商店返回的每个商店都存储它，每个商店都返回

00:44:11.440 --> 00:44:14.880
商店将把它说出来，是的，我得到了，一切都会返回

00:44:14.880 --> 00:44:18.880
你说我拥有它，因为这是的，这是如此

00:44:18.880 --> 00:44:22.640
有一天会被人利用

00:44:22.640 --> 00:44:26.240
我们在哪里问别人的操作，您有这个吗？

00:44:26.240 --> 00:44:28.720
如果他们有它，那么我们对他们有所了解，就会有人找到

00:44:28.720 --> 00:44:33.599
一种进入这个想法的方法，它进展得不是很好

00:44:33.599 --> 00:44:37.280
因为每个人都会说您可以在网上询问任何人

00:44:37.280 --> 00:44:40.880
CD，他们会说我没有，因为他们不，不，不，会的

00:44:40.880 --> 00:44:44.480
就像浏览器中的所有这些现金错误一样，是的，是的，

00:44:44.480 --> 00:44:48.720
是的，关于新鲜度信息我同意它将要出来的这是

00:44:48.720 --> 00:44:56.160
为什么有时您会遮挡约会的眼睛yeah ii认为这有点像

00:44:56.160 --> 00:45:02.000
我跑步的原因是我们是否愿意在90年代推动我们前进

00:45:02.000 --> 00:45:06.000
是的，但我想这艘船也已经航行了，我的意思是

00:45:06.000 --> 00:45:11.520
他们存在，我们必须与他们打交道，但是我想是的，因为我说过我们可以做一个

00:45:11.520 --> 00:45:15.680
像是一样的更好的工作，像是一样的解释

00:45:15.680 --> 00:45:19.200
解释自己的优点和缺点，或者说明自己的优点

00:45:19.200 --> 00:45:24.160
以及为什么要使用它们或为什么您可能想做其他事情

00:45:24.160 --> 00:45:26.880
是的，您应该怎么做，就像记录下我们的对话一样

00:45:26.880 --> 00:45:30.000
关于存储层就像应该回来

00:45:30.000 --> 00:45:32.800
他们，如果人们要他们，就像一件好事

00:45:32.800 --> 00:45:36.240
可以这样说，因为我很确定我们大多数商店都不喜欢

00:45:36.240 --> 00:45:39.920
嗯，就像他们中的很多一样，然后进入这个魔术层，

00:45:39.920 --> 00:45:47.200
放在使所有这些都可以做到这一点的一切之上

00:45:47.200 --> 00:45:50.400
我应该说像去文件硬币和快速去IP我不认为那是在

00:45:50.400 --> 00:45:53.760
去我把这些东西拿出来

00:45:55.200 --> 00:45:58.560
是的，所以嗯，还有

00:45:58.560 --> 00:46:02.160
当前我们作为默认代码发送的锈材料，我们仅发送

00:46:02.160 --> 00:46:08.160
安全的密码安全哈希，因此没有身份哈希

00:46:08.160 --> 00:46:11.839
显然是因为它不是加密安全的

00:46:11.839 --> 00:46:17.680
是的，嗯，等等，等等，等等

00:46:17.680 --> 00:46:22.319
身份概念比您可以使用的任何哈希更安全

00:46:22.319 --> 00:46:27.920
因为这取决于此否，因此保证永远不会

00:46:27.920 --> 00:46:31.200
碰撞，这是您无法碰撞的数据，没有办法

00:46:31.200 --> 00:46:34.480
哦，现金是一种非常有趣的方式

00:46:34.480 --> 00:46:36.960
看着

00:46:37.440 --> 00:46:40.640
完全正确的观察方式

00:46:40.640 --> 00:46:44.160
好的，是的，这是一个好点

00:46:44.160 --> 00:46:48.240
是的，是的，我不会说这是最安全的方法

00:46:48.240 --> 00:46:51.440
因为你用哈希做的事情不只是

00:46:51.440 --> 00:46:53.839
就像你可能依赖

00:46:53.839 --> 00:46:56.079
例如哈希内部的随机性

00:46:56.079 --> 00:47:00.079
就像我们现在在大块的树中一样

00:47:00.079 --> 00:47:03.599
但这与没有得到保护不同

00:47:03.599 --> 00:47:08.000
是的，是的，不安全，它可能不喜欢

00:47:08.000 --> 00:47:11.839
让我们分开

00:47:15.870 --> 00:47:19.030
[音乐]

00:47:19.839 --> 00:47:25.470
很遗憾，它是如此安全，您可以随时猜到它

00:47:25.470 --> 00:47:30.080
[笑声]

00:47:36.720 --> 00:47:42.960
太好了，它说的是像在la中那样的人吗？

00:47:42.960 --> 00:47:46.640
在慕尼黑举行的ipfs聚会

00:47:46.640 --> 00:47:52.720
在句子中提到您可以与内联城市进行圈子

00:47:52.720 --> 00:47:55.520
但我想不出是真的这样的情况，所以有人

00:47:55.520 --> 00:47:58.400
想起那一个

00:47:58.800 --> 00:48:03.760
您知道您基本上可以构建一个not标签，但是就像一个

00:48:03.760 --> 00:48:06.640
以某种方式循环

00:48:16.000 --> 00:48:19.760
我考虑了一下，但我想不出一个案例，但是

00:48:19.760 --> 00:48:23.680
我不确定在我心中是否真的有可能

00:48:23.680 --> 00:48:28.160
递归喜欢的方式

00:48:28.160 --> 00:48:32.400
就像所有其他问题一样，您必须得到同样的问题

00:48:32.400 --> 00:48:36.319
里面有哈希的cid，它将在某些主体中

00:48:36.319 --> 00:48:41.280
父母的机制，所以你做不到

00:48:41.280 --> 00:48:44.880
是的，我想你可以把南瓜扔出去，说没有信息，这是

00:48:44.880 --> 00:48:47.280
可能的

00:48:47.359 --> 00:48:50.400
内陆城市是否有可能，其他城市也有可能

00:48:50.400 --> 00:48:53.680
对于其他数据，我是说会是一样的

00:48:53.680 --> 00:48:58.400
嗯，就像没有办法在其中放置链接

00:48:58.400 --> 00:49:02.160
到不是基于散列的链接的父级

00:49:02.160 --> 00:49:07.280
因此，您必须将哈希值放入其中并进行预先计算，

00:49:07.280 --> 00:49:12.000
你必须知道父母，它在父母的身体里

00:49:14.880 --> 00:49:20.079
是的，如果有人想做作业并度过一个愉快的时光，

00:49:20.079 --> 00:49:24.800
周末证明不可能

00:49:26.240 --> 00:49:31.520
我很高兴读它，嗯，那有什么可以的

00:49:31.520 --> 00:49:37.359
也喜欢回到舒适的东西，所以基本上我们过去经常发布一些

00:49:37.359 --> 00:49:40.559
在那里评论大部分问题，所以基本上我们说

00:49:40.559 --> 00:49:43.680
就像今天一样

00:49:43.680 --> 00:49:46.960
应该去我们目前拥有的

00:49:46.960 --> 00:49:49.520
因为就像它一样，这是完全可以的

00:49:49.520 --> 00:49:52.720
这就是他们现在所拥有的，而我也曾与eric进行过简短的交谈，

00:49:52.720 --> 00:49:56.000
可能我们仍然可以将它们升级为某种工会，例如

00:49:56.000 --> 00:49:58.880
打破变化，所以如果我们愿意决定那是一个

00:49:58.880 --> 00:50:02.079
我们可以做的更好的方法，但我也想像我们

00:50:02.079 --> 00:50:05.680
不应该继续在诸如此类的东西上阻止他们

00:50:05.680 --> 00:50:11.520
是的，所以我会发表总结等评论，就像写得很好一样

00:50:11.520 --> 00:50:15.599
在团队中谈论您可以观看录音等等等等

00:50:15.599 --> 00:50:21.680
只是通过它，是的，是的，我只是发表了一点评论

00:50:21.680 --> 00:50:25.200
在那个大长公关上也已经对此

00:50:25.200 --> 00:50:29.200
迁移潜力，我认为我们可以使用另一件事

00:50:29.200 --> 00:50:33.280
将来，很多关于文档的潜在迁移潜力是因为

00:50:33.280 --> 00:50:36.880
我们已经开始考虑这个团队中的这一点，并呼吁人们

00:50:36.880 --> 00:50:40.559
有一定的定期性，但对人们来说却不是很明显

00:50:40.559 --> 00:50:43.839
在这个小组之外，我认为什么样的迁移很容易，哪些不是

00:50:43.839 --> 00:50:46.720
容易，事实证明，如果我们

00:50:46.720 --> 00:50:50.000
写这样的公关是这样写的，它说这仅仅是

00:50:50.000 --> 00:50:52.960
链接，然后我们想在以后扩大它

00:50:52.960 --> 00:50:56.319
使用一种工会，我很确定那是像

00:50:56.319 --> 00:51:00.559
最简单的迁移可能是最简单的，因为新的

00:51:00.559 --> 00:51:03.280
具有联合类型的模式将始终匹配

00:51:03.280 --> 00:51:06.880
所有旧数据都很棒

00:51:07.119 --> 00:51:10.400
但我们确实应该有一个文档，可以将人们直接链接到该文档

00:51:10.400 --> 00:51:13.040
解释说

00:51:13.680 --> 00:51:19.119
是的，人们也在努力刮胡子

00:51:19.119 --> 00:51:21.680
将会走向这些真正的瘦身

00:51:21.680 --> 00:51:26.000
使某些类型的联合真正成为其结构的表示形式

00:51:26.000 --> 00:51:29.599
真的很困难，所以，如果您不设计那种

00:51:29.599 --> 00:51:34.480
的东西和未来的证明，那么您就没有任何选择

00:51:34.480 --> 00:51:38.960
这个剃须的东西会再次出现

00:51:39.119 --> 00:51:42.160
现在我正在处理远处的硬币数据，而我却拥有更多

00:51:42.160 --> 00:51:45.599
这种同情剃须剃须的同情，但同时

00:51:45.599 --> 00:51:48.720
有这种自我解释的东西

00:51:48.720 --> 00:51:53.760
剃须的欲望会导致较小的障碍物，从而导致更多的障碍物

00:51:53.760 --> 00:51:57.040
复杂的图导致它就像

00:51:57.040 --> 00:52:02.160
这是这些多元问题空间之一，很难解决

00:52:02.160 --> 00:52:05.680
而且没有人真正做得很好

00:52:05.680 --> 00:52:09.119
呃所有变量及其对[音乐]的影响

00:52:09.119 --> 00:52:14.160
um构建的图的类型，而实际上这就是我们的

00:52:14.160 --> 00:52:17.440
工作，这是我们应该更多地研究并能够给予的东西

00:52:17.440 --> 00:52:22.079
回答我上周在通话中，我提出了这整个问题，

00:52:22.079 --> 00:52:25.520
我们继续回到ipld的上限定理，我们从未完全

00:52:25.520 --> 00:52:28.720
定义，而我只是无法将其从我的收藏夹中拉出

00:52:28.720 --> 00:52:31.359
继续前进，您知道我被更多询问了

00:52:31.359 --> 00:52:34.960
细节，就像哦，是的，而且就是这么多

00:52:34.960 --> 00:52:37.599
要映射它们很复杂的变量

00:52:37.599 --> 00:52:41.040
我知道我们需要对此做得更好

00:52:41.040 --> 00:52:44.400
我以某种方式想像也有很多人来

00:52:44.400 --> 00:52:48.480
从他们经历过一成不变的类型，所以他们在考虑

00:52:48.480 --> 00:52:51.680
代表的代价，他们没有考虑突变

00:52:51.680 --> 00:52:55.119
成本，因为那不是他们的脑海，因为那不是

00:52:55.119 --> 00:52:58.960
他们曾经与他们合作过，但是像您一样，您不能只考虑

00:52:58.960 --> 00:53:01.280
这些的一次表示以及要剃除的字节数

00:53:01.280 --> 00:53:04.319
您必须考虑要多少结构

00:53:04.319 --> 00:53:07.599
随着时间的变化而变化并变得孤立，这就像是

00:53:07.599 --> 00:53:09.920
您在数据库工程中考虑了很多，但您

00:53:09.920 --> 00:53:13.119
不一定要很好地思考世界的不变类型

00:53:13.119 --> 00:53:16.559
然后cid的大小也是巨大的

00:53:16.559 --> 00:53:21.680
当您喜欢小块的变异时

00:53:22.880 --> 00:53:26.960
是的，所以我只是不知道我们是否

00:53:26.960 --> 00:53:30.640
我不知道每次都在哪里

00:53:30.640 --> 00:53:33.680
上周我带给你们几个人的东西

00:53:33.680 --> 00:53:36.720
但是嗯，到目前为止，他们有这种机制

00:53:36.720 --> 00:53:39.760
推动围绕数据结构形状的决策

00:53:39.760 --> 00:53:44.880
嗯，所有的汽油都花在哪里了，所以每次操作都会花费汽油

00:53:44.880 --> 00:53:49.920
对，那么您如何调整数据结构，以减少耗油量

00:53:49.920 --> 00:53:54.160
就像，这是为了提高像这样运行连锁店的成本

00:53:54.160 --> 00:53:57.839
就是要推动那个，所以激励措施被压低了

00:53:57.839 --> 00:54:00.720
运行节点的成本高昂

00:54:00.720 --> 00:54:03.599
因为这些东西不应该太贵，所以你没有这些

00:54:03.599 --> 00:54:08.319
只会占用cpu和磁盘空间的不正当结构，但是

00:54:08.319 --> 00:54:11.119
做到这一点就像有太多

00:54:11.119 --> 00:54:14.880
正如我一直在说的变量，所以他们已经将其范围缩小了

00:54:14.880 --> 00:54:19.599
一些重要的变量等等

00:54:19.599 --> 00:54:21.839
基准测试，但很多也只是

00:54:21.839 --> 00:54:25.839
人与人之间的谈判以及其他各种激励措施

00:54:25.839 --> 00:54:29.040
所以很多东西都脱离了现实世界

00:54:29.040 --> 00:54:32.160
这很难代表它的真实世界

00:54:32.160 --> 00:54:35.839
嗯，对于这些数据结构，它们主要是

00:54:35.839 --> 00:54:39.359
由三项成本驱动，有获取的成本

00:54:39.359 --> 00:54:45.440
ipl获取我的ipld put成本以及每个字节的成本和每个字节的成本

00:54:45.440 --> 00:54:48.079
与其他两个相比，成本确实很小

00:54:48.079 --> 00:54:52.960
因此，他们非常不得不大量地对获利和认沽进行索引

00:54:52.960 --> 00:54:56.799
所以你可以看到如果买入和卖出的话会发生什么

00:54:56.799 --> 00:54:59.760
花费很多钱，并且想要减少数量，然后您将

00:54:59.760 --> 00:55:04.559
提高您的块大小，如果您的成本以字节为单位

00:55:04.559 --> 00:55:08.880
每次获取的输入不够高，那么就会变得越来越大，所以

00:55:08.880 --> 00:55:10.480
你知道有更大的方块，然后

00:55:10.480 --> 00:55:15.119
然后这会使您付出突变的代价，因此当您尝试进行变异时，您最终会

00:55:15.119 --> 00:55:18.720
复制这些巨大的块并只更改其中的一小部分

00:55:18.720 --> 00:55:22.160
这样就可以增加您需要存储的存储量

00:55:22.160 --> 00:55:26.400
这些块，嗯，但这也许是正确的决定

00:55:26.400 --> 00:55:30.240
因为也许存储很便宜然后处理

00:55:30.240 --> 00:55:32.559
障碍不是，但无论如何就是这样

00:55:32.559 --> 00:55:37.359
参与这个决策，这是很高兴能够参与其中

00:55:37.359 --> 00:55:40.480
在对话中，我们可以带来

00:55:40.480 --> 00:55:46.960
嗯，指标和科学的一些测量方法和工具对不起

00:55:46.960 --> 00:55:50.799
彼得，是的，虽然你绝对正确ii

00:55:50.799 --> 00:55:52.960
基本上想在那方面提供帮助

00:55:52.960 --> 00:55:59.200
不仅是测量，还没有巡回演出

00:55:59.200 --> 00:56:01.280
测量文化不存在，因为

00:56:01.280 --> 00:56:04.640
像呃

00:56:04.799 --> 00:56:08.400
人们对莲花的实际作用和水平有很多误解

00:56:08.400 --> 00:56:12.079
缓存的存在和什么是可以接受的

00:56:12.079 --> 00:56:15.760
磁盘上有多少，中间vfs缓存中有多少，我们有多少

00:56:15.760 --> 00:56:19.839
拥有真实的黄金

00:56:19.839 --> 00:56:25.680
您知道大小的内部缓存的样式呃，这被视为

00:56:25.680 --> 00:56:28.480
一个正在做测量的人的黑匣子

00:56:28.480 --> 00:56:32.880
不是解决这个问题的方法，所以我想对每个人都提出质疑

00:56:32.880 --> 00:56:36.559
打电话不要跳进去

00:56:36.559 --> 00:56:41.359
在进行测量之前进行设计决策，就像

00:56:41.359 --> 00:56:44.960
有点像我们使用dumbo drop的经验，直到我们验证了每一个

00:56:44.960 --> 00:56:48.079
事情正常，而实际上通话是

00:56:48.079 --> 00:56:52.000
顺利完成每笔交易

00:56:52.000 --> 00:56:54.480
为了这个人，所以一旦我们得到

00:56:54.480 --> 00:56:58.480
剩下的一切都调试完了，剩下的就是我想的，所以

00:56:58.480 --> 00:57:02.319
与测量和设计一样的东西

00:57:02.319 --> 00:57:06.319
我们需要至少两次重新测量所有内容

00:57:06.319 --> 00:57:12.240
对数字感到满意，所以这就是我们可以追溯到的

00:57:12.240 --> 00:57:16.319
的工作是因为这是因为它成为一个原因

00:57:16.319 --> 00:57:21.119
黑匣子是因为我们在谈论它几乎是晦涩的知识，例如什么时候

00:57:21.119 --> 00:57:23.760
您将其向下推到块级，它在某个地方

00:57:23.760 --> 00:57:26.960
大多数程序员只想将其扔到数据库中，

00:57:26.960 --> 00:57:31.280
忽略它，就像我把它放到那里，然后我从那里拿走，它就到那里

00:57:31.280 --> 00:57:35.680
而且我们已经关注这个空间，并且

00:57:35.680 --> 00:57:38.880
程序员不想也不想等等

00:57:38.880 --> 00:57:42.960
我们看到远处的硬币，我们看到它，我们会一次又一次地看到它

00:57:42.960 --> 00:57:46.480
因为大多数人都不在乎这些东西，而我们一直在关注自己

00:57:46.480 --> 00:57:49.280
让他们到达正确的位置是我们的工作，例如

00:57:49.280 --> 00:57:52.799
如果您可以忘记说明，则该说明会很有用

00:57:52.799 --> 00:57:56.319
嗯，但是然后像你一样，你知道你想签一些东西的费用，所以你

00:57:56.319 --> 00:57:59.280
必须以某种方式实际增加抽象的成本，

00:57:59.280 --> 00:58:02.319
了解他们，所以突然之间，您真的无法

00:58:02.319 --> 00:58:06.319
生活在任何抽象的内部，您必须解开一切并量化

00:58:06.319 --> 00:58:10.799
一切都非常困难，是的，所以我们的工作是

00:58:10.799 --> 00:58:15.119
真正找到了使精髓变得沸腾的方法

00:58:15.119 --> 00:58:19.280
这些东西来传达他们，我想我不

00:58:19.280 --> 00:58:22.160
想我不想说我们没有做

00:58:22.160 --> 00:58:28.240
做得很好，但是你知道这里有工作要做

00:58:28.880 --> 00:58:34.400
好吧，我们时间不多了，有什么事吗

00:58:34.839 --> 00:58:38.400
否则很好，谢谢大家的参与

00:58:38.400 --> 00:58:41.839
下周见

