WEBVTT
Kind: captions
Language: zh-Hans

00:00:01.070 --> 00:00:32.279
然后我开始直播，欢迎大家参加每周IPL

00:00:32.279 --> 00:00:41.879
聋哑会议时间是我的时间是4月29日晚上11点，欢迎大家

00:00:41.879 --> 00:00:47.760
因此，每次我们只是回顾所做的事情，然后讨论所有未解决的问题

00:00:47.760 --> 00:00:55.410
当我是旅行负责人的守门人时，我可能是

00:00:55.410 --> 00:01:00.780
第一个编辑了项目的人，所以我基本上只是从事知识产权

00:01:00.780 --> 00:01:06.450
格式的东西在过去的一周里我仍然得到了Rod的好评，所以希望

00:01:06.450 --> 00:01:11.040
现在的前几个小时都很好，可以在接下来的一两天内合并

00:01:11.040 --> 00:01:18.390
然后冒充整个笔录世界中的整个链条，并与

00:01:18.390 --> 00:01:24.119
我正在尝试为堆栈指定规格而不是IP LD，

00:01:24.119 --> 00:01:36.600
真正快速的错误是一些代表空间的东西，不，哦，我实际上并没有添加

00:01:36.600 --> 00:01:42.329
无论如何，动画都是关于地理数据和空间时态数据的，

00:01:42.329 --> 00:01:48.600
只是一个目录，通常使用美学JSON文件进行订阅，并且

00:01:48.600 --> 00:01:55.890
它确实建立在网络上的em HTTP之上，希望我能说服

00:01:55.890 --> 00:02:00.869
人们至少在某些地方会改变规格或

00:02:00.869 --> 00:02:07.229
与内容寻址系统配合使用，好消息是它们不使用em json-ld

00:02:07.229 --> 00:02:12.370
所以他们不会使用全部内容，就像拥有自己的链接内容一样

00:02:12.370 --> 00:02:17.260
并且他们使用的是网址，因此如果我们使用类似的内容，我们应该会很好

00:02:17.260 --> 00:02:22.120
像IPL d这样的方案：然后CID赛车编码或类似的东西

00:02:22.120 --> 00:02:27.250
我们将看到，还有另一个好消息是，我是大多数朋友

00:02:27.250 --> 00:02:31.900
规范的作者，所以我不太可能有很高的机会

00:02:31.900 --> 00:02:37.380
影响规格，计划是

00:02:37.739 --> 00:02:41.920
实际上可以使用原型，因为它将在八月份召开的会议上

00:02:41.920 --> 00:02:47.200
在我提出要解决的挑战的地方

00:02:47.200 --> 00:02:53.500
东西，我认为是可以接受的，即使它不被接受，我仍然会继续努力

00:02:53.500 --> 00:02:57.430
我班上的那些东西，我认为这也很令人兴奋，因为它

00:02:57.430 --> 00:03:01.000
将是进入Geo世界的第一步，他们不需要获取I

00:03:01.000 --> 00:03:06.220
不喜欢避孕套如何工作的完整概念，他们的主要目的是

00:03:06.220 --> 00:03:09.580
像水壶一样的小步伐显然，进入该空间仅一步之遥，他们

00:03:09.580 --> 00:03:13.180
希望说服他们人们使用它，然后再说一个你知道的首席执行官

00:03:13.180 --> 00:03:15.430
我的数据在里面等等，然后从那里去

00:03:15.430 --> 00:03:20.920
但我对此感到兴奋，因为我认为这是一个不错的小型项目

00:03:20.920 --> 00:03:28.440
开始工作，是的，我所拥有的

00:03:28.720 --> 00:03:33.910
我也可以把它也放在我想忘掉的笔记中

00:03:33.910 --> 00:03:38.260
谈论太多，所以我认为您不必键入我所有的内容

00:03:38.260 --> 00:03:44.250
谢谢你，下一个是迈克尔

00:03:45.170 --> 00:03:50.670
是的，所以我做了一些快速更新，我在地上剥皮了，

00:03:50.670 --> 00:03:55.140
我为我们准备了一些演示的大商店现在基本上可以正常工作了

00:03:55.140 --> 00:03:59.010
可以给我们铸造一些代币，我们可以将其仅用作存储块的地方，如果

00:03:59.010 --> 00:04:03.990
我们想构建一些东西，然后做非常简单的演示，我仍然

00:04:03.990 --> 00:04:08.310
摆弄亚马逊的东西，试图让子域上的云工厂正常工作

00:04:08.310 --> 00:04:12.330
但是我们现在可以使用其他不同的实际结构

00:04:12.330 --> 00:04:17.549
而不是下周的聚会，所以我们有很多人来举行仪式

00:04:17.549 --> 00:04:21.269
我认为在这一点上，是否还有其他人想在这里进行演讲

00:04:21.269 --> 00:04:25.530
房间虽然我们有我们一个非常大的插槽，像一个半小时，所以任何人

00:04:25.530 --> 00:04:27.900
谁想说些什么，也请已签约的人这样做

00:04:27.900 --> 00:04:32.250
请记住，您喜欢写演讲，所以要这样做，然后是，然后

00:04:32.250 --> 00:04:41.880
在几周内为峰会做准备，这真的很有趣两件事是做的

00:04:41.880 --> 00:04:46.190
两周应该可以预定我的票

00:04:52.400 --> 00:04:57.950
反正这是完全有道理的，所以下一个是埃里克（Eric）

00:04:59.790 --> 00:05:07.050
是的，包括我在内的下周的谈话是我忘记了的一件事

00:05:07.050 --> 00:05:11.670
最近几天，我做了很多选择器工作，最后我公开承认

00:05:11.670 --> 00:05:17.670
今天早些时候，所以我们就此和图形公司举行了一次漫长的会议

00:05:17.670 --> 00:05:22.770
一群人，这里的加密板里有一堆链接（如果有人）

00:05:22.770 --> 00:05:26.820
想要检查一下，我已经与一些人讨论过了

00:05:26.820 --> 00:05:33.600
已经，但我认为还可以，但是我们会看到，所以有一些规格公关和

00:05:33.600 --> 00:05:37.080
go代码中的界面一直在慢慢发展，并且它得到了一些

00:05:37.080 --> 00:05:40.800
选择器等有趣的新功能现在将在

00:05:40.800 --> 00:05:45.870
用于描述它们是高基数还是低基数的代码

00:05:45.870 --> 00:05:50.010
他们将要探索的东西在那里，所以我们可以决定我们是否

00:05:50.010 --> 00:05:53.190
要遍历整个节点，或者我们要像拔掉个人插头一样

00:05:53.190 --> 00:05:56.360
字段，这可能是重要的性能优化，例如

00:05:56.360 --> 00:06:03.690
复杂的数据构成了营地和其他东西，所以很有趣，是的

00:06:03.690 --> 00:06:07.530
现在回来的时候，其中一些东西似乎实际上正在很好地成型

00:06:07.530 --> 00:06:11.280
转换为递归格式，所以说实话更像是Volker

00:06:11.280 --> 00:06:15.660
试图推动很久以前，然后我从中吸取的东西

00:06:15.660 --> 00:06:21.290
同时，谢谢你们都比我聪明，我终于来了

00:06:22.610 --> 00:06:29.280
我对这些设计还有一些未解决的问题，例如我曾经遇到过这样的问题

00:06:29.280 --> 00:06:33.090
这样的思路，也许应该有一些细微的区别

00:06:33.090 --> 00:06:39.870
之间的问题之间，例如特定节点是否在匹配集中

00:06:39.870 --> 00:06:44.580
我要在库中调用回调的东西与

00:06:44.580 --> 00:06:48.000
被探索的节点，现在这些都是大杂烩

00:06:48.000 --> 00:06:52.080
在相同的结构中一起玩，我有点想玩另一个草稿

00:06:52.080 --> 00:06:57.540
他们可能分开的地方，因为我认为这可能是一个有用的想法，但

00:06:57.540 --> 00:07:00.570
这就像是一个很大的想法，所以如果有人有更多的时间

00:07:00.570 --> 00:07:03.300
下个星期左右，我想谈谈我非常喜欢的其他话题

00:07:03.300 --> 00:07:11.610
大脑和其他新闻中，我们有杰里米，而我谈论的内容将是

00:07:11.610 --> 00:07:14.550
Falcone开始使用go IPL D所需的

00:07:14.550 --> 00:07:18.600
主要ntldr，他们可能需要绑定两个节点实现

00:07:18.600 --> 00:07:23.970
而且我不知道如何确定优先顺序，所以有一些正在进行中

00:07:23.970 --> 00:07:29.480
对我来说就是这样的讨论

00:07:36.140 --> 00:07:45.110
好的，很酷，谢谢，现在可以了

00:07:45.110 --> 00:07:52.150
其他人有任何更新或想了解他的状态或我的事情

00:07:53.380 --> 00:08:01.400
猜猜我有一个问题，如果我们有时间迈克尔，你可以决定我们这是...

00:08:01.400 --> 00:08:08.200
还是不是，但我一直在向Mike抱怨一下

00:08:08.200 --> 00:08:17.060
我感觉像功能um，我想我的问题就像速度有多慢

00:08:17.060 --> 00:08:24.530
就您而言，它太慢了，您知道问题是否真的如您所知

00:08:24.530 --> 00:08:28.820
如果我们减少提供者记录的数量，例如DHT，

00:08:28.820 --> 00:08:34.850
太慢了，无法做任何事情，我们现在需要东西供人类使用，就像这样

00:08:34.850 --> 00:08:39.200
继续说一个很大的问题，就像我们使用集中式

00:08:39.200 --> 00:08:47.990
与它相反的东西，您可能知道它可能有点慢，或者

00:08:47.990 --> 00:08:52.460
如果人们不知道如何运行集群，那么对他们来说运行集群是很痛苦的。

00:08:52.460 --> 00:08:55.310
您希望他们能够像在Amazon上托管一样使用err或

00:08:55.310 --> 00:08:59.720
类似于使用s3而不是运行必须处理所有节点的节点

00:08:59.720 --> 00:09:03.650
我认为这些流量就像是我想提供的不同问题

00:09:03.650 --> 00:09:08.770
如果人们有时间并且好奇我会很有趣

00:09:08.770 --> 00:09:13.850
好吧，我的意思是说那个问题就是那个问题的答案

00:09:13.850 --> 00:09:17.180
根据用例的不同而有所不同，例如对于某些用例

00:09:17.180 --> 00:09:22.340
可以很好地工作，对于某些不是很好，我想我还不太清楚

00:09:22.340 --> 00:09:27.800
ipfs的主要用例是什么，而不仅仅是软件包管理器和

00:09:27.800 --> 00:09:31.940
如果有一个特定的软件包管理器，并且它是我们知道我们需要的数据

00:09:31.940 --> 00:09:35.510
询问，我们知道有多少条记录可以提出

00:09:35.510 --> 00:09:39.470
相当明确的答案，例如是否可行，但是否可行

00:09:39.470 --> 00:09:42.290
只是一个开放式的问题，我真的不知道如何像我一样正确地解决它

00:09:42.290 --> 00:09:45.530
知道当我们的凯蒂（Katie）做一些尝试去谈论的工作时

00:09:45.530 --> 00:09:50.060
给合作伙伴或潜在合作伙伴及其用例，其中一些已经

00:09:50.060 --> 00:09:56.089
你知道在数以百万计的记录中，这只是一次不做，但我

00:09:56.089 --> 00:09:59.509
不知道这些年轻人是否是我们真正关心的孩子

00:09:59.509 --> 00:10:06.889
在短期内，现在他们有数百万条独立记录吗？

00:10:06.889 --> 00:10:14.689
是的，我们实际上需要个人访问，就像um一样，

00:10:14.689 --> 00:10:19.220
其中之一，就像有多少只小猫，我不知道那里有很多

00:10:19.220 --> 00:10:24.949
将来会更多，这可能是唱片，所以其中一些

00:10:24.949 --> 00:10:29.029
情况下，您可以创建一个大型目录，但问题是，如果

00:10:29.029 --> 00:10:36.250
我想通过哈希指向这些子记录之一直接宣布它

00:10:36.250 --> 00:10:39.800
是的，我的意思是我认为类似问题的问题包括加密猫和

00:10:39.800 --> 00:10:43.610
在很多情况下，这些东西就像是一条长长的长尾巴，

00:10:43.610 --> 00:10:46.550
每个人都会要求的真正高访问权限，然后

00:10:46.550 --> 00:10:51.439
像是90％以上的人像没有人问过的，或者

00:10:51.439 --> 00:10:54.949
确实很少要求这样做，而您知道我们是否将其放在一个

00:10:54.949 --> 00:10:58.009
火腿，这就像是随机的目录

00:10:58.009 --> 00:11:02.269
需要或那个，然后不一定要为我们解决这个问题

00:11:02.269 --> 00:11:06.230
就像我们没有一种很好的方法来提前知道哪些需求

00:11:06.230 --> 00:11:11.060
跳马不关注的那种行为模式

00:11:11.060 --> 00:11:14.870
我正在尝试穿衣服，实际上我有信心写得很好，我可以投入

00:11:14.870 --> 00:11:18.079
我的营地，那么至少我们不会宣布一条路线，但那里的问题是

00:11:18.079 --> 00:11:22.009
这就像有人在外面，所以你知道我直接想要物品而不是这个

00:11:22.009 --> 00:11:27.560
美丽的我的阴茎，那只是行不通，因为我不会有机会

00:11:27.560 --> 00:11:33.139
每一个单独的记录，现在您也正在启动网络

00:11:33.139 --> 00:11:36.860
对于树上右侧的每个更改，因为您只是宣布路线

00:11:36.860 --> 00:11:40.009
因此，喜欢的人在收到数据后就订阅了旧路线

00:11:40.009 --> 00:11:43.699
昨天不会与新朋友共享网络，但是

00:11:43.699 --> 00:11:47.720
但是同时如果您查看软件包管理器用例，例如

00:11:47.720 --> 00:11:53.000
很多受欢迎的软件包都只有5％，所以如果我们只是

00:11:53.000 --> 00:11:57.529
去吧，他们说的像包裹名称记录一样，像路线

00:11:57.529 --> 00:12:01.819
每个软件包的名称而不是每个单独的版本的名称

00:12:01.819 --> 00:12:05.750
这样就足够了，然后您就会知道

00:12:05.750 --> 00:12:10.550
npm很快就会有一百万条记录，现在大概有70万条，但是

00:12:10.550 --> 00:12:12.860
那可能实际上是可以管理的，而就像你

00:12:12.860 --> 00:12:15.980
执行版本，然后执行版本中每个文件的所有块

00:12:15.980 --> 00:12:19.100
你看着你知道也许有1亿条记录

00:12:19.100 --> 00:12:27.420
然后，我们可能可以宣布整棵树的路线，好吧，不，不，

00:12:27.420 --> 00:12:31.820
 [笑声]

00:12:37.180 --> 00:12:41.600
是的，我的意思是，我想我认为NPM如果我们不跟他一起去，我们就去

00:12:41.600 --> 00:12:44.360
将它们包装成较小的包装，我们绝对可以在每个包装中做到这一点

00:12:44.360 --> 00:12:48.110
包名称，如果我们想放置NPM数据并且我们想要足够它们堆叠

00:12:48.110 --> 00:12:53.420
名称，我们知道那是一百万条记录，是的，如果可以的话，

00:12:53.420 --> 00:12:57.680
知道我们可以做一百万条记录，但是那是我也是

00:12:57.680 --> 00:13:01.700
像一些更集中的签约系统那样有独立的问题

00:13:01.700 --> 00:13:05.420
这当然是更分散的东西，我集中了数据

00:13:05.420 --> 00:13:10.130
基本上，您的存储系统具有良好的性能，就像您仍然可以找到数据一样

00:13:10.130 --> 00:13:14.870
说是网络，但您希望参考或其中的内容

00:13:14.870 --> 00:13:19.790
告诉你在哪里可以找到数据可能是某人集中的是的，是的，我的意思是

00:13:19.790 --> 00:13:23.810
像这些，这些都像我们有很多不同的答案，

00:13:23.810 --> 00:13:26.570
我们可以适用于不同的用例，我认为我们真正需要的是

00:13:26.570 --> 00:13:30.920
理解这就像用例所说的ITS最终将达到最大

00:13:30.920 --> 00:13:34.580
像进行优化一样，我们肯定需要能够修复，然后我们可以

00:13:34.580 --> 00:13:37.880
说好吧，就是这个，这可能是我们的研究项目

00:13:37.880 --> 00:13:40.280
还没有一个很好的答案，也许我们需要在

00:13:40.280 --> 00:13:45.110
过渡，或者只是简单的事情哦，不，我们只是写一个系统

00:13:45.110 --> 00:13:49.430
我们只宣布树的这一级别，而不是每个req而不是每个

00:13:49.430 --> 00:13:52.280
cid在树中，然后这就是我们需要编写的解决方案

00:13:52.280 --> 00:13:56.570
那是因为我们还没有，但是是的，我只是不明白

00:13:56.570 --> 00:14:00.110
关于用途的答案已经针对它进行了优化，所以我不是，我没有什么好

00:14:00.110 --> 00:14:08.300
现在的方向，是的，很好，我想我只是很好奇

00:14:08.300 --> 00:14:13.670
因为是的，显然我提出的建议

00:14:13.670 --> 00:14:21.439
与DHT记录无关，这很有帮助，但很有帮助，但是

00:14:21.439 --> 00:14:25.069
如果您希望能够在不运行的情况下存储数据，将很有帮助

00:14:25.069 --> 00:14:29.420
Nakia巨星笔记，但如果我也有的话，对这个问题根本没有帮助

00:14:29.420 --> 00:14:36.050
很多记录，我是说II我不是，我实际上没有充分的理由不

00:14:36.050 --> 00:14:39.980
正确地做，就像我没有充分的理由不将多重加法器放进去

00:14:39.980 --> 00:14:44.209
意思是也许斯蒂芬做到了，但我不明白为什么会有这种灵活性

00:14:44.209 --> 00:14:47.749
将来对某些用例不会有用，我只是不知道

00:14:47.749 --> 00:14:52.309
一定要解决我们现在认为最优先的问题，但我没有

00:14:52.309 --> 00:14:55.279
认为这是一个很大的变化，就像如果我不认为那会是什么一样

00:14:55.279 --> 00:14:58.759
实施起来很困难，所以我没有任何理由不这样做

00:14:58.759 --> 00:15:06.769
这将是痛苦的，但是任何网络变化基本上都是痛苦的

00:15:06.769 --> 00:15:10.759
我认为可能有一些方法可以使我们基本上减轻痛苦

00:15:10.759 --> 00:15:13.519
我们要做的是过渡期，就像大型服务器启动了一个

00:15:13.519 --> 00:15:19.569
服务器开始支持它，然后我有一些深海客户开始使用它

00:15:19.839 --> 00:15:34.540
实际上就像是的，那您是说我会有一段时间

00:15:34.540 --> 00:15:38.480
意思是说，我想借此让自己更清晰，你的意思是说有一段时期

00:15:38.480 --> 00:15:42.170
在DHT中有使用此新事物的记录的时间

00:15:42.170 --> 00:15:45.439
同行只是不知道该怎么做，或者像这些同行一样会崩溃

00:15:45.439 --> 00:15:49.009
当他们看到这些数据是因为他们喜欢哦，不，这是正确的，例如

00:15:49.009 --> 00:15:52.639
就像那对网络的破坏性很好一样，只是服务器

00:15:52.639 --> 00:15:57.470
可能会拒绝它，这取决于我们如何实现拒绝的东西

00:15:57.470 --> 00:16:02.569
这些记录完全是这样，因此实际上它想使它有用，而无需添加

00:16:02.569 --> 00:16:04.759
一堆往返，例如尝试一些尝试，然后如果那不起作用

00:16:04.759 --> 00:16:09.170
尝试其他类似的事情，我们可以让沙滩队

00:16:09.170 --> 00:16:11.899
协议，所以如果您提前学习哦，您会说这个人的协议

00:16:11.899 --> 00:16:15.709
因此，我知道过去曾经可以存储这些记录，或者我们

00:16:15.709 --> 00:16:19.790
就像说得好一样，我们在服务器端为此提示记录添加了支持

00:16:19.790 --> 00:16:22.850
等待几个版本获得最大的网络升级，我们可以看看

00:16:22.850 --> 00:16:26.629
像高清网络爬虫一样，似乎最无主的网络被无罪释放了，然后一次

00:16:26.629 --> 00:16:30.139
发生了这种情况，然后我们升级了所有客户，然后说现在可以了

00:16:30.139 --> 00:16:33.580
客户可以开始装修，否则我认为

00:16:33.580 --> 00:16:36.760
客户将记录放置在DVR之前，我们支持将这些服务器删除

00:16:36.760 --> 00:16:45.100
唱片中的白色，我们将打破一切，是的，很好

00:16:45.100 --> 00:16:49.800
不会破坏任何不会添加任何功能的客户端，因此

00:16:49.800 --> 00:16:54.550
我很好，我的意思是说，这样我就可以像唱片一样将其放在唱片中

00:16:54.550 --> 00:16:57.970
可能会吸引一些东西，有些我不知道会破坏它

00:16:57.970 --> 00:17:01.450
是的，否则我知道，就像他只是不做任何事一样

00:17:01.450 --> 00:17:08.189
可能不错，其他问题，例如我不确定

00:17:08.189 --> 00:17:11.500
我知道我逐渐确定激励因素是正确的解决方案

00:17:11.500 --> 00:17:15.220
因为多重还寻址机器，它们有点像

00:17:15.220 --> 00:17:23.500
像这台机器mm-hmm，我们还能说点什么吗，就像我们需要的一样

00:17:23.500 --> 00:17:27.610
你应该对这台机器说这个协议赫兹这个东西很好

00:17:27.610 --> 00:17:30.480
就像他们告诉您如何连接机器，但他们不喜欢

00:17:30.480 --> 00:17:34.360
好吧，现在有整个事情，就像有什么懈怠

00:17:34.360 --> 00:17:38.620
发生的事情和一些关于Lib kooky家伙试图解决的github问题

00:17:38.620 --> 00:17:44.530
用多梯形图输出HTTP和UNIX套接字地址，是的，就像该计划是

00:17:44.530 --> 00:17:52.600
做到这一点，但这就是真的，就像地址HTTP端点不一样

00:17:52.600 --> 00:17:57.520
按摩成文件，就像使用了HTM点之类的所有东西

00:17:57.520 --> 00:18:00.550
例如RPC库或类似内容的内容

00:18:00.550 --> 00:18:06.100
服务器就像大多数事情一样，只是它不用于内容，就像这样

00:18:06.100 --> 00:18:09.400
我们会用它说好吧，这里就像服务器中的该目录，

00:18:09.400 --> 00:18:14.110
那么在此之下或真的就像这是该API端点在某处查询

00:18:14.110 --> 00:18:20.080
这个东西的API端点问题就像我认为我们有

00:18:20.080 --> 00:18:24.340
三个字段不会像这里是您与之交谈的端点

00:18:24.340 --> 00:18:29.530
协议，您应该与该端点通信，然后，是的，真的

00:18:29.530 --> 00:18:31.930
开始黑鬼了，是的，但这是终点，这是我们的协议

00:18:31.930 --> 00:18:37.420
应该像人们共同描述的雇员那样讲这个，我们可以

00:18:37.420 --> 00:18:43.140
可能使他们像这样的空间不是所有的剧院都很好定义

00:18:45.110 --> 00:18:53.000
是的，对不起，我不得不结束这个讨论，因为我刚刚看到了那个标尺

00:18:53.000 --> 00:18:56.570
它加入了通话，他还应该花时间谈论他的更新

00:18:56.570 --> 00:19:10.750
所以对吧，对不起，对，所以在Maya地方看，我没有什么主要的

00:19:10.750 --> 00:19:15.620
报告说，我有两个星期的工作效率最高，原因是

00:19:15.620 --> 00:19:23.710
一些健康问题，但是我花了很多时间在架构上

00:19:23.710 --> 00:19:30.290
在一个小的测试套件中构建一个模式学历，希望能尝试获得

00:19:30.290 --> 00:19:34.490
这项权利，还碰到了我一直在讨论的一些问题

00:19:34.490 --> 00:19:40.280
与埃里克（Eric）来回交流有关联盟代表的情况，因此

00:19:40.280 --> 00:19:47.000
这很有意思，另一件事是请求请求

00:19:47.000 --> 00:19:52.970
volkl放入所有IPL DJ的库中，这确实是一个很好的选择

00:19:52.970 --> 00:19:58.690
有机会深入了解它们的所有细节，就像我没有真正看过

00:19:58.690 --> 00:20:05.450
protobuf我剥开了一个图书馆，我花了一些宝贵的时间来理解，所以

00:20:05.450 --> 00:20:11.780
那对理解事物的阶段非常有帮助，所以那些

00:20:11.780 --> 00:20:15.670
对我来说是两大亮点

00:20:15.760 --> 00:20:20.990
继续前进，我主要专注于架构方面，因为我想要我想要

00:20:20.990 --> 00:20:24.500
我真的很想做到这一点，让我可以真正开始实施

00:20:24.500 --> 00:20:29.810
因为我可以想象这是一个持续的兔子洞

00:20:29.810 --> 00:20:34.400
几个月我真的不希望发生这种情况，我希望能够将其用于

00:20:34.400 --> 00:20:39.860
很快就会有一些有趣的事情，以便我们可以证明其实用性，那就是

00:20:39.860 --> 00:20:46.539
旨在使其很快有用的目标是

00:20:46.539 --> 00:20:55.269
-感谢您的更新，还有其他人想谈的话题吗？

00:20:55.269 --> 00:21:01.130
一种方法，可以使塞西尔早日计划

00:21:01.130 --> 00:21:08.210
像上帝一样思考，肯定是我一直在考虑的一件事

00:21:08.210 --> 00:21:14.570
现在，在NGO方面进行的工作不考虑DSL解析器的角度，

00:21:14.570 --> 00:21:18.830
在go代码中具有完全等效的表示形式，并试图

00:21:18.830 --> 00:21:24.590
写验证器部分，因为这对我们在某些情况下使用它会很好

00:21:24.590 --> 00:21:30.350
我真的很想拥有其他东西的数据，如果我不能哀叹的话

00:21:30.350 --> 00:21:34.730
拥有DSL，但随后将所有这些类型写入go结构中，然后

00:21:34.730 --> 00:21:38.990
在我为选择器起草的东西上使那个验证方法起作用

00:21:38.990 --> 00:21:43.519
例如，只需确保我没有在选择器中执行任何BS

00:21:43.519 --> 00:21:47.059
会给我的另一件事是真的很快就在你身上，这不是东西

00:21:47.059 --> 00:21:50.450
完全降落了，要么去图书馆，但我希望这是为了

00:21:50.450 --> 00:21:57.799
如何使其具体化的一个例子验证您的意思

00:21:57.799 --> 00:22:04.279
像不是基本类型的类型就是你所要

00:22:04.279 --> 00:22:12.320
在思考哪种验证方式就像需要IPL的整个树一样

00:22:12.320 --> 00:22:17.870
并像理智的检查它是否匹配架构，就像我有一个布尔值一样

00:22:17.870 --> 00:22:27.679
出现在这些数据中，本来不应该说话，但我真的很

00:22:27.679 --> 00:22:33.320
真的很高兴您也在做DSL科学方面的工作，我只是我不是

00:22:33.320 --> 00:22:38.029
特别是在JavaScript中看到它，我看不到更简单的制作方法

00:22:38.029 --> 00:22:44.480
它不仅可以获取数据，而且还可以进行转换，因此非常有用

00:22:44.480 --> 00:22:52.700
结构将其转变为您真正想要的就是我在想的

00:22:52.700 --> 00:22:56.600
也许这不是错误的做法，但这似乎是最合乎逻辑的

00:22:56.600 --> 00:23:02.629
部分实用程序，我对所有这些都感到非常兴奋

00:23:02.629 --> 00:23:06.139
到目前为止，您已经选择了一些路线，所以我只是提供一些

00:23:06.139 --> 00:23:12.399
这里的方式不同，但是基于不同的限制-所以她是我

00:23:13.749 --> 00:23:19.489
仍然想把这个联盟的东西弄对，所以我接下来要做什么

00:23:19.489 --> 00:23:24.379
几天都在努力，我将处理您提出的建议

00:23:24.379 --> 00:23:30.379
将字段的表示与朋友对齐，看看是否

00:23:30.379 --> 00:23:34.849
解决了一些烦恼，因为它确实是当您看着

00:23:34.849 --> 00:23:39.049
在解析器中，然后是工会才成为问题，因为所有

00:23:39.049 --> 00:23:42.950
参考表示所做的事情与您所要做的完全不同

00:23:42.950 --> 00:23:51.470
阅读，所以看起来似乎不正确，这是哦，是否有可能

00:23:51.470 --> 00:23:55.070
没有太多其他奇怪的例子，但您是否尝试过

00:23:55.070 --> 00:24:00.710
有价格的例子，如结构，我表示为数组的东西

00:24:00.710 --> 00:24:05.509
因为那些人​​也很奇怪，但也许不是，我真的

00:24:05.509 --> 00:24:11.690
昨天在船上工作的时候，似乎并没有发现

00:24:11.690 --> 00:24:17.840
有问题，我没有完成任何字符串格式的工作

00:24:17.840 --> 00:24:25.009
男人，也许他们最终也会变得很怪异，但看起来好像工会

00:24:25.009 --> 00:24:28.879
从根本上来说很奇怪，因为他们每个人都是不同的，但是

00:24:28.879 --> 00:24:32.200
是的，你可能是对的

00:24:35.019 --> 00:24:39.259
因此，在这种情况下，我需要的就像我想在JavaScript中拥有的一样

00:24:39.259 --> 00:24:44.090
基本上只是一个更改日志数据结构，所以注释本身将

00:24:44.090 --> 00:24:47.809
具有当前路线，例如指向当前路线的链接，但我不链接至

00:24:47.809 --> 00:24:51.739
先前的更改日志路由，以便您可以遍历所有先前的

00:24:51.739 --> 00:24:57.320
版本随着您的更新而变化，并且随着您的更新，它的变化也比较温和

00:24:57.320 --> 00:25:02.989
将路径应用到这些路径，这些路径都直接应用于当前的

00:25:02.989 --> 00:25:07.070
当前路线，但还有一个属性，可用于返回版本

00:25:07.070 --> 00:25:11.179
时间，但是是的，那些人会暴露于几乎没有什么不同的原因，他们

00:25:11.179 --> 00:25:13.130
实际上是在数据结构中查找，所以就像

00:25:13.130 --> 00:25:18.800
就像我转变为读者一样，是的，我不知道我不知道如何

00:25:18.800 --> 00:25:22.870
接近，我们要成为一件事情

00:25:24.610 --> 00:25:28.910
我想跳过它们的原因之一是一些不太新颖的

00:25:28.910 --> 00:25:33.530
之所以使用string.format只是因为我没有想到他们显然有

00:25:33.530 --> 00:25:41.510
通过转换直接屏蔽哦，是的，这不是

00:25:41.510 --> 00:25:46.250
字符串转换的东西，它是它的路径转换文件，继续吧，知道一个

00:25:46.250 --> 00:25:51.080
这是我正在尝试通过修剪来更快地达到该目标

00:25:51.080 --> 00:25:55.610
其中一些东西似乎有点多余，但有必要，但

00:25:55.610 --> 00:26:03.290
在将来，但对于早日投入使用不是那么有用，所以我的意思是

00:26:03.290 --> 00:26:07.400
我需要我需要根据我的方法画一条线，因为我不需要

00:26:07.400 --> 00:26:13.760
就像我说的那样，我不想在接下来的两个月里花光

00:26:13.760 --> 00:26:18.860
暂停并使其变得完美，因为这似乎不是一个好地方

00:26:18.860 --> 00:26:25.610
使用时间，所以我需要确保我采取的方法正在工作

00:26:25.610 --> 00:26:32.270
朝着有用的东西迈进，如果没有改变，也许会继续前进

00:26:32.270 --> 00:26:36.160
用于验证器而不是转换

00:26:36.700 --> 00:26:43.490
是的，很好奇，自您粘贴以来，我认为我没有看过很多代码

00:26:43.490 --> 00:26:57.470
聊天中的一些挂钩语法，您是否生成了一个ast节点图，我

00:26:57.470 --> 00:27:05.210
猜想那是可以做的

00:27:05.210 --> 00:27:11.660
因此付费语法将生成一个本质上是一种数据结构，

00:27:11.660 --> 00:27:19.660
代表强大的力量，不是完美的AST，但足够接近

00:27:21.550 --> 00:27:26.750
我会尽快将代码上传到github上的某个地方

00:27:26.750 --> 00:27:32.390
处于可以放置任何地方的良好状态，最好多做一点

00:27:32.390 --> 00:27:38.270
结构化，所以我想要做的就是共享测试用例

00:27:38.270 --> 00:27:42.830
夹具，所以我以一种形式编写它们，它们以以下格式编写

00:27:42.830 --> 00:27:50.630
不是特定于JavaScript的，因此它具有模式片段和一个JSON

00:27:50.630 --> 00:27:55.580
表示将产生什么，如sup很有用，然后我

00:27:55.580 --> 00:28:02.120
想要补充一下，以使您知道数据结构，这是因为它

00:28:02.120 --> 00:28:07.340
可能来自以JSON表示形式的块，然后能够应用

00:28:07.340 --> 00:28:11.180
这个计划我也还没讲，但这就是其他

00:28:11.180 --> 00:28:15.320
直到下周我一直都是极客，所以我想和你分享这些，因为

00:28:15.320 --> 00:28:22.310
他们就是我开始看到更多这些模式的地方

00:28:22.310 --> 00:28:27.080
的例子真的会让这件事至少对我来说变得生动起来，所以

00:28:27.080 --> 00:28:30.230
这些东西构成了这些东西的小片段

00:28:30.230 --> 00:28:35.390
它应该代表什么是有用的

00:28:35.390 --> 00:28:39.200
我也很想展示最有趣的一点，所以我继续讲下去

00:28:39.200 --> 00:28:50.210
github以某种有用的方式，所以很酷，还可以吗，因为

00:28:50.210 --> 00:28:56.170
我们已经快没时间了，我没看到任何人

00:28:56.170 --> 00:29:04.220
所以哦，我看到了双手，但他们没有等好，谢谢大家的时间

00:29:04.220 --> 00:29:10.900
再过两个星期再谈

