WEBVTT
Kind: captions
Language: zh-Hans

00:00:02.389 --> 00:00:11.969
欢迎大家参加本周的IPL d每周会议，即2020年2月10日

00:00:11.969 --> 00:00:16.680
每周我们都会回顾上周末计划要做的事情

00:00:16.680 --> 00:00:21.869
下周，然后讨论我们可能拥有或也介绍的所有未完成项目

00:00:21.869 --> 00:00:26.210
每个刚接触本专栏的人都想自我介绍

00:00:26.210 --> 00:00:32.399
是的，也许是从这个开始的，所以我看到了一张新面孔

00:00:32.399 --> 00:00:37.980
好吧，如果您不想要的话，您想快速介绍一下自己吗，那也很好

00:00:37.980 --> 00:00:51.570
我只是想看看IPL D世界中发生了什么

00:00:51.570 --> 00:00:56.670
从我自己开始，我当然没有做太多与实际相关的事情

00:00:56.670 --> 00:01:01.829
上周上班，但是这周我肯定会有时间再上班

00:01:01.829 --> 00:01:06.810
在粗糙的一面，而我主要集中在多格式的东西上

00:01:06.810 --> 00:01:12.060
因为是的，几个克里斯在福克斯（Forks）开张，然后又把他们聚在一起，

00:01:12.060 --> 00:01:19.020
我有一个坚实的基础可以面对高质量

00:01:19.020 --> 00:01:28.470
我名单上的下一位是Michael对不起Nina，是的，所以基本上上周我

00:01:28.470 --> 00:01:34.920
到达了这个大数据集项目的compy生成方面，所以它

00:01:34.920 --> 00:01:39.740
立即让lambda崩溃了，我们调查了它使用了很多

00:01:39.740 --> 00:01:46.259
暂存磁盘空间和大量内存，因此在国外将其计算出来

00:01:46.259 --> 00:01:50.640
除去包裹在铁锈中的第一块，这消除了一些记忆

00:01:50.640 --> 00:01:57.149
我认为的用法，但仍使用大量暂存磁盘和内存，然后使用支点

00:01:57.149 --> 00:02:00.420
从那里开始，我想我们周围的人走到了一起，所以现在

00:02:00.420 --> 00:02:05.670
认为我们最终会像在lambda上运行时那样生锈

00:02:05.670 --> 00:02:10.379
体育版本而不会崩溃嗯，但这就是这个

00:02:10.379 --> 00:02:13.800
都是我们是否一直在生成par文件的问题

00:02:13.800 --> 00:02:17.640
只是再来一点，因为我们认为风在

00:02:17.640 --> 00:02:21.570
猎鹰部门的填充工作是，您将所有部件组装成一个

00:02:21.570 --> 00:02:25.530
扇区，然后您进行了填充，但是填充实际上发生在每个

00:02:25.530 --> 00:02:31.620
一块，所以每一块的大小必须是两倍或扇形的因数，

00:02:31.620 --> 00:02:37.860
所以这意味着一个文件突然超过一个演出将填充到两个演出，这是

00:02:37.860 --> 00:02:41.370
像几乎所有我们一直在为此生成的数据一样，所以我必须去

00:02:41.370 --> 00:02:48.540
返回并重写切片器和分配器地球，然后重新生成一个

00:02:48.540 --> 00:02:52.080
小数据集确保所有功能都可以通过compy运行，如果

00:02:52.080 --> 00:02:56.580
到那时为止工作正常，然后还编写了一个非常大的正在运行的迁移

00:02:56.580 --> 00:03:03.840
脚本将所有旧数据移至新数据，并将其切片并分配到

00:03:03.840 --> 00:03:09.470
par文件小于一个好文件，所以这是我本周的最后一个周末

00:03:09.470 --> 00:03:14.310
上周也完成了评论，所以我会评论大约101到

00:03:14.310 --> 00:03:27.060
今天要经过他们了，下一个是蒂姆，好吧，所以上周是

00:03:27.060 --> 00:03:30.300
有效率的我经历了选择者所受到的所有限制

00:03:30.300 --> 00:03:35.250
语法，并提出了这种非常深奥的语法，可能无法正常工作

00:03:35.250 --> 00:03:39.720
我知道我的意思是如果这是制约因素，所以我写了一个PR来描述它，而我

00:03:39.720 --> 00:03:45.120
现在愿意为它运行一个解析器以验证它不是非常模棱两可

00:03:45.120 --> 00:03:52.230
我看到的最大问题是，将来我们可能会遇到一些类似的问题

00:03:52.230 --> 00:03:55.860
语法的版本和解析器的新版本，反之亦然，这不是

00:03:55.860 --> 00:04:00.959
完全自我记录的语法，需要一些上下文，以便决定是否

00:04:00.959 --> 00:04:06.810
是个好主意，但是是的，这周我很期待反馈

00:04:06.810 --> 00:04:14.220
在那并进行迭代，这在上下文中确实有很多

00:04:14.220 --> 00:04:23.250
也适用于完全解析的形式

00:04:23.250 --> 00:04:27.780
像JSON这样的结构化数据格式，您得到的引号是任意键

00:04:27.780 --> 00:04:32.070
而与此相关的关键字只让您知道关键字的起始位置和

00:04:32.070 --> 00:04:35.850
停止是因为您有一个固定的关键字词典，但没有

00:04:35.850 --> 00:04:41.820
空间可以很好地区分，因此从技术上讲它是一种非常紧凑的编码

00:04:41.820 --> 00:04:45.660
但我不确定它是否足够灵活，足以应对我不得不说的迁移问题

00:04:45.660 --> 00:04:50.040
我的意思是说我可能是埃里克（Eric）可以点击

00:04:50.040 --> 00:04:53.760
就我而言，我不能，但就像我脑海中的所有情况一样，我会

00:04:53.760 --> 00:05:01.530
不必担心必须拥有特定于版本的语法解析器

00:05:01.530 --> 00:05:05.580
因为解析后的形式很好并且不需要该上下文，所以我们总是可以

00:05:05.580 --> 00:05:13.770
拥有解析后的表单，并且确切地知道我的意思是我让我变得与以前完全一样

00:05:13.770 --> 00:05:17.760
没错，我是说ILD数据结构是

00:05:17.760 --> 00:05:23.100
事实是，如果我最担心的是，如果我有一个新的

00:05:23.100 --> 00:05:26.970
版本的语法，我可能正在使用旧版本的解析器

00:05:26.970 --> 00:05:31.100
不会这么做的，但是如果我们不在乎支持的话，我们会很好的

00:05:31.100 --> 00:05:37.020
是的，我认为我们至少可以在一段时间内发现情况并非如此

00:05:37.020 --> 00:05:41.420
这不是真的，我们会担心它的到来

00:05:43.870 --> 00:05:52.600
普尔混合了什么是埃里克（Eric）出口，我将选择您认为是的DSL东西

00:05:52.600 --> 00:05:56.350
只要你不要太疯了，让我们说些简单的话，我并不担心

00:05:56.350 --> 00:06:01.720
迁移是您看到的最后几条评论

00:06:01.720 --> 00:06:08.050
按时间顺序，电子邮件或空白具有一些语义，我认为这是

00:06:08.050 --> 00:06:12.250
只要您将其定义为要打开的空白，就可以任意折叠

00:06:12.250 --> 00:06:21.580
无论如何，像这样的空白空间是很常见的事情，所以我

00:06:21.580 --> 00:06:24.340
刚坐下来，本周做了很多代码，这很好

00:06:24.340 --> 00:06:29.260
我与我上周希望达到的水平相当

00:06:29.260 --> 00:06:34.750
重新实现了整个基本IPL表示包，以使无类型内容符合

00:06:34.750 --> 00:06:42.040
出于性能目的的新接口，并且几乎完成了该工作，

00:06:42.040 --> 00:06:44.740
有一个列表的新实现和其他所有的新实现

00:06:44.740 --> 00:06:50.740
标量所有15个新接口，我将进行一系列新测试，因此下周

00:06:50.740 --> 00:06:56.740
只是将这些内容带入核心，所以现在很有趣

00:06:56.740 --> 00:07:02.260
所有这些东西都写在名为研究的分支中，而在其他一些分支中

00:07:02.260 --> 00:07:06.370
将软件包与主要软件包分开以控制范围爆炸

00:07:06.370 --> 00:07:11.530
当我处理它时，下一步是将其合并到主文件夹中

00:07:11.530 --> 00:07:15.700
主分支，处理日常混乱的爆炸，所以我要

00:07:15.700 --> 00:07:20.680
希望我可以移植所有编解码器，所有遍历逻辑和所有

00:07:20.680 --> 00:07:24.580
新界面的选择器，我要声明我可以在一个

00:07:24.580 --> 00:07:32.500
一周，我们会看到这有点激进，但也许像这些

00:07:32.500 --> 00:07:36.160
界面更改也可能会为任何事情产生一些工作

00:07:36.160 --> 00:07:40.870
下游正在使用它，我主要是在想

00:07:40.870 --> 00:07:44.500
我认为汉娜是主要的甲板protobuf面对面回购

00:07:44.500 --> 00:07:49.780
作者，那将需要一些更新，但希望它们很简单

00:07:49.780 --> 00:07:54.280
像这样的东西应该有哈希固定的版本，所以它不是

00:07:54.280 --> 00:07:57.879
想要完全打破门

00:07:57.879 --> 00:08:03.399
当我将所有这些更新进行为

00:08:03.399 --> 00:08:06.520
法典，逆转和选择器，还有我实际上所学的课程

00:08:06.520 --> 00:08:11.349
暂时将当前的令人信服的软件包放入仓库中

00:08:11.349 --> 00:08:14.919
抛弃他们，因为我认为保持移民生活的效用不大

00:08:14.919 --> 00:08:18.399
会变得有价值，我只是想写一堆这样的东西

00:08:18.399 --> 00:08:21.939
我认为吸取的教训并在更换镜头后重新启动

00:08:21.939 --> 00:08:25.110
这将变得更加容易，并且吸取了一些教训，所以就像

00:08:25.110 --> 00:08:31.240
也净化了逾越节，我在做测试的过程中玩得很开心

00:08:31.240 --> 00:08:34.329
现在，这是我上次尝试进行序列化时学到的东西

00:08:34.329 --> 00:08:40.060
laberd是探测每个极端情况与序列化之间的矩阵，

00:08:40.060 --> 00:08:45.639
所有这些递归结构程序集，还处理可能要键入的内容

00:08:45.639 --> 00:08:50.050
或同时未键入类型的灵活数据的数量

00:08:50.050 --> 00:08:56.139
要测试的东西真的非常多，所以我开始付出更多的努力

00:08:56.139 --> 00:09:00.730
确保这次所有的测试规格都能很好地形成

00:09:00.730 --> 00:09:04.959
只是不幸地给他们起了个名字，就像确保我知道我拥有的东西一样。

00:09:04.959 --> 00:09:10.089
案例涵盖，所以如果理想的话，我想拥有一套程序化的

00:09:10.089 --> 00:09:15.430
像这样的行为的测试规范应确认正确的操作

00:09:15.430 --> 00:09:20.560
Mac，只要该映射的定义具有字符串键和整数值

00:09:20.560 --> 00:09:26.500
和这些特殊的键，这很有趣，因为如果您有未键入的地图

00:09:26.500 --> 00:09:32.769
那不是一堆约束，但是如果您在一块打字的纸上使用它

00:09:32.769 --> 00:09:35.889
如果碰巧像地图一样强大的信息，那么突然

00:09:35.889 --> 00:09:39.730
所有这些额外的入门食物都很重要，所以我开始用它来编写测试规范

00:09:39.730 --> 00:09:52.709
请记住，这很有趣，这是我的一周，谢谢，我名单上的下一个是

00:09:53.819 --> 00:10:02.880
好吧，所以我开始一周的时间非常接近JavaScript C球

00:10:02.880 --> 00:10:08.800
发布基本的解码器和编码器-暂时支持标签

00:10:08.800 --> 00:10:15.800
哇，我只想发布它，所以我可以公开进行工作，以便

00:10:15.800 --> 00:10:20.470
是酒吧试图到达的地方，只需要完成浮漂就可以完成

00:10:20.470 --> 00:10:26.830
我是凯恩（Kane）关于探索垂直整合的话题

00:10:26.830 --> 00:10:33.560
之间的潜力一直到计划者，所以不仅仅是治疗

00:10:33.560 --> 00:10:38.360
从传统上讲，特别是在JavaScript节点中，我们会非常

00:10:38.360 --> 00:10:45.470
严格遵守我们的模块边界，但我认为如果我们改变思维方式

00:10:45.470 --> 00:10:52.790
关于JavaScript中IP LD中的Codex，还有很多有趣的潜力

00:10:52.790 --> 00:11:01.190
用于连接该垂直通道，所以无论如何，这就是我一直在拖曳的东西

00:11:01.190 --> 00:11:09.020
我脑子里充满了很多，而我正在建立关于你怎么说的事情

00:11:09.020 --> 00:11:14.780
一些教练和模式，您可以真正建立关于

00:11:14.780 --> 00:11:22.760
如果您构建可在类似环境下工作的编解码器，这些东西将如何编码

00:11:22.760 --> 00:11:28.580
时尚，所以如果您说好，我就知道这很简单，我在做这种模式，而我

00:11:28.580 --> 00:11:33.160
只关心C球很棒，您可以做一些非常酷的垂直整合

00:11:33.160 --> 00:11:37.670
如果您想变得更加灵活，那么就必须使用编解码器

00:11:37.670 --> 00:11:42.590
很好地结合在一起，其中很多来自埃里克已经拥有很多东西的地方

00:11:42.590 --> 00:11:49.700
我认为这方面的发挥还不错，还有很多潜力可以发挥

00:11:49.700 --> 00:11:56.450
一直从编解码器一直连接到一起，但仍然存在

00:11:56.450 --> 00:12:01.310
发生了很多垂直的事情，在那里东西可以交换进出

00:12:01.310 --> 00:12:06.920
通过不将分层视为超严格的公正出血来提高效率

00:12:06.920 --> 00:12:12.250
他们以明智的方式彼此相处得更多，你知道

00:12:12.250 --> 00:12:19.670
反正成为一个好的模范公民，这就是我这周开始的事情

00:12:19.670 --> 00:12:22.339
然后因为其他事情而分心，因为这些

00:12:22.339 --> 00:12:27.680
出现了五个硬币的东西，所以我正在处理的两件事很快

00:12:27.680 --> 00:12:33.379
javascript的汽车格式修复程序证明，Michael只是想抛出

00:12:33.379 --> 00:12:38.990
汽车文件生成器中的数据和我的ap眼睛假设您要

00:12:38.990 --> 00:12:45.350
成为一个好等待的公民，说并冷静地等待着障碍

00:12:45.350 --> 00:12:50.779
写的，所以我不得不改变它，并使其真正写东西

00:12:50.779 --> 00:12:56.889
顺序地假设事物可以进入而没有

00:12:56.889 --> 00:13:04.089
等待，那似乎正在工作，现在我仍然来迈克尔

00:13:04.089 --> 00:13:08.689
花一些时间测试您以此生成的不同汽车文件

00:13:08.689 --> 00:13:13.490
确保他们确实在做应该做的事情

00:13:13.490 --> 00:13:18.709
可以，但我们会到达那里，然后另一件事是生成comm文件

00:13:18.709 --> 00:13:25.399
迈克尔提到的东西，这是我们发现的两件事

00:13:25.399 --> 00:13:31.189
深入研究实际上是我们正在做的事情

00:13:31.189 --> 00:13:35.689
在此之前，然后使用执行某些工作的go库，然后

00:13:35.689 --> 00:13:41.720
越过FFI边界进入生锈的证明中，我们基本上

00:13:41.720 --> 00:13:47.779
现在，我们已经接近三个步骤，几乎重新实现了证明

00:13:47.779 --> 00:13:54.920
你知道的东西，我们需要仔细考虑多少

00:13:54.920 --> 00:14:00.139
这是我们真正想做的，但事实证明，有两个方面

00:14:00.139 --> 00:14:06.410
它使用磁盘填充，运行填充版本，将其写入磁盘

00:14:06.410 --> 00:14:10.429
这样做的原因是因为填充算法的寻道很少

00:14:10.429 --> 00:14:18.410
在它里面只是跳了一两口，所以当你给它填充时

00:14:18.410 --> 00:14:23.269
算术运算法则，您知道拥有巨大的阅读器，可以像阅读器一样顺序阅读

00:14:23.269 --> 00:14:29.569
字节流，然后它希望能够向前移动然后向后移动

00:14:29.569 --> 00:14:32.899
一点点，然后向前，然后一点点地来回，依此类推

00:14:32.899 --> 00:14:36.900
因为它需要这样做，所以您不能仅仅给它一个纯粹的商店

00:14:36.900 --> 00:14:42.450
除非它有适当的缓冲量，那么证明什么

00:14:42.450 --> 00:14:48.110
所做的是将其写入磁盘，然后从该磁盘中将其放入该临时文件

00:14:48.110 --> 00:14:55.350
说可以做到这一点，所以沃尔克写了一篇内存中的文章

00:14:55.350 --> 00:14:59.040
它的版本只是将其写入内存，然后可以从中来回移动

00:14:59.040 --> 00:15:04.050
内存，然后我们发现它仍在使用两倍的内存

00:15:04.050 --> 00:15:08.820
磁盘上的大小，结果表明正在使用的Merkle树算法

00:15:08.820 --> 00:15:12.570
产生的补偿只是公司的默克尔证明

00:15:12.570 --> 00:15:20.550
东西，一块的东西，也是如此，将它分成32个字节

00:15:20.550 --> 00:15:26.100
然后将它们散列，然后让默克尔对待您知道2的arity

00:15:26.100 --> 00:15:30.540
直到最后一块和正在使用的奇迹树算法

00:15:30.540 --> 00:15:38.480
磁盘缓存，用于缓存碎片，因为哈希是在此树上工作时

00:15:38.480 --> 00:15:50.010
而且这样磁盘缓存的代码实际上可以接受它

00:15:50.010 --> 00:15:54.540
执行本地树内容的库可以占用磁盘缓存

00:15:54.540 --> 00:16:00.170
或内存缓存，但在火币证明中，它作为磁盘缓存硬连线

00:16:00.170 --> 00:16:06.240
嗯，现在他们在这里有了一个链接，可以重新实现它

00:16:06.240 --> 00:16:11.010
只是从证明代码中复制了很多副本，并将其替换为

00:16:11.010 --> 00:16:15.450
第一个是Volker实施的填充内容，

00:16:15.450 --> 00:16:20.790
第二个是将本地树调用替换为将其称为“本地树调用”的东西

00:16:20.790 --> 00:16:28.830
加上一个内存缓存，所以我们现在可以将磁盘换成内存，但是它仍然

00:16:28.830 --> 00:16:36.570
使用三倍于四舍五入的基础的大小大约是

00:16:36.570 --> 00:16:42.090
对于一个演出，它使用了将近三个演出的内存，然后在

00:16:42.090 --> 00:16:45.840
如果我们将其变成lambda，那么我们会增加更多的内存开销

00:16:45.840 --> 00:16:50.890
因为我们必须添加其他内容才能使其与Lambda完美搭配

00:16:50.890 --> 00:16:57.730
最重要的是，我们已经有了关于我们的决策点

00:16:57.730 --> 00:17:04.870
习惯使用现在很少使用实际证明代码的东西

00:17:04.870 --> 00:17:10.929
它正在使用自定义的实际实现或我们想做什么

00:17:10.929 --> 00:17:15.130
其他品种，但这就是我要说的是，我们必须要看真的

00:17:15.130 --> 00:17:18.220
真的非常紧密，我的意思是为了让斯蒂芬斯受益，因为他进来了

00:17:18.220 --> 00:17:21.429
迟了，但是我们遇到的问题是，就像我们有一些有趣的事情一样

00:17:21.429 --> 00:17:26.170
在lambda中运行这些约束，我们目前必须执行其中一些操作，

00:17:26.170 --> 00:17:29.200
主要的限制是我们不能真的没有任何临时磁盘空间

00:17:29.200 --> 00:17:33.700
可以使用，但我们最多可以记忆三场演出，然后我们就可以买车了

00:17:33.700 --> 00:17:39.760
只要我们不能使用磁盘并减少使用量，文件就可以降到演出以下

00:17:39.760 --> 00:17:45.520
每辆汽车文件舒适的生成时间超过3 Gb的内存，我们还可以，但是任何东西

00:17:45.520 --> 00:17:49.780
在那之后，我们遇到了很多问题，所以这就是为什么我们一直

00:17:49.780 --> 00:18:00.420
致力于这一工作，你们真的可以像tmpfs一样访问吗

00:18:00.420 --> 00:18:04.929
本质上就是您知道无需更改即可将文件存储到内存中

00:18:04.929 --> 00:18:12.429
任何事情，所以这就是我在本地做的测试，但在lambda中

00:18:12.429 --> 00:18:18.700
你不，我不相信你有任何方式来创建或使用速度

00:18:18.700 --> 00:18:22.720
节日，但使用节奏的另一个问题面临如此严格的约束

00:18:22.720 --> 00:18:27.309
是您必须绝对确保为运行时留有足够的空间

00:18:27.309 --> 00:18:32.080
超级完美地划分了它，您知道lambda给了您三千

00:18:32.080 --> 00:18:38.710
8兆字节，在测试此可执行文件期间，他使用了209

00:18:38.710 --> 00:18:48.850
一百九十五兆字节，这真的很紧，是的，他在

00:18:48.850 --> 00:18:56.670
JavaScript，现在已经生锈了，因此您尝试对它进行编译

00:18:56.670 --> 00:19:02.790
32位ABI，它将小两倍

00:19:03.429 --> 00:19:10.539
你不能解雇谁来了，如果在64位硬币，这是另一个

00:19:10.539 --> 00:19:17.559
进退两难的是，我们离防锈技术越走越远

00:19:17.559 --> 00:19:22.839
二进制文件会给我们带来不匹配的补偿带来的更多风险，因此

00:19:22.839 --> 00:19:27.909
如果我们以这种方式继续做下去，我想我想随机抽样一些

00:19:27.909 --> 00:19:33.940
输出并产生竞争产生补偿只是一种传统方法

00:19:33.940 --> 00:19:38.379
进行理智检查，以确保我们没有找到一些奇怪的边缘情况

00:19:38.379 --> 00:19:41.950
整个故事都是关于寻找极端案例的故事

00:19:41.950 --> 00:19:45.429
并发现我们不了解的新事物，没人告诉我们

00:19:45.429 --> 00:19:52.330
关于，我仍然对此深有恐惧，所以我想我们要保持理智

00:19:52.330 --> 00:20:03.429
认真检查我们在做正确的事，好吗，有人吗

00:20:03.429 --> 00:20:17.940
否则似乎没有任何更新，评论或议程项目，于是我

00:20:17.940 --> 00:20:25.320
丢了会议，说再见，下周再见

