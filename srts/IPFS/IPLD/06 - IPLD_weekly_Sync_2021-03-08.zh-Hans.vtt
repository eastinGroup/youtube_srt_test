WEBVTT
Kind: captions
Language: zh-Hans

00:00:11.920 --> 00:00:16.320
欢迎大家参加本周的ipld同步会议

00:00:16.320 --> 00:00:24.640
这是2021年3月8日，每周我们都会在

00:00:24.640 --> 00:00:30.400
过去一周中我们工作过的东西，然后讨论所有开放式引擎项目

00:00:30.400 --> 00:00:36.160
我们可能会从我自己开始，所以我仍然在

00:00:36.160 --> 00:00:40.320
javascript内容，仍然是指向

00:00:40.320 --> 00:00:44.719
与上周相同的公关

00:00:44.719 --> 00:00:51.440
我是否再次改进了js ipfc的um代码

00:00:51.440 --> 00:00:58.719
ipfs unix fs，所以现在真的用不了旧的

00:00:58.719 --> 00:01:02.800
样式cids了，现在我试图得到它

00:01:02.800 --> 00:01:08.880
进入js ffs，也没有使用我们所谓的js ipaldi，但这只是

00:01:08.880 --> 00:01:11.680
虽然我不使用所谓的块API

00:01:11.680 --> 00:01:16.080
确保它确实是ipfs块api，但基本上只是

00:01:16.080 --> 00:01:21.680
您可以放字节并取回字节，但这是当前所有的unix fs

00:01:21.680 --> 00:01:25.119
需要和使用嗯是的，这非常简单

00:01:25.119 --> 00:01:30.799
界面，我希望um ipfs的其他部分也可以

00:01:30.799 --> 00:01:34.320
只是用这个东西而不是一个完整的块

00:01:34.320 --> 00:01:38.960
服务或ipld，当然接下来要保留

00:01:38.960 --> 00:01:44.079
将其集成到js ipfs中的j中

00:01:44.079 --> 00:01:51.280
嗯，我快到了，我大概有六个

00:01:51.280 --> 00:01:55.520
六个运行不佳的测试，例如我们有类似的东西

00:01:55.520 --> 00:02:01.439
就像300次测试一样，所以就像到达那里，但现在不行了

00:02:01.439 --> 00:02:06.240
可能比调试um更难，而这个想法真的是um

00:02:06.240 --> 00:02:12.160
从ipfs方面来看，您仍然与旧的cid交互，或者

00:02:12.160 --> 00:02:16.959
基本上是您习惯的CD，然后在较低的水平上

00:02:16.959 --> 00:02:22.160
转换，例如unix fps将完全使用新的cid

00:02:22.160 --> 00:02:25.040
的东西，但在外部服务器上，它仍然会

00:02:25.040 --> 00:02:29.599
在外面，所以如果您使用js ipfs，它将可以正常工作

00:02:29.599 --> 00:02:34.400
像往常一样，至少像开始时一样，然后我们需要计算

00:02:34.400 --> 00:02:38.959
像是对性能有影响吗？我们想这样做吗

00:02:38.959 --> 00:02:43.760
和细节，但第一件事就是我们真的可以使事情起作用

00:02:43.760 --> 00:02:50.400
嗯，这是我还可以的地方，那一切就在我的清单上。

00:02:50.400 --> 00:02:53.440
是丹妮尔

00:02:54.160 --> 00:02:58.080
很酷，所以我上周提到的是

00:02:58.080 --> 00:03:02.959
我一直将我们转移到标尺甲板上的编解码器pp包中

00:03:02.959 --> 00:03:06.640
前一阵子写的是ipld上的dac婴儿编解码器

00:03:06.640 --> 00:03:12.159
首要原因是ipfs和ipld中的某些库已在使用

00:03:12.159 --> 00:03:16.800
ipld素类，但他们使用了一个不同的dac bb编解码器，称为

00:03:16.800 --> 00:03:22.159
去ipld prime proto，它们都是兼容的，但不是

00:03:22.159 --> 00:03:26.080
不能同时使用，所以我们必须选择一个并使用

00:03:26.080 --> 00:03:31.040
所以好消息是ii转换了gomerkaldag gocar和gograph sync

00:03:31.040 --> 00:03:34.879
这是使用其他编解码器的现有软件中仅有的一部分，

00:03:34.879 --> 00:03:38.000
我们不能同时使用，而且一切正常

00:03:38.000 --> 00:03:41.920
很好，他们没有很多测试，只有一个测试失败

00:03:41.920 --> 00:03:45.519
但我想我可以知道以后再检查

00:03:45.519 --> 00:03:49.280
因为我们现在还没有合并代码，而我现在正在做的是

00:03:49.280 --> 00:03:53.200
将所有这些都合并到go ipfs中，因为hana确实在

00:03:53.200 --> 00:03:56.879
转到使用的go merkle dag的go ipfs

00:03:56.879 --> 00:04:00.480
去ipld Prime，她有四个失败的测试，但

00:04:00.480 --> 00:04:03.840
其他一切正常，所以我添加了正在移动的内容

00:04:03.840 --> 00:04:07.920
一切都交给um rods编解码器和更多的东西失败了，

00:04:07.920 --> 00:04:12.720
我正在尝试调试那个um，是的，我还是不知道是什么

00:04:12.720 --> 00:04:16.079
什么是失败的，或者为什么这可能是我做错的错误，可能是某些原因

00:04:16.079 --> 00:04:19.120
我误解了，这有点奇怪，因为我得到了

00:04:19.120 --> 00:04:23.520
我在编解码器中添加调试打印的相同cid什么都没有

00:04:23.520 --> 00:04:28.000
失败了，没有错误，所以我仍然不知道测试为什么

00:04:28.000 --> 00:04:30.160
失败和失败的测试是

00:04:30.160 --> 00:04:33.040
给我非常有用的错误消息，例如

00:04:33.040 --> 00:04:36.960
失败为零或类似的失败找不到类似的东西

00:04:36.960 --> 00:04:41.280
所以调试非常有趣，是的，这就是我

00:04:41.280 --> 00:04:43.919
我希望我能告诉你怎么了，但我想这会让我像

00:04:43.919 --> 00:04:47.840
再过一天左右找出问题所在

00:04:48.479 --> 00:04:53.120
但如果有人有任何想法，我很想听听他们的看法

00:04:53.680 --> 00:04:58.000
谢谢我只能告诉我在javascript上我也有那些像

00:04:58.000 --> 00:05:02.560
找不到错误，就像是，是的，所以在javascript上是一样的

00:05:02.560 --> 00:05:10.960
方面也很好，所以接下来是埃里克

00:05:10.960 --> 00:05:14.400
所以我仍然在尝试上游

00:05:14.400 --> 00:05:18.320
几个星期前的一些东西已经进入了

00:05:18.320 --> 00:05:21.759
多哈希，现在肯定快要着陆了

00:05:21.759 --> 00:05:26.080
我们将有一个不错的插件式注册e

00:05:26.080 --> 00:05:30.720
系统，因此您可以将多哈希添加到多哈希库中

00:05:30.720 --> 00:05:34.240
不必喜欢修补库本身

00:05:34.240 --> 00:05:37.440
然后您就可以散列出来，它们将流式传输所有这些内容，并且

00:05:37.440 --> 00:05:41.440
我很确定我在上周的录音中谈到了原因，所以我不会

00:05:41.440 --> 00:05:45.600
再做一次，但是有一个过程

00:05:45.600 --> 00:05:48.639
我们努力克服了数百个小细节

00:05:48.639 --> 00:05:52.000
在那个vr中，我认为还有四个

00:05:52.000 --> 00:05:58.800
当然，它们将在一天后完成，然后lynx系统pr

00:05:58.800 --> 00:06:03.919
还没有出来，几乎是在等待多散列的时候放松一下

00:06:03.919 --> 00:06:06.800
东西，所以我将尽快重新讨论

00:06:06.800 --> 00:06:10.960
我们可以合并多哈希更改，而只需删除一堆代码

00:06:10.960 --> 00:06:15.919
主要从该公关，然后继续进行，没有一个api

00:06:15.919 --> 00:06:18.560
真的会改变

00:06:18.840 --> 00:06:22.000
嗯，然后我们开始彼此拥有

00:06:22.000 --> 00:06:26.319
上周的讨论可能会

00:06:26.319 --> 00:06:29.600
对链接系统pr进行非常快速的火灾跟踪

00:06:29.600 --> 00:06:34.639
这是关于我们是否要讨论的讨论

00:06:34.639 --> 00:06:41.600
有一些API可以让存储功能说出是否应该信任它们

00:06:41.600 --> 00:06:46.639
所以基本上，如果您正在阅读东西，有时您会有一个存储池，

00:06:46.639 --> 00:06:49.360
如果您完全控制存储池并且相信自己是唯一的

00:06:49.360 --> 00:06:52.639
可以触摸它的一个，依此类推，等等，然后将数据放入该存储中

00:06:52.639 --> 00:06:56.880
池，然后您哈希该时间，那么我们应该

00:06:56.880 --> 00:06:59.440
能够读出并反序列化

00:06:59.440 --> 00:07:04.160
不用理会散列，也许有时候这是合理的

00:07:04.160 --> 00:07:07.440
现在，我们只是没有一个api，因此您总是在检查哈希值时

00:07:07.440 --> 00:07:12.080
加载东西，但是如果您真的确定那是

00:07:12.080 --> 00:07:17.120
重复工作，然后好吧，也许我们应该能够避免这种情况

00:07:17.120 --> 00:07:21.280
所以问题是我们应该把那个api放在哪里

00:07:21.280 --> 00:07:24.800
有不止一种可能的想法，还有一个公关

00:07:24.800 --> 00:07:29.919
上面有一个选项，关于该公关还有其他一些讨论

00:07:29.919 --> 00:07:34.000
我们可以通过其他方式做到这一点，因此，如果有兴趣的人可以偷看一下

00:07:34.000 --> 00:07:39.759
嗯，克里斯很酷，是的，我想快速讲一下

00:07:39.759 --> 00:07:43.599
选项的概要是我们正在考虑像一个大标志

00:07:43.599 --> 00:07:45.840
整个链接系统都一样，如果您要处理的话

00:07:45.840 --> 00:07:49.840
用这整个东西，然后不要检查东西，或者如果我们应该

00:07:49.840 --> 00:07:52.800
使存储功能的api复杂化

00:07:52.800 --> 00:07:56.240
说他们是否应该被信任只是一种决定

00:07:56.240 --> 00:08:00.800
像谁应该承担这个责任

00:08:04.560 --> 00:08:08.479
下一个是

00:08:10.560 --> 00:08:15.039
酷，嗯，我忙着一堆filecoin

00:08:15.039 --> 00:08:18.639
上周调试问题，所以没有那么多，但我想我会更新

00:08:18.639 --> 00:08:21.919
其他一些与ipld相关的事物

00:08:21.919 --> 00:08:26.479
嗯，他们俩都是我们在看ipld和ipfs上周度过的

00:08:26.479 --> 00:08:33.599
嗯，现在有一个ipld prime git编解码器

00:08:33.599 --> 00:08:36.719
通过所有往返测试

00:08:36.719 --> 00:08:42.719
使ipld节点脱离其自身存储库中的所有get子树

00:08:42.719 --> 00:08:46.399
然后重新序列化它们，它们最终成为

00:08:46.399 --> 00:08:49.680
相同的sha-1散列和对象

00:08:49.680 --> 00:08:52.560
哪个好

00:08:53.760 --> 00:08:58.640
那个接口

00:08:59.279 --> 00:09:03.600
来考虑什么抓取ipfs对象

00:09:03.600 --> 00:09:08.720
在ipld原始土生土长的方言中，看起来像是

00:09:08.720 --> 00:09:11.839
该界面在上周有所改进，嗯，您可以看一下

00:09:11.839 --> 00:09:16.240
嗯，现在是什么，但我认为实际上是很多

00:09:16.240 --> 00:09:20.800
更易于使用的人体工程学界面是的，它只是有一个回调而不是

00:09:20.800 --> 00:09:24.160
两个渠道，这使得生活变得更加轻松

00:09:24.160 --> 00:09:27.360
了解谁负责关闭频道，以及

00:09:27.360 --> 00:09:32.640
为什么有两个频道，等等另一个令人兴奋的事情

00:09:32.640 --> 00:09:36.160
我认为这就像在星期五汉娜能够聚在一起

00:09:36.160 --> 00:09:43.600
嗯，去unix fs节点um ipl的素数表示adl

00:09:43.600 --> 00:09:50.320
 unix fs节点的外观看起来很令人兴奋，因为这使我们

00:09:50.320 --> 00:09:54.000
迈向拥有这些突变类型的另一步

00:09:54.000 --> 00:09:56.959
东西或呃，这特别用于路径

00:09:56.959 --> 00:10:01.200
嗯，因为这是您想要尝试查看数据时的视图

00:10:01.200 --> 00:10:03.920
做各种遍历移情风格的事情

00:10:03.920 --> 00:10:07.600
所以那里的东西掉下来了，我

00:10:07.600 --> 00:10:11.680
认为就是我可以吗

00:10:11.680 --> 00:10:15.120
再详细一点

00:10:15.120 --> 00:10:19.839
是的，如果你不介意的话

00:10:20.079 --> 00:10:24.399
是的，所以好吧，所以实际数据在某种意义上是电视数据

00:10:24.399 --> 00:10:28.000
嗯，所以您可以通过链接获得这些信息，但是当我们

00:10:28.000 --> 00:10:31.519
谈论我们想要的路径

00:10:31.519 --> 00:10:34.720
将会基于ipfs，对不起

00:10:34.720 --> 00:10:39.279
Unix fs pads，并将其视为具有相似名称的地图

00:10:39.279 --> 00:10:45.600
到目录权限的子目录，如果我们只有dag tb数据，

00:10:45.600 --> 00:10:47.360
可能是我们最初想要的编解码器

00:10:47.360 --> 00:10:51.360
将数据加载到块外，因为我们不知道如何通过它

00:10:51.360 --> 00:10:57.360
因此，我们需要将其解释为unixfs以及ipld中当前拥有的内容

00:10:57.360 --> 00:11:02.399
ipfs的格式版本是这样的

00:11:02.399 --> 00:11:06.399
扩展，我们对dag pv protobuf有种看法，我们有这个

00:11:06.399 --> 00:11:10.160
我们称为文件系统节点的其他protobuf事物

00:11:10.160 --> 00:11:13.519
这是unix fs的一种视图，然后我们有了这个自定义

00:11:13.519 --> 00:11:17.279
当您想将我视为地图时，就像这样的路径逻辑

00:11:17.279 --> 00:11:20.880
如果我是目录，并且在其中看起来很像，我将公开我的目录，并且

00:11:20.880 --> 00:11:24.720
做一些特殊的起搏器，所以我们需要

00:11:24.720 --> 00:11:30.480
ipld prime仍然有能力执行这项看似自然的操作

00:11:30.480 --> 00:11:33.760
遍历目录树的事情是我们要做的所有事情

00:11:33.760 --> 00:11:36.480
时间，所以问题是如何运作

00:11:36.480 --> 00:11:42.000
恩，我想我们仍在弄清楚它是如何工作的

00:11:42.000 --> 00:11:45.839
因为我们已经知道了dag pb节点

00:11:45.839 --> 00:11:49.360
从磁盘加载，但是我们也有这个unix fs节点

00:11:49.360 --> 00:11:51.760
这就是我们想要与之互动的东西

00:11:51.760 --> 00:11:55.360
路径风格的东西，我们要做的交易也是如此

00:11:55.360 --> 00:11:59.040
做类似adl的事情，我们要把它包起来吗

00:11:59.040 --> 00:12:02.880
当我们执行路径操作并获得回复时，我们会遇到一件事

00:12:02.880 --> 00:12:06.320
这两个都是可怕的混合融合

00:12:06.320 --> 00:12:10.160
东西或其他东西，所以回购是一个

00:12:10.160 --> 00:12:13.120
首次通过可能会在以下方面发展

00:12:13.120 --> 00:12:16.079
在我们如何做这些方面实际上意味着什么

00:12:16.079 --> 00:12:21.440
当我们满足实际代码和利用率时，这两件事的对偶性

00:12:21.440 --> 00:12:25.440
迫使您知道我们找出路径

00:12:25.440 --> 00:12:28.880
阻力最小，所以我没有所有的答案，但是我

00:12:28.880 --> 00:12:35.200
先执行一些代码，然后再进行测试

00:12:36.399 --> 00:12:39.839
现在，太酷了，谢谢

00:12:40.160 --> 00:12:44.959
好吧，下一个是坚如磐石，我可以在上面多一点信息吗？

00:12:44.959 --> 00:12:50.160
是的，在继续之前，请确保我们也有一些非常古怪的东西

00:12:50.160 --> 00:12:55.040
上周的想法，嗯，好吧，我叫它古怪，这是我的想法，我

00:12:55.040 --> 00:12:59.440
认为这很古怪，所以

00:12:59.440 --> 00:13:02.959
我们只是谈论我们可能如何

00:13:02.959 --> 00:13:07.200
我们正在考虑使用adl概念

00:13:07.200 --> 00:13:11.279
重新定义我们做unix最佳方法的方式，方法更加简单，

00:13:11.279 --> 00:13:15.519
我们希望以更连贯的方式承担一些责任

00:13:15.519 --> 00:13:18.959
我们可能会期望像

00:13:18.959 --> 00:13:22.000
低级dag pb的翻译

00:13:22.000 --> 00:13:25.680
编解码器内容，以了解我们要如何遍历

00:13:25.680 --> 00:13:28.880
并且其中一些可能会照顾到

00:13:28.880 --> 00:13:35.839
目录分片麻菜什么都在那里

00:13:37.120 --> 00:13:40.320
在照顾这些事情上，它做了很多工作，但是

00:13:40.320 --> 00:13:45.600
关于unix fs的另一点有趣之处在于

00:13:45.600 --> 00:13:49.040
当您遍历目录时，这些麻类的东西

00:13:49.040 --> 00:13:53.120
然后您还具有许多属性，然后您就获得了跳跃

00:13:53.120 --> 00:13:56.800
在下一个内容上，因此实际上意味着您在执行操作时

00:13:56.800 --> 00:14:01.839
ipfs中的路径，例如遍及您的地址

00:14:01.839 --> 00:14:06.160
如果您将其分割成斜线，则ipfs文件路径在此处

00:14:06.160 --> 00:14:08.079
所有这些细分市场中的每一个都在做

00:14:08.079 --> 00:14:12.079
它通过手跳了几件事，所以

00:14:12.079 --> 00:14:14.000
这就是我们可能会使用此ADL进行的操作

00:14:14.000 --> 00:14:18.560
而且它还在做其他类似dag pb语义翻译的事情

00:14:18.560 --> 00:14:22.000
然后逐步进入小属性结构

00:14:22.000 --> 00:14:25.360
然后它向前发展

00:14:25.680 --> 00:14:32.160
所以这周的奇特想法可能是我们实际上可以

00:14:32.160 --> 00:14:36.800
用两个看相同数据的adl代表所有这些东西，

00:14:36.800 --> 00:14:39.199
他们中的一个可能会跳过障碍，然后

00:14:39.199 --> 00:14:44.160
它为您提供带有元数据的条目，然后

00:14:44.160 --> 00:14:48.320
另一个人可以做汉普顿跳跃，并跳过元数据并给你

00:14:48.320 --> 00:14:52.160
下一个完整的节点，第二个会很有趣

00:14:52.160 --> 00:14:57.519
因为这实际上将为您提供ipfs样式路径的所有方式

00:14:57.519 --> 00:15:01.680
没有额外的魔法，那么您可以选择，所以第二个是

00:15:01.680 --> 00:15:06.079
这个原型是什么，它一直在跳，是的，我相信

00:15:06.079 --> 00:15:08.720
我相信是这样

00:15:08.800 --> 00:15:12.399
但您可能两者都想要，因为如果您想稍微下车，

00:15:12.399 --> 00:15:16.720
并查看元数据，然后再执行此操作

00:15:16.720 --> 00:15:20.720
嗯，我们看看情况如何

00:15:25.760 --> 00:15:32.399
谢谢，下一个是摇滚乐，一个简单的我

00:15:32.399 --> 00:15:38.959
我正在努力帮助获得一些这最终是关于

00:15:38.959 --> 00:15:42.399
使一些打字稿网络降落在jsi bfs中

00:15:42.399 --> 00:15:48.399
东西，嗯，那沃尔卡的一部分正在做一些

00:15:48.399 --> 00:15:53.120
在那里集成了我们较新的ipld javascript组件

00:15:53.120 --> 00:15:54.880
那里有正在发生的事情

00:15:54.880 --> 00:16:00.079
在那个领域，嗯，这意味着要消耗我们一些较新的作品

00:16:00.079 --> 00:16:03.199
嗯，但是存在兼容性问题，而且我们

00:16:03.199 --> 00:16:07.519
我们知道这将是一个问题，因为这是这个问题的一部分

00:16:07.519 --> 00:16:11.199
javascript生态系统正在进行的es模块迁移

00:16:11.199 --> 00:16:17.519
在我们尝试使用新产品的地方，跨越了这条线

00:16:17.519 --> 00:16:22.639
更刻意地使用它，并有更多的未来展望

00:16:22.639 --> 00:16:26.959
但是我们仍然在痛苦之中，所以

00:16:26.959 --> 00:16:30.320
我们走了一条路，但是ipfs团队

00:16:30.320 --> 00:16:34.000
um他们用于所有

00:16:34.000 --> 00:16:37.680
他们正在测试和捆绑的所有东西

00:16:37.680 --> 00:16:41.759
选择使用这个称为es build的工具

00:16:41.759 --> 00:16:48.320
javascript编译的东西，它不支持ds模块的导出映射

00:16:48.320 --> 00:16:53.120
等等，我们依靠导出图来解决es模块中的所有问题

00:16:53.120 --> 00:16:58.000
如此大的面积，所以我们的新员工无法与

00:16:58.000 --> 00:17:03.519
就像其他pl javascript堆栈一样，所以我们只是试图

00:17:03.519 --> 00:17:07.600
解决这个问题，嗯，这只是一个

00:17:07.600 --> 00:17:10.880
一款大型的打地鼠游戏，我们知道会是这种情况，因为您为

00:17:10.880 --> 00:17:15.039
一个捆绑器，然后是另一个捆绑器

00:17:15.039 --> 00:17:18.640
但是所以我以为上周我有一个解决方案

00:17:18.640 --> 00:17:22.240
昨天合并的公司尝试了一下，这不是经纪人的捆绑

00:17:22.240 --> 00:17:24.319
实际上是损坏的打字稿编译器

00:17:24.319 --> 00:17:27.520
因此修复了一件事，打字稿编译器坏了

00:17:27.520 --> 00:17:33.360
嗯，但我认为我们有办法很好地解决这个问题，但谁知道呢

00:17:33.360 --> 00:17:36.320
否则会弹出，所以可能是这样的情况，我们将得到这个

00:17:36.320 --> 00:17:40.799
修复，然后有人会报告，嘿，现在我的这个坏了

00:17:40.799 --> 00:17:43.919
谁知道他们在使用什么工具链

00:17:43.919 --> 00:17:48.960
是的，这有点混乱，但我们会在内部继续前进，看看

00:17:48.960 --> 00:17:54.160
只是突然发生了什么，我没有说我真的很喜欢

00:17:54.160 --> 00:17:57.360
为有价值的东西而建

00:17:57.440 --> 00:18:01.840
模显然与您遇到的任何问题

00:18:02.320 --> 00:18:07.280
嗯，所以，一个评论ii忘记发布在

00:18:07.280 --> 00:18:11.280
如果您希望有人使用common.js进行测试，请发出该数字

00:18:11.280 --> 00:18:15.360
因为他们就像我可以做js ffs一样工作，所以我可以对其进行测试

00:18:15.360 --> 00:18:18.480
因为我实际上做了那些事情，所以我想做

00:18:18.480 --> 00:18:22.960
今天，但忘了它，但嗯，我真的很想要那样，所以我

00:18:22.960 --> 00:18:27.039
我想，因为迈克尔的设置方式

00:18:27.039 --> 00:18:29.679
为这些内容发布我实际上无法为它们发布预发布版本

00:18:29.679 --> 00:18:32.559
因为迈克尔拥有钥匙，所有的东西

00:18:32.559 --> 00:18:37.120
通过github action发布，没有办法像预发布那样

00:18:37.120 --> 00:18:41.200
但我想我会做的就是得到我认为可行的解决方案

00:18:41.200 --> 00:18:44.720
实际上只是发布了js多种格式，然后将其抛出

00:18:44.720 --> 00:18:48.080
交给您测试常见的js，因为这是缺少的部分

00:18:48.080 --> 00:18:51.679
我们真正需要的测试范围是这个消耗品

00:18:51.679 --> 00:18:57.120
通过典型的普通js消耗以及typescript集成和js

00:18:57.120 --> 00:19:00.400
 ipfs是所有东西汇集在一起​​的地方

00:19:00.400 --> 00:19:04.240
是的，我也可以，我想我也可以指出你

00:19:04.240 --> 00:19:07.440
如果你喜欢，因为我有一个公关

00:19:07.440 --> 00:19:12.960
unix fs，基本上应该做到这一点的

00:19:12.960 --> 00:19:16.480
基本上把这个br检查出来编译一下，看看它是否有效

00:19:16.480 --> 00:19:22.480
我认为很好，是的，我们可以在通话后赶上

00:19:22.480 --> 00:19:26.080
酷，让我们来看看

00:19:26.080 --> 00:19:31.600
[音乐]其他

00:19:31.919 --> 00:19:37.679
哦，我在那边有一些人的笔记，说我们有很多

00:19:37.679 --> 00:19:43.600
谁想对此发表评论的仓库

00:19:43.600 --> 00:19:47.679
是的，这只是一个有趣的事实，我想提供嗯

00:19:47.679 --> 00:19:53.120
在该协议的所有内容中工作的其他人

00:19:53.120 --> 00:19:56.799
实验室支持，所以像所有ipfs，所有ipld，所有lib

00:19:56.799 --> 00:20:02.000
 p2p所有其他事情，呃，我试图做一个总结，

00:20:02.000 --> 00:20:05.039
探索所有区域中有多少个回购协议

00:20:05.039 --> 00:20:08.159
这些人都在为这些组织做贡献的组织

00:20:08.159 --> 00:20:13.039
答案是几百个，甚至不是几百个

00:20:13.039 --> 00:20:18.480
就像770 ish，然后我想我们发现了一个

00:20:18.480 --> 00:20:22.960
整个其他组织实际上并未完全计入该报告

00:20:22.960 --> 00:20:26.880
所以大概是八九百或更多

00:20:26.880 --> 00:20:31.840
嗯，是的，是的，我想一个人在那里

00:20:31.840 --> 00:20:38.720
但是是的，嗯，很大的数字，所以我最近看了一个小时

00:20:38.720 --> 00:20:42.640
仍然发现我就像是啊，他们不在我的脑海中

00:20:42.640 --> 00:20:46.880
除了，我认为我总的来说像

00:20:46.880 --> 00:20:50.480
即使是这个小组，我们也可以确定

00:20:50.480 --> 00:20:54.240
我们只想存档的ipld org或

00:20:54.240 --> 00:20:56.799
不建议使用，因此如果管家提出了一个建议

00:20:56.799 --> 00:21:01.120
如何做到这一点的策略，我认为我们可以很快做出

00:21:01.120 --> 00:21:03.600
在ipl.org上发生的事情只是我们没有

00:21:03.600 --> 00:21:07.440
现在的策略，所以他们只是处于困境

00:21:07.440 --> 00:21:11.760
是的，那没关系，你要进入

00:21:11.760 --> 00:21:15.120
您要进入人们个人的回购协议吗

00:21:15.120 --> 00:21:21.520
完全不依赖的帐户我不认为我们不在第一个

00:21:21.520 --> 00:21:30.240
一轮分析的好点，尽管这在我们的堆栈中从未发生

00:21:30.240 --> 00:21:33.679
是的，这是Cbg gen的真正失物

00:21:33.679 --> 00:21:38.240
嗯，我认为有很多令人惊讶的

00:21:38.240 --> 00:21:42.960
严重依赖回购协议和仍然处于变化中的失修状态

00:21:42.960 --> 00:21:46.559
保守派的人的个人账目

00:21:46.559 --> 00:21:49.760
想像一下，看着莲花编译并看到行进

00:21:49.760 --> 00:21:52.240
依赖和锈依赖以及所有

00:21:52.240 --> 00:21:56.640
用户名出现，这很有趣，因为

00:21:56.640 --> 00:22:02.240
就像一个人在那里，所以我要说的是

00:22:02.240 --> 00:22:06.640
莲花其实是非常非常有趣的感觉

00:22:10.840 --> 00:22:14.960
很酷，不是要给你更多的工作

00:22:14.960 --> 00:22:18.240
不，这实际上是一个非常好的观察，你是对的，我

00:22:18.240 --> 00:22:21.280
就像上面贴着我名字的东西

00:22:21.280 --> 00:22:24.400
我知道在我们各个地方的传递深度中有一些棒的东西

00:22:24.400 --> 00:22:27.600
有一些胡安之类的东西

00:22:27.600 --> 00:22:32.380
人们命名事物[音乐]

00:22:38.840 --> 00:22:44.960
嗯，还有别的吗

00:22:44.960 --> 00:22:49.360
人们想聊天或发表评论

00:22:51.919 --> 00:22:56.799
不，是的，不，我有点，我不太清楚

00:22:56.799 --> 00:22:59.280
今天就赶上细节，我还没有

00:22:59.280 --> 00:23:02.960
从有关链接系统的github流量中找出来

00:23:02.960 --> 00:23:06.960
诸如保持链接系统之类的东西并进行多哈希处理

00:23:06.960 --> 00:23:12.640
提到它很普遍，但似乎是冲突还是仅仅是

00:23:12.640 --> 00:23:19.360
优先级问题或速度问题

00:23:19.520 --> 00:23:25.120
您eric并会与团队合作，这是否会成为

00:23:25.120 --> 00:23:30.880
解决了，所以链接系统的东西

00:23:31.760 --> 00:23:36.880
我希望它会在一段时间前完成，但是

00:23:36.880 --> 00:23:41.039
在试图理顺这一过程中，我起草了整件事

00:23:41.039 --> 00:23:44.640
假设go multihash库将让我获得一个标准

00:23:44.640 --> 00:23:47.760
具有此接口的库哈希

00:23:47.760 --> 00:23:52.159
Go标准库自从字面上永远存在以来，我发现它

00:23:52.159 --> 00:23:54.640
没有，那实际上就像是真的搞砸了

00:23:54.640 --> 00:23:59.760
与抽象，所以一开始我就像

00:23:59.760 --> 00:24:03.279
绝对推翻了我的经历，就像我要取代这个

00:24:03.279 --> 00:24:07.279
整个过程，带有从幻数到哈希的简单映射，它将

00:24:07.279 --> 00:24:11.840
很好，我做到了，而且也很好

00:24:11.840 --> 00:24:14.080
但

00:24:14.880 --> 00:24:18.960
随后进行了一些讨论，我们共同决定不要

00:24:18.960 --> 00:24:22.000
拥有第二套系统，因此我们将尝试上游的所有系统

00:24:22.000 --> 00:24:26.559
那些东西立即进入多哈希回购中

00:24:27.840 --> 00:24:35.120
也许还好，所以暂时的依赖很好，所以当我们尝试上游时

00:24:35.120 --> 00:24:39.120
我们在该仓库中发现了更多东西，因为那是一个

00:24:39.120 --> 00:24:42.400
我们的哦，一半的承诺来自七个

00:24:42.400 --> 00:24:48.240
年前有各种各样的存储库，

00:24:48.240 --> 00:24:53.120
事情正在改善，也许其中一些不是我们必须要做的

00:24:53.120 --> 00:24:56.880
如果我们能够优先考虑

00:24:58.720 --> 00:25:05.440
对范围扩展更加谨慎，现在可以到达

00:25:05.440 --> 00:25:08.159
虽然复杂

00:25:13.520 --> 00:25:17.520
有很多有趣的事情，例如

00:25:17.520 --> 00:25:20.640
每当我认为该团队中的任何人讨论任何有关

00:25:20.640 --> 00:25:23.919
多种格式，我们对它失控的速度感到惊讶

00:25:23.919 --> 00:25:29.360
像那些魔术数字一样，它们只是其中的一些东西而已

00:25:29.360 --> 00:25:32.960
multihash就像哦，是的，我们有一个函数来检查

00:25:32.960 --> 00:25:36.799
这个魔幻数字是这样的正确的魔幻数字

00:25:36.799 --> 00:25:42.240
我们知道是多哈希井，这意味着什么？

00:25:42.240 --> 00:25:45.600
它在此仓库中有一个常数，这意味着它在csv中有一个常数

00:25:45.600 --> 00:25:49.360
那里的文件，这意味着我们已经为它注册了一个实现

00:25:49.360 --> 00:25:53.679
以及其中一些已有七年历史的代码

00:25:53.679 --> 00:25:56.720
只是没有区分我们可能是哪些东西

00:25:56.720 --> 00:26:00.080
关注，现在，当我尝试实施此注册表系统时，

00:26:00.080 --> 00:26:03.679
实际上可以让您即时注册事物并喜欢

00:26:03.679 --> 00:26:07.520
一直没有无限的运输依赖

00:26:07.520 --> 00:26:12.480
现在，这种区别实际上以一种前所未有的方式变得明显

00:26:12.480 --> 00:26:16.080
因此，其中一些旧的抽象就像

00:26:16.080 --> 00:26:19.679
突然我们不得不问这个东西是什么意思，并做到了

00:26:19.679 --> 00:26:23.520
真正提供价值，当您要求时提供

00:26:23.520 --> 00:26:26.080
已经存在七年的功能的价值

00:26:26.080 --> 00:26:31.039
没人问过它很好，你知道这是否重要

00:26:31.039 --> 00:26:35.440
答案是是或否，无论如何，问题都是棘手的

00:26:37.120 --> 00:26:40.480
是的，我是说我也认为

00:26:40.480 --> 00:26:44.000
升级到元级别，就是这样

00:26:44.000 --> 00:26:47.520
弄清楚那是什么的张力的现实

00:26:47.520 --> 00:26:53.679
你知道产品是否需要一个原型

00:26:53.679 --> 00:26:59.200
三周之内的事情，现实是我们就像

00:26:59.200 --> 00:27:03.600
很难合并内容并实际进行良好的发布管理，

00:27:03.600 --> 00:27:06.320
而且事情的时间表不同，我们必须弄清楚

00:27:06.320 --> 00:27:08.640
找出我们如何平衡这些以及我们如何谈论这些

00:27:08.640 --> 00:27:14.640
嗯，我想您知道我们可以在类似的时候指出这一点

00:27:14.640 --> 00:27:18.320
嗯，您知道的是我们所确定的现实

00:27:18.320 --> 00:27:22.559
这些东西需要我们可以来回翻转的项目

00:27:22.559 --> 00:27:26.080
之间捡起畅通的线程，我想

00:27:26.080 --> 00:27:30.320
我们很幸运，为此，ipl和ipfs一个

00:27:30.320 --> 00:27:32.799
有足够多的不同的东西，我们没有被阻止

00:27:32.799 --> 00:27:36.720
就像还有其他事情需要发生

00:27:36.720 --> 00:27:40.399
嗯，但特别是对于较小范围的东西

00:27:40.399 --> 00:27:44.080
当我们最终到达那里时，我认为说好是非常合理的，所以

00:27:44.080 --> 00:27:48.159
您知道我们做了工程工作，但是现在我们需要等待两三个星期

00:27:48.159 --> 00:27:52.159
要通过管家审查来做到这一点，这是你知道的

00:27:52.159 --> 00:27:56.399
作者回答评论的时间占百分之十，但仅仅是

00:27:56.399 --> 00:27:59.200
你知道工作量的事情，所以我们在谈论时如何谈论它

00:27:59.200 --> 00:28:02.480
大约需要三个星期的时间

00:28:02.480 --> 00:28:05.520
所以我认为在弄清楚这意味着什么方面会有迭代

00:28:05.520 --> 00:28:09.520
嗯，但我不为这件事感到不高兴

00:28:09.520 --> 00:28:12.799
作为事物的开始，然后我们回过头来指出，好吧，那是什么

00:28:12.799 --> 00:28:16.799
畅通无阻，是的，尤其是当您来到

00:28:16.799 --> 00:28:18.960
像是多格式的东西，实际上是

00:28:18.960 --> 00:28:23.520
这里最大的事情之一就是我们之间存在这样的愿景冲突，但是

00:28:23.520 --> 00:28:27.360
整个事情也不够清晰

00:28:27.360 --> 00:28:30.640
因此，如果您一旦开始接触它，

00:28:30.640 --> 00:28:34.960
可能会有点被烧毁而变得不奇怪，这可能不足为奇。

00:28:34.960 --> 00:28:39.600
需要更深入，那可能真的很不错

00:28:39.600 --> 00:28:43.600
我认为有一支空姐团队可以将其作为更大的集体拥有

00:28:43.600 --> 00:28:46.640
我希望我能很好地解决您的问题

00:28:46.640 --> 00:28:52.559
依靠其他人来解决这个问题

00:28:52.640 --> 00:28:56.159
达成共识可能很漂亮

00:28:56.840 --> 00:29:00.880
容易，这将是一个笑话

00:29:05.440 --> 00:29:14.080
好吧，我想如果没有别的了

00:29:14.080 --> 00:29:27.840
然后我结束会议，再见大家，下周再见

