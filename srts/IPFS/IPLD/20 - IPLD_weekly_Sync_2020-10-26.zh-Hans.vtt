WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.840 --> 00:00:18.080
欢迎大家参加本周的ipld同步会议

00:00:18.080 --> 00:00:25.279
大约是2020年10月26日

00:00:25.279 --> 00:00:28.960
在过去的一周中我们一直在努力，

00:00:28.960 --> 00:00:33.920
在下一个上，然后讨论议程项目，我只是检查是否

00:00:33.920 --> 00:00:39.360
直播确实有效，因为它看起来很奇怪哦，很酷

00:00:39.360 --> 00:00:44.160
某种程度上youtube自动播放不再自动播放

00:00:44.160 --> 00:00:47.760
因为我知道我必须按下暂停按钮，我很困惑自己没有

00:00:47.760 --> 00:00:52.960
但是好吧，嗯，嗯

00:00:52.960 --> 00:01:00.000
我敢于开始我自己，所以这周我实际上有时间上班

00:01:00.000 --> 00:01:07.119
关于一些意大利的东西，我做了一些勘探报告

00:01:07.119 --> 00:01:10.960
关于um​​ id数据模型和映射键，以及

00:01:10.960 --> 00:01:16.240
字符串等等，所以嗯，简短的版本是

00:01:16.240 --> 00:01:20.240
打开一个就像讨论的起点

00:01:20.240 --> 00:01:24.000
而且在那里，但我认为最重要的是

00:01:24.000 --> 00:01:28.720
我希望我们开始明确区分

00:01:28.720 --> 00:01:32.320
数据模型，编程语言和编解码器

00:01:32.320 --> 00:01:35.759
而且因为像目前一样，我认为规格中的某种

00:01:35.759 --> 00:01:39.040
结合在几个地方，我想是的，使这个

00:01:39.040 --> 00:01:44.000
区分清楚也将使讨论更加容易

00:01:44.000 --> 00:01:48.960
而我做的另一种方式是基于数据模式和基于

00:01:48.960 --> 00:01:52.799
我在irc上与eric聊天

00:01:52.799 --> 00:01:57.119
因此，勘探报告的结论是

00:01:57.119 --> 00:02:04.719
um映射键应该是他们自己的东西，而不应该是我们已经拥有的一种

00:02:04.719 --> 00:02:09.920
有嗯，所以要向人们说清楚

00:02:09.920 --> 00:02:15.280
并观看，因此勘探报告是由某人撰写的，

00:02:15.280 --> 00:02:19.120
它或多或少也像是关于事物如何运作的看法，所以这不像

00:02:19.120 --> 00:02:22.080
这是我们使用的确定性拍子，但

00:02:22.080 --> 00:02:26.560
就像是，然后可能会融入其中的想法

00:02:26.560 --> 00:02:30.239
嗯，是的，

00:02:30.239 --> 00:02:34.239
在东西的生锈方面，所以多泡沫和钠生锈最后我做了一个

00:02:34.239 --> 00:02:37.599
过期多的防锈多碱释放

00:02:37.599 --> 00:02:45.440
它添加了基础64到36编码，可悲的是在一个聪明的哈希上

00:02:45.440 --> 00:02:49.280
目前还没有发布，因为还有一个公关就是

00:02:49.280 --> 00:02:53.680
一种评论，它的所有细节，但希望本周我会做一个适当的

00:02:53.680 --> 00:02:57.680
最后一个CD版本中的客户破折号发布，我当然可以

00:02:57.680 --> 00:03:01.280
仍然没有收到所有P2P用户的回音，但我现在就继续

00:03:01.280 --> 00:03:05.040
到版本，然后重新建立我的公关只有p2p和希望

00:03:05.040 --> 00:03:09.120
然后他们将审核该公关并将其合并

00:03:09.120 --> 00:03:13.440
因为这样我进行了快速回顾，所以我对小P2P东西进行了快速回顾

00:03:13.440 --> 00:03:17.360
而且似乎总的来说还可以，因为我想推迟发布

00:03:17.360 --> 00:03:21.360
基本上是这样，以便他们仍然可以在我发布之前进行包装更改

00:03:21.360 --> 00:03:25.280
但似乎他们不需要它，所以我只做发布，

00:03:25.280 --> 00:03:28.879
如果他们仍然需要它，我们仍然可以发布另一个版本

00:03:28.879 --> 00:03:36.080
嗯，我认为这是我为ipod做的所有工作，因此清单上的下一个是摇滚

00:03:36.720 --> 00:03:42.400
好的，嗯，我做了一些小事

00:03:42.400 --> 00:03:46.480
事情和一些大事情，所以多影线多编解码器

00:03:46.480 --> 00:03:54.319
主要工作的JavaScript，如空白的两个多哈希

00:03:54.319 --> 00:04:00.080
嗯，有些dag go dag pv工作不多，尽管我

00:04:00.080 --> 00:04:02.080
真的很想完成

00:04:02.080 --> 00:04:06.400
并完成了更多的汽车工作，其中一些JavaScript的汽车工作

00:04:06.400 --> 00:04:11.280
是另一个即将完成的问题

00:04:11.280 --> 00:04:16.560
致力于各种api决定，但实际上我正在使用

00:04:16.560 --> 00:04:19.359
分支与新的工作，我一直在使用

00:04:19.359 --> 00:04:26.639
到处都是，这真的很好，所以我只需要关闭它，

00:04:26.639 --> 00:04:32.880
作为这个新的汽车库发布了一些js模式的工作，我

00:04:32.880 --> 00:04:36.160
好一阵子都没有碰过，因为那与

00:04:36.160 --> 00:04:38.639
我正在做的其他工作，这三个

00:04:38.639 --> 00:04:43.440
上周我做的大事是其中之一

00:04:43.440 --> 00:04:50.400
jsi pld模式描述器，它将使用一个javascript对象

00:04:50.400 --> 00:04:59.520
并将使用ipld模式对其进行尽可能少的描述

00:04:59.520 --> 00:05:02.960
使用一些诸如此类的灵活选项

00:05:02.960 --> 00:05:07.360
像nullable和union一样

00:05:07.360 --> 00:05:13.680
它会为您提供任何相对简单的javascript对象

00:05:13.680 --> 00:05:20.800
无论如何都落入数据模型之内，然后在另一方面

00:05:20.800 --> 00:05:26.000
没有验证器的js ipld方案，它将构建您的小javascript

00:05:26.000 --> 00:05:31.759
验证您可以标记的任何给定ipld模式的功能

00:05:31.759 --> 00:05:35.440
一个javascript对象并说它是否与模式匹配

00:05:35.440 --> 00:05:40.800
而且它们是最小且快速的，这支持了所有架构功能

00:05:40.800 --> 00:05:45.199
字符串连接和字符串对除外

00:05:45.199 --> 00:05:49.759
它是唯一不支持的表示形式

00:05:49.759 --> 00:05:54.560
嗯，那真的很整齐，嗯，您可以看到很多用例

00:05:54.560 --> 00:05:58.400
但是在模式领域内，它主要是很有趣的，但是

00:05:58.400 --> 00:06:03.840
嗯，因为我将这两件事放在这辆车的架构中

00:06:03.840 --> 00:06:07.360
项目，这之所以出现，是因为我们做了

00:06:07.360 --> 00:06:16.080
做出一些不明确的承诺，提出帮助他们的建议

00:06:16.080 --> 00:06:21.039
更好地了解他们的数据，因为他们承受着压力

00:06:21.039 --> 00:06:25.600
减少存储空间的大小

00:06:25.600 --> 00:06:30.080
在某种程度上，嗯，那里有各种各样的建议

00:06:30.080 --> 00:06:32.960
我们已将其标记为问题，但

00:06:32.960 --> 00:06:35.759
我们可能会继续前进而没有其他事情，所以

00:06:35.759 --> 00:06:39.520
嗯，我认为有人最好做一些这样的工作，所以

00:06:39.520 --> 00:06:45.680
嗯，这个卡特模式的事情是它将需要一个汽车文件并通过

00:06:45.680 --> 00:06:48.560
它会在模式中描述那里的所有形状

00:06:48.560 --> 00:06:51.680
这样您就可以得到所有独特的模式

00:06:51.680 --> 00:06:56.800
但是我现在添加的是向它提供方案库的功能

00:06:56.800 --> 00:06:59.440
以及，因此它会首先检查您的

00:06:59.440 --> 00:07:02.880
现有的模式，如果有的话，将它们汇总起来

00:07:02.880 --> 00:07:07.199
如果没有，它将使用架构描述器来描述它们，因此您最终会

00:07:07.199 --> 00:07:12.160
分为两部分，目的是使您从无到有

00:07:12.160 --> 00:07:17.360
图书馆到一个完整的图书馆，然后您将能够看到

00:07:17.360 --> 00:07:20.720
街区占据了您必须计算的大部分故事

00:07:20.720 --> 00:07:24.240
按与计划者uh匹配的块数，然后

00:07:24.240 --> 00:07:31.120
嗯，除此之外，最好有一些有关块大小的统计信息

00:07:31.120 --> 00:07:38.639
所以你可以说像山寨币区块链有30

00:07:38.639 --> 00:07:45.759
属于中间amt节点的节点，平均平均占用64个节点

00:07:45.759 --> 00:07:49.440
字节，这是一种垃圾，所以这是

00:07:49.440 --> 00:07:51.039
你应该可以这样说

00:07:51.039 --> 00:07:55.039
然后那应该导致更好的决策

00:07:55.039 --> 00:07:58.879
如何进行优化，而不仅仅是跳出诸如此类的话题

00:07:58.879 --> 00:08:02.960
让我们将小块作为cid排成一行

00:08:02.960 --> 00:08:06.400
在桌子上，可能是

00:08:06.400 --> 00:08:10.080
作为解决问题的首批解决方案之一而实施

00:08:10.080 --> 00:08:13.280
如果我们没有更好的输入，就束手无策

00:08:13.280 --> 00:08:19.360
就是这样，现在我所处的位置是

00:08:19.360 --> 00:08:24.080
经历的会是什么，这叫做什么项目

00:08:24.080 --> 00:08:29.120
叫做哦，国家div，它将在

00:08:29.120 --> 00:08:34.800
对于到目前为止的硬币，请使用rpld的主要语言，我去过

00:08:34.800 --> 00:08:38.839
试图建立一些问题

00:08:38.839 --> 00:08:41.599
这些具有这些数据结构的是

00:08:41.599 --> 00:08:46.800
您有很多节点，例如汉普顿或amt

00:08:46.800 --> 00:08:53.279
值在哪里，因此您希望模式描述

00:08:53.279 --> 00:08:56.640
数据结构加上内联值

00:08:56.640 --> 00:09:01.440
并避免使用任何东西，因为您确实希望能够

00:09:01.440 --> 00:09:04.720
还要描述该部分，所以您将最终获得

00:09:04.720 --> 00:09:09.839
就像具有此值的amt和具有此值的amt

00:09:09.839 --> 00:09:15.680
嗯，是的，这很有趣，是的，我在所有

00:09:15.680 --> 00:09:18.800
如你所见，那是我拥有的东西

00:09:18.800 --> 00:09:23.120
我做了某种类型的解释表示，所以

00:09:23.120 --> 00:09:25.920
障碍只是举例来说，而不是事物的地图

00:09:25.920 --> 00:09:28.959
试图描述这些中间节点的实际布局方式，

00:09:28.959 --> 00:09:32.240
我认为那是有工作的地方，也许是你在工作的地方

00:09:32.240 --> 00:09:37.200
丹，所以最终我们将有一些方法

00:09:37.200 --> 00:09:42.080
插入这些adl的内容，也许是，但是的

00:09:42.080 --> 00:09:47.920
是的，所以我想弄清楚，因为下一个挑战是好的，我已经

00:09:47.920 --> 00:09:52.160
有一个描述事物的计划，我不知道那是什么东西，因为

00:09:52.160 --> 00:09:56.240
我对猎鹰的数据结构不是很熟悉，我必须走

00:09:56.240 --> 00:09:58.720
挖东西，我很感激能做很多工作

00:09:58.720 --> 00:10:01.760
虽然我昨天才刚开始

00:10:01.760 --> 00:10:04.880
并且已经遇到了像我有结构这样的初始形状的麻烦

00:10:04.880 --> 00:10:08.800
具有三个属性，您知道两个cid和int和

00:10:08.800 --> 00:10:12.959
恩字节我找不到匹配的任何东西

00:10:12.959 --> 00:10:16.000
到目前为止，这有点像一场比赛，

00:10:16.000 --> 00:10:19.600
想要让您对数据更加熟悉的人的一种东西

00:10:19.600 --> 00:10:24.880
可以完成一些工作的结构，但是我不知道我是否真的可以撕下

00:10:24.880 --> 00:10:27.839
任何人都因为我的意思是我想我想说的另一点不仅仅是

00:10:27.839 --> 00:10:30.560
就像我有这个障碍，我不知道它看起来像什么

00:10:30.560 --> 00:10:36.480
如果您确实通过步行进行重建，那么您就可以拥有父母和其他东西

00:10:36.480 --> 00:10:38.560
当您到达某个街区时的上下文

00:10:38.560 --> 00:10:44.160
无法识别这样可能会更有帮助，就像哦，这是

00:10:44.160 --> 00:10:47.600
链接到的cid是从断开的链接

00:10:47.600 --> 00:10:50.640
即使您无法识别直接类型

00:10:50.640 --> 00:10:53.760
内容有时很稀疏，而您可能不会

00:10:53.760 --> 00:10:57.440
能够找到它出现的那条路

00:10:57.440 --> 00:11:03.040
是超级有用的，是的，这是一个很好的理想

00:11:03.040 --> 00:11:08.079
只是处理大量的数据

00:11:08.079 --> 00:11:12.560
这种随机访问方式很棘手，所以我已经

00:11:12.560 --> 00:11:17.680
到目前为止，它一直在解决它，只是以任何顺序向我提供块

00:11:17.680 --> 00:11:20.160
他们在汽车档案中，我会弄清楚

00:11:20.160 --> 00:11:24.320
嗯，但是在链接信息中有实用程序，我只是

00:11:24.320 --> 00:11:28.000
我根本没有动过，因为那只是一个问题空间

00:11:28.000 --> 00:11:30.959
对于我现在想咬的东西来说有点太复杂了，但是

00:11:30.959 --> 00:11:33.760
真的，你应该能够谈论之间的关系

00:11:33.760 --> 00:11:37.120
块，但现在就像我到达了cid

00:11:37.120 --> 00:11:41.519
那只是一个链接，除此之外，现在不关心它，所以

00:11:41.519 --> 00:11:45.120
但这引发了很多真正有趣的领域

00:11:45.120 --> 00:11:49.279
非常有趣的地方，可以进行其他工作或研究

00:11:49.279 --> 00:11:53.920
嗯，我现在没有时间，我真的不想

00:11:53.920 --> 00:11:56.720
做了很长一段时间，我必须回去完成一堆

00:11:56.720 --> 00:12:01.040
其他的东西，但是嗯，这绝对是一个丰富的空间

00:12:01.040 --> 00:12:04.639
我认为是实际的工作，但我可以看到有用的东西吗？

00:12:04.639 --> 00:12:07.519
就像我有一个我必须完成比特币代码

00:12:07.519 --> 00:12:10.240
期望，其中一部分是描述事物

00:12:10.240 --> 00:12:14.240
在计划者和我中，我已经写了一些模式

00:12:14.240 --> 00:12:17.920
只要您知道手写内容与我所见相符，我会很高兴

00:12:17.920 --> 00:12:20.800
能够验证他们或实际使用它来创建

00:12:20.800 --> 00:12:24.880
一些初始模式，然后在此处构建一些匹配项，以便

00:12:24.880 --> 00:12:28.480
已经有实用程序，我已经将其应用于dag pb了，嗯，这很有趣

00:12:28.480 --> 00:12:32.959
也可以用来验证那里的一些架构决策

00:12:32.959 --> 00:12:35.360
实际上这里有很多实用的东西

00:12:35.360 --> 00:12:41.200
可以成长给我一个例子，或者让我指出我最后提到的一个例子

00:12:41.200 --> 00:12:44.959
一周，我正在使用cbdl简洁数据定义语言进行大量工作

00:12:44.959 --> 00:12:48.320
嗯，实际上上周也有一个russ图书馆也指向你们

00:12:48.320 --> 00:12:51.839
它还没有完全完成，但是我要开始为它做些贡献

00:12:51.839 --> 00:12:55.680
我正在做和建立一些分支逻辑

00:12:55.680 --> 00:12:58.560
所以基本上你可以做一些测试用例

00:12:58.560 --> 00:13:01.920
类别或类型实际上只是在做

00:13:01.920 --> 00:13:06.079
满足于生锈，所以我想嗯

00:13:06.079 --> 00:13:10.639
但是如果你给我指点，我会思考一下

00:13:11.839 --> 00:13:15.200
我只是在想我可能最终会写这个或

00:13:15.200 --> 00:13:18.320
戳出来，但我认为这是一种有趣的

00:13:18.320 --> 00:13:22.320
一个可以反复使用的方法，您可以在基本情况下使用此工具

00:13:22.320 --> 00:13:24.880
就像这样说是根块的架构

00:13:24.880 --> 00:13:28.720
并且这是您开始的地方，然后随着它的建立或试图计算

00:13:28.720 --> 00:13:32.480
找出其他模式，您至少知道分支的位置

00:13:32.480 --> 00:13:35.440
来自正确的，所以，如果你说的像哦二

00:13:35.440 --> 00:13:38.560
不知道该属性中的一堆数据，这是一堆

00:13:38.560 --> 00:13:40.560
我为之生成的模式

00:13:40.560 --> 00:13:44.399
你至少得到哦，你有点知道它来自哪里的上下文

00:13:44.399 --> 00:13:47.360
这样您就可以轻松得多，可以在

00:13:47.360 --> 00:13:49.839
您刚刚获得的数据，然后每次您获得的数据

00:13:49.839 --> 00:13:53.279
锁定其中一个以获得更多信息，然后进行细分

00:13:53.279 --> 00:13:56.639
关于您不了解块的位置的更多信息

00:13:56.639 --> 00:14:01.040
是的，甚至有一个像昨天

00:14:01.040 --> 00:14:07.120
与alex讨论他们在存储和badge方面的挑战

00:14:07.120 --> 00:14:10.480
嗯，然后研究解决这个问题的新颖方法

00:14:10.480 --> 00:14:16.320
一些非常新颖的东西，但甚至只是知道什么是本质

00:14:16.320 --> 00:14:19.920
这些数据结构的负责人领导的方式

00:14:19.920 --> 00:14:23.760
到它们下面不同大小的结构，好吧，我们有一个

00:14:23.760 --> 00:14:26.959
这个，你知道我们有最终的路线，但是我们知道，我们有

00:14:26.959 --> 00:14:29.360
这些不同的其他路线

00:14:29.360 --> 00:14:32.560
诸如此类的东西是什么的东西

00:14:32.560 --> 00:14:34.959
事物而只是无法看到它，或者

00:14:34.959 --> 00:14:38.399
或这个数字真的很令人沮丧

00:14:38.399 --> 00:14:42.959
如果我们有更好的工具，那会很好，但是

00:14:42.959 --> 00:14:49.519
是的，无论如何，这是一个开始，并且有很多想法

00:14:53.360 --> 00:14:57.279
我名单上的下一个是丹妮尔

00:14:57.360 --> 00:15:02.000
很酷，所以我想我几天前提到了这个，但是有人

00:15:02.000 --> 00:15:05.680
实际写过go multihash版本的人

00:15:05.680 --> 00:15:09.199
就像在图书馆一样，我们彼此不认识

00:15:09.199 --> 00:15:13.120
嗯，因为我已经写下了一个计划，但是我没有写太多

00:15:13.120 --> 00:15:15.120
代码还没有，所以我最终联系了他们

00:15:15.120 --> 00:15:19.199
笔记中有一个链接，令人惊讶的是，您知道他们是开放的吗？

00:15:19.199 --> 00:15:22.560
我的反馈意见，所以我们已经进行了一些评论

00:15:22.560 --> 00:15:27.440
与这个人循环，大部分只是删除一些

00:15:27.440 --> 00:15:31.040
他们编写的代码并完善了其余的代码，而我

00:15:31.040 --> 00:15:32.880
认为我现在对国家非常满意，所以

00:15:32.880 --> 00:15:37.440
我本周要去复活gomoza哈希回购

00:15:37.440 --> 00:15:41.040
樱桃采摘此人的承诺，然后添加以下几项：

00:15:41.040 --> 00:15:44.240
我自己的嗯，但是很明显我所做的任何改变

00:15:44.240 --> 00:15:47.920
最重要的将是请求

00:15:48.000 --> 00:15:52.320
我也做了很多火腿工作来支持任意值

00:15:52.320 --> 00:15:56.959
还有多个哈希算法，我也更新到了新架构

00:15:56.959 --> 00:16:00.320
我在这之前的一周主要做了

00:16:00.320 --> 00:16:04.959
但是那是我在固定模式中发现该错误的时候

00:16:04.959 --> 00:16:11.360
通话后，我现在正在处理的是对以下节点的支持

00:16:11.360 --> 00:16:14.880
链接，而不只是内联，因为

00:16:14.880 --> 00:16:20.880
需要我为链接加载器添加一些额外的api，依此类推，我也阅读了

00:16:20.880 --> 00:16:25.839
该文档最终阅读了eric和volker在字符串和映射键上编写的文档

00:16:25.839 --> 00:16:29.040
所以我不会再开始辩论了，但是

00:16:29.040 --> 00:16:32.480
我想我终于明白了症结所在，我认为我形成了

00:16:32.480 --> 00:16:35.600
即使是我很高兴的观点

00:16:35.600 --> 00:16:39.839
最后，我还提出了一些问题来改进

00:16:39.839 --> 00:16:46.320
koi pld prime的go代码生成，除此之外，与ipld无关

00:16:46.320 --> 00:16:50.880
但是因为结冰而来

00:16:50.880 --> 00:16:53.920
就像过去四天我一直在忙碌，因为有几件事

00:16:53.920 --> 00:16:56.320
我真的很想进去，但他们落后了

00:16:56.320 --> 00:17:00.639
所以我把其中的两个合并了，但是第三个不像挑剔

00:17:00.639 --> 00:17:04.079
地狱，我真的很沮丧，它可能不会冻结之前合并

00:17:04.079 --> 00:17:06.959
来了，然后你知道你必须再等六个

00:17:06.959 --> 00:17:11.199
几个月，仅此而已

00:17:11.679 --> 00:17:15.280
谢谢，下一个是彼得

00:17:15.520 --> 00:17:21.039
哦，男孩，是的，大家好，所以实际上，很少有人给我发这个东西

00:17:21.039 --> 00:17:25.679
虽然我是整个链条中所有这些努力的一部分

00:17:25.679 --> 00:17:30.559
一种或另一种这样的方式

00:17:30.559 --> 00:17:37.919
与ipod密切相关的是，我得到了一些实际的原始数据

00:17:37.919 --> 00:17:42.000
的人不包括在内，所以您知道很多

00:17:42.000 --> 00:17:46.400
许多类似的初步探索都是通过实时数据完成的

00:17:46.400 --> 00:17:54.320
嗯，也是哨兵中一些呃工作的一部分

00:17:54.320 --> 00:18:00.799
在探索数据存储性能时，基本上

00:18:00.799 --> 00:18:07.600
量化什么是行得通的，什么不行，我也喜欢

00:18:07.600 --> 00:18:14.000
方面在一个原型上工作，基本上有一个

00:18:14.000 --> 00:18:18.559
两层的块存储一个您现在需要的东西

00:18:18.559 --> 00:18:21.039
另一个从其他地方获取块

00:18:21.039 --> 00:18:24.320
基本上是从一个地方到另一个地方的迁移策略

00:18:24.320 --> 00:18:28.720
嗯，说实话有点烦人

00:18:28.720 --> 00:18:34.320
对这些东西了解得比我更多的人专注于

00:18:34.320 --> 00:18:38.640
优化徽章和类似的东西，但是从长远来看，这是不可能的

00:18:38.640 --> 00:18:42.400
不能为我们工作，就像我们的连锁店一样

00:18:42.400 --> 00:18:49.919
太大，就像我说太大时一样，我真的建议您

00:18:49.919 --> 00:18:53.520
没有真正接触过猎鹰只是得到其中一个汽车档案的人

00:18:53.520 --> 00:18:57.760
我像不同的呃层一样留在ipod房间里

00:18:57.760 --> 00:19:02.480
基本上是大的水平，是的，是的，是的

00:19:02.480 --> 00:19:08.720
现在有5亿把钥匙，所以不，不，不，不，

00:19:16.240 --> 00:19:19.679
如果已经那么大，那意味着一年之内就不会有

00:19:19.679 --> 00:19:22.720
您可以在本地使用的足够的存储机制

00:19:22.720 --> 00:19:26.720
像我们一样快，我们实际上没有技术，所以我们需要

00:19:26.720 --> 00:19:31.440
做的很好，是的，但是那你需要弄清楚

00:19:31.440 --> 00:19:33.840
就像您在本地需要什么集，它是什么

00:19:33.840 --> 00:19:39.600
你可以推出是的，而且因为几乎没有

00:19:39.600 --> 00:19:43.360
专注于长期思考好吧，我想把一些东西放在一起

00:19:43.360 --> 00:19:45.600
像超级笨蛋一样，不会无处不在

00:19:45.600 --> 00:19:49.120
将不会被包括在任何地方，不喜欢发生了什么事

00:19:49.120 --> 00:19:51.200
我的第一个正确概念就是现在

00:19:51.200 --> 00:19:56.559
公关请不要，但基本上要看一下

00:19:56.559 --> 00:19:59.760
即使它可行，我们也可以从那种

00:19:59.760 --> 00:20:03.039
给一点点更多的背景

00:20:03.039 --> 00:20:08.240
Rod说嗯是的他们是国米他们肯定是有兴趣的

00:20:08.240 --> 00:20:12.880
减小尺寸，我有点怀疑任何创可贴会

00:20:12.880 --> 00:20:16.559
为减少尺寸而努力，因为

00:20:16.559 --> 00:20:20.799
链的实际模式的复杂性

00:20:20.799 --> 00:20:24.000
不是各个块的架构，而是

00:20:24.000 --> 00:20:27.280
就像我们了解的架构一样，它是一个关系模型

00:20:27.280 --> 00:20:31.679
那是第一名，第二名，我实际上不确定

00:20:31.679 --> 00:20:35.840
有一种方法可以摆脱这种情况，因为如果您在

00:20:35.840 --> 00:20:40.880
实际的块存储量为95％

00:20:40.880 --> 00:20:46.400
小于这5亿的2 KB，并且

00:20:46.400 --> 00:20:50.720
不对不起，我的不良99％的内存不足2 KB

00:20:50.720 --> 00:20:57.039
 95个不到512个字节，我们有很多块

00:20:57.039 --> 00:21:03.039
哈希和所有您知道的东西都大了一个字节

00:21:03.039 --> 00:21:09.120
在它周围那么什么

00:21:12.720 --> 00:21:15.440
一战长

00:21:17.280 --> 00:21:20.320
在真正研究之前先弄清楚自己要面对的是什么

00:21:20.320 --> 00:21:23.440
进入您如何解释实际模式的过程，因为

00:21:23.440 --> 00:21:27.840
这将构成您在思考的方式很多哦，我该怎么做

00:21:27.840 --> 00:21:32.720
很好，但这又回到了我们需要能够做的同样的事情

00:21:32.720 --> 00:21:38.240
至少提供可视化或提供统计信息的方式

00:21:38.240 --> 00:21:40.080
这些形状在实践中可行，因为

00:21:40.080 --> 00:21:44.080
许多这种架构已经消失了，已经进入了大约um

00:21:44.080 --> 00:21:47.840
这似乎是挂东西的正确地方，或者让我们在此处放置链接

00:21:47.840 --> 00:21:51.600
看起来不错，让我们排队看一下这似乎是正确的

00:21:51.600 --> 00:21:56.159
但您看不到任何这些决定的结果

00:21:56.640 --> 00:21:59.760
嗯，这不仅是因为您知道没人能看到决策的结果，

00:21:59.760 --> 00:22:02.240
基本上正确，这就是我的意思，这就是我在说的话

00:22:02.240 --> 00:22:04.159
关于这是ipld的一个普遍问题，

00:22:04.159 --> 00:22:07.760
系统设计师对，这是一个真正的问题

00:22:07.760 --> 00:22:10.799
你知道我实际上也遇到了同样的问题

00:22:10.799 --> 00:22:14.400
这是我正在与其他人一起工作的医疗保健工作，我们正在

00:22:14.400 --> 00:22:17.039
就像我们只需要能够可视化dag

00:22:17.039 --> 00:22:22.080
嗯，了解它并进行交流吧，我并没有真正考虑过

00:22:22.080 --> 00:22:25.200
块的大小，但这实际上是可视化的另一方面

00:22:25.200 --> 00:22:28.640
所以，我同意我的意思是，我认为当您开始在这个世界中使用时，

00:22:28.640 --> 00:22:32.400
就像我们有关系数据库之类的工具一样，您可以绘制

00:22:32.400 --> 00:22:36.320
嗯，你知道的模式，它的构造是

00:22:36.320 --> 00:22:39.200
控制其他方式，您可以做到，但可以可视化

00:22:39.200 --> 00:22:42.320
这很有意义

00:22:43.760 --> 00:22:46.960
是的，那是我的最新消息

00:22:46.960 --> 00:22:50.720
所以很高兴只是要清楚一点，彼得，你说那里有很多街区

00:22:50.720 --> 00:22:55.039
块数据是一个字节长

00:22:55.039 --> 00:22:58.480
是的，你知道那是什么吗

00:22:58.480 --> 00:23:02.640
好吧，你为什么要这么做，为什么那会在何时发生

00:23:02.799 --> 00:23:09.039
就像某种无声的句子迈克尔，你无声的等待那不是

00:23:09.039 --> 00:23:12.320
许多一字节的配置，就像只有八个

00:23:12.320 --> 00:23:16.559
有点像你怎么有这么多的块

00:23:16.720 --> 00:23:20.000
他们具有偶尔使用的位域数据结构

00:23:20.000 --> 00:23:22.960
可能是因为他们可能链接到一个位字段，

00:23:22.960 --> 00:23:26.240
最终成为，但你只能得到愚蠢的是的

00:23:26.240 --> 00:23:28.559
是的，您仍然需要重复删除所有内容

00:23:28.559 --> 00:23:32.480
255.就像我不是说有百万

00:23:32.480 --> 00:23:35.360
其中很明显，我不是说有什至是

00:23:35.360 --> 00:23:37.840
一口一口，基本上整个相机

00:23:37.840 --> 00:23:42.000
像是哦哦是啊好吧好吧好吧好吧好吧好吧好吧

00:23:42.000 --> 00:23:45.120
实际上，我想我想我能坚持下去，是的，

00:23:45.120 --> 00:23:50.480
所以这是链条的直方图，我的意思是它很小，因为

00:23:50.480 --> 00:23:56.880
因为ii是这样运行的，所以前三列最多为390

00:23:56.880 --> 00:23:59.200
个字节

00:23:59.360 --> 00:24:05.120
390.前三列，所以您的列是四个

00:24:05.120 --> 00:24:08.640
像素宽，是的，完全可以，可以，可以

00:24:08.640 --> 00:24:11.520
确保没有相邻的四列

00:24:11.520 --> 00:24:14.799
不，不，不，不，那些是第一个可以的，这是

00:24:14.799 --> 00:24:16.720
基本上这是大多数连锁店

00:24:16.720 --> 00:24:20.080
实际上，然后你来一点点是的

00:24:20.080 --> 00:24:23.360
是的，那是总大小而不是字节数

00:24:23.360 --> 00:24:26.720
此图的高度为总大小，而非数字，否，无此高度

00:24:26.720 --> 00:24:31.120
图是多少个块，多少个好吧，所以

00:24:31.120 --> 00:24:34.559
所以，就像当你在这里下得更远时，

00:24:34.559 --> 00:24:38.480
是更多实际数据字节，是的，我是说

00:24:38.480 --> 00:24:40.480
这对badge没有帮助，因为问题是

00:24:40.480 --> 00:24:43.039
键，但我只是想弄清楚是什么

00:24:43.039 --> 00:24:48.080
好的，是的，是的，这又回到了同样的权衡

00:24:48.080 --> 00:24:50.159
我们已经谈论了很久了

00:24:50.159 --> 00:24:53.120
他们是他们正在优化我认为很多情况下会发生突变

00:24:53.120 --> 00:24:55.760
费用，因此他们在早期就进行了基准测试

00:24:55.760 --> 00:24:58.320
汉普顿，想出了五位的宽度

00:24:58.320 --> 00:25:02.880
这只会让您在一个区块中获得32的arity

00:25:02.880 --> 00:25:07.520
相对较小的块，但是后来被选择的原因是

00:25:07.520 --> 00:25:11.440
突变的速度和进行突变的成本足够低

00:25:11.440 --> 00:25:15.919
所以最终会有很多小块，但您继续重复使用这些块

00:25:15.919 --> 00:25:20.559
因为您的突变不必只为一小部分插入新的大块

00:25:20.559 --> 00:25:23.919
变化，所以到处都需要权衡取舍

00:25:23.919 --> 00:25:26.320
那是我认为这是我们工作的重要部分

00:25:26.320 --> 00:25:31.600
教育和提供权衡利弊的工具

00:25:33.120 --> 00:25:42.080
是的，因为再次像实际数量一样

00:25:42.080 --> 00:25:45.679
之类的连锁店之所以大，是因为我们试图在其上发布很多信息

00:25:45.679 --> 00:25:48.480
就像有一个极限，就是你不能

00:25:48.480 --> 00:25:50.480
知道您现在只需要优化事情

00:25:50.480 --> 00:25:55.440
所以分开的州

00:25:55.520 --> 00:25:59.360
我想说的是这样的尝试

00:25:59.360 --> 00:26:03.360
这些像小块的东西，它们被悬挂在哪里

00:26:03.360 --> 00:26:06.960
因为这可能就是我们设计的

00:26:06.960 --> 00:26:11.039
数据明智，没有魔力

00:26:11.039 --> 00:26:17.120
像使它变得更好，您知道块的数量或类似的东西

00:26:18.240 --> 00:26:22.000
所以这基本上意味着最终小块将不会得到更多，因为

00:26:22.000 --> 00:26:26.640
我们所有的人都像在某一时刻，我们都拥有全部三者

00:26:26.640 --> 00:26:30.480
像所有可能的组合一样，链中有300个字节的块

00:26:30.480 --> 00:26:33.440
有很多障碍

00:26:35.600 --> 00:26:38.640
所以我真的和我聊天了

00:26:38.640 --> 00:26:41.919
今天和杰里米在一起，他提到劳尔在

00:26:41.919 --> 00:26:46.000
潜在的badge替代品，而他实际上指出，这是

00:26:46.000 --> 00:26:50.000
我应该已经想到了这一点，所以你会很感激的。

00:26:50.000 --> 00:26:53.039
但是badge使用lsm树和ls条目

00:26:53.039 --> 00:26:56.240
就像真的想要订购您的钥匙，

00:26:56.240 --> 00:26:59.679
对突变的位置具有某种相似的一致性，因此

00:26:59.679 --> 00:27:03.039
实际上，我们就像在其中插入随机密钥

00:27:03.039 --> 00:27:06.240
只是使磁盘上的实际数据结构像

00:27:06.240 --> 00:27:11.440
效率很低，所以像您不必喜欢ls条目

00:27:11.440 --> 00:27:15.200
不必像在更好的情况下那样在理论上进行分类，但是

00:27:15.200 --> 00:27:20.320
你不必不，不，是的，不，但如果

00:27:20.320 --> 00:27:25.919
无论结构看起来像什么，您的突变都在同一个地方

00:27:25.919 --> 00:27:28.480
不，不，不，不，没关系，喜欢它

00:27:28.480 --> 00:27:32.080
没关系，就像我忘了存储的名称一样

00:27:32.080 --> 00:27:34.640
以前有一个基本上是

00:27:34.640 --> 00:27:38.240
类似于lsm，但没有排序，基本上它只是一个哈希映射，而您

00:27:38.240 --> 00:27:42.320
可以像你可以做的那样做lsm

00:27:42.320 --> 00:27:45.760
有点像哈希图的结构

00:27:45.760 --> 00:27:50.720
就像它完全是一个多级存储系统

00:27:50.720 --> 00:27:54.559
嗯，但是tr，但是像我正在跟我说话的lsm

00:27:54.559 --> 00:27:58.159
关于alex的原因是因为alex指向的东西也正在戳它

00:27:58.159 --> 00:28:02.080
这些数据结构，例如badge和级别db，以及

00:28:02.080 --> 00:28:07.279
甚至lmdb，它们都存在以支持范围查询，并且它们是

00:28:07.279 --> 00:28:13.039
针对已排序的案例进行了优化，因此它可以支持传统的lsm

00:28:13.039 --> 00:28:17.039
就像有一些用例，您可以在没有它们的情况下进行排序，但是这些

00:28:17.039 --> 00:28:19.600
事情是围绕排序进行优化的，我们没有做任何事情

00:28:19.600 --> 00:28:24.480
这需要锯切，所以我们最关心的就是快速检索密钥

00:28:24.480 --> 00:28:28.080
哪种排序有帮助，但这不是唯一的方法，所以我

00:28:28.080 --> 00:28:30.640
意思是说这里有很大的潜力

00:28:30.640 --> 00:28:35.120
让我们有一个新的数据存储库嗯，是自定义的

00:28:35.120 --> 00:28:38.320
查找，更重要的是插入

00:28:38.320 --> 00:28:42.159
实际上是什么使我们丧命，因为我们的插入得到了保证，就像每个人一样

00:28:42.159 --> 00:28:44.480
单键，保证下一个在

00:28:44.480 --> 00:28:46.640
由于散列，索引的另一面

00:28:46.640 --> 00:28:53.200
是的，恰好喜欢and and and to uh

00:28:53.200 --> 00:28:59.760
让他有一个更正确的看法，今天我的答案是

00:28:59.760 --> 00:29:04.640
从一开始就运行笔记，它不再保持同步

00:29:04.640 --> 00:29:08.640
原因是badge现在大约需要25秒

00:29:08.640 --> 00:29:12.960
在30秒内，您将获得新的块，因此答案就在字面上

00:29:12.960 --> 00:29:18.640
删除badge，导入新的较小链，然后从那里继续

00:29:20.000 --> 00:29:24.399
就像那样，我们很多人一旦遇到问题就开始遇到问题

00:29:24.399 --> 00:29:29.600
链数据库增长到超过512个演出，以供参考

00:29:29.600 --> 00:29:32.000
大小

00:29:33.120 --> 00:29:37.200
那就是我的想法，所以我认为我应该特别

00:29:37.200 --> 00:29:40.399
像秋天一样，我仍然有这个存储空间，我知道像

00:29:40.399 --> 00:29:44.480
在我脑海中的10年，我只想最终建造它，我可以做这种情况，因此

00:29:44.480 --> 00:29:49.440
就像我想最终建立它

00:29:49.440 --> 00:29:55.039
是的，你可能比你想的要早

00:29:55.039 --> 00:29:58.960
是的，但是我不想这样做，所以[音乐]

00:29:58.960 --> 00:30:04.240
这可能是个问题，因为我听说海鸥是不行的

00:30:05.120 --> 00:30:08.720
实际上，这可以押韵

00:30:08.720 --> 00:30:12.559
人们试图去做一些疯狂的事情

00:30:12.559 --> 00:30:19.279
将海转变为本土生物以避免海鸥，但是

00:30:19.279 --> 00:30:22.880
忙碌的人们不介意发现诸如锈之类的锈物质实际上非常快

00:30:22.880 --> 00:30:25.360
对他们来说，就像海鸥是一个禁忌，但

00:30:25.360 --> 00:30:29.279
生锈的东西实际上很快，不，我想像您这样存放

00:30:29.279 --> 00:30:32.320
也会经历，就像有十六进制不这样做，而是

00:30:32.320 --> 00:30:36.640
就像理论上不喜欢，但实际上不喜欢

00:30:36.640 --> 00:30:41.440
所以是的，我不认为它是这样，它只是绑定了

00:30:41.440 --> 00:30:44.799
锈也通过c go绑定到黄金二进制文件

00:30:44.799 --> 00:30:50.559
这是口红，嗯，对不起，C api同步了

00:30:50.559 --> 00:30:52.960
克服生锈的成本与

00:30:52.960 --> 00:30:57.760
看，这对于更昂贵的东西（例如证明）很好

00:30:57.760 --> 00:31:00.399
验证，但对于您要存储的所有存储项目

00:31:00.399 --> 00:31:05.760
变得非常痛苦，并把它变成管理内存和

00:31:05.760 --> 00:31:09.120
退出也不是你想做的事我

00:31:09.120 --> 00:31:10.960
想想你应该能够

00:31:10.960 --> 00:31:12.880
避免那样的意思是

00:31:12.880 --> 00:31:17.039
双方的追踪成本为零

00:31:17.039 --> 00:31:22.159
是啊嗯，只是呃，目前正在戳它的人，因为我想转发一个

00:31:22.159 --> 00:31:25.760
纸，因为那样的人就像现在正在研究这个的人一样

00:31:25.760 --> 00:31:30.080
在Fico方面，有两个方面的作用

00:31:30.080 --> 00:31:34.000
积极地看着你知道可能会替换东西

00:31:34.000 --> 00:31:37.919
我认为alex也正在做其他一些长期工作，但我已经

00:31:37.919 --> 00:31:42.159
已经建议他跟你们几个说话，但我认为您应该

00:31:42.159 --> 00:31:45.279
肯定会给亚历克斯上一些信息，是的

00:31:45.279 --> 00:31:49.840
酷，是的，因为是的，很好，嗯，我会做的

00:31:49.840 --> 00:31:55.200
所以下一个是我实际上会很兴奋吗，因为我通常会问

00:31:55.200 --> 00:31:59.440
其他任何人，所有您将无话可说

00:31:59.440 --> 00:32:02.480
是的，这次我终于到处打开hackmd了

00:32:02.480 --> 00:32:05.760
短短的几句话，所以谢谢彼得

00:32:05.760 --> 00:32:09.679
上周，我们做了很多实际工作

00:32:09.679 --> 00:32:14.000
汽车数据存储或汽车街区存储可以正常工作

00:32:14.000 --> 00:32:17.519
说到新型数据存储，如果您有汽车出口，这将建立

00:32:17.519 --> 00:32:22.080
一个索引，它有几个不同的索引um

00:32:22.080 --> 00:32:25.600
用于随机访问取回汽车文件

00:32:25.600 --> 00:32:28.640
然后在其上导出锁存储接口

00:32:28.640 --> 00:32:33.360
这样您就不必重新导入badge或类似的内容

00:32:33.360 --> 00:32:38.720
但可以访问um，我是

00:32:38.720 --> 00:32:44.960
我想到的是，我们有一个ipld模式，这将是真的

00:32:44.960 --> 00:32:49.440
很好地在同一件事上获得了graphql样式的访问权限

00:32:49.440 --> 00:32:57.039
所以我该如何从现有模式中生成代码生成

00:32:57.039 --> 00:33:00.720
它的graphql格式，然后我该如何使用相同的机器

00:33:00.720 --> 00:33:04.399
实际执行graphql查询，所以

00:33:04.399 --> 00:33:08.000
大概是我在这里开始走的路

00:33:08.000 --> 00:33:11.840
因为很多使我们生活缓慢的原因

00:33:11.840 --> 00:33:18.799
我想是有两件事吗

00:33:19.200 --> 00:33:22.240
访问这些单独的项目还不错

00:33:22.240 --> 00:33:28.080
因为正如彼得所说，它们很小，但完整的枚举通常非常

00:33:28.080 --> 00:33:31.039
昂贵，所以能够有选择地退出

00:33:31.039 --> 00:33:34.960
您想要的小东西，并有一条有效的途径可以找到它们

00:33:34.960 --> 00:33:39.600
是我们经常缺少的部分，因此我们需要做的两件事是

00:33:39.600 --> 00:33:42.240
是表达你想要离开的方式的方式

00:33:42.240 --> 00:33:46.480
现在涉及定制痛苦的编程，这是很痛苦的

00:33:46.480 --> 00:33:50.320
另一个是我们需要通过这些adl进行有效访问

00:33:50.320 --> 00:33:54.960
所以我不知道这是否意味着我拥有的自定义ipld节点的种类

00:33:54.960 --> 00:33:58.080
使um允许完全不包含路径

00:33:58.080 --> 00:34:03.200
实现hampt和amped节点时加载um

00:34:03.200 --> 00:34:08.320
可能就是那个意思，嗯，但我会继续努力的

00:34:10.079 --> 00:34:13.359
下一个是迈克尔

00:34:15.280 --> 00:34:20.399
是的，好的，所以我现在必须看一下东西，我已经丢失了

00:34:20.399 --> 00:34:27.760
嗯，我上周确实做过事，我向你保证，在这里我们可以

00:34:27.760 --> 00:34:30.800
哦，是的，我在猎鹰升空式飞机上发表了演讲

00:34:30.800 --> 00:34:33.520
嗯，我们从不同的演讲中汲取了很多东西

00:34:33.520 --> 00:34:36.399
时代，把所有事情放在一起嗯，一切进行得非常顺利

00:34:36.399 --> 00:34:39.760
嗯，我和我和mikola谈过

00:34:39.760 --> 00:34:42.960
森科，我们为此be树项目设立了赠款

00:34:42.960 --> 00:34:46.480
嗯，在我们之后，我有一些非常令人兴奋的东西可以分享

00:34:46.480 --> 00:34:49.919
完成站起来，然后卡森农夫已经

00:34:49.919 --> 00:34:52.800
戳dag待一会儿，然后

00:34:52.800 --> 00:34:56.000
上个星期他告诉我说他写了一个习俗

00:34:56.000 --> 00:35:00.000
使用我在那里的新值类型的东西的crdt数据结构

00:35:00.000 --> 00:35:03.359
使用了解crdt的自定义复制器，因此非常热

00:35:03.359 --> 00:35:10.000
嗯，然后他也去写了一个度数遥远的嗯

00:35:10.000 --> 00:35:13.839
就像我们为您提供的HTTP和其他内容一样，但是在li行p2p上

00:35:13.839 --> 00:35:17.839
所以这实际上就像使用lip pdp网络在dag之间复制

00:35:17.839 --> 00:35:20.079
成为节点，但它没有使用位交换

00:35:20.079 --> 00:35:22.560
实际上仍在使用内部协议

00:35:22.560 --> 00:35:25.839
嗯，实际上比起dag效率要高很多

00:35:25.839 --> 00:35:30.240
与呃图同步或bitswap，因为它有一个

00:35:30.240 --> 00:35:33.760
阻止链接索引um，所以它真的非常好

00:35:33.760 --> 00:35:37.359
用于在您有不同的呃缓存日期时进行复制，因此

00:35:37.359 --> 00:35:40.960
嗯，这真的很酷，它促使我今天进行了其他一些改进，以

00:35:40.960 --> 00:35:45.359
就像进行远程设置一样好一些

00:35:45.359 --> 00:35:47.839
像是我们要进行lfs测试的事情

00:35:47.839 --> 00:35:50.960
总是，我们真的应该只在ci中运行它们，因为它们有点难

00:35:50.960 --> 00:35:54.560
在本地运行，嗯，那是那里的东西

00:35:54.560 --> 00:35:59.359
嗯，接下来是克里斯

00:35:59.359 --> 00:36:02.800
啊，大字了，一堆文字，但是

00:36:02.800 --> 00:36:07.280
嗯，主要是我在上课周见过工艺品

00:36:07.280 --> 00:36:10.960
有点很多，我想死胡同还是这样的开始，但是

00:36:10.960 --> 00:36:14.960
嗯，一件事是我，所以去图同步有这种

00:36:14.960 --> 00:36:19.280
消息队列机制，您知道其中的聚合请求响应

00:36:19.280 --> 00:36:22.320
并将它们发送出去，我开始执行相同的操作，但是

00:36:22.320 --> 00:36:25.520
它变得非常复杂，我对此有所思考，真的

00:36:25.520 --> 00:36:28.079
我不认为这样做不值得

00:36:28.079 --> 00:36:30.960
前面，所以基本上我有点喜欢

00:36:30.960 --> 00:36:34.240
最终只是为每个请求创建了一个新的流

00:36:34.240 --> 00:36:39.599
表现出色，但从请求者的角度来看可能微不足道

00:36:39.599 --> 00:36:45.280
嗯，然后我去了呃，我在选择器上遇到了eric，因为尽管

00:36:45.280 --> 00:36:48.000
我仍然多次读取标准倍数或规格倍数

00:36:48.000 --> 00:36:51.280
不能完全撼动它，而我发送给的选择器

00:36:51.280 --> 00:36:55.280
去ipfs没有做我认为是那么的事情，他走了我

00:36:55.280 --> 00:36:58.000
通过它，我想这个链接之前已经消失了

00:36:58.000 --> 00:37:03.200
但是呃，那个被链条拯救的家伙在这个链接里有这个呃这个例子。

00:37:03.200 --> 00:37:06.880
用选择器显示类似数据，然后显示什么

00:37:06.880 --> 00:37:09.119
这个选择器的结果是善良的

00:37:09.119 --> 00:37:12.400
这个测试因素非常有用，我认为总体上我们需要一些

00:37:12.400 --> 00:37:16.320
那种类型的教程，因为我不认为这就是全部

00:37:16.320 --> 00:37:20.079
该规范对于许多人来说可能并不可靠

00:37:20.079 --> 00:37:24.640
不适合我吧，让我们拭目以待，我继续前进

00:37:24.640 --> 00:37:28.400
在内部使用请求者呃逻辑，所以实际上

00:37:28.400 --> 00:37:31.200
端到端的工作，实际上我可以接收块并将其放在块中

00:37:31.200 --> 00:37:36.160
存储并查看它们，这样很酷，我开始进行一些工作

00:37:36.160 --> 00:37:40.240
基本验证，因为我没有选择器引擎，我在想哦，我会

00:37:40.240 --> 00:37:44.320
只是做这个深度首先阻止了呃简单的验证，但有一个

00:37:44.320 --> 00:37:48.800
问题在于至少使用go ipfs，所以go ipfs需要

00:37:48.800 --> 00:37:52.240
仅适用于深度受限的递归选择器，因此

00:37:52.240 --> 00:37:55.839
最多也只能设置100个

00:37:55.839 --> 00:37:59.359
是如果我的图深于100

00:37:59.359 --> 00:38:03.839
节点，这将给我一个局部图，而我却没有办法

00:38:03.839 --> 00:38:07.680
在没有选择引擎的情况下真正验证这一点，这也可以做到

00:38:07.680 --> 00:38:12.320
在节点级别，所以我不能只通过先执行块级别深度来使用它

00:38:12.320 --> 00:38:14.960
um验证，所以有点

00:38:14.960 --> 00:38:17.760
当我发现这一点时感到沮丧，然后另一件事是我工作了

00:38:17.760 --> 00:38:20.000
通过像错误处理API设计一样

00:38:20.000 --> 00:38:23.359
感觉有点讨厌，但您知道它是可行的，但就像它感觉很好

00:38:23.359 --> 00:38:28.240
的人感觉不太正确，嗯，所以我要回到

00:38:28.240 --> 00:38:31.440
在这里结束，但也发现这也很奇怪，我不知道我

00:38:31.440 --> 00:38:35.119
不知道这一点，但我认为js多种格式是最新的主页

00:38:35.119 --> 00:38:39.200
对于CF的cids和javascript，它不是jscid和

00:38:39.200 --> 00:38:42.079
所以直到今天我才知道，所以我也不知道为什么

00:38:42.079 --> 00:38:45.359
我怎么错过那没意识到的地方，但我也找到了这个新的街区

00:38:45.359 --> 00:38:47.119
那是我不知道的另一件事

00:38:47.119 --> 00:38:50.480
那里，但是我确实需要此前缀功能

00:38:50.480 --> 00:38:54.000
而且我知道之前提到的女武神已被弃用，但我仍然需要

00:38:54.000 --> 00:38:57.119
发起本地竞赛或将竞赛放入另一个共享库

00:38:57.119 --> 00:39:00.400
因为图同步有这个，你知道前缀作为消息的一部分，所以我有

00:39:00.400 --> 00:39:05.440
能够得到那个嗯，所以最后一件事就是

00:39:05.440 --> 00:39:08.800
今天和迈克尔讨论api的东西

00:39:08.800 --> 00:39:12.960
您最初建议我为此使用异步生成器迭代器，但我当时是

00:39:12.960 --> 00:39:15.119
只是想让基本的东西起作用

00:39:15.119 --> 00:39:18.720
通过他们交谈，我认为您实际上可以为

00:39:18.720 --> 00:39:22.160
我在那里提到的问题，所以一个是清理错误处理，因为

00:39:22.160 --> 00:39:26.480
而不是像主对象那样跟踪所有对象

00:39:26.480 --> 00:39:29.599
您的错误类型，我可以将其分布到各种错误中

00:39:29.599 --> 00:39:32.640
管道中的异步生成器迭代器，所以我就像一个整体

00:39:32.640 --> 00:39:35.760
管道可以处理多种事情，例如我可以放一些

00:39:35.760 --> 00:39:39.359
错误处理对他们来说更本地化，这也使它更具可选性，所以我将

00:39:39.359 --> 00:39:43.359
喜欢用所有这些错误处理来覆盖api

00:39:43.359 --> 00:39:46.720
状态的东西，它也应该允许我移动

00:39:46.720 --> 00:39:49.920
验证逻辑超出核心库的范围，所以我再也无法

00:39:49.920 --> 00:39:53.040
我没有选择器引擎，但最终有人会构建一个选择器引擎

00:39:53.040 --> 00:39:56.480
那时用户库可以

00:39:56.480 --> 00:39:59.760
如果他们想在某些情况下将其放在那里以进行验证，

00:39:59.760 --> 00:40:03.760
关心验证，这样才有意义，然后整个块

00:40:03.760 --> 00:40:06.319
创作，所以当你把这些方块重新拿回来时

00:40:06.319 --> 00:40:09.599
图形同步，您需要编解码器寄存器才能

00:40:09.599 --> 00:40:13.359
实际构建块对象um

00:40:13.359 --> 00:40:16.160
感觉，但会造成问题，会发生什么

00:40:16.160 --> 00:40:19.280
如果我收到一个块，说明我没有编解码器，该怎么办

00:40:19.280 --> 00:40:21.920
确实希望能够很好地处理整个错误，所以我想我可以拥有所有这些

00:40:21.920 --> 00:40:24.319
这些方式我可以配置这种东西

00:40:24.319 --> 00:40:28.160
但是如果我只是使用这些异步生成器将其移动到管道中，

00:40:28.160 --> 00:40:31.359
基本上可以将其撑起并踢向任何人

00:40:31.359 --> 00:40:33.680
在乎处理它，所以我认为

00:40:33.680 --> 00:40:37.119
感觉很好，我想我现在在哪里

00:40:37.119 --> 00:40:41.119
我需要某种提示结构来连接我在其中接收消息的地方

00:40:41.119 --> 00:40:44.640
它到实际的发电机，因为方式

00:40:44.640 --> 00:40:49.040
图同步的工作方式是让请求在一个流中发送出去，然后

00:40:49.040 --> 00:40:52.720
回应又回来了，所以我必须喜欢

00:40:52.720 --> 00:40:56.079
直接连接返回的流

00:40:56.079 --> 00:40:59.520
生成器所在的原始对象，因此我将研究使用它

00:40:59.520 --> 00:41:04.400
pushable，它是某种类型的um异步生成器提示，

00:41:04.400 --> 00:41:07.680
如果其他人对异步生成器的队列有其他想法

00:41:07.680 --> 00:41:10.000
友好，基本上我想拥有一些我可以

00:41:10.000 --> 00:41:13.359
从另一个上下文中推送它并使其弹出

00:41:13.359 --> 00:41:19.040
发电机就是我想要的，所以无论如何都是我的更新

00:41:19.599 --> 00:41:23.280
谢谢，下一个是哦，我只想简单地提及一下

00:41:23.280 --> 00:41:28.079
您是否与js p2p人士进行了交谈，因为我认为他们也切换了一些

00:41:28.079 --> 00:41:31.760
异步迭代器的事情很好，我没说过

00:41:31.760 --> 00:41:34.480
对他们来说，但这是我必须弄清楚的事情之一

00:41:34.480 --> 00:41:38.480
随着时间的流逝，p2p的工作原理是因为它是它的核心

00:41:38.480 --> 00:41:45.119
字符串的异步生成器，因此pdp流不像node.js

00:41:45.119 --> 00:41:49.359
链不是它是数据的异步生成器，所以

00:41:49.359 --> 00:41:51.760
嗯，是的，他们正在使用那个

00:41:51.760 --> 00:41:55.920
确实对设计有影响，但没有

00:41:55.920 --> 00:41:58.400
它不只是一个异步生成器，它就像

00:41:58.400 --> 00:42:02.640
他们用它们拥有的这些喜欢的模块来装饰它

00:42:02.640 --> 00:42:05.440
实际上，有时候没有它们就很难使用

00:42:05.440 --> 00:42:08.079
其他迭代器模块也是如此

00:42:08.079 --> 00:42:11.280
实际上，要弄清楚，比想像的要复杂得多

00:42:11.280 --> 00:42:17.839
嗯，很酷，所以下一个是eric

00:42:19.440 --> 00:42:23.200
所以这周我开始做大约100件事

00:42:23.680 --> 00:42:28.079
其中之一是我一直在努力制作一个

00:42:28.079 --> 00:42:33.440
rot 13 adl演示，以便演示高级数据

00:42:33.440 --> 00:42:36.480
在go中实现的布局就像

00:42:36.480 --> 00:42:39.920
本质上是文件，它会腐烂13

00:42:39.920 --> 00:42:46.880
字符串转换，所以除了用作演示之外，它是无用的，因此有一个新的公关

00:42:46.880 --> 00:42:50.240
继续推动着

00:42:50.240 --> 00:42:55.200
嗯，它的用途是文档，所以公关实际上可能是工件

00:42:55.200 --> 00:42:58.480
希望它也会在某个时候合并

00:42:58.480 --> 00:43:03.040
到目前为止，它也有一些大写锁定评论

00:43:03.040 --> 00:43:08.480
像这样一些有趣的选择

00:43:08.480 --> 00:43:12.160
找出内部节点的代码生成应如何

00:43:12.160 --> 00:43:15.760
与adl的想法也一样

00:43:15.760 --> 00:43:18.880
合成的高水平和内部的基质，如果

00:43:18.880 --> 00:43:23.280
底物也是热源，如果需要的话，它也必须是可见的

00:43:23.280 --> 00:43:26.960
看不见的问题，所以这是怎么回事

00:43:26.960 --> 00:43:30.800
在那边，我认为丹尼尔（Daniel）想出的是

00:43:30.800 --> 00:43:34.160
在他的很多情况下可能遇到许多相同的问题

00:43:34.160 --> 00:43:37.119
与竖琴的更多包容性和艰巨的工作，所以我一直在努力

00:43:37.119 --> 00:43:40.640
也把它们纠缠在一个较小的域中，看看是否

00:43:40.640 --> 00:43:44.560
更简单，它可能甚至都不会更简单

00:43:44.560 --> 00:43:48.319
嗯，有必要进行一堆编解码器强化工作

00:43:48.319 --> 00:43:51.920
在上个星期左右的丙二酸

00:43:51.920 --> 00:43:56.319
所以有一些新的东西合并到主人那里

00:43:56.319 --> 00:44:00.240
在序列化期间进行预算，其中一些已在上周进行了修复，因此

00:44:00.240 --> 00:44:02.240
我想我可能已经谈论过他们，但现在他们

00:44:02.240 --> 00:44:05.760
在大师中，我添加了一些回归测试，这些测试实际上可以确保它们

00:44:05.760 --> 00:44:08.960
工作很重要，也有一些

00:44:08.960 --> 00:44:13.920
意外的恐慌，围绕畸形的cid，因此这些问题现已得到解决，

00:44:13.920 --> 00:44:17.520
这来自于

00:44:17.520 --> 00:44:21.119
一般而言，最不权威的团队，尤其是几个人

00:44:21.119 --> 00:44:26.079
我认为谁，我把全名放在

00:44:26.079 --> 00:44:30.480
为什么它们仍然不能清晰发音的文档

00:44:30.480 --> 00:44:38.240
因此，由于某些原因，我对Codex的关注更多了

00:44:38.640 --> 00:44:44.880
而且我在编解码器api上进行了全新的尝试，因为它们也困扰着我，

00:44:44.880 --> 00:44:48.480
编解码器api和go ipld prime尚在初稿中，很亲切

00:44:48.480 --> 00:44:54.000
在某些时候需要第二稿，目前他们正在工作，但很奇怪

00:44:54.000 --> 00:44:57.200
很显然，它们使用的是抽象细节

00:44:57.200 --> 00:45:01.200
这个其他图书馆和其中一些图书馆的

00:45:01.200 --> 00:45:06.480
配置结构从这些接口泄漏很不好

00:45:06.480 --> 00:45:09.760
因此，请尝试减少api数量的用户重新购买

00:45:09.760 --> 00:45:13.440
吱吱作响，同时试图使更多的可重用

00:45:13.440 --> 00:45:17.119
组件，所以这涉及到全新的运行

00:45:17.119 --> 00:45:23.040
关于令牌化的工作原理，该思想与当前的思想非常相似

00:45:23.040 --> 00:45:26.720
实现，但正在移动代币的边界

00:45:26.720 --> 00:45:29.920
是一点点，大的变化基本上是什么

00:45:29.920 --> 00:45:34.400
说我们将不透明地将ipld链接视为一个整体令牌

00:45:34.400 --> 00:45:38.000
因此，我认为实际上改变了可组合性的边界，并且

00:45:38.000 --> 00:45:42.720
我们可能会编写新的编解码器，它将有更多

00:45:42.720 --> 00:45:46.560
代码重用，我希望我们会看到它还没有完成

00:45:46.560 --> 00:45:50.160
但我认为应该有可能实现dag json和dag sieber

00:45:50.160 --> 00:45:52.560
更多实际的共享代码，而当前

00:45:52.560 --> 00:45:55.839
它们以某种类似的方式实现

00:45:55.839 --> 00:45:59.440
他们互相启发非常紧密，但有足够的分歧

00:45:59.440 --> 00:46:03.359
从文字上讲，它们完全是分叉的，并且喜欢保持这种状态

00:46:03.359 --> 00:46:06.720
真的很烂，我被提醒在实施

00:46:06.720 --> 00:46:08.720
预算修复，然后必须完成

00:46:08.720 --> 00:46:14.240
两次嗯，我宁愿不要那么希望这个新的令牌系统使

00:46:14.240 --> 00:46:16.800
将来可能会有更多的共享代码

00:46:16.800 --> 00:46:20.480
但我们会看看是否有人想对此进行审查，因为这很有趣

00:46:20.480 --> 00:46:23.680
主题是您无法做到这一点

00:46:23.680 --> 00:46:26.240
确定什么时候我要进一步推球，因为

00:46:26.240 --> 00:46:31.280
接下来的几个步骤将是移植更多的编解码器代码，我

00:46:31.280 --> 00:46:33.280
只是不确定现在是否优先

00:46:33.280 --> 00:46:39.599
所以可能会坐一会儿um和chris讨论选择器的问题

00:46:39.599 --> 00:46:42.640
已经谈论过很多，但我绝对同意他的评论

00:46:42.640 --> 00:46:47.359
我们需要将更多示例移至文档和规范存储库中

00:46:47.359 --> 00:46:49.599
因为我们有那些人在那里，但是他们在另一个地方

00:46:49.599 --> 00:46:52.640
他们目前无法发现，这很愚蠢

00:46:52.640 --> 00:46:56.480
还有他在谈论这件事时我已经意识到的其他事情

00:46:56.480 --> 00:47:00.720
再次是我们有选择器

00:47:00.720 --> 00:47:05.040
由图书馆实施，大多数规范都在谈论这一点

00:47:05.040 --> 00:47:08.160
作为图书馆的行为，其中很多涉及概念

00:47:08.160 --> 00:47:11.359
就像遍历一样或具有回调样式

00:47:11.359 --> 00:47:15.440
经验无关紧要，但嗯，他们跨过了

00:47:15.440 --> 00:47:18.160
节点级别

00:47:18.400 --> 00:47:24.079
而且我们也有ipfs拥有针对这些东西和那些东西的api

00:47:24.079 --> 00:47:27.359
在完全不同的语义层次上进行操作，并且

00:47:27.359 --> 00:47:30.160
他们展示了相当少量的选择器

00:47:30.160 --> 00:47:33.680
而且它们基本上是面向块的，它们给了你很多

00:47:33.680 --> 00:47:40.079
回来了，这就像是出于某些目的的有用的api，但是

00:47:40.079 --> 00:47:44.160
比选择器的一般功率水平窄

00:47:44.160 --> 00:47:47.839
所以我们应该添加明确的文档

00:47:47.839 --> 00:47:51.520
我现在才意识到这一点

00:47:51.520 --> 00:47:56.720
这样就可以在待办事项清单上找到更多有关um docs的信息

00:47:56.720 --> 00:48:00.400
和规格很多人在上周，我们有几个额外的

00:48:00.400 --> 00:48:04.319
会议以找出其中之一的内容

00:48:04.319 --> 00:48:07.280
散货商带来的东西是围绕我们使用的词汇的东西

00:48:07.280 --> 00:48:11.520
多种格式与多种编解码器的比较以及存在的问题

00:48:11.520 --> 00:48:15.839
有一些新的请求请求，其中包含这些讨论的注释

00:48:15.839 --> 00:48:18.400
可能有些语言应该改变，好像有一些强烈的

00:48:18.400 --> 00:48:24.319
到目前为止，如何以及什么协议还不太明确

00:48:24.319 --> 00:48:28.720
并更多地谈论惊喜字符串

00:48:29.599 --> 00:48:34.079
我还有另一个有关字符串情况的文件

00:48:34.079 --> 00:48:38.160
所以这是我自上次以来的最近几天刚开始的

00:48:38.160 --> 00:48:41.440
小组讨论，有一个链接

00:48:41.440 --> 00:48:45.200
hack md中的内容以及这一功能的主要特点

00:48:45.200 --> 00:48:52.079
是将东西分解成二维表，所以

00:48:52.079 --> 00:48:58.000
该表的一个维度是数据模型中存在哪些种类，

00:48:58.000 --> 00:49:02.400
它们是什么意思，所以它当然是在讨论字节

00:49:02.400 --> 00:49:05.359
并讨论了字符串，并在其中进行了一些讨论

00:49:05.359 --> 00:49:10.000
文本术语，对于本文档而言，我说字符串是

00:49:10.000 --> 00:49:14.000
如果使用八位字节定义的序列，该指的是什么

00:49:14.000 --> 00:49:17.760
和文字是我将如何指代

00:49:17.760 --> 00:49:21.680
我们实际上检查了unicode，因此该文档探讨了

00:49:21.680 --> 00:49:24.880
他们两个都在同一时间，就像在此不同的列

00:49:24.880 --> 00:49:31.119
我们可以做的事的小图，然后是最左边的

00:49:31.119 --> 00:49:35.119
图，所以每一行的特征就是我们如何定义

00:49:35.119 --> 00:49:38.880
什么是映射键以及遍历如何隐式工作

00:49:38.880 --> 00:49:42.079
所以这是一个很大的桌子

00:49:42.079 --> 00:49:46.079
有很多桌子可供选择，每个盒子有很多细节

00:49:46.079 --> 00:49:49.839
我只是做了桌子，并用两个字母填满了网格的正方形

00:49:49.839 --> 00:49:53.119
这是然后在下面有类似h3的标签，所以有一个

00:49:53.119 --> 00:49:57.599
通过FC选项，我只想警告任何想要的人

00:49:57.599 --> 00:50:02.720
读这就是那件事，嗯

00:50:02.720 --> 00:50:05.280
请享用

00:50:06.559 --> 00:50:09.359
他们很多

00:50:11.359 --> 00:50:14.800
我试图以非常完整的方式填写此表，因此

00:50:14.800 --> 00:50:18.079
其中一些彼此非常相似，事实证明，大多数

00:50:18.079 --> 00:50:21.920
整个c栏都有评论说这存在地方性的问题

00:50:21.920 --> 00:50:26.640
到c列，也许您知道只是略过这整个过程

00:50:26.640 --> 00:50:31.440
列um有几件事

00:50:31.440 --> 00:50:33.920
似乎有些不太合理

00:50:33.920 --> 00:50:37.280
一些原因与编解码器有关一些原因与编解码器有关

00:50:37.280 --> 00:50:39.440
他们会有多困难

00:50:39.440 --> 00:50:44.160
实现um的库是如何关闭的

00:50:44.160 --> 00:50:47.200
未来的编解码器，其中一些是关于如何处理的

00:50:47.200 --> 00:50:51.680
难以对现有编解码器进行改造

00:50:52.079 --> 00:50:56.240
我无法再大声朗读整个文档，所以我现在就停下来说

00:50:56.240 --> 00:51:00.079
这样的文件存在，如果您愿意的话，请喜欢它

00:51:00.079 --> 00:51:03.760
这将是我的更新的结尾，除了说神圣的废话

00:51:03.760 --> 00:51:07.280
Rod本周的工作真是太酷了

00:51:07.280 --> 00:51:10.319
而且他应该发布更多的屏幕截图，因为它太酷了

00:51:10.319 --> 00:51:12.800
我受够了

00:51:13.359 --> 00:51:19.119
谢谢，所以我们通过了还有其他人吗

00:51:19.119 --> 00:51:26.480
想谈论或有任何更新

00:51:26.640 --> 00:51:29.920
我只想强调一下

00:51:29.920 --> 00:51:35.280
eric所说的短语是我们上一次小组会议有关

00:51:35.280 --> 00:51:38.559
字符串键，我认为我们应该在最后一次集体治疗会议上进行，因为那是

00:51:38.559 --> 00:51:41.760
这变成了什么

00:51:43.839 --> 00:51:50.559
字符串是一个问题，我们必须找到一个限制函数

00:51:50.559 --> 00:51:55.119
我们使用弦乐的深度有多深，我们在使用弦乐时会有的风险

00:51:55.119 --> 00:51:58.079
知道val对于您的实现很重要，但是我们有

00:51:58.079 --> 00:52:01.839
进入设计空间的风险

00:52:01.839 --> 00:52:05.280
系统非常完美，无法使用[音乐]

00:52:05.280 --> 00:52:10.319
所以我们要小心一点

00:52:12.640 --> 00:52:16.480
就像有趣的是，基本上我们大家都有相同的担忧

00:52:16.480 --> 00:52:19.920
但是我们有不同的结果

00:52:19.920 --> 00:52:24.800
基本上意味着我们是一个易于实施的系统，我们拥有

00:52:24.800 --> 00:52:30.000
关于它的含义有不同的想法，但是很酷，我们分享价值

00:52:30.000 --> 00:52:34.640
所以那还是很好，我认为我们不应该这样

00:52:34.640 --> 00:52:37.839
现在只剩下六分钟了

00:52:37.839 --> 00:52:41.200
如果要六个小时，那将是足够的时间，但是六分钟是没有的

00:52:41.200 --> 00:52:44.960
足以说更多的会议

00:52:44.960 --> 00:52:50.480
已经安排好有关字符串的安排，所以您知道传奇故事还在继续

00:52:55.680 --> 00:53:03.920
好吧，这就是一切，然后我关闭会议，甚至牛肉

00:53:03.920 --> 00:53:07.839
不，没有，只有一件事，我把它放在议程上

00:53:07.839 --> 00:53:12.079
在议程上，您阅读了议程，嗯，我只是说

00:53:12.079 --> 00:53:17.520
有一个主意，抱歉，嗯，嗯，所以我和一对夫妇聊天

00:53:17.520 --> 00:53:22.240
人们已经对此有所了解，但不是每个人都有机会

00:53:22.240 --> 00:53:26.400
所以我们请这笔赠款中的mikola写信给我们

00:53:26.400 --> 00:53:30.880
嗯，我们假设那是我们需要进行重新平衡，然后

00:53:30.880 --> 00:53:33.680
不会是完全哈希一致的，因为像那些是约束

00:53:33.680 --> 00:53:36.319
我们认为适合各种口味

00:53:36.319 --> 00:53:39.599
结构，因为我们没有办法做到这一点

00:53:39.599 --> 00:53:45.119
尼古拉想出了一种技术，我们现在正在等待实施

00:53:45.119 --> 00:53:48.559
确保它起作用，但是当

00:53:48.559 --> 00:53:51.520
你想一想，我就踢自己不

00:53:51.520 --> 00:53:56.079
如果您熟悉的话，那么快之前就已经看过了

00:53:56.079 --> 00:54:00.319
汉普如何工作，我们对键进行哈希处理，然后将其放入

00:54:00.319 --> 00:54:05.040
在基本上像一个随机的地址空间，然后我们使用

00:54:05.040 --> 00:54:07.520
变量来弄清楚存储桶应该是什么样子，这将

00:54:07.520 --> 00:54:12.880
给我们像树一样的高度和宽度的平衡

00:54:12.880 --> 00:54:16.559
所以麦科拉决定弄清楚，如果你拿一个

00:54:16.559 --> 00:54:20.000
像rabin right这样的浮动指纹算法

00:54:20.000 --> 00:54:23.920
或更好的东西，您开始调整设置

00:54:23.920 --> 00:54:27.599
基本上给你的目标尺寸是多少

00:54:27.599 --> 00:54:31.280
尺寸的一些定义，比如让您知道这些

00:54:31.280 --> 00:54:35.520
像一个特定尺寸的东西更有可能或不太可能得到的东西

00:54:35.520 --> 00:54:41.520
块，如果您将随机数据扔进去，您实际上会得到该行为

00:54:41.520 --> 00:54:45.760
它不会像您在其中找到某种重要的公共空间

00:54:45.760 --> 00:54:47.680
文字实际上只是要给你

00:54:47.680 --> 00:54:52.559
就像大小与您要求的大小相同的块一样

00:54:52.559 --> 00:54:56.319
您只需要确保随机数据就可以提供某种随机性

00:54:56.319 --> 00:54:59.440
因此，mccoll决定要做的基本上是

00:54:59.440 --> 00:55:03.200
嗯，您可以使用任何排序结构执行此操作，但是将b3用作

00:55:03.200 --> 00:55:07.839
例如，如果您将所有值链接到

00:55:07.839 --> 00:55:10.480
块，然后有一个哈希摘要，您可以

00:55:10.480 --> 00:55:14.079
用作随机值，因此不使用静态值

00:55:14.079 --> 00:55:16.799
设置铲斗尺寸应为多少

00:55:16.799 --> 00:55:20.160
就像您拥有排序结构一样

00:55:20.160 --> 00:55:23.760
您将所有的价值摘要都提取出来，然后将其插入指纹中

00:55:23.760 --> 00:55:26.240
算法，然后采用那些边界

00:55:26.240 --> 00:55:29.839
它给你，你用那些作为你的水桶

00:55:29.839 --> 00:55:34.000
然后每当您进行突变时，您只需重新处理其中的数据

00:55:34.000 --> 00:55:37.040
然后，如果到达终点，又没有撞到另一个街区边界

00:55:37.040 --> 00:55:39.200
因为这稍微改变了指纹

00:55:39.200 --> 00:55:42.640
你，你基本上进入它旁边的分支

00:55:42.640 --> 00:55:46.400
所以它比传统的b树贵一点

00:55:46.400 --> 00:55:50.000
改变，因为它在工作中具有自我平衡

00:55:50.000 --> 00:55:53.920
但它也是完全确定性的，因此无论插入顺序如何

00:55:53.920 --> 00:55:57.359
无论您如何对其进行突变，都可以获得整个结构的一致哈希

00:55:57.359 --> 00:56:00.559
根据您的设置，它会相对平衡

00:56:00.559 --> 00:56:04.400
唯一的问题是，您使用哪种算法进行指纹识别和

00:56:04.400 --> 00:56:06.799
有哪些设置，因为这些设置将极大地给您带来喜欢

00:56:06.799 --> 00:56:08.960
结构的不同性能特征

00:56:08.960 --> 00:56:12.640
但是像那样，彼得的所有工作都是这样来的

00:56:12.640 --> 00:56:16.480
我们喜欢的整个设置，并在此问题上抛出大量数据

00:56:16.480 --> 00:56:18.640
喜欢啊喜欢拿所有这些随机数据，然后

00:56:18.640 --> 00:56:22.160
告诉我们这些结构是什么样的，以便我们找出理想的

00:56:22.160 --> 00:56:25.680
一个看起来像嗯，所以我们处于一个非常好的位置

00:56:25.680 --> 00:56:28.559
使用这项技术，嗯，是的，我们就像在等待

00:56:28.559 --> 00:56:32.640
实施和东西，但这给了我们一个全新的领域

00:56:32.640 --> 00:56:35.760
数据结构的开发和研究，因为我们曾经以为我们

00:56:35.760 --> 00:56:39.440
实际上并没有一种通用的方法来建立排序

00:56:39.440 --> 00:56:41.760
完全哈希一致的结构，所以您不能在其中使用它们

00:56:41.760 --> 00:56:44.400
filecoin，您不能在插入订单所在的任何地方使用它们

00:56:44.400 --> 00:56:48.240
真的很重要，现在就像我们可以做到的那样，我们实际上

00:56:48.240 --> 00:56:50.880
有一种用于构建这些数据结构的技术，如果

00:56:50.880 --> 00:56:54.640
从现在到实施之间，我们没有发现任何重大问题

00:56:54.640 --> 00:56:57.839
所以我想分享一下并引起人们的注意

00:56:57.839 --> 00:57:01.040
但这是令人兴奋的东西

00:57:02.400 --> 00:57:09.440
谢谢，所以现在我们是时候了，所以我必须要看的其他事情

00:57:09.440 --> 00:57:12.160
议程，没有，没有其他项目，没有，没有其他项目

00:57:12.160 --> 00:57:15.680
项目，谢谢您的参与，并与大家见面

00:57:15.680 --> 00:57:21.839
下周再见大家

