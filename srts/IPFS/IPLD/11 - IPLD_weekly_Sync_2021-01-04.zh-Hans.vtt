WEBVTT
Kind: captions
Language: zh-Hans

00:00:07.759 --> 00:00:11.760
而且我认为我们还活着

00:00:12.320 --> 00:00:17.359
我认为很好，欢迎大家加入ipld

00:00:17.359 --> 00:00:20.400
 [音乐]每周同步

00:00:20.400 --> 00:00:26.960
2021年，所以我们今天没有伏特加，但是

00:00:26.960 --> 00:00:32.160
每个人都在这里，让我们开始吧，我们要去做一个

00:00:32.160 --> 00:00:37.200
快站起来，所以丹尼尔，你是第一个

00:00:38.239 --> 00:00:41.760
很酷，这是我第一个礼拜回来，所以我还没有做

00:00:41.760 --> 00:00:45.840
很多，但我仍在努力做好我所做的第一件事

00:00:45.840 --> 00:00:50.000
就在我去度假之前，完成了0.7的重构

00:00:50.000 --> 00:00:56.399
eric呃，主要是改名，而且基本上是整理的

00:00:56.399 --> 00:00:59.680
api以我们想要的向后兼容方式

00:00:59.680 --> 00:01:02.480
做了几个月，所以那些现在被运了，但我认为

00:01:02.480 --> 00:01:06.720
埃里克（Eric）要谈论的是，我也做了很多评论

00:01:06.720 --> 00:01:11.439
我今天一直在看的是eric的要求

00:01:11.439 --> 00:01:16.720
um添加一个新的api来从头创建节点，所以我们有一个名为fluent的程序包

00:01:16.720 --> 00:01:20.400
这个，但是不是很好，而且还不如做的那么快

00:01:20.400 --> 00:01:24.320
直接手工操作，所以我们想出了一种新方法，我认为

00:01:24.320 --> 00:01:28.320
我对它做了一些细化而不使其变慢，这可能是一个好主意

00:01:28.320 --> 00:01:32.000
所以我将他的版本和我的版本链接到他的顶部

00:01:32.000 --> 00:01:38.320
如果有人想看，嗯，我也是今天早上在问为什么去

00:01:38.320 --> 00:01:42.960
ipfs太烂了，所以我有一个项目，我

00:01:42.960 --> 00:01:45.360
有助于使用go ipfs，您知道

00:01:45.360 --> 00:01:49.200
从go导入go ipfs意味着您像导入一堆

00:01:49.200 --> 00:01:53.280
协议实验室模块，我意识到二进制文件就像100兆字节

00:01:53.280 --> 00:01:57.600
所以我开始对此表示怀疑，事实证明ipfs本身应归咎于

00:01:57.600 --> 00:02:02.000
嗯，但是我意识到例如

00:02:02.000 --> 00:02:06.640
quick go使用一个名为goj的库来编组json进行日志记录

00:02:06.640 --> 00:02:13.680
Goj就像是超过一兆字节的方式，所以我认为这很可悲，所以我当时

00:02:13.680 --> 00:02:15.760
看着那个，戳马丁关于它

00:02:15.760 --> 00:02:20.400
嗯，他说他以标准库中的jason包为基准对其进行了基准测试

00:02:20.400 --> 00:02:22.640
二月，但他没有那个代码了

00:02:22.640 --> 00:02:26.000
所以他将在几天之内让我获得该代码，而我想

00:02:26.000 --> 00:02:29.200
看看那个，因为我很确定我们可以得到

00:02:29.200 --> 00:02:32.400
您知道快速记录，因为记录非常简单，无需

00:02:32.400 --> 00:02:35.519
需要添加如此沉重的依赖性只是为了快速进行

00:02:35.519 --> 00:02:38.959
所以无论如何这只是说我认为去ipfs有点沉重

00:02:38.959 --> 00:02:42.720
不属于那里的间接依赖

00:02:42.720 --> 00:02:46.800
我周末也很开心，做了一些最喜欢的分析

00:02:46.800 --> 00:02:49.920
github上流行的go模块，所以如果有人要

00:02:49.920 --> 00:02:53.280
做任何需要查看大量go代码的事情

00:02:53.280 --> 00:02:57.519
您知道您知道像分析代码库或如何执行代码

00:02:57.519 --> 00:03:00.720
人们这样做，或者您可以以此为起点

00:03:00.720 --> 00:03:07.120
克隆一堆仓库，看看它们，对我来说就是这样

00:03:10.000 --> 00:03:16.959
好的，是的，自上次会议以来，我没有做很多事情

00:03:17.760 --> 00:03:21.440
iii确实解决了该javascript续集的问题

00:03:21.440 --> 00:03:28.000
ii几乎提出了拉动请求，只是想看看更多改变海上漫步

00:03:28.000 --> 00:03:33.519
解析器，但最终导致浪费大量时间

00:03:33.519 --> 00:03:35.920
做基准测试，试图挤压

00:03:35.920 --> 00:03:40.159
表现出来我也得到了这个包装

00:03:40.159 --> 00:03:45.440
从它里面叫做ipld jsibilty垃圾，这只是一个

00:03:45.440 --> 00:03:52.319
垃圾数据生成器，该数据生成器生成符合以下条件的随机对象：

00:03:52.319 --> 00:03:55.599
数据模型，对于测试以及

00:03:55.599 --> 00:04:00.560
标杆，嗯，我的

00:04:00.560 --> 00:04:04.480
就是这样，这就是我本周将要处理的内容

00:04:04.480 --> 00:04:11.200
cbo的东西可以做到这一点，呃，我就像我说的工作已经完成了

00:04:11.200 --> 00:04:17.519
除了调整性能时，

00:04:18.400 --> 00:04:21.840
与我们目前的海床比较

00:04:21.840 --> 00:04:28.160
解析器，嗯，它的基准测试有点

00:04:28.160 --> 00:04:32.400
复杂，因为解析器是um转动的货币

00:04:32.400 --> 00:04:36.400
一次真的很糟糕，所以如果

00:04:36.400 --> 00:04:40.080
您仅将其用作解码器或编码器即可

00:04:40.080 --> 00:04:44.560
这确实很糟糕，但是当您在基准环境中进行操作时，

00:04:44.560 --> 00:04:47.840
做很多解码和编码，您在使用时

00:04:47.840 --> 00:04:52.479
这是我们在编解码器中使用它的方式，那么它需要做很多内存

00:04:52.479 --> 00:04:58.080
技巧，所以当您做很多事情时，它最终变得相当合理

00:04:58.080 --> 00:05:02.720
的编码和解码等等

00:05:02.720 --> 00:05:06.560
所以我跨越了这条不想使用的行

00:05:06.560 --> 00:05:09.759
与我们当前的符号解析器相同的技巧是

00:05:09.759 --> 00:05:16.080
非常有两个问题，因为它具有

00:05:16.080 --> 00:05:19.440
它使用的技巧之一就是分配这些大

00:05:19.440 --> 00:05:22.960
内存缓冲区，然后只保留它们

00:05:22.960 --> 00:05:27.039
和um等，然后使用的另一个技巧是使用

00:05:27.039 --> 00:05:33.919
嗯，优化节点缓冲区的性能

00:05:33.919 --> 00:05:42.080
嗯，让我挤一些边缘性能吧，我是

00:05:42.080 --> 00:05:45.120
做这个东西，所以当你在里面时，它并不依赖于你

00:05:45.120 --> 00:05:50.560
浏览器如此跨越，以致于

00:05:50.560 --> 00:05:53.600
在压缩性能方面有些烦人

00:05:53.600 --> 00:05:57.199
比较嗯，所以我不，我没有

00:05:57.199 --> 00:06:02.880
我真的很想赢得性能冠军，除非我比较这些东西

00:06:02.880 --> 00:06:09.840
在一个嗯嗯做一次，所以我有点

00:06:09.840 --> 00:06:12.880
对当前的位置感到失望，但我现在正在做一些工作

00:06:12.880 --> 00:06:16.319
进一步挤压，我还有其他一些不错的选择

00:06:16.319 --> 00:06:21.039
从这个东西出来的功能，例如um的能力

00:06:21.039 --> 00:06:23.759
拉出这只是海滨街区的长度，而不解码其余部分

00:06:23.759 --> 00:06:26.639
我可以做到这一点，所以我要添加

00:06:26.639 --> 00:06:30.400
一个到编解码器的链接方法

00:06:30.400 --> 00:06:34.160
而不是像解码um

00:06:34.160 --> 00:06:37.360
您可以只做链接，它只会为您提供一系列

00:06:37.360 --> 00:06:40.560
出现在链接中的链接的有序数组

00:06:40.560 --> 00:06:44.479
blob，这可能是添加到其他编解码器中的有趣捷径

00:06:44.479 --> 00:06:48.720
在高效的地方，您应该不仅返回了链接，还返回了

00:06:48.720 --> 00:06:52.000
也是链接的路径

00:06:54.080 --> 00:06:57.360
是的，如果您要查看新版本中的links方法，就需要同时使用这两种方法

00:06:57.360 --> 00:07:00.720
在新的多格式编解码器中，它会对其进行迭代，但始终会

00:07:00.720 --> 00:07:06.240
你的垫子以及呃链接是的，我想用例我

00:07:06.240 --> 00:07:11.039
想要像我将它用于文件硬币数据，就是这样

00:07:11.039 --> 00:07:14.560
可以给我带来一些不错的性能优势

00:07:14.560 --> 00:07:18.960
只是在解码上，但我真正想要的只是能够

00:07:18.960 --> 00:07:22.880
做一种原始的爬网，我不是真的

00:07:22.880 --> 00:07:27.280
想要路径，但我只想要链接，所以因为我

00:07:27.280 --> 00:07:32.160
所以是的，我的意思是因为那会增加开销

00:07:32.160 --> 00:07:35.680
通过做部分，因为你必须做更多的方式更多的解码，但

00:07:35.680 --> 00:07:38.960
是的，这是一个有趣的观点，是的，您必须保留

00:07:38.960 --> 00:07:42.560
状态跟踪也会好一点，我的意思是我可以看到两者的用途

00:07:42.560 --> 00:07:45.840
嗯，这只是大多数时间

00:07:46.000 --> 00:07:49.599
大多数时候，我也会选择其中一条路径，但是如果您愿意的话，

00:07:49.599 --> 00:07:51.759
用

00:07:53.840 --> 00:07:57.360
否否否您需要真正喜欢解码地图的字符串

00:07:57.360 --> 00:08:00.720
键以创建路径，而如果您

00:08:00.720 --> 00:08:02.879
只是在链接上播放，您实际上可以跳过所有这些内容

00:08:02.879 --> 00:08:06.240
直到你击中它，是的，一旦你进入琴弦，这就是一切

00:08:06.240 --> 00:08:10.479
像字符串一样痛苦，就像二进制文件中的字符串一样

00:08:10.479 --> 00:08:13.520
这是性能的最差路径吗

00:08:13.520 --> 00:08:16.319
所以就像一旦开始就去做一样，您不妨解码一下

00:08:16.319 --> 00:08:20.479
就是这样，是的

00:08:20.479 --> 00:08:22.400
我们在这里得到的性能矢量

00:08:22.400 --> 00:08:28.080
嗯，所以脚本真的很适合他们，但是

00:08:28.080 --> 00:08:33.760
让他们成为字符串是的是的，这是字节

00:08:33.760 --> 00:08:37.599
字符串，然后再次返回和utf-8，这只是

00:08:37.599 --> 00:08:41.039
无论如何，就像我在这个上浪费了一个星期一样

00:08:41.039 --> 00:08:45.760
狂热的编码和基准测试，以及

00:08:45.760 --> 00:08:49.279
最终比我想象的要令人失望的多

00:08:49.279 --> 00:08:52.320
嗯，无论如何，我将在本周完成这项工作

00:08:52.320 --> 00:08:55.600
这是我本周完成的任务，嗯，

00:08:55.600 --> 00:08:58.640
至少以初始形式发布，然后呃

00:08:58.640 --> 00:09:01.839
继续哦，另一件事是dag编解码器

00:09:01.839 --> 00:09:09.040
我说去代码pb我已经将其标记为已完成的版本

00:09:09.040 --> 00:09:15.600
嗯，它很好用，并且已经过了新的测试，这是什么

00:09:15.600 --> 00:09:18.959
github动作测试马丁做过的东西

00:09:18.959 --> 00:09:24.480
进行回购，并且从我们与之讨论的上次会议中获得了该错误

00:09:24.480 --> 00:09:28.000
已修复的int 64s每年递增

00:09:28.000 --> 00:09:31.920
素，现在又合并回去，然后全部发布并

00:09:31.920 --> 00:09:38.480
做得很好，是的，很好，嗯，就是我

00:09:38.480 --> 00:09:41.600
嗯，下一个艾瑞克

00:09:46.480 --> 00:09:51.839
所以我在休息时做得不好

00:09:52.320 --> 00:09:55.920
在过去的几周里，我试图花很多钱

00:09:55.920 --> 00:10:01.600
好玩的新应用程序和好消息是，我合法地

00:10:01.600 --> 00:10:05.680
我真的很想使用我们的ipld库和工具来获得

00:10:05.680 --> 00:10:11.279
做的事可以说是个好消息

00:10:11.279 --> 00:10:14.720
最终刺激了很多开发工作，您知道如何做，所以

00:10:14.720 --> 00:10:18.000
我实际上是以一种为

00:10:18.000 --> 00:10:22.480
ipld um so

00:10:22.480 --> 00:10:26.079
我们现在在go库中有一件有趣的事情是

00:10:26.079 --> 00:10:29.760
遍历包中有一个函数，称为聚焦变换

00:10:29.760 --> 00:10:33.839
这可以帮助您将突变指向现有的纪录片

00:10:33.839 --> 00:10:37.760
因此该功能基本上可以让您上交

00:10:37.760 --> 00:10:41.200
作为某些文档根目录的节点，以及您要执行某操作的路径

00:10:41.200 --> 00:10:45.360
到，然后它将给您回电

00:10:45.360 --> 00:10:48.800
您给它的任何回叫，然后说这是我在那部纪录片中发现的内容

00:10:48.800 --> 00:10:51.440
在那个位置，请告诉我你想做什么

00:10:51.440 --> 00:10:54.000
替换为它，然后它将经历

00:10:54.000 --> 00:10:57.680
以正确的方式围绕该纪录片重建其余的纪录片

00:10:57.680 --> 00:11:00.800
即使您有一条可以

00:11:00.800 --> 00:11:04.480
通过中间的几个链接跳至其他文档

00:11:04.480 --> 00:11:08.640
它将重建所有这些，所以这已经在路线图上了

00:11:08.640 --> 00:11:12.959
很久以来，我实际上已经写了它，并且已经过测试，我很确定

00:11:12.959 --> 00:11:17.200
有效，这样您甚至可以进行点突变

00:11:17.200 --> 00:11:20.560
在大图中，它将为您做正确的事

00:11:20.560 --> 00:11:23.600
如果需要的话，它应该可以节省很多工作

00:11:23.600 --> 00:11:27.200
像这样管理文件

00:11:27.279 --> 00:11:31.120
我还试图使它的形式更通用

00:11:31.120 --> 00:11:34.640
指定一堆点突变操作

00:11:34.640 --> 00:11:39.920
然后该功能将找出如何最有效地执行此操作

00:11:39.920 --> 00:11:42.720
结果变得有些棘手，所以最终从

00:11:42.720 --> 00:11:47.519
我最终在设计bin上从事一些工作，

00:11:47.519 --> 00:11:53.600
与um非常相似，那里有一个json补丁rfc

00:11:53.600 --> 00:11:57.839
最终得到了一个非常类似的东西

00:11:58.160 --> 00:12:02.000
但实际上实现了这样的多变异

00:12:02.000 --> 00:12:05.519
有效地发挥作用

00:12:05.760 --> 00:12:09.120
原来真的很棘手，我想做点更多的事情

00:12:09.120 --> 00:12:11.519
比执行一系列点突变更有效

00:12:11.519 --> 00:12:14.240
因为您当然可以在for循环中执行此操作

00:12:14.240 --> 00:12:20.880
但就像我想快点走，如果有人想

00:12:20.880 --> 00:12:24.000
看到我们的辛苦努力会真的很有趣

00:12:24.000 --> 00:12:29.600
我发现的零件是这样的，如果您希望这是最佳的，

00:12:29.600 --> 00:12:31.760
将要在您那里拥有此功能

00:12:31.760 --> 00:12:35.279
给它列出您要执行的转换

00:12:35.279 --> 00:12:38.399
然后该功能将要考虑到这一点，

00:12:38.399 --> 00:12:42.639
做某种类似于查询计划程序类型的逻辑并找出顺序

00:12:42.639 --> 00:12:46.480
它想要做到最好

00:12:46.880 --> 00:12:50.399
然后变得非常棘手，因为不是您执行的所有操作

00:12:50.399 --> 00:12:54.880
可能想做的实际上是可交换的

00:12:54.880 --> 00:12:58.560
更改地图中的某些内容，这些更改通常是

00:12:58.560 --> 00:13:03.040
在列表中可更改，因为您傻傻地更改了相同的地图键

00:13:03.040 --> 00:13:06.240
当然，我可以重新排列这些顺序，而不更改语义

00:13:06.240 --> 00:13:14.639
或附加地图键可能没问题，但嗯，好吧，我们要附加

00:13:14.639 --> 00:13:17.839
到列表的末尾，还好吧，假设我们要

00:13:17.839 --> 00:13:23.760
插入列表中间拍摄不好，无法进行通勤

00:13:23.760 --> 00:13:27.120
进行此操作，因为它将更改列表中所有其他列表索引的含义

00:13:27.120 --> 00:13:31.519
您的指令集的其余部分类似地列出了删除操作，实际上并没有

00:13:31.519 --> 00:13:34.959
通勤，所以事情变得非常复杂

00:13:34.959 --> 00:13:37.600
因为如果我有什么问题

00:13:37.600 --> 00:13:40.720
如果我有很多都说的插入操作

00:13:40.720 --> 00:13:44.240
零，所以他们将整个列表的其余部分移框，然后我执行此操作

00:13:44.240 --> 00:13:49.760
我想我能不能考虑一下你是否实施了足够的幻想

00:13:49.760 --> 00:13:53.120
逻辑，您可以使其中的一些东西可交换，但随后

00:13:53.120 --> 00:13:57.519
您想要进行多少次预处理才能将其检查出来，还是喜欢

00:13:57.519 --> 00:14:01.040
然后你会遇到像这样的极端情况

00:14:01.040 --> 00:14:05.680
如果您将其应用在列表中，但将其应用在地图上，则是可交换的

00:14:05.680 --> 00:14:12.720
那么不是，反之亦然，它变得毛茸茸，所以

00:14:12.720 --> 00:14:15.600
我把它放回设计箱中，但如果有人想看看和思考

00:14:15.600 --> 00:14:18.000
关于那个，我认为有很多有趣的事情要做

00:14:18.000 --> 00:14:20.720
将来有

00:14:21.120 --> 00:14:26.240
嗯，我认为danielle提到了这一点，但他和我俩都开始从事一些工作

00:14:26.240 --> 00:14:28.800
用于创建数据树的新辅助函数

00:14:28.800 --> 00:14:33.760
在我们的Go库中，快速重述了问题

00:14:33.760 --> 00:14:38.639
在go ipld prime库中，我们有这些节点接口和节点

00:14:38.639 --> 00:14:43.199
汇编程序接口，它们真的很丰富，功能也很强大，而且它们

00:14:43.199 --> 00:14:47.519
非常完整地建模ipld数据模型的域

00:14:47.519 --> 00:14:51.360
以及您可以使用它做的所有事情，因为它们是如此的完整，所以他们

00:14:51.360 --> 00:14:56.240
使用起来很冗长，而且屁股有点疼，所以

00:14:56.240 --> 00:14:59.760
我们一直期望我们将拥有这些节点api

00:14:59.760 --> 00:15:03.040
确实很丰富，然后我们将使可用性更出色

00:15:03.040 --> 00:15:06.959
他们周围的外墙，我们实际上开始尝试制作

00:15:06.959 --> 00:15:10.240
这些更多，所以我有一个公关，我想

00:15:10.240 --> 00:15:16.880
dan和另一个um进行了公关，他们在语法上都比较好

00:15:16.880 --> 00:15:19.600
比我们之前所做的事情都

00:15:19.600 --> 00:15:24.480
与以前相比，基准测试的开销要少得多

00:15:24.480 --> 00:15:28.240
而不是在使用我们的外墙之一之间做出尴尬的选择

00:15:28.240 --> 00:15:31.600
并有旅游法规，但会造成性能损失

00:15:31.600 --> 00:15:34.959
然后只能潜在地盯着将来的重写等

00:15:34.959 --> 00:15:38.160
我们提出了一些没有性能的新选择

00:15:38.160 --> 00:15:42.000
征税，所以您可以只使用它们，可能还不错，所以我们

00:15:42.000 --> 00:15:44.720
仍在完善这些功能，但是拥有更多选择令人兴奋

00:15:44.720 --> 00:15:46.959
为他们

00:15:47.440 --> 00:15:50.320
我们标记了一个发布

00:15:50.880 --> 00:15:54.959
我们在假期真的很不好，我们标记了发布

00:15:54.959 --> 00:15:59.120
Godfield Prime库中的0.7.0也是如此

00:15:59.120 --> 00:16:03.120
嗯，我认为两个说话的人都已经提到

00:16:03.120 --> 00:16:06.480
这个已经很短的插件在技术上已经固定了

00:16:06.480 --> 00:16:08.880
换个很小的东西，真的很简单

00:16:08.880 --> 00:16:14.320
进行升级，但丹尼尔（Um daniel）给了我们说的说明

00:16:14.320 --> 00:16:18.399
基本上可以自动地迁移所有这些东西，并且

00:16:18.399 --> 00:16:23.839
这些在更改日志记录中，因此应该可以真正轻松地进行升级

00:16:24.160 --> 00:16:29.440
该代码gem现在支持字符串前缀人类，因为我真的

00:16:29.440 --> 00:16:32.480
想要在这个假期中将其用于我的其他兴趣爱好项目中的一个，这样就完成了

00:16:32.480 --> 00:16:34.720
现在

00:16:34.839 --> 00:16:38.720
嗯和

00:16:39.199 --> 00:16:42.800
我不知道其他一些无聊的编码内容

00:16:42.800 --> 00:16:50.800
大概就是我想的字符串前缀

00:16:50.800 --> 00:16:55.120
工会在我们的规范中定义了，无论它们在哪里

00:16:57.440 --> 00:17:04.319
也许您需要为此执行对架构模式的拉取请求

00:17:04.319 --> 00:17:07.360
有前缀

00:17:07.439 --> 00:17:11.919
哦，开枪，你可能是对的

00:17:12.559 --> 00:17:19.679
好吧，彼得，你起来了，谢谢你，所以呃，对我来说，我一直在

00:17:19.679 --> 00:17:24.640
永远地工作是现实，现在

00:17:24.640 --> 00:17:31.440
确实可以复制数据库的数据库，但是有一个指向狗的链接，

00:17:31.440 --> 00:17:35.200
有一组实际的凭证，因此您可以

00:17:35.200 --> 00:17:38.960
只需登录，这将是随后的副本

00:17:38.960 --> 00:17:40.720
一个实际的莲花实例

00:17:40.720 --> 00:17:45.280
写入数据库写入块权限已写入所有链接

00:17:45.280 --> 00:17:49.440
钓鱼出来，所以你实际上可以做递归SQL

00:17:49.440 --> 00:17:53.120
在实际数据库中查询并获取您所知道的阻止

00:17:53.120 --> 00:17:57.679
学校的树木喜欢弄清楚状态的权重等等。

00:17:57.679 --> 00:18:02.559
它也分析了它看到的几个技巧并将其分解

00:18:02.559 --> 00:18:05.919
到另一组具有实际链表的表中

00:18:05.919 --> 00:18:09.840
呃，你知道连锁成员的消息在哪里，状态在哪里等等

00:18:09.840 --> 00:18:14.400
依此类推，这样您就可以进行完整遍历

00:18:14.400 --> 00:18:19.919
猎鹰链，而不必离开您的esco理事会

00:18:19.919 --> 00:18:26.840
嗯，这不是它来自的完整状态

00:18:26.840 --> 00:18:34.080
362 500块起，所以这大约是一个星期前

00:18:34.080 --> 00:18:37.600
这将继续工作，需要一些调整

00:18:37.600 --> 00:18:43.120
要获得它，基本上现在它会在大约七个过程中处理一个芯片组

00:18:43.120 --> 00:18:46.400
秒，完全可以让它跟上，跟上

00:18:46.400 --> 00:18:50.559
链，但它不允许我从零唱歌到

00:18:50.559 --> 00:18:56.080
有我需要加速的全部事情

00:18:56.080 --> 00:18:59.520
每小费第二秒，然后在一周内，我们将获得

00:18:59.520 --> 00:19:04.000
实际查询的整体效果

00:19:04.000 --> 00:19:07.360
正如我预期的复制一样，正如我预期的那样

00:19:07.360 --> 00:19:12.960
600 GB的数据库在大约两个小时内就流式传输到了新主机

00:19:12.960 --> 00:19:16.960
基本上只是启动了，是的，

00:19:16.960 --> 00:19:22.080
恩，我拥有一切，你知道伐木踢，踢踢轮胎让我

00:19:22.080 --> 00:19:24.799
知道是否缺少某些东西或看起来不怎么样，并且

00:19:24.799 --> 00:19:32.480
是的，所以，所以你比badge快

00:19:32.480 --> 00:19:35.840
是否有潜力只是嵌入

00:19:35.840 --> 00:19:39.440
在Lotus的未来版本中嵌入了一个postgres，只是放弃了r和

00:19:39.440 --> 00:19:42.320
这是数据存储的下一个升级

00:19:42.320 --> 00:19:47.440
所以对于档案馆来说，这绝对是我在用自己的东西，因为

00:19:47.440 --> 00:19:51.039
像the一样的东西是不可能生存的，它需要很多

00:19:51.039 --> 00:19:55.520
吃饭，所以我喜欢的是

00:19:55.520 --> 00:19:59.760
在谈话中，但是嗯，它的作用远不止于此

00:19:59.760 --> 00:20:02.480
还要针对您的情况进行跟踪

00:20:02.480 --> 00:20:04.480
工作，你知道和亚历克斯·诺顿的

00:20:04.480 --> 00:20:10.880
接地，它为每个提示集保留记录，其中读取了哪些块或

00:20:10.880 --> 00:20:14.000
像这样写的就是它的粒度

00:20:14.000 --> 00:20:17.200
就像一个巨大的日志，它只是不断写入并不断追加，因此您可以

00:20:17.200 --> 00:20:20.720
从字面上看，您可以看到特定的CID

00:20:20.720 --> 00:20:25.520
谁需要这个cid并获得完整的清单，您知道它在哪里使用以及如何使用

00:20:25.520 --> 00:20:29.120
而且甚至有一个时代，呃，抱歉，墙上的时光

00:20:29.120 --> 00:20:32.480
访问和类似的东西之间有多长时间，所以它是

00:20:32.480 --> 00:20:35.919
所以在那个水平上是超级一般的

00:20:35.919 --> 00:20:38.640
显然，您不需要常规的这个就可以了，因为您知道的常规

00:20:38.640 --> 00:20:42.640
定期安装我的东西是，如果我得到它

00:20:42.640 --> 00:20:45.919
这正是我想要成为的地方

00:20:45.919 --> 00:20:48.720
在大约一秒钟的范围内或类似的范围内

00:20:48.720 --> 00:20:53.120
而不是用以下方式分发此荒谬的汽车文件：

00:20:53.120 --> 00:20:56.640
您知道需要它们导入的快照等等。

00:20:56.640 --> 00:20:59.840
我可以开始分发sqlite快照

00:20:59.840 --> 00:21:03.520
刚好适合您的状态，您只需插入

00:21:03.520 --> 00:21:06.960
sqlite的东西，这只是一个文件到您的

00:21:06.960 --> 00:21:12.559
呃数据目录，您只需要使用它，因为它不像

00:21:12.559 --> 00:21:15.760
它是一个单节点，不需要超级性能

00:21:15.760 --> 00:21:21.280
我想直接回答您的问题棒就足够了

00:21:21.280 --> 00:21:24.720
您可能期望的是带有标志的Lotus的未来版本

00:21:24.720 --> 00:21:28.960
允许postgres后端可能不会运行postgresql，但是如果

00:21:28.960 --> 00:21:31.760
你有，但是你可以使用相同的

00:21:31.760 --> 00:21:37.520
Lotus代码和本地postgres以及一个标志来作为您的后盾

00:21:37.520 --> 00:21:40.720
数据存储而不是魔术

00:21:42.000 --> 00:21:47.760
整洁的酷工作好吗迈克尔

00:21:49.200 --> 00:21:55.200
我回来了，好吧，是的，所以有一些非常好的代码时间

00:21:55.200 --> 00:22:00.240
在我休假的时候，真是太好了，最大的事情是我写了另一本书

00:22:00.240 --> 00:22:03.600
我们已经讨论了一段时间的树的实现

00:22:03.600 --> 00:22:07.120
我和mikola一直在努力实现这一实施，

00:22:07.120 --> 00:22:10.960
做了几次，变得更好更干净了

00:22:10.960 --> 00:22:14.320
我意识到实现这种数据结构的一件事是

00:22:14.320 --> 00:22:17.440
如果不做的话，实施起来会更清洁

00:22:17.440 --> 00:22:21.280
像序列化一样，如果序列化就像

00:22:21.280 --> 00:22:25.520
某些类型会做的事情，但实际上确实存在

00:22:25.520 --> 00:22:28.799
实际上，如果仅以类似的方式来考虑它，效果就不会很好

00:22:28.799 --> 00:22:31.679
序列化路径将是什么样子

00:22:31.679 --> 00:22:34.799
嗯，这就像一个更清洁的实现

00:22:34.799 --> 00:22:38.240
的树，然后在实现的树的顶部

00:22:38.240 --> 00:22:41.679
一堆数据结构，所以有一个稀疏的数组

00:22:41.679 --> 00:22:49.360
db索引有序映射um u cid设置了其他一些内容um

00:22:49.360 --> 00:22:52.159
因此它确实有效，并且在这些不同的方面都具有通用性

00:22:52.159 --> 00:22:55.440
方案，它也可以像添加ipld一样工作

00:22:55.440 --> 00:23:00.080
序列化到它里面，嗯，这就是它现在所做的

00:23:00.080 --> 00:23:03.360
所以，然后我用它来写呃ip sql

00:23:03.360 --> 00:23:06.720
就像有一个完整的sql实现um

00:23:06.720 --> 00:23:09.840
有些语法现在还不存在，但是像

00:23:09.840 --> 00:23:14.960
您可以创建表，并且所有列都有完整的索引

00:23:14.960 --> 00:23:19.679
嗯，就像我有一个csv导入器一样，所以您可以将csvs导入

00:23:19.679 --> 00:23:23.039
现在您已经拥有了这个基于ipld的sql数据库

00:23:23.039 --> 00:23:26.720
当您对其进行查询时，您只提取这些数据的一部分

00:23:26.720 --> 00:23:28.320
这些查询所需的结构

00:23:28.320 --> 00:23:32.000
所以我现在正在研究它的演示部分，在这里您可以连接一些

00:23:32.000 --> 00:23:35.280
网络的东西，以便我们可以通过网络来做这些

00:23:35.280 --> 00:23:38.320
查询，但即使对于这些通过网络进行的不信任查询，如果我

00:23:38.320 --> 00:23:41.200
只想知道一个特定的索引

00:23:41.200 --> 00:23:45.440
我要拉的只是该索引的数据，没有别的了

00:23:45.440 --> 00:23:50.400
然后我将其本地存储在缓存中，这真的非常好，等等。

00:23:50.400 --> 00:23:53.279
我花的时间越多，我意识到

00:23:53.279 --> 00:23:58.559
我们可以做很多事情，像是一些基本的sql东西，就像是的

00:23:58.559 --> 00:24:01.679
想要支持所有基本的sql功能并具有常规表和

00:24:01.679 --> 00:24:05.039
专栏和其他所有内容，但对于它来说，这将是微不足道的

00:24:05.039 --> 00:24:11.360
说哦，这是添加dag表的方法，而dag表的一部分是

00:24:11.360 --> 00:24:15.279
您想索引哪些路径，就像它们是列一样

00:24:15.279 --> 00:24:18.640
然后，您可以对这些内容执行常规的sql查询

00:24:18.640 --> 00:24:23.360
这些索引上的列，您将获得像

00:24:23.360 --> 00:24:25.679
执行时的某种SQL查询语言

00:24:25.679 --> 00:24:29.760
嗯，这真的是很酷的东西嗯，是的，我正在努力

00:24:29.760 --> 00:24:32.880
让事情变得更加精致和可演示um，然后

00:24:32.880 --> 00:24:36.720
从那里就像是敲打其余的部分

00:24:36.720 --> 00:24:39.600
正确的语法，例如我还没有alter table

00:24:39.600 --> 00:24:42.799
而且你知道我需要像这样的东西进行连接

00:24:42.799 --> 00:24:46.799
还有一些我需要实现的比较，但是um sql是

00:24:46.799 --> 00:24:51.120
查询语言非常好，例如您在哪里设置了一些查询语言

00:24:51.120 --> 00:24:53.679
不同语法功能和内容的组合实际上是

00:24:53.679 --> 00:24:57.279
很好理解和可预见的，所以它真的很好地融入了

00:24:57.279 --> 00:25:00.640
到查询语言的实现中，因此我可以让路更多

00:25:00.640 --> 00:25:05.919
进度比我想象的要快，现在它可以正常工作了

00:25:05.919 --> 00:25:09.760
它发现的一种有趣的东西就像

00:25:09.760 --> 00:25:13.600
这些高级数据结构中的争用

00:25:13.600 --> 00:25:17.440
在以流式方式进行操作或进行操作之间

00:25:17.440 --> 00:25:22.159
以完全并发的方式呃，你真的必须选择一个

00:25:22.159 --> 00:25:25.600
嗯，所以在大块的树实现中，例如

00:25:25.600 --> 00:25:30.640
嗯，让我正确的界面成为

00:25:30.640 --> 00:25:33.679
生成器，以便您执行变异操作

00:25:33.679 --> 00:25:37.279
然后该生成器将返回您并在所有新块上进行迭代，并且

00:25:37.279 --> 00:25:40.640
最后一个块是您所做的任何突变的新根

00:25:40.640 --> 00:25:44.880
嗯，但是我真的不得不为此而拒绝，因为

00:25:44.880 --> 00:25:48.159
嗯，当您进行大型突变操作时，您可以

00:25:48.159 --> 00:25:51.600
真正同时并行化图的每个部分和每个部分

00:25:51.600 --> 00:25:53.760
以及每一个像你树的每一部分

00:25:53.760 --> 00:25:56.480
像另一个并发向量一样工作

00:25:56.480 --> 00:25:59.520
但是为了像您一样干净地实现，您只需要使用递归

00:25:59.520 --> 00:26:02.000
您不能并行执行的并行功能

00:26:02.000 --> 00:26:06.000
将其完全映射到生成器um中，实际上发生了相同的事情

00:26:06.000 --> 00:26:09.200
读起来就像您可以做这些迭代读一样

00:26:09.200 --> 00:26:11.919
但实际上，采取

00:26:11.919 --> 00:26:16.559
整个清晰范围查询，然后在整个树上向下滑动

00:26:16.559 --> 00:26:18.640
um可接受的查询范围，然后

00:26:18.640 --> 00:26:21.600
只需将所有内容放到最后，这样您就可以使用更多的内存，但是

00:26:21.600 --> 00:26:25.760
它实际上在雅典SQL中很好用，我能够得到

00:26:25.760 --> 00:26:27.840
两全其美的有点像

00:26:27.840 --> 00:26:31.520
如果您考虑什么是表突变

00:26:31.520 --> 00:26:34.720
你基本上是在突变表上的行，这是稀疏的

00:26:34.720 --> 00:26:37.520
进行突变时，阵列会返回

00:26:37.520 --> 00:26:40.960
旧的值，然后您可以更新您可以

00:26:40.960 --> 00:26:43.919
基本上开始每个索引的更新，

00:26:43.919 --> 00:26:48.080
同时发生，所以我所拥有的就是这种突变

00:26:48.080 --> 00:26:52.159
上位变异操作是一个生成器，因此我做第一个变异

00:26:52.159 --> 00:26:57.520
我踢出那些块，然后作为所有并发索引突变

00:26:57.520 --> 00:27:02.159
返回我也会发出所有这些块嗯，所以它很客气

00:27:02.159 --> 00:27:04.559
世界上最好的一点点，我没有像疯了一样用光

00:27:04.559 --> 00:27:08.159
内存量，但就像您知道的那样

00:27:08.159 --> 00:27:11.679
尽可能多地同时进行所有操作

00:27:11.679 --> 00:27:13.520
是的，那就是那里的东西

00:27:13.520 --> 00:27:16.559
嗯，我认为我们完成通话后会私下通话

00:27:16.559 --> 00:27:19.760
嗯，我想谈谈我遇到的一些事情

00:27:19.760 --> 00:27:24.480
尝试将其连接到ipfs并点亮pdp um，但我们不会介入

00:27:24.480 --> 00:27:30.960
现在我们可以继续前进，下一个是谁

00:27:31.120 --> 00:27:34.720
克里斯，你可能是我，好吧，我去过。

00:27:34.720 --> 00:27:39.679
过去几周的假期，所以回到现在，实际上我现在的目标是

00:27:39.679 --> 00:27:43.360
使js工艺同步项目过渡到ipfs

00:27:43.360 --> 00:27:50.240
这周的车队，所以这是我的最新消息

00:27:50.240 --> 00:27:56.720
是的，很好，好吧，我们还有其他几件

00:27:56.720 --> 00:28:02.320
现在在议程上，所以第一个是我，我想丹尼尔，这是你的，嗯

00:28:02.320 --> 00:28:07.919
在64个IPLD素数的长度中，我们应该这样做吗，我会承认

00:28:07.919 --> 00:28:12.320
当我使用它的时候这很烦人，而且确实感觉到

00:28:12.320 --> 00:28:16.240
也许它应该只符合len

00:28:16.240 --> 00:28:19.600
使用，但您知道这还没有结束

00:28:19.600 --> 00:28:23.120
是的，所以实际上我有点改变了我的

00:28:23.120 --> 00:28:27.760
在过去的20分钟里，我只是在思考和思考自己的想法

00:28:27.760 --> 00:28:32.240
有时会发生，但是我最初的想法是，如果这些高级助手

00:28:32.240 --> 00:28:35.520
仅用于快速的事物或性能不高的事物

00:28:35.520 --> 00:28:39.840
头等大事然后结束可能就可以了，因为

00:28:39.840 --> 00:28:44.000
对于非常数，例如很常见的东西的长度

00:28:44.000 --> 00:28:47.919
它意味着更简单的代码，但同时我在想

00:28:47.919 --> 00:28:51.919
好吧，但我们也不想将这些用于实际

00:28:51.919 --> 00:28:57.120
诸如大目标之类的好目标，也泛滥成灾，这是沉默的，所以如果

00:28:57.120 --> 00:28:59.120
东西溢出了，这不是您会注意到的

00:28:59.120 --> 00:29:05.440
嗯，所以我在想是的，忘记我说了什么

00:29:07.200 --> 00:29:12.960
因此，请稍等，反面是用于非常数的更简单的代码，但是

00:29:12.960 --> 00:29:20.720
反对的要点是什么意思，如果我很高兴地使用

00:29:20.720 --> 00:29:23.840
包装程序带ins的高级助手不

00:29:23.840 --> 00:29:26.799
在64。然后突然我的代码使用了一些东西

00:29:26.799 --> 00:29:30.399
这是非常非常大的呃溢出会安静下来

00:29:30.399 --> 00:29:35.600
没有什么可以警告您的，那将是一个很大的不，

00:29:36.080 --> 00:29:39.360
而且您可能拥有相同的明确性论证

00:29:39.360 --> 00:29:45.120
至于其他任何地方的64，是的，即使用户知道

00:29:45.120 --> 00:29:48.159
他们在做什么，您想真正鼓励他们去做吗？

00:29:48.159 --> 00:29:52.480
将10倍以上用于bose的东西，只是因为它们实际使用了

00:29:52.480 --> 00:29:57.360
较大的节点，也没有太大意义

00:30:06.720 --> 00:30:13.679
好吧，我见到他是这样的东西，它会因使用而震动

00:30:13.679 --> 00:30:16.960
可能是人们抱怨很多的事情，或者是您对此感到恼火的事情

00:30:16.960 --> 00:30:20.480
通过大量使用它，因此您需要重新访问它

00:30:20.480 --> 00:30:25.120
喜欢暂时保留它，如果它很重要，请重新访问它

00:30:25.120 --> 00:30:29.840
使用中的烦恼我怀疑会适中

00:30:29.840 --> 00:30:34.240
烦人，因为使用了任何非

00:30:34.240 --> 00:30:40.880
go中未指定的int在语法上有一定程度的烦人，但我

00:30:40.880 --> 00:30:43.039
思考

00:30:43.440 --> 00:30:46.880
最糟糕的是，如果我们混合使用它们

00:30:46.880 --> 00:30:50.080
那真的是很高的认知开销，而且

00:30:50.080 --> 00:30:55.760
实在令人沮丧，因此要在64分范围内统一执行

00:30:55.760 --> 00:30:58.080
似乎是目前最安全的选择，而我

00:30:58.080 --> 00:31:01.360
有点怀疑，我们将不得不重新审视它

00:31:01.360 --> 00:31:07.120
可能会被认为是中度不幸的

00:31:07.120 --> 00:31:10.720
永远，但这将成为每次有人的其中一件事情

00:31:10.720 --> 00:31:14.880
看着它，然后再次评论，他们会像哦

00:31:14.880 --> 00:31:21.360
是的，这就是必须要解决的问题

00:31:21.360 --> 00:31:23.919
这里的空间，当有人会来时会说

00:31:23.919 --> 00:31:28.799
对于长度，您确实应该在64中使用您。

00:31:30.240 --> 00:31:34.960
只要您在类型中执行自定义int链接

00:31:35.120 --> 00:31:40.559
在那一个上，我认为人们四处走动，说了一堆话

00:31:44.240 --> 00:31:48.159
好吧，至少现在就保留它

00:31:50.240 --> 00:31:53.760
嗯，是的，只是关于int与您的注释，

00:31:53.760 --> 00:31:58.720
嗯，实际上去的原因是使用这些地方的联锁，不是

00:31:58.720 --> 00:32:02.320
因为像在c中一样，他们必须发出减去这样的信号

00:32:02.320 --> 00:32:08.640
但是因为溢出不是简单的，所以u端的溢出确实是

00:32:08.640 --> 00:32:12.000
在我们的电话上发生灾难性的后果，然后只给您

00:32:12.000 --> 00:32:14.960
负面的东西，什么也听不懂，一切都破了

00:32:14.960 --> 00:32:21.679
所以这是要牢记的事情，所以如果我们有任何事情就做

00:32:21.679 --> 00:32:28.480
长度大于n64

00:32:28.480 --> 00:32:31.519
我知道如果你有一个愚蠢的变化

00:32:31.519 --> 00:32:34.799
n64，您可以使用减号1绝对是无效的

00:32:34.799 --> 00:32:38.960
您在un-64中没有选择。

00:32:40.960 --> 00:32:46.640
好吧，我对此的观点是在某些时候这些东西变成了位串

00:32:46.640 --> 00:32:48.720
如果您担心实际数字

00:32:48.720 --> 00:32:51.919
这些边缘情况，您已经意识到这些

00:32:51.919 --> 00:32:55.360
是位字符串，您不再将它们视为数字了

00:32:55.360 --> 00:33:00.960
因此，如果那是您选择好的寿命，那么它是64位

00:33:00.960 --> 00:33:06.960
一点点的字符串，请享受我不在乎它是否为负，这是您的问题

00:33:06.960 --> 00:33:11.760
很好的说，这使我们完美地进入了下一个项目

00:33:11.760 --> 00:33:16.240
即ieee 754泄漏到数据模型中

00:33:16.240 --> 00:33:22.640
嗯，规格回购中有两个问题，三个呃

00:33:22.640 --> 00:33:26.000
这是非常有趣的一个，所以这就是你知道的

00:33:26.000 --> 00:33:29.200
754定义无穷负无穷大，然后

00:33:29.200 --> 00:33:34.480
就像有效的东西一样，当你有花车时就得到它们

00:33:34.480 --> 00:33:38.960
然后他们将其用于7x4，并且有一种二进制格式

00:33:38.960 --> 00:33:41.919
他们，所以C板也将其烘烤到规格中，

00:33:41.919 --> 00:33:47.519
所以我们的两个cbor编解码器都使用它们，它们免费给您提供，因此

00:33:47.519 --> 00:33:52.159
在去和在JavaScript中这些将做一个往返

00:33:52.159 --> 00:33:58.080
顺利且符合规格，所以这个问题始于有人说的很好

00:33:58.080 --> 00:34:03.120
我们可以将其添加到杰森吗，有一个建议像

00:34:03.120 --> 00:34:08.560
我们有字节和链接um，所以接下来的讨论是

00:34:08.560 --> 00:34:12.879
好吧，那么我们必须面对这个问题，

00:34:12.879 --> 00:34:17.119
说这是我们明确支持的东西吗

00:34:17.119 --> 00:34:21.599
是否只是通过支持ieee 754的编解码器免费获得的东西？

00:34:21.599 --> 00:34:28.960
以某种方式还是在其他空间中，所以我试图

00:34:28.960 --> 00:34:33.119
列出为此需要解决的各种问题

00:34:33.119 --> 00:34:37.119
我们今天不需要解决它，但是参与该问题将是一件好事

00:34:37.119 --> 00:34:40.560
但是如果有人有任何想法，他们想加入

00:34:40.560 --> 00:34:44.639
现在我们可以对此进行快速讨论

00:34:44.639 --> 00:34:49.760
我认为我同意埃里克的观点，我们应该拒绝他们

00:34:49.760 --> 00:34:56.720
就像他们是他们之间在语言之间的共识要少得多

00:34:56.720 --> 00:35:00.800
我们支持的任何其他事情只是让我感到非常痛苦

00:35:00.800 --> 00:35:05.359
尝试并与他们打交道，因为交叉

00:35:05.359 --> 00:35:08.720
格式无法正常工作，就像会有

00:35:08.720 --> 00:35:12.960
就像我们无法在json中做到这一点，所以除非我们想这样做，否则json不在了

00:35:12.960 --> 00:35:16.320
比我们已经拥有的更疯狂的类型自定义我们讨厌它

00:35:16.320 --> 00:35:20.000
所以我不认为我们想这样做

00:35:20.000 --> 00:35:23.599
但是我们有字节和链接的先例，这就是问题所在

00:35:23.599 --> 00:35:27.359
正在提议，所以并非不可能，只是

00:35:27.359 --> 00:35:31.920
杂乱无章的感觉就像您接受这些东西一样

00:35:31.920 --> 00:35:36.880
他们成为最高级的种类，但是每种语言都可以做到这一点

00:35:36.880 --> 00:35:39.680
具有无穷大和人类的一致类型

00:35:39.680 --> 00:35:43.359
尤其是男人，我会感到惊讶，就像我不认为每个

00:35:43.359 --> 00:35:49.200
语言有一个男人，我想是的，如果您支持754

00:35:49.200 --> 00:35:54.800
这些是这些烤成的，所以我想它们是和蛋糕一起来的

00:35:54.800 --> 00:36:01.920
每个人都兼容754可能不是很好，事实是，这是

00:36:01.920 --> 00:36:05.839
不是七五四就像我们现在说浮动时不那样

00:36:05.839 --> 00:36:09.040
我们不是说这是七五四就是这样

00:36:09.040 --> 00:36:13.680
碰巧在黑暗的锡伯尔号上有七，五，四的对齐方式

00:36:13.680 --> 00:36:15.920
那真的就是我们所处的地方

00:36:15.920 --> 00:36:19.839
这个重叠，所以就像这个维恩图，它主要是

00:36:19.839 --> 00:36:23.200
重叠，但是当我们可以采取时，我们可以全跳

00:36:23.200 --> 00:36:26.079
说好，当我们说浮动时，我们的意思是7x4

00:36:26.079 --> 00:36:29.359
或者我们可以说浮动的意思是这些东西

00:36:29.359 --> 00:36:35.599
在数字um中放一个点，就是这样，在

00:36:35.599 --> 00:36:39.200
编解码器发生在编解码器中[音乐]

00:36:39.200 --> 00:36:42.560
我们不建议您使用它们，这确实是我们需要得到的

00:36:42.560 --> 00:36:46.800
出来说看这是不推荐这些

00:36:46.800 --> 00:36:49.520
各种原因我的意思是有些格式像我们一样

00:36:49.520 --> 00:36:52.960
希望能够在不具有这些类型的ipld中使用

00:36:52.960 --> 00:36:59.599
嗯，就像json嗯，是的，如果我们知道那是一个问题，那么我

00:36:59.599 --> 00:37:05.440
说我们只是在他们身上unt，所以我也想放平

00:37:05.440 --> 00:37:11.200
阅读ieee 754 Nan的定义

00:37:11.200 --> 00:37:18.800
来自维基百科，因为它比您想象的还要糟糕

00:37:18.800 --> 00:37:25.359
符号位可以是零，也可以是一个，偏置指数必须全部为

00:37:25.359 --> 00:37:31.680
一位，但小数部分可以是任何东西，除了

00:37:31.680 --> 00:37:36.480
全零位，因为全零位将表示无穷大

00:37:36.480 --> 00:37:43.520
所以那里有多少按位不相等的值

00:37:43.520 --> 00:37:50.800
这是ieee 754 nan我不知道很多他妈的

00:37:50.800 --> 00:37:54.960
有多少是疯狂的

00:37:54.960 --> 00:38:01.920
我们可以做ipld吗？

00:38:01.920 --> 00:38:06.160
对索引键盘说“不”，仅用于确定诸如以下问题的决定因素

00:38:06.160 --> 00:38:11.440
就像我们不能让人们对于相同的数据使用不同的哈希值

00:38:12.640 --> 00:38:15.920
确实将其缩小到一个，但是只有一种方法可以做到这一点

00:38:15.920 --> 00:38:19.119
对，你可以有一个规范的代表

00:38:19.119 --> 00:38:22.720
他们这样做，虽然好吧，你听起来好像他们只是指着

00:38:22.720 --> 00:38:26.079
754并说那是我们的浮动，就像那是我们从那里得到人的地方

00:38:26.079 --> 00:38:30.480
而不是喜欢说哦，不，不，特别是男人，这只是

00:38:30.480 --> 00:38:37.520
二进制形式，是的，不，我认为754规范确实指定了

00:38:37.520 --> 00:38:41.440
位布局只是因为它与您的操作方式有关

00:38:41.440 --> 00:38:46.000
算术和所有类似的东西，而sibor

00:38:46.000 --> 00:38:49.200
归结为这三个特色菜

00:38:49.200 --> 00:38:52.880
这些是您将其编码为的字节

00:38:52.880 --> 00:38:58.720
从本质上来说好吧好吧，所以我认为它是合规的

00:38:58.720 --> 00:39:01.119
相当

00:39:02.160 --> 00:39:05.599
它没有我想像的那么恐怖，但是那仍然像

00:39:05.599 --> 00:39:09.119
我觉得那仍然像是我们没有的海港特色

00:39:09.119 --> 00:39:15.839
其他格式的事情要做

00:39:17.920 --> 00:39:20.960
也就像在哲学上和概念上一样

00:39:20.960 --> 00:39:25.040
可以序列化无限真的让我很烦

00:39:25.040 --> 00:39:28.640
就像我不知道我的大脑怎么样

00:39:28.640 --> 00:39:34.000
但不像那不是我们同意的真实事物

00:39:34.000 --> 00:39:39.200
我不知道你能写下来还不够吗

00:39:39.200 --> 00:39:43.200
我的意思是就像字符串无穷大一样

00:39:43.200 --> 00:39:47.760
一致性，就像无穷大一样，是概念上的数值

00:39:47.760 --> 00:39:51.440
只是不是嗯

00:39:51.520 --> 00:39:56.320
我想如果你坚持下去，那你最终会遇到同样的问题

00:39:56.320 --> 00:40:00.880
浮点数通常只编码浮点数

00:40:00.880 --> 00:40:06.319
出于很多原因，我觉得这些问题较少

00:40:06.319 --> 00:40:10.800
就像我们没有什么浮标的数学模型一样

00:40:10.800 --> 00:40:13.440
就像我们的浮点数计算模型有点怪异

00:40:13.440 --> 00:40:16.960
就像我们对他们和计算机进行数学运算的方式实际上很困难

00:40:16.960 --> 00:40:21.599
并不是像在数学上我们没有达成共识一样

00:40:21.599 --> 00:40:27.680
最好的方法来解决这个问题，好吧，好吧，迈克尔，您可能想要

00:40:27.680 --> 00:40:30.560
将您的投票投向那里的那个问题，以便我们可以

00:40:30.560 --> 00:40:34.960
我们可以朝着解决这个问题的角度

00:40:34.960 --> 00:40:39.280
听起来确实像iii倾向于

00:40:39.280 --> 00:40:44.480
呃，也许把它留在一个不确定的空间里，就像

00:40:44.480 --> 00:40:48.079
有可以做到这一点的法典，所以您不应该依赖但不会的法典

00:40:48.079 --> 00:40:54.240
你不应该依赖它，但是我你知道

00:40:54.240 --> 00:40:57.359
也许这是一个我们需要明确的地方，因为我们就像

00:40:57.359 --> 00:41:00.480
呃，你现在可以编码未定义

00:41:00.480 --> 00:41:06.880
在匕首js出租车球，但嗯，但去ipld总理和

00:41:06.880 --> 00:41:11.839
然后去吧dixie ball会在d代码上拒绝它，因为它不会

00:41:11.839 --> 00:41:14.160
知道它不知道该怎么办

00:41:14.160 --> 00:41:17.359
所以我们已经有了不确定的问题，我是我在

00:41:17.359 --> 00:41:19.920
修复过程中，我将拒绝undefined，因为您可以

00:41:19.920 --> 00:41:23.920
编码就可以了，但是在相似的地方

00:41:23.920 --> 00:41:27.280
你可以做这件事，但是也许你

00:41:27.280 --> 00:41:30.880
不应该这样，也许我们应该排除它，我也是

00:41:30.880 --> 00:41:34.240
就像我们倾向于谈论这些事情一样

00:41:34.240 --> 00:41:38.240
就像他们如何映射到现有的格式和语言，但是

00:41:38.240 --> 00:41:40.800
我们需要记住的另一件事是

00:41:40.800 --> 00:41:44.079
当我们建立更多本机格式时，这些对我们有何影响

00:41:44.079 --> 00:41:47.119
像ii一样认为我们将拥有更多的块格式

00:41:47.119 --> 00:41:50.160
就像我们前进的过程中的一些工程

00:41:50.160 --> 00:41:53.520
您知道他们对特定用例的定制要多得多

00:41:53.520 --> 00:41:58.160
而且您需要执行的事情越多，执行起来就越困难

00:41:58.160 --> 00:42:02.960
以及更多的bug区域，并且仅保留内容就具有一致性

00:42:02.960 --> 00:42:06.160
对我来说，较小而不是较大似乎更好，特别是当它们位于

00:42:06.160 --> 00:42:10.720
我们知道很难在以下方面进行兼容性

00:42:11.839 --> 00:42:15.359
同意，只要它不会对

00:42:15.359 --> 00:42:19.280
人们使用我们的东西的可能性

00:42:19.280 --> 00:42:22.319
如果不是在json中，我很难相信人们

00:42:22.319 --> 00:42:26.800
如此大量地使用它，对于我们来说，没有它是一个初学者

00:42:26.800 --> 00:42:31.440
是的，而且大多数情况下，这些值是它们始终被用作

00:42:31.440 --> 00:42:34.640
只是这些符号，您使用的这些标记

00:42:34.640 --> 00:42:37.599
对于某种情况下的边缘情况，你可以

00:42:37.599 --> 00:42:42.800
使用任何东西作为标记，例如使自己成为特殊的字符串，例如

00:42:45.119 --> 00:42:53.440
好吧，在我们停止录音之前，还有其他任何事情

00:42:53.440 --> 00:42:57.040
我在上面戳了一些东西

00:42:57.040 --> 00:43:03.520
你知道人们的休假时间，所以我向大家提到了

00:43:03.520 --> 00:43:07.760
前一阵子，但是我有能力

00:43:07.760 --> 00:43:13.359
基本上是通过下载来逐步下载大块的um

00:43:13.359 --> 00:43:16.640
如果是第二个，则向后退，如果是三个，则向后退，任何人都在使用射击

00:43:16.640 --> 00:43:20.079
三个，您可以使用一棵梅克尔树，但如果是一壳或两壳

00:43:20.079 --> 00:43:24.560
这是一个流式哈希，因此您可以向后下载它

00:43:24.839 --> 00:43:28.240
嗯，我当时在想的另一件事

00:43:28.240 --> 00:43:32.640
汉娜就这样提出了一个建议

00:43:32.640 --> 00:43:36.640
最近um围绕图同步和bitswap排序

00:43:36.640 --> 00:43:43.359
抓住基本上使用图同步来抓住呃

00:43:43.359 --> 00:43:48.640
抓取文件中所有块的清单，然后将其发送过来

00:43:48.640 --> 00:43:51.119
进行位交换，然后并行获取所有块

00:43:51.119 --> 00:43:56.319
从任何人那里，这正是我刚想出的我需要为ipsql做的事情

00:43:56.319 --> 00:43:59.440
实际上就像是使用rpc一样，但是

00:43:59.440 --> 00:44:02.880
从字面上看就像执行查询，然后告诉我所有

00:44:02.880 --> 00:44:05.440
块，你的核心需要，然后我会问

00:44:05.440 --> 00:44:11.040
对于那些我没有权利的人，你就是这样

00:44:11.040 --> 00:44:14.640
所以这很有趣，这能使我想起什么

00:44:14.640 --> 00:44:18.880
或向我指出是我的理解是短暂的

00:44:18.880 --> 00:44:23.359
曾经有过这样的束缚，那就是

00:44:23.359 --> 00:44:26.640
我们之所以拥有一个人的原因

00:44:26.640 --> 00:44:30.720
完全具有块大小，为什么具有块大小，原因

00:44:30.720 --> 00:44:33.280
它们的块大小为，因此您无需下载

00:44:33.280 --> 00:44:37.040
在意识到它是垃圾之前任意数量的垃圾

00:44:37.040 --> 00:44:43.119
但这是一个谎言，因为graphsync确实做到了，这是您唯一的方法

00:44:43.119 --> 00:44:46.480
如果我有线性历史记录或

00:44:46.480 --> 00:44:54.240
区块链或其他任何东西，如果我每次都必须走一个街区而没有协议

00:44:54.240 --> 00:44:57.119
在世界上，你可以写，这将使速度很快

00:44:57.119 --> 00:45:01.839
唯一有效的方法是如果我一次下载多个块

00:45:01.839 --> 00:45:05.440
当我有机会的时候我就验证他们

00:45:05.440 --> 00:45:09.920
对，如果您的管道速度比我的cpu快，那您就给我发送更多

00:45:09.920 --> 00:45:15.359
更多的垃圾，我对那个嗯没事，然后如果你对

00:45:15.359 --> 00:45:17.680
然后，您必须设置一些参数，例如

00:45:17.680 --> 00:45:21.680
多少垃圾还好吧，我愿意得到多少信任

00:45:21.680 --> 00:45:24.240
兆字节的信任是十亿字节的信任吗

00:45:24.240 --> 00:45:27.520
它是否根据您已经向我发送了100兆字节的事实进行扩展

00:45:27.520 --> 00:45:32.079
过去，这些是我不知道的事情

00:45:32.079 --> 00:45:36.880
我们就像位交换中最棘手的问题，因为这是不可能的

00:45:36.880 --> 00:45:39.839
我们只是被忽略了，就像图同步一样，它解决了我们所有的问题，

00:45:39.839 --> 00:45:45.119
像不，我们只是跳过了答案um，如果我们都参加的话，那很好

00:45:45.119 --> 00:45:47.839
接着就，随即

00:45:48.240 --> 00:45:54.000
并非如此，所以我想放松几件事，所以那个是

00:45:54.000 --> 00:45:58.960
在图同步请求中，确定性排序

00:45:58.960 --> 00:46:01.280
该请求，因此实际上存在确定性

00:46:01.280 --> 00:46:04.720
订购积木，因此，如果您一次获得一个积木，

00:46:04.720 --> 00:46:09.599
实际上可以一次验证他们，使他们需要收据

00:46:09.599 --> 00:46:11.760
因为你会因为你会问

00:46:11.760 --> 00:46:17.359
对他们来说肯定，但是当我只有时间去的时候我会收到10个街区

00:46:17.359 --> 00:46:21.760
验证第一个区块，所以我已经下载了九个区块

00:46:21.760 --> 00:46:26.000
在我意识到第一个区块不好之前，理论上是垃圾

00:46:26.000 --> 00:46:29.760
这仅仅是因为协议的实现方式

00:46:29.760 --> 00:46:33.200
不，你不能以不同的方式做到这一点，而要保持缓慢

00:46:33.200 --> 00:46:36.400
不，不，我可以在本地开始查询

00:46:36.400 --> 00:46:41.280
在我收到遥控器的任何响应之前，所以当第一个程序块出现时，我

00:46:41.280 --> 00:46:44.720
可以解码，我知道我的下一个块会得到什么

00:46:44.720 --> 00:46:48.079
就像从字面上同步我之前

00:46:48.079 --> 00:46:51.520
甚至要求下一个街区，也就是下一个街区到来的时间

00:46:51.520 --> 00:46:55.839
断开网络，如果这样，那么您实际上就是您

00:46:55.839 --> 00:47:00.319
应该永远不会在其中保留解码后的块

00:47:00.319 --> 00:47:04.960
像缓冲um一样，网络可能会有一点缓冲

00:47:04.960 --> 00:47:08.640
在您处理其中一些内容时继续，但是就像在代码中一样，如果可以的话

00:47:08.640 --> 00:47:11.920
从字面上看是不是就像我在要求之前得到一个方块一样

00:47:11.920 --> 00:47:15.920
无效并终止连接，您无法执行该操作的原因是

00:47:15.920 --> 00:47:18.319
图形同步的实现方式如

00:47:18.319 --> 00:47:21.520
用于不同控制流的单独流，以及

00:47:21.520 --> 00:47:25.040
嗯，以及您必须将其包装在自身之上的方式

00:47:25.040 --> 00:47:28.559
就像从字面上看它只是抗拒流

00:47:28.559 --> 00:47:32.880
就像没有办法喜欢设置流控制一样，让我知道我是否

00:47:32.880 --> 00:47:36.240
需要阻止它，您实际上只需推迟所有操作

00:47:36.240 --> 00:47:39.599
就像那样，这就是为什么它以这种方式实现的原因，这就是为什么我们

00:47:39.599 --> 00:47:42.559
有这个问题，但从理论上讲，您不应该有这个问题

00:47:42.559 --> 00:47:44.720
如果协议设计得更好，就会出现问题

00:47:44.720 --> 00:47:48.640
您将永远不会保留一个块和缓冲区

00:47:48.640 --> 00:47:52.880
我的意思是说这不是真的，尽管像想象中的那样，我每个人有100艾字节

00:47:52.880 --> 00:47:56.079
第二个管道，我正在运行图形同步

00:47:56.079 --> 00:48:01.440
ti-83上的程序我将收到比我更多的数据

00:48:01.440 --> 00:48:05.599
就像从根本上一样，及时地进行处理

00:48:05.599 --> 00:48:09.280
这不会像观看整个控件那样持续

00:48:09.280 --> 00:48:12.480
整个控制流程好吧，您可以将100兆字节放入网络

00:48:12.480 --> 00:48:16.319
驱动程序好了，网络驱动程序像发送思科

00:48:16.319 --> 00:48:20.480
嗯，就像嘿，我这里有数据，您的程序将数据从

00:48:20.480 --> 00:48:25.280
网络并解码第一个块，现在它将第一个块交给您

00:48:25.280 --> 00:48:29.599
当您解码第一个块时，您将该块同步解码为

00:48:29.599 --> 00:48:32.800
c杆遍历它，您知道您的下一个块是什么

00:48:32.800 --> 00:48:36.800
你开始你的下一个障碍进入它就像某种推迟未来

00:48:36.800 --> 00:48:40.160
模式说像在处理之前给我这个

00:48:40.160 --> 00:48:43.440
您有能力处理下一个程序段

00:48:43.440 --> 00:48:46.800
但是就像你真的在

00:48:46.800 --> 00:48:49.200
流式处理块并将其生成到程序中

00:48:49.200 --> 00:48:52.960
当它们从缓冲区中流出时，您确实会终止

00:48:52.960 --> 00:48:55.359
在这样的状态下，网络驱动程序可能是

00:48:55.359 --> 00:48:58.880
缓冲很多垃圾，但是程序的内存却没有

00:48:58.880 --> 00:49:02.880
您实际上可以，如果您有控制流程，则可以执行此操作

00:49:02.880 --> 00:49:06.000
我们打破了控制流程，所以这对于我们的任何程序都是不正确的

00:49:06.000 --> 00:49:09.920
所以您基本上可以忽略我在说什么，但是就像如果我们做对了

00:49:09.920 --> 00:49:13.040
这不会像您可以做到的那样，并且

00:49:13.040 --> 00:49:17.599
并补充说我们有限制的原因不是因为

00:49:17.599 --> 00:49:23.040
嗯，一般来说，垃圾是这样，以便您可以在单个块中进行散列

00:49:23.040 --> 00:49:26.559
您可以在限定时间内拉出链接

00:49:26.559 --> 00:49:30.319
因为否则，我发送给您的第一个数据块可能是PB的

00:49:30.319 --> 00:49:33.839
数据，你永远不知道讨论在哪里

00:49:33.839 --> 00:49:36.640
但是那是什么

00:49:37.280 --> 00:49:44.559
这些东西是相关的，对的，你是的，但是它们是完全不同的。

00:49:44.559 --> 00:49:47.920
我认为这不像你让它们那么独特

00:49:47.920 --> 00:49:52.800
因为您的网络喜欢

00:49:54.160 --> 00:49:58.000
我的机器正在下载数据，越来越像

00:49:58.000 --> 00:50:02.960
它正在通过我的路由器，这是昂贵的部分

00:50:02.960 --> 00:50:09.280
不是在我身边害羞，而是

00:50:09.280 --> 00:50:12.960
好，但是您的路由器将开始丢弃它们

00:50:12.960 --> 00:50:16.880
当实际硬件水平上有足够的背压时

00:50:16.880 --> 00:50:21.440
甚至是utp是的，最终是，最终，区块将开始

00:50:21.440 --> 00:50:25.839
将开始向右下降，但是那是恒定的对，所以在那里

00:50:25.839 --> 00:50:29.599
是一个常数，这就是我愿意浪费多少垃圾

00:50:29.599 --> 00:50:32.559
在一切崩溃之前下载

00:50:32.559 --> 00:50:36.960
我们假设我们可以在软件中进行设置，只说一个兆

00:50:36.960 --> 00:50:42.640
但是就像不是很正确，是的，一机不

00:50:42.640 --> 00:50:45.280
其次保护您的网络保护您的网络

00:50:45.280 --> 00:50:48.880
呃你的进程存储空间就是它的作用

00:50:48.880 --> 00:50:52.160
是的，是的，所以如果您想这样做

00:50:52.160 --> 00:50:55.359
如果您选择在下载整个PB时执行此操作，但是您

00:50:55.359 --> 00:51:00.079
向后下载它，您可以逐步设置您的内存

00:51:00.079 --> 00:51:05.440
事情仍然是一个兆，你仍然下载整个事情

00:51:05.440 --> 00:51:08.400
因为就像图同步一样

00:51:08.400 --> 00:51:13.200
提前信任以获取大量数据，但随后您

00:51:13.200 --> 00:51:18.400
进行验证时，您可以对此做同样的事情，因此

00:51:18.400 --> 00:51:22.800
几件事情，就像嗯，我同意你这样

00:51:22.800 --> 00:51:26.079
特定的事情并不能做到这一点，这就是我们所说的

00:51:26.079 --> 00:51:29.040
嗯，但还有很多其他的东西

00:51:29.040 --> 00:51:33.680
就像很多解码器是串行工作的一样，所以您想要一些

00:51:33.680 --> 00:51:36.480
块大小可能不是兆字节，而是一些块大小

00:51:36.480 --> 00:51:39.839
嗯，实际上有很多理由要保持小块

00:51:39.839 --> 00:51:42.720
像所有这些数据一样，在所有这些权利的外部保持较小的块

00:51:42.720 --> 00:51:45.440
我们一直在变异的结构，就像我们实际上想要保留的结构一样

00:51:45.440 --> 00:51:48.880
块大小相当小，这样我们就可以减少突变

00:51:48.880 --> 00:51:52.559
因此，就协议设计而言，我们始终会

00:51:52.559 --> 00:51:56.000
需要一种有效的方法来像许多块一样高效

00:51:56.000 --> 00:51:59.280
恩，即使我们从其他一些东西中脱颖而出

00:51:59.280 --> 00:52:04.640
最后，我喜欢将它们向后移动的想法，以便您可以流式传输

00:52:04.640 --> 00:52:07.920
d代码，但您却需要这样做

00:52:07.920 --> 00:52:13.200
您在将内存写入副本之前先吃了一个内存副本来反转缓冲区

00:52:13.200 --> 00:52:15.839
套接字，所以您要多吃点内存

00:52:15.839 --> 00:52:18.400
复制您要发送的每个块

00:52:18.400 --> 00:52:21.760
使用任何依赖于它们的协议，然后当您

00:52:21.760 --> 00:52:25.359
得到它们，当您重新组装它时，您将不得不做另一个内存复制

00:52:25.359 --> 00:52:33.040
无论哪种方式，所以我在想的是你会

00:52:33.040 --> 00:52:36.319
因此，接下来的事情就是如果您假设您可以

00:52:36.319 --> 00:52:40.800
有大块你可能会说是有一个

00:52:40.800 --> 00:52:44.240
在很常见的情况下，您可以通过多种方式

00:52:44.240 --> 00:52:48.240
描述相同的数据，其中一个作为一个大块

00:52:48.240 --> 00:52:53.920
其他的像一棵小块的树，就像文件一样

00:52:53.920 --> 00:53:00.880
这样我就可以将文件数据存储为一系列小的数据

00:53:00.880 --> 00:53:03.599
块，所以我下载了我下载的块

00:53:03.599 --> 00:53:09.280
你知道一个TB的块向后像小块一样全部存在于我的

00:53:09.280 --> 00:53:14.960
块存储个别作品，但后来我把它们串在一起

00:53:14.960 --> 00:53:20.400
元数据，所以我可以说，哦，我有这个文件

00:53:20.400 --> 00:53:24.079
它以这种特定方式进行了分块，但是您也可以将文件作为一个文件

00:53:24.079 --> 00:53:27.359
阻止，这意味着如果有人请求

00:53:27.359 --> 00:53:32.400
从我的文件作为一个整体，这可以正常工作，所以我可以去规范

00:53:32.400 --> 00:53:37.599
网站找到ubuntu iso的sha 256

00:53:37.599 --> 00:53:41.599
在ipfs上搜索它，有人可以将其发送给我

00:53:41.599 --> 00:53:45.280
因为有一种方法可以确定性地偏离这一点

00:53:45.280 --> 00:53:50.240
对我来说很大的障碍，甚至可以并行执行

00:53:50.240 --> 00:53:53.599
我的意思是不是那种汽车文件是什么样的

00:53:53.599 --> 00:53:56.960
标头中有多余的东西，但这基本上是汽车文件

00:53:56.960 --> 00:54:03.119
除了标识符是这个标识符，就像每个人一样

00:54:03.119 --> 00:54:05.920
已经同意

00:54:08.319 --> 00:54:14.559
好吧，但对于您来说，您的ubuntu iso希望事先同意更改帽数

00:54:14.559 --> 00:54:17.440
以相同的方式是不，没有分块

00:54:17.440 --> 00:54:20.960
这就是这个的一部分所以是零

00:54:20.960 --> 00:54:24.559
施工中零碎裂的原因是其中的两个

00:54:24.559 --> 00:54:28.800
整个文件是的，但是对于人们来说，

00:54:28.800 --> 00:54:33.680
安全地将其流式传输给您，以便我实际上可以选择

00:54:33.680 --> 00:54:38.480
作为客户，我可以要求您以我想要的任何方式将其流式传输给我

00:54:38.480 --> 00:54:43.280
例如，我可以说我希望您开始向我发送一些小片段

00:54:43.280 --> 00:54:46.799
然后，当我更加信任您时，我想开始向您发送更大的作品

00:54:46.799 --> 00:54:54.880
就像我愿意的话，可以选择建筑，所以您几乎想发送

00:54:54.880 --> 00:55:01.839
作为客户的检查策略，您知道提供者将

00:55:01.839 --> 00:55:04.880
以这种方式检查并发送回给您，是的

00:55:04.880 --> 00:55:08.319
那会很好，但我不知道我们是否在那里，所以

00:55:08.319 --> 00:55:10.720
不是我什至不认为这是

00:55:10.720 --> 00:55:14.640
那样，我的意思是要实现这一目标您需要做的事情

00:55:14.640 --> 00:55:19.359
对，添加文件时您需要一种方法吗

00:55:19.359 --> 00:55:23.760
当您添加时，如果您知道将文件添加到ipfs，则需要存储

00:55:23.760 --> 00:55:29.119
第二个dag权限，或者是第二个类似的元数据排序

00:55:29.119 --> 00:55:31.359
说的东西嘿，这是我串时的哈希

00:55:31.359 --> 00:55:36.880
所有这些都在一起，这是交给他们的作品清单

00:55:36.880 --> 00:55:40.720
然后我将需要bitswap知道它可以要求像虚拟

00:55:40.720 --> 00:55:44.240
对象，我的意思是，它不能正常工作

00:55:44.240 --> 00:55:48.319
突变，但哦，不，突变很烂，但是有很多

00:55:48.319 --> 00:55:50.640
我们实际上并未变异的大量数据

00:55:50.640 --> 00:55:56.000
嗯，并不是说您仍然可以将其存储为图形，因为

00:55:56.000 --> 00:55:59.680
事物底部的各个部分

00:55:59.680 --> 00:56:04.480
只是它的一种形式，我仍然可以将它们拼凑起来，但是我

00:56:04.480 --> 00:56:08.880
想要这样，但我虽然没用，但多么没用

00:56:08.880 --> 00:56:12.720
因为如果您拥有文本数据，则要使用

00:56:12.720 --> 00:56:16.240
理想情况下，您想要使用诸如raven之类的分块器

00:56:16.240 --> 00:56:20.559
在变好的地方获得更好的语义

00:56:20.559 --> 00:56:24.079
当您拥有的数据格式实际上是二进制格式，而没有

00:56:24.079 --> 00:56:28.000
很好地变异，您可能想要特定的数据类型

00:56:28.000 --> 00:56:32.799
它像这样已经被分块了

00:56:32.799 --> 00:56:36.720
分成块，您将基本上按照自己的方式获得公牛块

00:56:36.720 --> 00:56:39.839
想要查找文件或将其交给解码器

00:56:39.839 --> 00:56:43.280
就像是视频文件一样，您希望它围绕关键帧边界，因为

00:56:43.280 --> 00:56:46.319
就像每个人永远需要的单元

00:56:46.319 --> 00:56:49.119
嗯，或可能像您在

00:56:49.119 --> 00:56:52.160
某些zip文件和类似的内容，例如，您实际上可以弹跳起来，

00:56:52.160 --> 00:56:55.760
如果将它适当地分块，请寻找并执行它

00:56:55.760 --> 00:56:59.440
因此，就像许多这些格式实际上只是具有理想的分块器一样，您会

00:56:59.440 --> 00:57:05.760
想无论如何都要确保自己做到这一点，所以您想在这里占便宜

00:57:05.760 --> 00:57:09.359
就像向后兼容

00:57:09.359 --> 00:57:13.839
互联网对每个哈希文件的人都可以

00:57:13.839 --> 00:57:16.400
现在只需在ipfs上搜索哈希，看看是否

00:57:16.400 --> 00:57:21.599
找到它，另一个是我现在可以

00:57:21.599 --> 00:57:25.760
喜欢改变我的块，而不是整个场景

00:57:25.760 --> 00:57:28.480
仍然会有一个操作，也许还有一个最佳的分块器，我们将

00:57:28.480 --> 00:57:32.079
仍然能够像您知道的那样共享包含

00:57:32.079 --> 00:57:36.880
有块状图的图形，但是有一个规范的表示

00:57:36.880 --> 00:57:41.920
对于文件，我的意思是我们应该只将哈希值放进去

00:57:41.920 --> 00:57:46.480
无论如何，整个文件在元数据中的位置就像

00:57:46.480 --> 00:57:50.640
没有理由不让我们拥有它，因为这是一件很有用的事情

00:57:50.640 --> 00:57:55.040
如果您想与其他呃文件进行比较，例如

00:57:55.040 --> 00:57:57.440
不安全，就像长度不安全一样

00:57:57.440 --> 00:58:01.839
就像人们可以伪造它，但就像我们已经有先例一样

00:58:01.839 --> 00:58:04.400
就像我们已经拥有另一个拥有

00:58:04.400 --> 00:58:11.119
因此，但这并不能帮助我正确找到它，下载它不是，不是吗？

00:58:11.119 --> 00:58:14.079
像您一样，但是您只是在DHT中记录了一个

00:58:14.079 --> 00:58:17.280
然后像人们找到你一样，他们走了，嘿，你有没有与

00:58:17.280 --> 00:58:19.599
哈希，然后转到是，然后将其流式传输给他们

00:58:19.599 --> 00:58:22.640
然后您下载了TB的数据，然后又不知道它是正确的

00:58:22.640 --> 00:58:25.520
喜欢你需要这个你需要你喜欢这种方式

00:58:25.520 --> 00:58:28.240
确认您没有下载无限量的垃圾

00:58:28.240 --> 00:58:32.480
对，就像固定的数量

00:58:33.119 --> 00:58:37.920
然后问题就变成了您要发行哪个现金，总是和56聊天？

00:58:37.920 --> 00:58:42.640
是的，它总是总是与256聊天。就像那样

00:58:42.640 --> 00:58:44.559
每个人都有我的意思是那是我会说的

00:58:44.559 --> 00:58:48.240
像这样，这就是ipfs默认权限，这样您就可以

00:58:48.240 --> 00:58:52.400
规范的事情，如果每个人都决定您知道ipfs是否也被射击，然后

00:58:52.400 --> 00:58:57.599
后来我们切换到像您知道sha64然后

00:58:57.599 --> 00:59:00.640
所有人突然开始使用264镜头作为发布

00:59:00.640 --> 00:59:02.960
规范的，因为那是规范的

00:59:02.960 --> 00:59:07.359
现在每个人都在使用，每个人都可以帮助我们每个人

00:59:07.359 --> 00:59:09.520
解锁已经发布了Unix惊喜

00:59:09.520 --> 00:59:15.040
布雷克，所以你知道哦，是的，这次对话也让我想起

00:59:15.040 --> 00:59:17.040
我应该提出一些疯狂的东西

00:59:17.040 --> 00:59:20.480
嗯，这就像非常早期的阶段

00:59:20.480 --> 00:59:24.000
基本上是我的一个朋友，他从事许多Web标准工作，而我们已经与之联系了

00:59:24.000 --> 00:59:26.400
因为他开始从事一些类似的工作

00:59:26.400 --> 00:59:31.680
在我们所处的空间里，他本质上想做的是

00:59:31.680 --> 00:59:35.839
他希望使浏览器中的捆绑程序性能更好

00:59:35.839 --> 00:59:39.839
嗯，这样您就可以像同步捆绑包一样

00:59:39.839 --> 00:59:42.960
捆绑中已更改的部分种类，因此捆绑中维护了一些

00:59:42.960 --> 00:59:46.000
了解来自什么文件以及类似的东西

00:59:46.000 --> 00:59:49.680
并通过基本添加很多来做到这一点

00:59:49.680 --> 00:59:53.359
像um代码一样创建捆绑包的工具

00:59:53.359 --> 00:59:56.799
以及浏览器，并具有某种传输方式，并且介于两者之间

00:59:56.799 --> 01:00:00.720
很简单，保持不变，但就像

01:00:00.720 --> 01:00:02.960
我们有点像他降落的东西一样哦

01:00:02.960 --> 01:00:06.799
是的，这就是默克尔树的用途，很明显，就像您一样

01:00:06.799 --> 01:00:09.359
当您想进行这种结构时，可以用一颗梅克尔树来做

01:00:09.359 --> 01:00:12.400
所以我们一直在围绕一些想法打球，但是就像

01:00:12.400 --> 01:00:16.240
我认为可能会结束的一个地方是

01:00:16.240 --> 01:00:19.359
在某个时候可能有某种清单文件，所以像

01:00:19.359 --> 01:00:23.599
捆扎机可以非常轻松地进行后处理，我认为我们应该

01:00:23.599 --> 01:00:29.200
可能能够创建首个编解码器

01:00:29.200 --> 01:00:35.359
对于那个清单，它将浮现一个数据模型表示，

01:00:35.359 --> 01:00:38.720
符合我们想要cp2的unix

01:00:38.720 --> 01:00:42.079
所以这些字面上可能像这些清单一样可以是有效文件，并且所有

01:00:42.079 --> 01:00:46.160
链接，然后是到文件um其余部分的哈希链接

01:00:46.160 --> 01:00:48.559
并且我们想有效地喜欢用什么来打断

01:00:48.559 --> 01:00:53.359
浏览器正在遍历编解码器层，因为它们不会完全一样

01:00:53.359 --> 01:00:59.359
Unix fs像他们不能um这样的事情之一

01:00:59.359 --> 01:01:05.599
就像当我提起这个东西时一样

01:01:05.599 --> 01:01:10.079
几个月前

01:01:10.079 --> 01:01:14.319
我担心的事情就像我不知道该如何形容

01:01:14.319 --> 01:01:19.359
这些对象um这样下载文件向后对象

01:01:19.359 --> 01:01:22.960
所以这种方法说就像

01:01:22.960 --> 01:01:26.720
不在乎它像ipld一样在乎它像网络一样

01:01:26.720 --> 01:01:34.079
确实避开了很多运输物

01:01:34.079 --> 01:01:36.960
这些问题，但是它带有它自己的东西

01:01:36.960 --> 01:01:40.240
意味着突然间，像bitswap一样必须知道如何

01:01:40.240 --> 01:01:43.520
分手两件事，它必须知道如何分手

01:01:43.520 --> 01:01:47.599
对于每个哈希函数，只需要一枪

01:01:47.599 --> 01:01:50.720
我只是做了一个新的协议，就像我不会尝试

01:01:50.720 --> 01:01:54.240
不管我不在乎，不管你叫什么协议，我都不知道

01:01:54.240 --> 01:01:57.359
是的，我是说位交换就像不喜欢

01:01:57.359 --> 01:02:00.720
像那样难以令人失望的权利

01:02:00.720 --> 01:02:06.799
嗯，一旦您开始添加如此多的可选项（如易用性）

01:02:06.799 --> 01:02:10.559
消失了，这好像不是真的有用，我的意思是说公平

01:02:10.559 --> 01:02:14.319
一点交换就像是一个琐碎的协议

01:02:14.319 --> 01:02:17.920
所有会话内容，所以如果您可以从中提取会话

01:02:17.920 --> 01:02:21.440
bitswap然后bitswap就像是12行

01:02:21.440 --> 01:02:25.440
代码我的意思是它说我已经封锁了，请给我

01:02:25.440 --> 01:02:28.240
阻止所有的情报都在

01:02:28.240 --> 01:02:31.599
会话数，因此无论您想称其为什么

01:02:31.599 --> 01:02:37.039
就在这里是带有选项的protobuf，请将数据发送给我protobuf，

01:02:37.039 --> 01:02:40.480
只是希望我拥有一个可以处理您正在说的事情的图书馆

01:02:40.480 --> 01:02:43.920
像这样，在javascript中实际上不是你可以做的事情

01:02:43.920 --> 01:02:46.799
你不能使用bitsoft吗

01:02:46.799 --> 01:02:50.000
实施而无需承担所有基础架构的任务

01:02:50.000 --> 01:02:53.280
或类似基础架构的一半，尽管js bitswap没有

01:02:53.280 --> 01:02:56.160
会议，所以我不明白，不，不是

01:02:56.160 --> 01:02:59.280
就像您要进入大商店并且要互动一样

01:02:59.280 --> 01:03:01.760
就像不喜欢，不喜欢

01:03:01.760 --> 01:03:04.720
这是一个街区告诉我，当您被要求输入街区时，就像没有

01:03:04.720 --> 01:03:08.079
像这样的界面，就像您不遵守我们一样

01:03:08.079 --> 01:03:11.200
块存储抽象，然后将块存储连接到这个东西

01:03:11.200 --> 01:03:16.799
好的，是的，本次讨论的另一部分是

01:03:16.799 --> 01:03:21.839
我见过抛出几次是我们可以拥有这些自定义分块器吗

01:03:21.839 --> 01:03:25.520
作为webrtc或打包的wasom模块

01:03:25.520 --> 01:03:30.000
与数据，因此数据以某种方式链接到其

01:03:30.000 --> 01:03:33.839
自己的解码器，现在您有了通用解码器

01:03:33.839 --> 01:03:36.880
而不是需要预先定义

01:03:36.880 --> 01:03:41.520
在您的标准库中设置了实际上更多的流，以实现灵活性

01:03:41.520 --> 01:03:43.440
不良的布局，您不需要编码器，而您需要

01:03:43.440 --> 01:03:47.119
编码器基本上可以提前告知它有什么问题

01:03:47.119 --> 01:03:53.920
它的根cad的优势是什么，这是我的意思，是的

01:03:53.920 --> 01:03:58.319
显然喜欢，如果您知道该怎么做，如果您知道如何进行分块

01:03:58.319 --> 01:04:02.319
那样很好，但是你要把块放在哪里，就像

01:04:02.319 --> 01:04:07.039
你会用你的孩子分发它，为什么

01:04:07.039 --> 01:04:11.200
为什么我不不你，你只是在数据根源上链接到它

01:04:11.200 --> 01:04:15.359
是的，它只是说这是如何解码奇数数据文件的其余部分

01:04:15.359 --> 01:04:18.079
对，所以就像使它真正有用的事情之一，就像

01:04:18.079 --> 01:04:20.880
说是说是拉宾吧，说只是乌鸦块

01:04:20.880 --> 01:04:24.960
并进行一些设置um（如果这是我文件的根目录）

01:04:24.960 --> 01:04:27.359
呃，如果我是，如果我从你那里拿走了那个文件，我

01:04:27.359 --> 01:04:32.000
变异它，我知道如何理想地重新组合它，而我实际上拥有该程序

01:04:32.000 --> 01:04:34.960
重新打包它，而您不知道包括那些外部

01:04:34.960 --> 01:04:40.400
依赖或其他任何东西，但是一旦我们到达那里

01:04:40.400 --> 01:04:44.160
想到有与之相关的代码

01:04:44.160 --> 01:04:50.480
内容已经是您可以想象的想法，而不是

01:04:50.480 --> 01:04:52.480
说好吧，我们将拥有以下的元数据

01:04:52.480 --> 01:04:57.760
整个文件的镜头256。是这个额外的字段，也许我们会有

01:04:57.760 --> 01:05:01.039
dht中的那些您可以具有任意标识符

01:05:01.039 --> 01:05:07.520
关于与他们相关联的格式的一些事情

01:05:07.520 --> 01:05:10.640
这样你知道的时候

01:05:10.640 --> 01:05:16.880
您正在寻找256的ubuntu

01:05:16.880 --> 01:05:21.599
到是具有该射门的清单256

01:05:21.599 --> 01:05:28.480
嗯，还有像验证器这样的代码，可以帮助您精打细算

01:05:28.480 --> 01:05:33.440
根据该格式解码um并给您一些验证，

01:05:33.440 --> 01:05:37.039
编码，因为您需要的是

01:05:37.039 --> 01:05:41.039
可验证的权利，所以密钥与下载

01:05:41.039 --> 01:05:44.079
向后移动，并且您可以像往常一样将块移动一点，但是

01:05:44.079 --> 01:05:48.400
像这样的关键是我可以告诉你我想要的

01:05:48.400 --> 01:05:50.400
数据，然后您以某种方式将其发送回给我

01:05:50.400 --> 01:05:54.640
我可以验证正确，因此拥有所有的清单

01:05:54.640 --> 01:05:59.039
除非清单出现，否则方块并不能真正帮助我

01:05:59.039 --> 01:06:02.799
它看起来就像我期望的形式

01:06:02.799 --> 01:06:06.640
然后我就可以开始下载块并逐点验证它们

01:06:06.640 --> 01:06:12.799
但我无法验证它们的存在，就像它们存在一样。

01:06:12.799 --> 01:06:17.359
想知道这里是否没有紧凑而有效的

01:06:17.359 --> 01:06:20.880
验证可以链接到的零知识证明

01:06:20.880 --> 01:06:24.799
东西，以便您还可以提供两个sha-256的证明

01:06:24.799 --> 01:06:28.799
等价于是

01:06:31.119 --> 01:06:34.799
在不获取整个元数据块的情况下进行翻译

01:06:34.799 --> 01:06:39.039
以一种有效的方式，并跳过所有原始讨论

01:06:39.039 --> 01:06:42.559
是的，院长，我想您确实忘记了这里的一个重要观点，那就是

01:06:42.559 --> 01:06:45.680
就像如果您有一个非常大的文件，并且您

01:06:45.680 --> 01:06:49.039
只需拍摄其中的两个镜头，您就可以验证整个文件是否倒退

01:06:49.039 --> 01:06:52.400
无论您如何获得这些块，但前提是您只能从一个块中获取它们

01:06:52.400 --> 01:06:55.920
聚会，您将无法真正有效地从多个聚会中获取他们

01:06:55.920 --> 01:06:58.960
派对，因为你只能因为你只能使一个人无效

01:06:58.960 --> 01:07:01.599
当您向后移动时一次

01:07:01.599 --> 01:07:05.119
就是这个原因，这就是图同步的原因，但是就像图一样

01:07:05.119 --> 01:07:08.720
同步我们已经存在的知识或理解

01:07:08.720 --> 01:07:11.200
采取额外的块进来这就是我

01:07:11.200 --> 01:07:14.240
设置我愿意下载的参数

01:07:14.240 --> 01:07:20.880
一次正确放置10块垃圾，然后我可以并行操作，我可以问一下吗

01:07:20.880 --> 01:07:25.680
你知道我要为下一个100个街区提供清单，然后我只是

01:07:25.680 --> 01:07:30.160
一次向我周围的每个人射击10

01:07:30.160 --> 01:07:33.920
是的，我的意思是，随着时间的流逝，我越来越多

01:07:33.920 --> 01:07:38.240
我所相信的会越来越多地表现出来，因为前一百个区块看起来

01:07:38.240 --> 01:07:41.039
很好，为什么接下来的一百个块看起来不好

01:07:41.039 --> 01:07:46.640
所以我记得很多这样的讨论都是在bittorrent中发生的

01:07:46.640 --> 01:07:50.400
该协议仍在设计之中，就像很多这类东西一样

01:07:50.400 --> 01:07:52.400
出现了，您可以进行很多优化，

01:07:52.400 --> 01:07:56.559
人们做过的很多实验，而且喜欢在哪里我都不记得所有的实验

01:07:56.559 --> 01:07:58.480
确切的理由，如果它仍然是公关

01:07:58.480 --> 01:08:02.000
生活，所以也许它已经过时了，我们应该重新评估它，但就像

01:08:02.000 --> 01:08:06.079
我确实记得这种普遍的学习，就是

01:08:06.079 --> 01:08:09.280
看看是否让方块变小而又变小

01:08:09.280 --> 01:08:13.520
只是验证单位，其他所有内容都变得更加容易

01:08:13.520 --> 01:08:17.199
并尝试执行低于该验证的任何操作或尝试增加

01:08:17.199 --> 01:08:19.759
验证您最终会经历所有其他漫长的事情

01:08:19.759 --> 01:08:22.239
尾巴问题，特别是一旦您受到攻击

01:08:22.239 --> 01:08:24.799
我的意思是这也是另一件事，就像很多东西开始发生一样

01:08:24.799 --> 01:08:28.319
随着网络越来越受到攻击，这一点变得越来越重要，

01:08:28.319 --> 01:08:30.799
人们试图做负面的事情，

01:08:30.799 --> 01:08:33.839
先给你一些好方块，然后再给你坏方块和类似的东西

01:08:33.839 --> 01:08:37.600
就像您知道自己一样，您曾经拥有过npa和其他演员

01:08:37.600 --> 01:08:40.319
故意试图让您知道网络有毒

01:08:40.319 --> 01:08:44.400
嗯，是的，是的，虽然

01:08:44.400 --> 01:08:47.600
一切就像我们会说像权衡取舍一样，也许如果我是

01:08:47.600 --> 01:08:51.199
愿意说好吧，我会像几何增长一样做，

01:08:51.199 --> 01:08:55.600
如果有人积极地攻击我，我愿意让我的一半障碍变坏

01:08:55.600 --> 01:08:58.960
必须先给我一半我想要的文件，然后他们才能发送给我

01:08:58.960 --> 01:09:03.199
等量的坏位我不知道我的意思是如果你从

01:09:03.199 --> 01:09:04.880
文件硬币的角度来看，就像

01:09:04.880 --> 01:09:08.080
您正在使用增量付款渠道，所以您会像这样糟糕地撕裂

01:09:08.080 --> 01:09:12.480
块大小之类的东西，比如um很小

01:09:12.480 --> 01:09:18.560
是的，就像这样，所以增量付款

01:09:18.560 --> 01:09:21.440
您只为验证的区块付费的渠道

01:09:21.440 --> 01:09:25.199
通过图搜索同步请求，因此您实际上无法允许

01:09:25.199 --> 01:09:28.400
缓冲区变得太大，因为嗯，然后它们实际上只是

01:09:28.400 --> 01:09:31.759
如果您没有发送过，请停止向您发送数据

01:09:31.759 --> 01:09:36.560
他们的感谢，因为你停止支付是的，是的，是的

01:09:36.560 --> 01:09:40.880
这意味着我的意思是付款变得越来越容易和困难

01:09:40.880 --> 01:09:46.239
嗯，所以就像一个单独的

01:09:46.239 --> 01:09:49.839
单独的问题，但这就像我不知道我

01:09:49.839 --> 01:09:52.560
只是我想我发现它有点疯狂，就像

01:09:52.560 --> 01:09:56.239
如果抢是愿意坐在那里喜欢

01:09:56.239 --> 01:09:59.920
吃光了，就象隔离的隔离式大商店一样

01:09:59.920 --> 01:10:04.239
它正在等待验证我是否阻止然后就像我们可以做所有这些一样

01:10:04.239 --> 01:10:08.800
位交换中的东西，就像那么容易，不要期待它

01:10:08.800 --> 01:10:11.760
就像哦，不，他们可以那样做，所以很好

01:10:11.760 --> 01:10:14.719
好像不是很好，就像真的

01:10:14.719 --> 01:10:19.440
大量的错误和类似的问题，就像你知道的那样，它真的很慢

01:10:19.440 --> 01:10:22.239
现在，嗯，缺乏流量控制

01:10:22.239 --> 01:10:26.800
流真的在伤害它，真的在伤害像um这样的性能

01:10:26.800 --> 01:10:29.920
没有人认为这是一个好主意，就像我们唯一的方式

01:10:29.920 --> 01:10:33.520
可以让事情现在开始运作，就像我不希望基准决策

01:10:33.520 --> 01:10:37.840
在这个现有的东西上，它应该真的像它一样消失

01:10:37.840 --> 01:10:42.080
应该变得健康，是的，就像我再次将其链接到这样的一系列问题一样，我和

01:10:42.080 --> 01:10:45.760
迈克尔写了所有关于我们不能做所有这些的事

01:10:45.760 --> 01:10:49.600
现在的事情，但那些不相关，我的意思是那些

01:10:49.600 --> 01:10:52.080
与您相关，您知道其中一些

01:10:52.080 --> 01:10:55.679
接口和要求，就像

01:10:55.679 --> 01:11:00.239
在某种程度上，我必须能够下载

01:11:00.239 --> 01:11:06.320
一次要有更多的数据我必须要说的是，如果再次像延迟一样

01:11:06.320 --> 01:11:10.400
如果等待时间真的很长，您甚至必须开始向我发送块

01:11:10.400 --> 01:11:15.840
在我确认我真的想要他们正确之前

01:11:15.840 --> 01:11:18.800
也许到了那时候我可能会忽略其中的一些，具体取决于我的身高

01:11:18.800 --> 01:11:23.760
缓冲区在我的操作系统和程序中的网络中，但就像您必须

01:11:23.760 --> 01:11:26.239
在我准备好数据之前就开始向我发送数据

01:11:26.239 --> 01:11:29.520
所以我们可以在bitswap中采取类似的方法

01:11:29.520 --> 01:11:33.679
好吧，但是客户端永远不会保护客户端免受您发送数据的影响

01:11:33.679 --> 01:11:36.880
客户端，如果您发送该数据，客户端唯一可以做的就是

01:11:36.880 --> 01:11:40.080
连接，所以所发生的就是像

01:11:40.080 --> 01:11:43.280
客户可能会向您发送错误的数据，直到您意识到它并切断了

01:11:43.280 --> 01:11:47.040
连接um，无论您做的越长，

01:11:47.040 --> 01:11:50.320
缓冲区越多，它将受到攻击

01:11:50.320 --> 01:11:56.640
我们在这个时间里做的更长，是的，是的，嗯

01:11:56.640 --> 01:12:00.000
是的，无论如何，我们现在可以停止录制吗，因为我只是

01:12:00.000 --> 01:12:02.640
这成为我只想谈论的事情，我为此感到骄傲

01:12:02.640 --> 01:12:06.159
有点

01:12:07.040 --> 01:12:11.760
你说错了，但后来却被静音了，所以我没听到

01:12:11.760 --> 01:12:14.800
我只是想说YouTube上是否有任何问题，但事实并非如此

01:12:14.800 --> 01:12:16.880
我们

