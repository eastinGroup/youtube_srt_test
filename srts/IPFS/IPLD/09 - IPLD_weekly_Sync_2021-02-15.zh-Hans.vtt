WEBVTT
Kind: captions
Language: zh-Hans

00:00:16.240 --> 00:00:21.279
我想大家都在打招呼，欢迎大家光临

00:00:21.279 --> 00:00:25.680
一周的IPL 2月的每周同步会议

00:00:25.680 --> 00:00:29.679
2021年15日，以及

00:00:29.679 --> 00:00:33.680
每周我们都会回顾我们所从事的工作

00:00:33.680 --> 00:00:38.320
在过去一周或几周内，因为我们有一段时间没有适当的会议了

00:00:38.320 --> 00:00:45.120
然后我们将在um上工作的东西，所以我

00:00:45.120 --> 00:00:48.800
开始我自己，我没有什么要报告的

00:00:48.800 --> 00:00:53.360
其实这样做，我什么都没有真正贬低

00:00:53.360 --> 00:00:58.559
嗯，但我对某些人可能感兴趣的是

00:00:58.559 --> 00:01:06.400
我将致力于将js多种格式的内容添加到js ipfs中

00:01:06.400 --> 00:01:13.360
嗯，是的，这就是我想做的第二季度末

00:01:13.360 --> 00:01:16.400
我们会看看情况如何，是的，我只是

00:01:16.400 --> 00:01:20.720
仍然像上周一样，我有足够的时间，但是本周，我可能会有时间

00:01:20.720 --> 00:01:24.320
而且我仍然在探索自己的状态，例如准备情况如何

00:01:24.320 --> 00:01:28.880
还是我应该从哪里开始，是的，我们会看看情况如何

00:01:28.880 --> 00:01:35.680
嗯，这就是我所拥有的，所以

00:01:35.680 --> 00:01:41.840
我列表上的下一个是eric

00:01:43.920 --> 00:01:48.079
射击，我仍然在输入嗯

00:01:48.720 --> 00:01:55.439
所以这是一个非常混乱的一周左右，但是如果有人

00:01:55.439 --> 00:01:59.840
有兴趣查看Go代码，我已经做了很多尝试

00:01:59.840 --> 00:02:03.360
重做go ipld prime中链接的工作方式

00:02:03.360 --> 00:02:08.160
所以这是我们有几个问题需要解决的问题

00:02:08.160 --> 00:02:11.520
很长一段时间说啊，这个界面感觉不好我们可以

00:02:11.520 --> 00:02:15.360
感觉很好，我想现在有草稿

00:02:15.360 --> 00:02:18.080
实际上大大改善了这一点

00:02:18.080 --> 00:02:24.879
简短的故事是，而不是链接类型携带大量

00:02:24.879 --> 00:02:28.959
现在附加了逻辑的概念

00:02:28.959 --> 00:02:31.760
链接系统，所有逻辑都在这里

00:02:31.760 --> 00:02:35.040
它有一些不错的小插件，用于您如何选择编解码器以及如何选择

00:02:35.040 --> 00:02:38.480
哈希和类似的东西，现在链接接口是预期的

00:02:38.480 --> 00:02:44.239
只是携带信息而做并且不包含任何逻辑

00:02:44.239 --> 00:02:47.599
嗯，我希望这将使一堆代码更加清晰，很多

00:02:47.599 --> 00:02:51.760
它的连接中的圆形不大，也

00:02:51.760 --> 00:02:55.599
意味着这些go库可以移动

00:02:55.599 --> 00:02:59.120
远离严格依赖于旅途中的一些东西

00:02:59.120 --> 00:03:07.040
多哈希库，这不是我想要的龙

00:03:07.040 --> 00:03:10.159
在此重构的开始就被杀死了，但事实证明它正在前进

00:03:10.159 --> 00:03:16.080
无论如何我都直接去了，有一点点

00:03:16.080 --> 00:03:19.680
在我什至没有真正去之前，就对go multihash库有所关注

00:03:19.680 --> 00:03:22.879
意识到这个问题有多大，直到我开始戳它

00:03:22.879 --> 00:03:26.000
但是那个图书馆里有一堆

00:03:26.000 --> 00:03:31.680
散列函数直接依赖

00:03:31.680 --> 00:03:35.360
因此，如果您想添加任何新的多哈希并且可以在go库中使用

00:03:35.360 --> 00:03:38.319
您必须修补无法注册的库

00:03:38.319 --> 00:03:41.760
他们自己，那里没有像这样的注册表概念

00:03:41.760 --> 00:03:46.799
和um及其所有api都不允许流式传输

00:03:46.799 --> 00:03:52.080
像错了一样，所以我一直试图解决这个问题

00:03:52.080 --> 00:03:55.040
以及该链接系统的一部分将正常工作，所以现在有

00:03:55.040 --> 00:03:58.480
在某些时候，有一张地图只是从多编解码器

00:03:58.480 --> 00:04:05.360
编号到标准库完全正常的接口

00:04:05.360 --> 00:04:08.159
这要简单得多

00:04:09.360 --> 00:04:12.720
我也有一些更多的哈希哈希的公关

00:04:12.720 --> 00:04:16.000
我想我们房间里的大多数人可能已经看过，但基本上

00:04:16.000 --> 00:04:21.199
我选择了数字的sha-2变体

00:04:23.199 --> 00:04:27.120
有一个公关，我想这里没有太多要说的了

00:04:27.120 --> 00:04:29.840
嗯

00:04:30.160 --> 00:04:33.919
我尚无话可说的事情

00:04:33.919 --> 00:04:38.560
但想想的是

00:04:38.560 --> 00:04:42.160
我认为参加长跑比赛真是太好了

00:04:42.160 --> 00:04:48.000
prs中的问题，任何在码头和规格上都很容易而且很小的问题

00:04:48.000 --> 00:04:50.479
回购

00:04:50.639 --> 00:04:54.400
我认为可能有些东西我很想让它们达到某个程度

00:04:54.400 --> 00:05:00.240
我们的未解决问题的数量就像希望没事了，因为我仍然

00:05:00.240 --> 00:05:03.440
希望能够继续巩固

00:05:03.440 --> 00:05:06.560
一堆回购

00:05:06.800 --> 00:05:10.960
其他人一直问我我在很多方面正在回答的问题

00:05:10.960 --> 00:05:16.479
github问题和东西，就像我需要再次写文档

00:05:17.520 --> 00:05:22.080
嗯，这就是我最近一直在想的一切

00:05:22.960 --> 00:05:32.080
谢谢，接下来是哦，事情胜过彼得

00:05:34.160 --> 00:05:38.400
是的，抱歉，我在上面放了一些代码来讨论

00:05:38.400 --> 00:05:42.320
它看起来不像我想的那样好啊，所以

00:05:42.320 --> 00:05:49.600
嗯，除了以下内容外，报告ipod还是明智的选择

00:05:49.600 --> 00:05:53.280
我现在大概已经工作了两个月了

00:05:53.280 --> 00:06:00.000
是一个实际的图书馆，现在还没有被推送，但是我只是

00:06:00.000 --> 00:06:03.759
需要再通过一次关于它的文档

00:06:03.759 --> 00:06:10.400
出现并在本周相对较早可用，是

00:06:10.400 --> 00:06:14.160
它有一个有趣的名字，因为它确实希望

00:06:14.160 --> 00:06:17.199
你知道一个链子，但实际上可以用作一般

00:06:17.199 --> 00:06:23.280
普通拳击手还有很多有趣的事情

00:06:23.280 --> 00:06:27.680
发现了其中一个我想谈论的话题今天晚些时候，我们有时间

00:06:27.680 --> 00:06:35.600
嗯，这几乎就是我的更新了，谢谢

00:06:35.600 --> 00:06:41.360
接下来是Rock um，好吧，是的现在我的矿山非常小

00:06:41.360 --> 00:06:45.280
被拉入新事物

00:06:45.280 --> 00:06:49.840
正如我认为我们所有人都一样，但我一直在努力

00:06:49.840 --> 00:06:53.280
我真的很想让这个规格演员

00:06:53.280 --> 00:07:01.360
um v3 um def东西完成了这个um规格仓库

00:07:01.360 --> 00:07:06.240
我们已经描述了块和规范参与者的格式

00:07:06.240 --> 00:07:09.039
到目前为止，我们有零版本

00:07:09.039 --> 00:07:14.319
两个，现在三个正在推广中，因此

00:07:14.319 --> 00:07:17.919
已经在呃状态div中完成了这项工作

00:07:17.919 --> 00:07:22.880
我需要我也要做

00:07:22.880 --> 00:07:26.000
然后我可以猜到理智地检查他的工作和帮助

00:07:26.000 --> 00:07:30.240
在那边，但是我只是认为这将会很好，相关的事情是

00:07:30.240 --> 00:07:34.080
在状态差异没有实际的变化，这只是重复，因为我

00:07:34.080 --> 00:07:37.120
隐藏内部障碍，这就是您要处理的

00:07:37.120 --> 00:07:39.680
改变的是汉普顿内部

00:07:39.680 --> 00:07:42.160
所以我实际上在想我一直在思考该怎么做

00:07:42.160 --> 00:07:46.000
我认为现在是时候将adls提取到一个单独的位置了

00:07:46.000 --> 00:07:49.360
文档的那部分原本是目标，但

00:07:49.360 --> 00:07:51.680
很难思考该怎么做，但我认为

00:07:51.680 --> 00:07:54.720
我认为是时候这样做了，并描述不同的地方

00:07:54.720 --> 00:07:57.840
ADL的格式，然后再如何使用

00:07:57.840 --> 00:08:01.440
因为问题在于大多数情况下，它们与内联值一起使用，并且

00:08:01.440 --> 00:08:05.680
一些，我认为在几个地方有链接，但嗯

00:08:05.680 --> 00:08:08.800
我想因为他们理想上是adls

00:08:08.800 --> 00:08:12.479
也在文档中，但是现在它就像被摧毁了

00:08:12.479 --> 00:08:16.479
描述这是当你碰到这些东西时的块格式

00:08:16.479 --> 00:08:19.520
就像是正常的，

00:08:19.520 --> 00:08:22.879
文档也需要有一个adl的概念，那就是

00:08:22.879 --> 00:08:25.520
当您尝试描述事物时，这确实具有挑战性

00:08:25.520 --> 00:08:29.840
如果他们不在，那也符合um

00:08:29.840 --> 00:08:33.360
如果值符合要求，这只是一个链接，您可以说

00:08:33.360 --> 00:08:36.800
就像您在状态diff中所做的一样，您只是在捏捏它，而只是

00:08:36.800 --> 00:08:39.599
说这里有东西去那里，然后

00:08:39.599 --> 00:08:42.800
然后再回来嗯，但这并不是那么容易

00:08:42.800 --> 00:08:49.120
是的文档，是的，是的，但是在什么时候

00:08:49.120 --> 00:08:53.680
当我们描述块布局时，并不是那么容易

00:08:53.680 --> 00:08:56.800
但是不，你说得对，也许这就是我要做的，只是因为我们

00:08:56.800 --> 00:09:01.279
最初使用adls的想法是将adl描述为

00:09:01.279 --> 00:09:05.680
只是地图代表而不是adl名称，我们

00:09:05.680 --> 00:09:08.959
由于种种原因，我们拒绝了这一点，但是

00:09:08.959 --> 00:09:12.880
理想的情况是要有类似的内容

00:09:12.880 --> 00:09:16.800
您使用地图语法，但是说这实际上是

00:09:16.800 --> 00:09:21.760
你在其他地方找到这个，只是我们不认为

00:09:21.760 --> 00:09:24.399
直觉的观点对

00:09:24.399 --> 00:09:28.880
首先说您应该将其视为地图

00:09:28.880 --> 00:09:34.640
这是我们实际表示方式的内部原理

00:09:35.120 --> 00:09:38.399
并像第一遍一样进入细节

00:09:38.399 --> 00:09:41.440
当某人试图了解正在发生的事情时

00:09:41.440 --> 00:09:45.360
我们没有任何地方的第一点是，您应该认为这是

00:09:45.360 --> 00:09:49.839
键值映射或字典这就是我们实际上的方式

00:09:49.839 --> 00:09:53.040
布置它是这很奇怪的事情，我们去过这里的一些文档

00:09:53.040 --> 00:09:56.320
我只是想让它变得清晰

00:09:56.320 --> 00:10:00.480
这个东西很奇怪这不是一张地图这是一个奇怪的东西

00:10:00.480 --> 00:10:03.360
警告，这就是为什么我们拥有我们拥有很长一段时间的原因

00:10:03.360 --> 00:10:07.519
语法是表示高级的，然后是adl名称，实际上

00:10:07.519 --> 00:10:11.200
清楚地说，这很奇怪，有地图，但是有

00:10:11.200 --> 00:10:16.160
三个令牌之后，也许我应该随便去吧，呃

00:10:16.160 --> 00:10:22.560
如果我们能做得更好的话，以后再解决

00:10:22.800 --> 00:10:26.399
无论如何，那就是我，我不认为我还有其他有意义的事情。

00:10:26.399 --> 00:10:28.480
只需一点点维护

00:10:28.480 --> 00:10:31.279
JavaScript的东西，但是嗯，我们已经

00:10:31.279 --> 00:10:35.200
嗯，我们通过JavaScript更改获得了一些打字稿内容

00:10:35.200 --> 00:10:39.680
而且似乎每个打字稿请求请求

00:10:39.680 --> 00:10:43.040
添加类型，还包括对以下内容进行更改

00:10:43.040 --> 00:10:45.519
它接触的每个库是

00:10:45.519 --> 00:10:51.760
奇怪，所以我们必须处理，我认为它来自

00:10:51.760 --> 00:10:56.160
人们试图以新的方式使用东西并发现

00:10:56.160 --> 00:11:00.079
我们导出的接口不是特别适合于类型的

00:11:00.079 --> 00:11:03.279
对于旧的语言，较旧的库和较新的库，他们发现

00:11:03.279 --> 00:11:06.240
界面可能会更直观

00:11:06.240 --> 00:11:11.360
他们想消费它们，这就是反馈，只是

00:11:11.360 --> 00:11:15.839
是的，无论如何也是如此

00:11:17.360 --> 00:11:20.240
接下来是真实的

00:11:21.440 --> 00:11:28.640
嗯，我想我上周开始的主要事情是

00:11:28.640 --> 00:11:32.160
与他人一起试图获取一组设计文档

00:11:32.160 --> 00:11:39.839
当前go ipfs代码库升级到的外观

00:11:39.839 --> 00:11:46.320
整个当前都使用go ipld prime，它使用的是较旧的go ipld

00:11:46.320 --> 00:11:50.160
格式库，它肯定会很好

00:11:50.160 --> 00:11:54.160
不会发生这种情况，并允许

00:11:54.160 --> 00:11:57.200
一些事情的一些更好的表示，所以

00:11:57.200 --> 00:12:01.360
在一起，应该结束于

00:12:01.360 --> 00:12:06.079
极地请求斜线问题斜线世界围绕着我发展

00:12:06.079 --> 00:12:12.079
um位置在本周晚些时候，以供更广泛的消费um

00:12:12.399 --> 00:12:15.760
希望这可以转化为一堆人

00:12:15.760 --> 00:12:19.839
实际上使之成为现实并成为现实，这对

00:12:19.839 --> 00:12:25.839
恩去ipld prime和ipfs

00:12:28.560 --> 00:12:33.440
谢谢，我们有天才，但我也记得

00:12:33.440 --> 00:12:39.200
来自上周与克里斯的暮光会议

00:12:39.200 --> 00:12:42.880
您想稍微谈谈离子，所以我们应该这样做

00:12:42.880 --> 00:12:45.920
首先也许

00:12:46.730 --> 00:12:50.160
[音乐]是的，我不知道我的意思是我想的

00:12:50.160 --> 00:12:55.279
我提到这可能甚至在两个星期前

00:12:55.279 --> 00:12:58.720
我发现这里有一个编解码器

00:12:58.720 --> 00:13:04.079
Aws叫做ion um，当我经历它的时候

00:13:04.079 --> 00:13:06.560
他们似乎经过了深思熟虑

00:13:06.560 --> 00:13:10.639
我们或我猜想设计和解决的一些问题

00:13:10.639 --> 00:13:14.560
我们已经烧入了json和seymour之类的一些问题之类的东西

00:13:14.560 --> 00:13:20.639
我实际上正在用它做我自己的金属成像工作

00:13:20.639 --> 00:13:24.000
在这里嗯，实际上不是因为它是aws，而是

00:13:24.000 --> 00:13:26.560
呃，只是因为我以为是

00:13:26.560 --> 00:13:29.279
其实我想我认为这很有趣，我想尝试一下

00:13:29.279 --> 00:13:32.639
看到可以使用的新技术，所以我做到了

00:13:32.639 --> 00:13:36.240
很酷，所以我坚持了下来，但我认为我的理想世界是

00:13:36.240 --> 00:13:38.959
将会有ipld将支持

00:13:38.959 --> 00:13:42.560
离子嗯，实际上，如果您有

00:13:42.560 --> 00:13:46.639
有机会看它，但似乎有点

00:13:46.639 --> 00:13:51.680
可能是一个很好的比赛，嗯，我已经与它合作过，因为它很有趣

00:13:51.680 --> 00:13:55.120
就像你知道我猜比较从javascript的角度来看，但

00:13:55.120 --> 00:13:58.560
与其他ipod编解码器一样的javascript相比，

00:13:58.560 --> 00:14:02.320
有点返回javascript对象，这很好

00:14:02.320 --> 00:14:04.800
但随后您遇到了一些问题，例如

00:14:04.800 --> 00:14:09.600
如果嗯嗯会发生

00:14:09.600 --> 00:14:12.800
让我们看看我正在尝试它是什么，就像数字一样

00:14:12.800 --> 00:14:15.360
就像我们说您在执行测量时遇到精度问题

00:14:15.360 --> 00:14:18.560
到我认为与ipld相似的json中

00:14:18.560 --> 00:14:21.920
今天可能只是忽略或没有真正解决

00:14:21.920 --> 00:14:25.120
他们用um ion做的就像你必须

00:14:25.120 --> 00:14:28.320
明确地说给我喜欢的数字或给我很大的帮助

00:14:28.320 --> 00:14:32.959
您必须选择它的版本，所以它不是一个友好的界面

00:14:32.959 --> 00:14:37.199
对于一个javascript开发人员，但这是更正确的，因为它可以处理

00:14:37.199 --> 00:14:41.839
那些与json和javascript世界迷失的东西，所以我

00:14:41.839 --> 00:14:45.360
不知道那将如何映射到ipld接口，因为我知道这些

00:14:45.360 --> 00:14:48.800
可能是正确的我错了，但似乎像一个JavaScript

00:14:48.800 --> 00:14:52.079
旨在使法典人员暴露

00:14:52.079 --> 00:14:55.360
并且往往是非常像本机javascript的，但是您知道有一些

00:14:55.360 --> 00:14:58.720
这些问题或与我猜的JavaScript，我不知道如何

00:14:58.720 --> 00:15:01.519
你会暴露一些离子的特征

00:15:01.519 --> 00:15:05.279
但嗯，但无论如何，那就是我一直在玩的

00:15:05.279 --> 00:15:12.000
我知道我问过迈克尔，他对他的想法是什么

00:15:12.000 --> 00:15:15.760
我将一些aws铁开发人员与杆连接起来，所以他

00:15:15.760 --> 00:15:19.360
我是这样做的，但是还没有进行很多对话，但是我

00:15:19.360 --> 00:15:21.360
不知道他是否有机会看

00:15:21.360 --> 00:15:25.440
您知道有任何想法或意见，但这是

00:15:25.440 --> 00:15:29.199
我看了一下，但这不是深入的观察，我只是

00:15:29.199 --> 00:15:32.480
那是当我看到类型的数量时

00:15:32.480 --> 00:15:35.759
但是迈克尔走得更远，迈克尔对此非常肯定，他认为

00:15:35.759 --> 00:15:37.680
看起来他看起来还不错，甚至长大了

00:15:37.680 --> 00:15:43.040
一些内部讨论，嗯，事实证明，那是

00:15:43.040 --> 00:15:47.360
考虑剥皮回去，我不知道什么时候，当他们

00:15:47.360 --> 00:15:51.440
最终决定与dag一起以seaboard为基础

00:15:51.440 --> 00:15:57.839
像ion这样的出租车板是一种更好的格式um的候选人，所以这是

00:15:57.839 --> 00:16:00.880
真的很有趣，我不知道它的背景，也不知道他们为什么翻转

00:16:00.880 --> 00:16:04.880
到sibor上可能与链接有关

00:16:04.880 --> 00:16:09.279
我不知道引入连接类型的离子的可扩展性

00:16:09.279 --> 00:16:14.560
嗯，这可能是个问题，嗯，是的

00:16:14.560 --> 00:16:18.560
这是肯定的，嗯，还有这样的小json变体

00:16:18.560 --> 00:16:21.680
它还是可以在json中很好地表示它们的东西，

00:16:21.680 --> 00:16:25.279
似乎它有一些不错的属性，我们应该

00:16:25.279 --> 00:16:30.880
考虑，是的，它实际上有两种编码，它的文本格式是

00:16:30.880 --> 00:16:36.399
看起来像json以及二进制格式，我认为基本原理是

00:16:36.399 --> 00:16:39.440
您知道二进制文件的效率，但是如果您想要一些人性化的文件

00:16:39.440 --> 00:16:43.519
可读性强，喜欢您支持原型制作或喜欢

00:16:43.519 --> 00:16:46.560
去看看没有工具，它是一种内置的，所以我不

00:16:46.560 --> 00:16:49.920
从我想知道这意味着什么我建立编解码器的角度

00:16:49.920 --> 00:16:53.759
如果您愿意，您会知道两个抄本，我希望文本简单而不是二进制

00:16:53.759 --> 00:16:57.120
还是只是明显地被攻击了我不是很清楚，但是

00:16:57.120 --> 00:17:01.199
是的，我认为这太有趣了，但实际上就是

00:17:01.199 --> 00:17:04.400
我想让jason最终确定该用例的原因

00:17:04.400 --> 00:17:07.439
您希望在其中可以看到想要处理的数据的位置

00:17:07.439 --> 00:17:11.360
手动操作，并且与民用计算机一起使用是不好的方法，并且

00:17:11.360 --> 00:17:14.400
所以具有二元性真的很好，尤其是当有

00:17:14.400 --> 00:17:16.880
它们之间的双向性是可以的

00:17:16.880 --> 00:17:20.160
您知道您可以毫无问题地交换彼此，并且

00:17:20.160 --> 00:17:23.679
杰森离那更近会很好

00:17:23.679 --> 00:17:27.439
嗯，我仍然有一个使命，那就是很难适应

00:17:27.439 --> 00:17:32.559
除非我们使用我们的项目组织结构

00:17:32.559 --> 00:17:35.760
确实可以帮助我们应对其中一些问题

00:17:35.760 --> 00:17:37.360
我不知道你听说了多少

00:17:37.360 --> 00:17:42.000
我们的reorg um crisp我们有点洗牌和um

00:17:42.000 --> 00:17:46.000
我们当中有些人不会像

00:17:46.000 --> 00:17:52.160
专注于ipld uh作为一个单一的事物

00:17:52.160 --> 00:17:58.559
好吧，我听说过一些关于呃，这可能不一定

00:17:58.559 --> 00:18:02.240
ipld团队了，还是自愿的，我不确定

00:18:02.240 --> 00:18:06.160
但我很想在离线状态下了解更多信息，这应该意味着

00:18:06.160 --> 00:18:09.120
越来越多的人接触ipld，而且越来越多

00:18:09.120 --> 00:18:12.799
我认为这将是这个特别ipld的优势

00:18:12.799 --> 00:18:18.080
素，所以可能的缺点是这个

00:18:18.080 --> 00:18:22.960
小组甚至将不再专注于这些努力

00:18:22.960 --> 00:18:25.679
虽然我们都是我，但我认为我们都对这些充满热情

00:18:25.679 --> 00:18:29.440
事情以及我们可能会继续展示这些事实的事实

00:18:29.440 --> 00:18:33.120
开会，即使我们的工作不在其他地方

00:18:33.120 --> 00:18:36.480
迈克尔的口号也提到了有关

00:18:36.480 --> 00:18:40.840
广大的观众，我想我将带一些aws的人们

00:18:40.840 --> 00:18:46.000
在不久的将来开会，如果能更好地促进这一点，那将会

00:18:46.000 --> 00:18:49.600
太好了，是的，绝对是我要说的

00:18:49.600 --> 00:18:54.559
实况转播，这实际上就像是在空中，

00:18:54.559 --> 00:18:57.679
所有指标都表明这次特殊会议将继续进行

00:18:57.679 --> 00:19:00.799
至少在可预见的未来中前进，是的，更多

00:19:00.799 --> 00:19:04.400
更多的人加入会很棒，我认为愿望是

00:19:04.400 --> 00:19:08.720
像这样将这次会议变成一个更多的社区会议

00:19:08.720 --> 00:19:11.760
而不是让我们进行同步，但实际上

00:19:11.760 --> 00:19:15.200
邀请人们谈论他们的东西并谈论伊比利亚

00:19:15.200 --> 00:19:18.240
一般，这样会很好

00:19:20.000 --> 00:19:23.200
所以我发生了几件事

00:19:23.200 --> 00:19:28.720
克里斯（Chris），您是在告诉我们有关um ion的信息吗？

00:19:28.720 --> 00:19:33.039
我一直想在脑海中永远发音的方式，但也许我很奇怪

00:19:33.039 --> 00:19:37.760
我没有听到有人在这里发音，所以我不知道我只是

00:19:37.760 --> 00:19:42.480
假设离子足够公平，所以你

00:19:42.480 --> 00:19:45.520
一开始就提到了有关javascript中的库的方式

00:19:45.520 --> 00:19:47.919
工作了

00:19:48.000 --> 00:19:51.679
这对我们来说可能真的很有趣，因为我认为

00:19:51.679 --> 00:19:55.679
至少有人在谈论

00:19:55.679 --> 00:19:58.960
如果我们应该尝试制作具有更多这种氛围的javascript库，我

00:19:58.960 --> 00:20:01.600
认为Rod和伊拉克都想到了

00:20:01.600 --> 00:20:04.960
在各个方面，有时我们都谈到了

00:20:04.960 --> 00:20:09.360
制作像primary这样的库，因为它越来越接近ast类

00:20:09.360 --> 00:20:12.559
go库被写入的顶空空间

00:20:12.559 --> 00:20:19.200
所以看离子库如何做到这一点的例子

00:20:19.200 --> 00:20:24.240
真的很有趣，尤其是当人们基准测试时

00:20:24.240 --> 00:20:28.080
我怀疑那可能真的很有趣，因为

00:20:28.080 --> 00:20:31.679
有时当我们对此进行讨论时

00:20:31.679 --> 00:20:36.960
我们还没有做的事情我们还没有做很多这样的原型

00:20:36.960 --> 00:20:42.080
所以我们不知道，但是我们同时进行的讨论似乎经常引发

00:20:42.080 --> 00:20:47.760
一些充满信心的假设，认为这将是完全站不住脚的

00:20:47.760 --> 00:20:53.440
javascript um中的一些性能原因，所以如果有

00:20:53.440 --> 00:20:57.120
来自那些喜欢完成更多任务的人的所有数据

00:20:57.120 --> 00:20:59.919
我想看的东西

00:20:59.919 --> 00:21:05.120
ii会实施的，这会非常令人兴奋，我的意思是我

00:21:05.120 --> 00:21:08.960
应该像您在谈论实际使用他们的api一样

00:21:08.960 --> 00:21:17.039
是的，所以我对此有所了解，但是我的意思是我当然可以

00:21:17.039 --> 00:21:20.080
显示我所知道的，但这不是很多，我是说我要继续工作

00:21:20.080 --> 00:21:24.480
有了它，所以我会在几周内得到更多，但是实际上一个

00:21:24.480 --> 00:21:27.679
是的，这真的是我会说的

00:21:27.679 --> 00:21:30.000
当我开始时，通过旋转我的头

00:21:30.000 --> 00:21:34.880
碰上了，因为不是，我没有准备，因为我期望只是

00:21:34.880 --> 00:21:38.559
javascript对象，它就像是一层层的东西，

00:21:38.559 --> 00:21:42.240
您必须要做的事情才能正确访问数据

00:21:42.240 --> 00:21:45.200
所以是的，我可以展示我所知道的，但是请给我几个星期的练习时间

00:21:45.200 --> 00:21:47.520
我可以更聪明地谈论它，但是

00:21:47.520 --> 00:21:51.200
另一类真正相关的事物

00:21:51.200 --> 00:21:54.799
让我感兴趣，你们可能想考虑的是，他们有

00:21:54.799 --> 00:21:58.080
整个哲学说你应该是

00:21:58.080 --> 00:22:03.039
能够像对数据进行流解析一样，然后将

00:22:03.039 --> 00:22:05.120
您想要那是附近最有趣的

00:22:05.120 --> 00:22:07.760
文件的开头，因此您基本上可以尽早终止并退出并

00:22:07.760 --> 00:22:11.679
不支付解析整个相似结构的费用

00:22:11.679 --> 00:22:14.559
等离子，因为我认为他们我认为

00:22:14.559 --> 00:22:16.480
他们在内部使用谁知道什么，但是

00:22:16.480 --> 00:22:19.919
嗯，但是如果有的话，这很有意义

00:22:19.919 --> 00:22:23.760
一千个数据项，像其中的十个一样，您大部分时间都需要

00:22:23.760 --> 00:22:25.120
其他你很少需要的，然后你把

00:22:25.120 --> 00:22:28.640
在前面，您已经打开它，可以节省自己的计算存储空间

00:22:28.640 --> 00:22:31.360
无论网络成本如何，我都不知道该怎么办

00:22:31.360 --> 00:22:33.520
应用ipld，但我认为是原则

00:22:33.520 --> 00:22:37.200
我不知道ipld是否可以在您可以像流解码一样的地方工作

00:22:37.200 --> 00:22:41.120
或者如果它基本上迫使您对块进行完全解码

00:22:41.120 --> 00:22:43.760
然后进行操作，但我认为这是一个非常有趣的原则

00:22:43.760 --> 00:22:45.440
意思是我就像是对我感到兴奋，因为

00:22:45.440 --> 00:22:48.960
实际上在医学成像中，我们一直在运行这种情况，

00:22:48.960 --> 00:22:52.320
和数千个类似的动作

00:22:53.039 --> 00:22:56.480
其中的99个很好，可以将它们放在最前面并订购

00:22:56.480 --> 00:22:58.720
办法

00:23:02.159 --> 00:23:05.760
我想知道我们是否应该这样做，所以我认为有一份文件要写

00:23:05.760 --> 00:23:09.440
我们尚未写过的那个附近的某个地方是

00:23:09.440 --> 00:23:12.960
写起来很棘手，因为有一些非常基本的东西

00:23:12.960 --> 00:23:17.679
权衡任何序列化格式将

00:23:17.679 --> 00:23:22.880
最终重新发现，我认为不可避免的折衷是

00:23:22.880 --> 00:23:26.240
流式传输与流式传输读取几乎拉扯

00:23:26.240 --> 00:23:29.360
像我这样的你认为明显矛盾

00:23:29.360 --> 00:23:34.000
如果您正在做流媒体版权，请在某些时候进行操作

00:23:34.000 --> 00:23:38.400
那么你就不能做长度前缀，因为你不能正确地传输它

00:23:38.400 --> 00:23:42.400
并专注于流媒体阅读，他们说的似乎不是最好的，

00:23:42.400 --> 00:23:46.159
他们的用例，例如读的次数是权利的50倍，或者

00:23:46.159 --> 00:23:49.840
他们正在优化的内容，是的，他们确实喜欢前缀

00:23:49.840 --> 00:23:56.799
属性写作和很多是，这是您可以选择的选择

00:24:01.600 --> 00:24:10.240
嗯，关于永恒或离子的其他事情，嗯，我不知道

00:24:10.240 --> 00:24:13.360
我没有最早了解pl的其他人的想法

00:24:13.360 --> 00:24:22.640
关于这一点，但我认为其中一些如果有从

00:24:22.640 --> 00:24:26.400
这到json也将很有趣，但我猜

00:24:26.400 --> 00:24:31.039
您是说它具有人类可读的文本表示形式

00:24:31.039 --> 00:24:35.679
看起来像json，但可能不是

00:24:35.679 --> 00:24:42.159
是的，我觉得这是一套超棒的

00:24:42.159 --> 00:24:48.159
json，所以他们json确实以这种格式编码，但是如果您

00:24:48.159 --> 00:24:51.039
想要一些高级功能以及我认为您需要的其他功能

00:24:51.039 --> 00:24:54.000
使用，所以你为你做一些不同的事情

00:24:54.000 --> 00:24:57.600
当然不是json对吗

00:24:57.600 --> 00:25:01.520
是的，这基本上和我们谈论dag json时遇到的问题相同

00:25:01.520 --> 00:25:06.320
与json比较接近，但dag的数据模型

00:25:06.320 --> 00:25:09.600
json比普通json多两种

00:25:09.600 --> 00:25:14.960
映射是否一定不完美

00:25:14.960 --> 00:25:18.159
所以我想如果我们要在两者之间架起桥梁

00:25:18.159 --> 00:25:23.120
ipld数据模型及其离子格式将是

00:25:23.120 --> 00:25:29.039
如果我们想将离子格式转变为ipld，则有点类似

00:25:29.039 --> 00:25:33.919
数据模型，因为离子种类更多，我们必须定义

00:25:33.919 --> 00:25:40.159
形态学有些谨慎，但否则应该相当可行

00:25:40.159 --> 00:25:43.840
要做到这一点

00:25:45.039 --> 00:25:48.080
但是，就像罗德所说，离子中的织补种类很多

00:25:48.080 --> 00:25:55.279
例如时间戳Blob，俱乐部，弦乐，符号，男孩

00:25:55.279 --> 00:25:59.600
那很有趣，我并不是说这很好

00:25:59.600 --> 00:26:05.200
嗯是嗯我没说我只在浏览

00:26:05.200 --> 00:26:08.559
正如我们所说的规格

00:26:08.880 --> 00:26:15.440
好吧，我想我认为我们现在都在使用javascript和go

00:26:15.440 --> 00:26:19.360
处于不难的位置

00:26:19.360 --> 00:26:22.640
让他们尽早保释

00:26:22.640 --> 00:26:26.320
如果您不匹配架构um，则不要传递完整的内容

00:26:26.320 --> 00:26:30.400
嗯，所以我们现在为javascript库提供了一个新的后端传递器

00:26:30.400 --> 00:26:33.520
确实完成了解析的一步

00:26:33.520 --> 00:26:37.039
您可以在其中插入诸如模式检查器之类的内容

00:26:37.039 --> 00:26:40.240
你嗯，甚至其他地方

00:26:40.240 --> 00:26:43.440
您正在阅读障碍物，可以提早保释，但我认为

00:26:43.440 --> 00:26:47.760
我认为ipld专注于较小的区块，例如我们只是

00:26:47.760 --> 00:26:51.440
我认为不要做大量的障碍物，因为

00:26:51.440 --> 00:26:53.840
出色地

00:26:53.919 --> 00:26:58.320
你知道最大一个兆字节是不小的，但是

00:26:58.320 --> 00:27:01.279
当然不大

00:27:01.360 --> 00:27:03.600
伟大的

00:27:04.799 --> 00:27:12.159
好吧，我们应该继续处理性别项目吗？我已经在这里放了一个项目

00:27:12.159 --> 00:27:18.240
因为我们仍然拥有这个um软件遗产的多编码功能

00:27:18.240 --> 00:27:22.320
请求打开我的意思是，是的，

00:27:22.320 --> 00:27:25.360
讨论枯竭了，是的，所以我认为我们在

00:27:25.360 --> 00:27:29.760
那一点，我们应该做些什么

00:27:29.760 --> 00:27:34.880
是的，是一个问题，例如下一步我们应该怎么做，所以我个人会说

00:27:34.880 --> 00:27:38.640
因此，我仍然建议他们使用

00:27:38.640 --> 00:27:44.880
获取除国家以外的所有类型的um的原始对象

00:27:44.880 --> 00:27:48.640
我认为是哪一个快照或um

00:27:48.640 --> 00:27:52.880
特殊类型，并为其注册了一种特殊类型

00:27:52.880 --> 00:27:55.600
类型，因此基本上您有一种特殊类型，对于所有其他类型，它们

00:27:55.600 --> 00:27:59.279
使用git raw这我仍然认为是我

00:27:59.279 --> 00:28:04.080
宁愿嗯，我他们似乎还可以，我

00:28:04.080 --> 00:28:09.679
是的，所以我应该提出建议

00:28:09.679 --> 00:28:12.399
再次显然重复我在讨论中所说的，然后说

00:28:12.399 --> 00:28:17.520
这是我建议的，这样对您来说就可以了，然后

00:28:17.520 --> 00:28:21.600
如果他们说是，那么我们合并并触发

00:28:25.520 --> 00:28:29.679
嗯，我只是要观察的任何事情，我认为其中的一些人

00:28:29.679 --> 00:28:34.000
讨论获得某种资助或其他东西

00:28:34.000 --> 00:28:37.600
对此做进一步的工作，他们可能会测试他们的理论

00:28:37.600 --> 00:28:42.320
在某个时候使用代码，所以我想知道我们是否可以问他们在哪里

00:28:42.320 --> 00:28:46.320
进步是让他们在需要的时候踢我们的短裤

00:28:46.320 --> 00:28:50.720
决定，也许我们可以在此做出更多信息

00:28:50.720 --> 00:28:53.679
我想我上次看到关于他们在说什么的任何讨论

00:28:53.679 --> 00:28:56.080
是的，这是一个有趣的问题，但就像

00:28:56.080 --> 00:28:59.679
我们可以建立原型而不会挂

00:28:59.679 --> 00:29:02.320
还没有解决，所以我想，也许如果我们不让

00:29:02.320 --> 00:29:08.640
他们可能还不错，这很不错，所以我明白了，就像

00:29:08.640 --> 00:29:10.640
也喜欢我们是否完全可以像问他们一样

00:29:10.640 --> 00:29:13.760
就像这是紧迫的事情还是它

00:29:13.760 --> 00:29:18.159
就像这样，就像它能感觉到如此未完成一样

00:29:18.159 --> 00:29:21.440
目前尚不清楚它的发展方向，但如果我们喜欢，我也可以完全喜欢

00:29:21.440 --> 00:29:23.600
说现在情况还好吗

00:29:23.600 --> 00:29:26.399
保持打开状态，然后保持打开状态，我对此表示完全满意

00:29:26.399 --> 00:29:29.919
就像我不想基本上将它们拖到一起

00:29:29.919 --> 00:29:32.960
尽管我们不再讨论，只是

00:29:32.960 --> 00:29:40.000
是的，我只想问他们，我想是的

00:29:40.000 --> 00:29:43.520
是的，我要说的是ii实际上并没有在

00:29:43.520 --> 00:29:50.399
在门票上，因为我喜欢它，如果我愿意，我会觉得出轨

00:29:50.399 --> 00:29:54.320
嗯，报时了，但又像回到我们刚才说的那样

00:29:54.320 --> 00:30:00.480
上周呃，我们可能在这里失去机会

00:30:00.480 --> 00:30:04.960
code在法典上，因为

00:30:04.960 --> 00:30:12.559
编解码器的注释很有价值，因为它们

00:30:12.559 --> 00:30:17.679
做得很好，但可以解释为

00:30:17.679 --> 00:30:20.799
某种方式

00:30:20.840 --> 00:30:29.039
我不知道这对我来说是说哦，这件事，你知道这个

00:30:29.039 --> 00:30:31.919
新的迪士尼编解码器，您也可以将其视为

00:30:31.919 --> 00:30:35.679
一件好事是便宜和长期更好

00:30:35.679 --> 00:30:39.760
而不是说哦，不，这就像git和

00:30:39.760 --> 00:30:43.520
如果您实际上需要注意这是其他事情，那么您就可以

00:30:43.520 --> 00:30:47.279
您将在其他一些寄存器中查找或类似的内容

00:30:47.279 --> 00:30:54.480
但这是我的两分钱，嗯，我猜我猜

00:30:54.480 --> 00:30:58.080
这是一个更根本的问题，例如

00:30:58.080 --> 00:31:02.000
是编解码器表，只为您了解基本

00:31:02.000 --> 00:31:05.919
呃解码还是用于识别

00:31:05.919 --> 00:31:13.360
也许维护人员可以在他们的工作中知道

00:31:13.360 --> 00:31:16.559
骑士bld Prime即将进行的工作可以澄清这一点，因为现在我们有

00:31:16.559 --> 00:31:21.120
此表本质上不明确

00:31:28.399 --> 00:31:34.000
那就是我有一个随机的想法，我会分享那个

00:31:34.000 --> 00:31:39.120
只是漂浮在我的头上

00:31:39.440 --> 00:31:44.720
我不在乎的程度实际上只是在加剧

00:31:44.840 --> 00:31:48.159
时候我看了一些javascript代码

00:31:48.159 --> 00:31:50.159
实际上是迈克尔的踢

00:31:50.159 --> 00:31:53.919
加密的东西让我意识到，也许我只是不在乎

00:31:53.919 --> 00:31:58.320
嗯，因为他有这段代码片段，而他只是有一堆

00:31:58.320 --> 00:32:01.760
um编解码器编号，他将它们全部分配给了他们

00:32:01.760 --> 00:32:06.240
到制造事物并将其关联的某些工厂函数的输出

00:32:06.240 --> 00:32:10.159
与数字，但喜欢他们之间的变化量

00:32:10.159 --> 00:32:16.080
在代码中就像一个，我就像哦，是的，我们可以做到这一点

00:32:16.080 --> 00:32:18.880
所以

00:32:19.200 --> 00:32:24.399
一堆多编解码器数字的想法

00:32:24.399 --> 00:32:30.880
功能上可能映射到相同的编码和解码功能

00:32:30.880 --> 00:32:35.840
而只是在cid中保留的另一个数字

00:32:36.640 --> 00:32:39.919
是的，我思考的时间越长

00:32:39.919 --> 00:32:43.840
完全不打扰我

00:32:47.679 --> 00:32:51.840
虽然也变得越来越不在乎，但这是通往熵的途径

00:32:51.840 --> 00:32:55.440
这就是这是最大的挑战是

00:32:55.440 --> 00:32:57.760
好吧，所以你不在乎，让我们添加任何东西

00:32:57.760 --> 00:33:01.600
然后沿着那条线有一个点

00:33:01.600 --> 00:33:05.600
桌子变得完全没有意义，只是数字和字符串

00:33:05.600 --> 00:33:10.640
这只是一个很大的井，我的意思是那是我的初始职位，所以我

00:33:10.640 --> 00:33:14.399
对也喜欢我们要维持什么业务

00:33:14.399 --> 00:33:18.960
全球事物的地图，就是您所知道的，这就是您所推动的范围

00:33:18.960 --> 00:33:25.840
就像是谁，好吧，这是

00:33:30.880 --> 00:33:35.919
是的，我的意思是等一下，我们维护该表的最简单原因是

00:33:35.919 --> 00:33:40.399
如果有另一张桌子，没有其他人在做一张

00:33:40.399 --> 00:33:44.320
有了这个规则，我们将完全使用它，只是不存在

00:33:44.320 --> 00:33:49.120
因为那不是抛出规则，规则很简单

00:33:49.120 --> 00:33:55.200
你基本上没有不带他的箱子，你知道这是唯一的ID

00:33:55.200 --> 00:33:57.600
就是这样

00:33:57.919 --> 00:34:03.200
即使有那些规则，没有人有像这样的桌子

00:34:04.640 --> 00:34:07.519
我的意思是，仅此而已，我的意思是，欢迎您提出建议，并为我阅读

00:34:07.519 --> 00:34:10.560
可以说这只是一个全球

00:34:10.560 --> 00:34:13.919
具有特定规则的数字名称空间到字符串

00:34:13.919 --> 00:34:16.399
我只是

00:34:16.960 --> 00:34:20.240
ii坚持一些麻烦

00:34:20.240 --> 00:34:24.560
一旦执行此操作，便会确定其目的的公司

00:34:24.560 --> 00:34:28.240
就像你知道的那样，能够很好地抓住一些目的

00:34:28.240 --> 00:34:31.679
考虑到我们如何混合编解码器和

00:34:31.679 --> 00:34:35.359
你知道那里的网络协议之类的东西

00:34:35.359 --> 00:34:42.720
它已经变得模糊了，但是这个东西在哪里

00:34:42.720 --> 00:34:45.200
讨论的重点是我们关心的是

00:34:45.200 --> 00:34:48.960
Codex是一小类Codex，这些东西自称是

00:34:48.960 --> 00:34:54.399
编解码器，这就是我们的事情，我们

00:34:54.399 --> 00:34:57.680
正在尝试定义成为编解码器的含义，

00:34:57.680 --> 00:35:02.800
并且在这个空间中，编解码器标识符不再是有用的

00:35:02.800 --> 00:35:05.760
而您还需要其他一些东西，这是我们还没有解决的其他问题

00:35:05.760 --> 00:35:07.839
因为我们还没有给出解决方案，所以我们

00:35:07.839 --> 00:35:11.359
只是说这是您需要处理的其他事情，我们无济于事

00:35:11.359 --> 00:35:14.960
嗯，所以我们要么说我们要么忽悠

00:35:14.960 --> 00:35:18.960
在编解码器上说，哦，您可以将其用于其他用途

00:35:18.960 --> 00:35:23.680
好吧，或者我们推动他们解决它

00:35:23.680 --> 00:35:28.400
不同的更好方法，或者我们提出解决方案

00:35:29.680 --> 00:35:33.599
老实说，我对这些选择都不感到强烈

00:35:33.599 --> 00:35:40.240
然后让我稍微开放的东西让开放让别人妥协

00:35:40.240 --> 00:35:42.880
这些事实是，这些编解码器是

00:35:42.880 --> 00:35:46.400
无论如何，因为您可以从原始和任何

00:35:46.400 --> 00:35:50.000
这些编解码器可能是原始的，就像它们只是字节一样，我可以读取

00:35:50.000 --> 00:35:54.880
它们是原始的，而当您加紧时，就增加了意义的层次

00:35:54.880 --> 00:35:58.800
和嗯，所以我们从原始到知道dag pb

00:35:58.800 --> 00:36:02.160
然后，你知道你，你甚至可以

00:36:02.160 --> 00:36:05.680
从dag bb转到您可能正在制作

00:36:05.680 --> 00:36:09.760
一个说unix fs的编解码器，我的意思是我们在不同的意义层上添加了

00:36:09.760 --> 00:36:15.440
但嗯，关于获得之一的事情是

00:36:15.440 --> 00:36:19.760
他们在实例化数据上添加了一层含义

00:36:19.760 --> 00:36:23.440
嗯，里面可能还有其他东西

00:36:23.440 --> 00:36:26.560
那只是因为编解码器告诉他们

00:36:26.560 --> 00:36:30.640
那里就像那里有一根绳子

00:36:30.640 --> 00:36:33.839
实例化的数据模型，告诉他们其标识符

00:36:33.839 --> 00:36:36.800
此数据，仅存在，因为编解码器

00:36:36.800 --> 00:36:40.720
让他们看到那边，就像另一个例子

00:36:40.720 --> 00:36:44.720
嗯，我认为我们称之为二元默克尔

00:36:44.720 --> 00:36:49.720
只是两个的一个编解码器，就像它的两个64字节一样

00:36:49.720 --> 00:36:54.800
sha256s作为通用二进制merkle卡在一起，您可以

00:36:54.800 --> 00:37:01.839
您可以将其解释为两个32字节的uh 32位32字节的哈希

00:37:01.839 --> 00:37:05.440
压缩成一个64字节的二进制文件

00:37:05.440 --> 00:37:09.680
或者你可以通过什么是比特币TX来查看

00:37:09.680 --> 00:37:14.160
编解码器以相同的方式对其进行解码，但您会看到不同的东西

00:37:14.160 --> 00:37:18.160
然后您可以看一下z tx编解码器，这又是相同的东西，但是

00:37:18.160 --> 00:37:21.520
您会看到其中的不同之处，因此我们已经在

00:37:21.520 --> 00:37:27.040
意思是具有不同的不同字节，因此存在现有技术

00:37:27.040 --> 00:37:30.079
展示这些东西

00:37:30.160 --> 00:37:33.440
所以是呃工人问题的底线

00:37:33.440 --> 00:37:36.800
是的，让我们与他们一起检查他们在哪里，

00:37:36.800 --> 00:37:40.000
是的，解开它们，因为这个很小

00:37:40.000 --> 00:37:45.520
嗯，你知道segway嗯，告诉我我们不会同意

00:37:45.520 --> 00:37:50.480
在桌子上做什么很快就好了，最近我又来了

00:37:50.480 --> 00:37:52.320
认为院长也一直在推动这一点

00:37:52.320 --> 00:37:55.920
关于我们的原始人有很多误解

00:37:55.920 --> 00:37:58.960
大家都来找我们说

00:37:58.960 --> 00:38:01.280
想要这个新功能时添加了这个东西

00:38:01.280 --> 00:38:05.280
而且往往是因为他们对

00:38:05.280 --> 00:38:09.599
我们提供的原语，我们在多编解码器表中看到了

00:38:09.599 --> 00:38:12.480
人们经常说我想添加这个东西，而我们

00:38:12.480 --> 00:38:16.079
和他们一起做一些校正工作，他们走了啊，好吧，我没有

00:38:16.079 --> 00:38:19.359
看到那应该是那个东西，那是有道理的

00:38:19.359 --> 00:38:24.640
所以最初在这个公关中，这对我来说就像是

00:38:24.640 --> 00:38:30.320
很多其他公关都是这样的，但是你知道这确实像他们

00:38:30.320 --> 00:38:33.680
摇滚比其他许多摇滚都多，而他们只是拥有额外的一层

00:38:33.680 --> 00:38:36.640
意思是他们想插入，所以我们推回去是正确的

00:38:36.640 --> 00:38:40.000
这些东西，说是的，添加您想要的东西，并按照需要使用它

00:38:40.000 --> 00:38:43.359
嗯，但也许有些时候我不知道

00:38:43.359 --> 00:38:50.400
我不知道，但是欢迎您对所说的内容加一，让他们

00:38:50.400 --> 00:38:53.040
回到我们身边

00:38:54.240 --> 00:39:00.640
好吧，嗯，关于um的另一条评论

00:39:00.640 --> 00:39:03.839
p原始图元不像

00:39:03.839 --> 00:39:07.760
全面相关的还有

00:39:07.760 --> 00:39:15.119
研究和部门小组有一个RFC，代表rsc代表什么

00:39:15.119 --> 00:39:19.200
在这种情况下，一些ipod的东西嗯，我是

00:39:19.200 --> 00:39:23.119
就像哦，我的天哪是去复习一下，但也就像在那里，就像

00:39:23.119 --> 00:39:29.920
它的一半就像是的，而不是ipld，我们如何谈论ipld

00:39:29.920 --> 00:39:34.160
所以这就像对ipod的工作方式以及对ipod的误解一样

00:39:34.160 --> 00:39:37.760
就像是的，所以就像再次提出它一样

00:39:37.760 --> 00:39:40.960
我会复习的东西，但也像是的，我同意

00:39:40.960 --> 00:39:44.720
有一些误解，或者我们需要更清楚一些，或者是，请确保

00:39:44.720 --> 00:39:47.839
我建立对ipod d的理解

00:39:47.839 --> 00:39:52.240
与我们的sap ip完全一样，因为似乎有很多

00:39:52.240 --> 00:39:56.400
是的，我们如何谈论ipod和其他

00:39:56.400 --> 00:40:01.440
了解意大利，嗯，是的

00:40:01.839 --> 00:40:05.599
是的，我会先进行审核，然后再说一遍，您可能会审核

00:40:05.599 --> 00:40:08.720
是的，我们会看到的，但我不想浪费任何一个

00:40:08.720 --> 00:40:14.880
时间到了，是的，无论如何，还有

00:40:14.880 --> 00:40:20.640
是的，还有另外一个发电项目，这个项目看起来很吓人，但这是

00:40:20.640 --> 00:40:25.810
真的非常快，所以嗯，同时用...写我的东西

00:40:25.810 --> 00:40:30.160
[音乐]基于数据库的呃块存储，我需要一个

00:40:30.160 --> 00:40:35.040
某些原语可以做的比块格式还多

00:40:35.040 --> 00:40:39.599
我通过的这段代码实际上是整个代码

00:40:39.599 --> 00:40:44.720
原始数据的方法以及基本拼写时确保我

00:40:44.720 --> 00:40:48.079
你知道忠实地生产一切我意识到

00:40:48.079 --> 00:40:52.160
我们当前的块几乎到处都只返回字节片

00:40:52.160 --> 00:40:58.800
因为他们保持它没有副本，所以我基本上如果我有一个街区，我

00:40:58.800 --> 00:41:01.440
得到它的原始数据我得到一个切片，然后我就可以

00:41:01.440 --> 00:41:04.400
随意修改，块将是您知道的东西

00:41:04.400 --> 00:41:07.680
我可以例如添加完全不同的东西，诸如此类

00:41:07.680 --> 00:41:11.760
嗯，基本上我不是说要用笔，而是要在上面加上一些东西

00:41:11.760 --> 00:41:15.359
基本上会写上那里已经存在的东西

00:41:15.359 --> 00:41:19.200
自己把这个卖给了我，基本上是全球性的

00:41:19.200 --> 00:41:24.160
总是在呃，但这我想是

00:41:24.160 --> 00:41:27.280
用文档或一般来澄清

00:41:27.280 --> 00:41:30.640
当你们要使自己更具吸引力时，前提是这些东西

00:41:30.640 --> 00:41:37.119
嗯，所有这些数据的所有权规则是什么，因为正确

00:41:37.119 --> 00:41:42.800
现在基本上就像别人写的一样

00:41:42.800 --> 00:41:45.440
那不酷

00:41:46.160 --> 00:41:51.760
那是eric是的，是的，不，这是我真的很讨厌

00:41:51.760 --> 00:41:54.720
类型系统脸

00:41:56.000 --> 00:41:59.920
我同意这是一个巨大的问题，它使我发疯

00:41:59.920 --> 00:42:03.680
几乎每次我打开代码编辑器时，我

00:42:03.680 --> 00:42:07.040
对于知道什么是不变性的类型系统感到绝望，因为

00:42:07.040 --> 00:42:12.560
试图通过代码中的注释来跟踪这一点很烂

00:42:12.560 --> 00:42:17.839
就是这样

00:42:18.560 --> 00:42:22.400
我能够想到的最好的事情就是我开始制定公约

00:42:22.400 --> 00:42:25.760
在说这是主要评论之后

00:42:25.760 --> 00:42:31.839
非法改变价值的回报

00:42:32.640 --> 00:42:36.400
是的，这就是您可以做的所有事情，是的，我们只是

00:42:36.400 --> 00:42:40.000
谈到是的，这完全没问题，我们基本上不说

00:42:40.000 --> 00:42:43.920
我现在基本上提出了我们栈中任何地方的任何内容

00:42:43.920 --> 00:42:46.079
我们要么只是说我们是

00:42:46.079 --> 00:42:49.680
开始复制内容，因为这样做可能有充分的理由

00:42:49.680 --> 00:42:53.440
在4月取决于ipld黄金世界，否则我们必须进行基本注释

00:42:53.440 --> 00:43:02.000
像您这样的一切都无法触及，我认为我们应该

00:43:02.000 --> 00:43:08.560
开始注释一切都违背文档是非法的

00:43:08.560 --> 00:43:12.960
基本上每个地方都应有的应有的地方

00:43:12.960 --> 00:43:15.200
嗯

00:43:17.119 --> 00:43:20.880
是的，我真的希望我能想到一些更强大的事情

00:43:20.880 --> 00:43:24.240
比那个，但是

00:43:24.400 --> 00:43:27.839
哦，这是我

00:43:28.480 --> 00:43:32.079
是的，我基本上想基本上提出你知道的

00:43:32.079 --> 00:43:35.280
现在还没有记录，嗯，另一点是

00:43:35.280 --> 00:43:38.839
甚至想走实现我实现的目标的道路

00:43:38.839 --> 00:43:43.760
基本上，你可以为你制作这个副本，它会磨损

00:43:43.760 --> 00:43:47.119
全球松弛或类似的事情

00:43:48.960 --> 00:43:54.480
我宁愿不做你能做的最疯狂的事情

00:43:54.480 --> 00:43:58.160
我们可以考虑的是，您可以使用构建标记来执行

00:43:58.160 --> 00:44:02.480
像这样的东西，我见过人们在做包装

00:44:02.480 --> 00:44:05.760
是的，是的，你可以

00:44:06.160 --> 00:44:10.560
我见过人们在使用build标签的地方制作用于调试的软件包

00:44:10.560 --> 00:44:14.880
默认情况下，它将在调试printf函数中进行编译

00:44:14.880 --> 00:44:18.319
那实际上是空的功能块，所以什么也没有

00:44:18.319 --> 00:44:21.920
然后如果您使用构建标记启用替代模式

00:44:21.920 --> 00:44:26.240
它实际上在其中放了一些调试printf

00:44:26.319 --> 00:44:31.040
我们可以在任何地方进行防御性复制

00:44:31.040 --> 00:44:33.760
作为构建标签

00:44:35.119 --> 00:44:41.520
但我要争辩说，我们最重要或最远

00:44:41.520 --> 00:44:46.400
可能会使用uh os内存页面保护来

00:44:46.400 --> 00:44:50.000
拥有我们可以为您提供指向只读页面的指针的内存

00:44:50.000 --> 00:44:52.319
嗯

00:44:54.319 --> 00:44:57.520
那很昂贵那就是比复制它还要昂贵

00:44:57.520 --> 00:45:00.880
我的意思是，如果您的数据来自汽车，那取决于您的数据在哪里

00:45:00.880 --> 00:45:04.880
您在整个汽车上绘制的图只能读得很棒

00:45:04.880 --> 00:45:07.359
现在任何试图改变那些指针的尝试

00:45:07.359 --> 00:45:10.240
实际上给你错误

00:45:10.400 --> 00:45:14.000
现在很酷

00:45:16.319 --> 00:45:20.079
但是对于您要从法典和东西中获取的数据

00:45:20.079 --> 00:45:23.680
最终变得昂贵，而不是您可以真正摆脱的东西

00:45:23.680 --> 00:45:25.920
我认为

00:45:28.400 --> 00:45:32.000
是的，我们一直很难提供该功能

00:45:32.000 --> 00:45:35.599
担心会很好，但是

00:45:41.839 --> 00:45:46.400
是的，现在有一些相关的界面让我很困扰

00:45:46.400 --> 00:45:50.560
在大卖场周围的一些地方，人们一直非常

00:45:50.560 --> 00:45:55.839
试图进行优化以返回对数据的零拷贝访问

00:45:57.599 --> 00:46:03.839
因此，目标是要快，如果您

00:46:03.839 --> 00:46:06.640
在中使用io reader和io writer接口

00:46:06.640 --> 00:46:11.680
去不是

00:46:11.680 --> 00:46:15.680
超级善于机械同情

00:46:15.680 --> 00:46:20.319
像我那样尝试读取和写入块大小，但

00:46:20.319 --> 00:46:24.079
嗯，你往往会得到至少一本

00:46:24.079 --> 00:46:29.839
读取器接口传递的字节片

00:46:30.079 --> 00:46:35.760
所以人们提出了一些补丁，让我们使用一些

00:46:35.760 --> 00:46:39.200
如果该阅读器具有一种称为

00:46:39.200 --> 00:46:42.400
个字节为您提供了一个字节片，然后

00:46:42.400 --> 00:46:45.359
像投下内心，然后用东西，然后跳过其他所有东西

00:46:45.359 --> 00:46:48.800
复制，这很酷，因为它

00:46:48.800 --> 00:46:56.720
完成了一定要走的目标，但这也有点奇怪，因为

00:46:56.720 --> 00:47:00.400
嗯，这完全违反了io读者合同

00:47:00.400 --> 00:47:04.400
基本上，所以没有人对此做出错误报告，但是我

00:47:04.400 --> 00:47:07.440
界线感到惊讶，因为这在实践中意味着是否有人

00:47:07.440 --> 00:47:11.040
传递一个字节缓冲区，这是一种常用的类型

00:47:11.040 --> 00:47:19.440
如果读者的光标不会向前移动，那么如果您希望这样的话

00:47:19.440 --> 00:47:22.720
关于优化的有用功能实际上将在逻辑上做一些事情

00:47:22.720 --> 00:47:26.630
真的对你不正确

00:47:26.630 --> 00:47:31.040
[鼓掌]我也没有解决办法

00:47:31.040 --> 00:47:33.200
除了现在被适度的扰动

00:47:33.200 --> 00:47:38.079
我觉得山羊型系统真的在这里没有帮助我

00:47:38.079 --> 00:47:40.960
我们可能应该就如何执行此操作进行某种讨论

00:47:40.960 --> 00:47:45.680
在我们的图书馆中，我一致认为这会很有用

00:47:49.040 --> 00:47:52.160
是的，我只想把这些放在您的雷达上，因为我知道那是完全正确的

00:47:52.160 --> 00:47:56.079
您现在正在玩的那种东西，

00:47:58.319 --> 00:48:02.400
哦，这个接口也不会在错误时返回错误，所以我必须返回nil

00:48:02.400 --> 00:48:07.119
然后对错误的仇恨有不同的看法

00:48:10.640 --> 00:48:15.680
我期待您现有的postgres库

00:48:16.880 --> 00:48:21.119
那些叫只读的东西是什么，因为我试图服用

00:48:21.119 --> 00:48:24.880
注意并忘记了名称，因此为只读

00:48:24.880 --> 00:48:28.480
页面保护内存保护的东西这是

00:48:28.480 --> 00:48:32.000
我一直在寻找什么，谢谢您的填写

00:48:32.000 --> 00:48:40.319
差距，嗯，好吗是电话，是的，谢谢，嗯

00:48:40.319 --> 00:48:48.319
好吧，我认为我们已经完成了议程

00:48:48.319 --> 00:48:52.480
人们还有什么想谈的吗

00:48:52.480 --> 00:48:55.920
我们还有五分钟

00:48:56.480 --> 00:49:00.960
那就不要再召开更紧密的会议了，谢谢大家的参与和

00:49:00.960 --> 00:49:06.880
下周再见

