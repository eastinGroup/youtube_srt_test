WEBVTT
Kind: captions
Language: zh-Hans

00:00:14.920 --> 00:00:17.920
嗯

00:00:19.760 --> 00:00:23.920
欢迎大家参加本周的ipld会议

00:00:23.920 --> 00:00:29.679
2020年8月17日，每周我们都会回顾我们在

00:00:29.679 --> 00:00:32.000
过去一周，并计划下周进行

00:00:32.000 --> 00:00:38.160
然后我们讨论um性别项目或任何人有的问题，或

00:00:38.160 --> 00:00:43.200
是的，所以所有开放主题

00:00:43.200 --> 00:00:47.920
这个星期，我开始做我自己，这个星期，我没有什么要报告的

00:00:47.920 --> 00:00:49.920
ipld的东西，因为我还没做完

00:00:49.920 --> 00:00:56.239
上周任何与ipod相关的东西，我仍在忙于Filecoin的东西

00:00:56.239 --> 00:01:00.719
但这有望很快完成

00:01:00.719 --> 00:01:04.320
是的，很快我将再次获得该报告的纸质清单

00:01:04.320 --> 00:01:11.600
我名单上的下一位是彼得，但他还写道，他没有任何东西，所以

00:01:11.600 --> 00:01:16.000
下一个，除了我需要补充的是，本周我不会做

00:01:16.000 --> 00:01:23.439
好的，好的，很酷，是的，所以下一个

00:01:23.439 --> 00:01:29.040
如果是的话，那将是迈克尔，所以我的意思是我可以再说一遍

00:01:29.040 --> 00:01:33.680
我会第二秒钟写文字，我只是泡茶，所以我离开了

00:01:33.680 --> 00:01:37.920
相机第二个是的，是的，我还没有写笔记，但是

00:01:37.920 --> 00:01:43.360
嗯，主要是这个um文件硬币检索的东西，所以我们现在知道

00:01:43.360 --> 00:01:46.399
这就像从中获取任何数据的唯一方法

00:01:46.399 --> 00:01:51.200
文件硬币网络永远都具有检索和选择器，因此我们

00:01:51.200 --> 00:01:53.840
争先恐后地试图弄清楚我们如何能够获得

00:01:53.840 --> 00:01:57.600
区块链中的数据并没有真正合理的方法

00:01:57.600 --> 00:02:03.280
当前的方法，所以我写了为什么um，然后写了两个

00:02:03.280 --> 00:02:06.960
功能要求，使它在将来更可行

00:02:06.960 --> 00:02:10.399
期望在发布后获得优先考虑

00:02:10.399 --> 00:02:13.599
嗯，还有一些其他的后果，例如呃

00:02:13.599 --> 00:02:18.080
我今天和民俗人谈论加速我们要做的一些工作

00:02:18.080 --> 00:02:22.879
基于Wassum的只读编解码器，因此我们可能会有一大堆只读编解码器

00:02:22.879 --> 00:02:25.360
可以链接，并且您可以安全地卸载

00:02:25.360 --> 00:02:29.840
网络，并且实际上能够使用比编解码器更多的数据来读取数据

00:02:29.840 --> 00:02:34.879
您随身携带，仅此而已

00:02:34.879 --> 00:02:38.239
在ipjs构建工具上取得了一些进步

00:02:38.239 --> 00:02:42.319
嗯，现在正在建设中，我正在测试方面

00:02:42.319 --> 00:02:47.680
嗯，以便我们主要处理UM提起的东西

00:02:47.680 --> 00:02:50.879
周末，所以嗯，那应该真的工作

00:02:50.879 --> 00:02:54.239
很快我有一个小小的尝试，我试图在其中做一个新的编译器

00:02:54.239 --> 00:02:57.760
只是astum，因为它实际上并不难

00:02:57.760 --> 00:03:00.959
但后来我意识到汇总中还有其他一些功能

00:03:00.959 --> 00:03:04.000
想使用我们将无法复制呃

00:03:04.000 --> 00:03:07.200
只是在东部，所以我实际上想出了嗯

00:03:07.200 --> 00:03:10.560
一种我们可以利用某些缓存和性能方面的方法

00:03:10.560 --> 00:03:14.720
嗯，汇总并没有遇到一些瓶颈

00:03:14.720 --> 00:03:17.760
之前的所有内容，因此实际上已实现，而且速度更快

00:03:17.760 --> 00:03:20.800
比我以前用所有这些工人之前

00:03:20.800 --> 00:03:32.560
所以看到的真的很酷，那是我在右边的地方

00:03:32.560 --> 00:03:40.080
是的，所以我的两件事主要是

00:03:41.360 --> 00:03:44.879
嗯，这只汉普顿犬在我的大部分时间里都在麻麻里度过

00:03:44.879 --> 00:03:49.519
代码um进行更改，测试和文档

00:03:49.519 --> 00:03:57.200
和那个东西在那个仓库中的拉取请求中

00:03:57.200 --> 00:04:04.080
有点把这个交给了远古钱币的人

00:04:04.080 --> 00:04:08.560
嗯，其他人似乎只是一个带宽问题

00:04:08.560 --> 00:04:12.239
处理那个嗯

00:04:12.640 --> 00:04:15.760
好吧，似乎史蒂文（Steven）今天已经合并了一些东西，所以很好

00:04:15.760 --> 00:04:21.440
嗯，然后嗯，回到一些JavaScript

00:04:21.440 --> 00:04:24.000
只是为了

00:04:24.080 --> 00:04:28.000
尝试使一些其他东西关闭，但嗯

00:04:28.000 --> 00:04:32.320
除了没什么要报告的，没有别的要报告的了

00:04:32.320 --> 00:04:36.240
我确实有埃里克一起去参加一些比赛

00:04:36.240 --> 00:04:40.160
他正在做一些基准测试，并试图

00:04:40.160 --> 00:04:45.199
弄清楚冲洗语义是如何工作的以及它们实际上是什么

00:04:45.199 --> 00:04:50.880
受益了，嗯，他为此得到了一些很好的文档

00:04:50.880 --> 00:05:00.240
嗯，是的，这对我来说真的很好嗯，还有其他人想要吗

00:05:00.240 --> 00:05:03.440
提供任何更新或

00:05:03.759 --> 00:05:07.039
如果没有的话，我们也可以公开讨论

00:05:07.039 --> 00:05:11.840
有什么要谈论或讨论的

00:05:14.400 --> 00:05:20.080
对于ipld来说，这似乎是一个相当安静的一周

00:05:21.600 --> 00:05:24.960
我的意思是上周实际上发生了很多事情，并且完成了很多工作，

00:05:24.960 --> 00:05:29.840
没有很多与此相关的公开问题，这仅仅是

00:05:29.840 --> 00:05:34.800
喜欢发生的事情，它发生了，嗯

00:05:34.800 --> 00:05:39.360
我们可以谈谈你们的情况吗

00:05:39.360 --> 00:05:42.880
在迈克尔工作消费已经互相交谈你怎么设想

00:05:42.880 --> 00:05:47.280
那不是实现只读的东西

00:05:47.280 --> 00:05:50.720
基本上，这将是对

00:05:50.720 --> 00:05:56.000
链接加载程序，否则将会更多，给真棒一个流，然后返回

00:05:56.000 --> 00:05:59.840
块或其他不，这肯定是

00:05:59.840 --> 00:06:04.240
与所有块数据一样一次性进行事务处理

00:06:04.240 --> 00:06:07.520
只是你知道这是一个块，所以给我解码了

00:06:07.520 --> 00:06:12.000
该版本或更准确地说是

00:06:12.000 --> 00:06:16.319
像这里是x格式的块数据给我回去挖c

00:06:16.319 --> 00:06:20.560
 bar um，因为您必须喜欢会有某种

00:06:20.560 --> 00:06:23.280
无论如何，二元文明，这是我们唯一知道的每个人

00:06:23.280 --> 00:06:26.400
已经拥有并且它支持整个数据模型，因此

00:06:26.400 --> 00:06:29.759
嗯，这也许就是它的作用，但其中一些细节仍在

00:06:29.759 --> 00:06:32.000
算出来的，但绝对不需要与流一起使用

00:06:32.000 --> 00:06:36.639
因为它总是一次处理整个块

00:06:38.400 --> 00:06:42.319
对，所以基本上您将要承担

00:06:42.319 --> 00:06:48.800
呃，在每个链接上都放进了很棒的灯笼，是的，这不是故意的

00:06:48.800 --> 00:06:51.840
世界上最快的事物，例如您知道您是否要真正执行

00:06:51.840 --> 00:06:56.080
像您将附带本机版本的编解码器，我想像是um

00:06:56.080 --> 00:06:59.520
这主要是因为您希望能够读取

00:06:59.520 --> 00:07:04.400
您没有随附编解码器iv，因此可能只是一点点

00:07:04.400 --> 00:07:07.840
您知道的速度较慢，尤其是如果我们最终在海滨对其进行编码，因为

00:07:07.840 --> 00:07:11.360
从字面上看，您将把它传递给wasm get

00:07:11.360 --> 00:07:15.440
它解码，然后再次按字面量解码为滑行板，因此

00:07:15.440 --> 00:07:19.599
对对对，所以您可以拉出链接，嗯

00:07:19.599 --> 00:07:26.479
获得阅读器或其他内容的受信任版本的机制

00:07:26.479 --> 00:07:28.800
就像您是矿工一样

00:07:28.800 --> 00:07:33.440
然后您会达成协议，接下来会发生什么，所以我们会

00:07:33.440 --> 00:07:36.880
公布一个dag的cid，那个dag会

00:07:36.880 --> 00:07:41.039
将编解码器标识符与

00:07:41.039 --> 00:07:46.639
wasm二进制文件，因此您将查找

00:07:46.639 --> 00:07:49.039
那个嘿，就像那其中之一，然后你会

00:07:49.039 --> 00:07:53.039
拔出它，然后您就像一个电话，就像一个您知道一个

00:07:53.039 --> 00:07:55.520
不分享任何内容，称为合著者

00:07:55.520 --> 00:07:59.759
这是一个数据块，一些内存可以为我解码

00:07:59.759 --> 00:08:04.160
你现在就知道民俗了，我考虑一下，我认为彼得是对的，我们应该

00:08:04.160 --> 00:08:08.240
除了反序列化整个结构外，还放置um

00:08:08.240 --> 00:08:11.280
我们应该有一种方法让您返回

00:08:11.280 --> 00:08:15.840
只是cds嗯，想出了某种

00:08:15.840 --> 00:08:18.879
仅对ID进行序列化，因为如果您只是在解析

00:08:18.879 --> 00:08:22.879
所有链接出来以进行遍历的图

00:08:22.879 --> 00:08:26.400
是的，但问题是您需要这样做，而当我们只是

00:08:26.400 --> 00:08:29.520
削减它我想过一样，但问题是你仍然需要

00:08:29.520 --> 00:08:33.519
所以您还需要返回路径，因为基本上是的，您继续

00:08:33.519 --> 00:08:36.719
之类的，然后让您出发前往

00:08:36.719 --> 00:08:40.080
cid，因此您还需要返回通往城市的路径

00:08:40.080 --> 00:08:43.680
然后，嗯，这整个街区都还给我

00:08:43.680 --> 00:08:47.519
链接的所有路径，所以路径和链接

00:08:47.519 --> 00:08:51.040
然后那只是一个元组数组，所以您只需做一个seabor数组

00:08:51.040 --> 00:08:55.440
元组返回是的，但情况会有所不同

00:08:55.440 --> 00:08:59.200
这将是与完全解码完全不同的调用，是的，是的

00:08:59.200 --> 00:09:02.720
就像这样，基本上，第一个版本可能只是

00:09:02.720 --> 00:09:06.000
返回所有内容，然后您可以添加诸如路径之类的内容

00:09:06.000 --> 00:09:08.880
这是最基本的版本

00:09:08.880 --> 00:09:14.480
我想路径，所以你会得到更大的链接，然后你可以添加新的像

00:09:14.480 --> 00:09:18.560
但是我想是的，是的，我们应该开始设计

00:09:18.560 --> 00:09:21.360
数据结构，但数据结构基本上应该像

00:09:21.360 --> 00:09:29.040
嗯，就像是编解码器的结构，然后是每种方法的结构

00:09:29.040 --> 00:09:32.320
对于这些方法中的每一种，您将只有一个单独的wasm条目

00:09:32.320 --> 00:09:34.880
指向正确

00:09:35.600 --> 00:09:39.279
是的，就像一个基本上被称为

00:09:39.279 --> 00:09:42.800
是的，就像您添加了完全称为cid的代码一样，或者您称它为是

00:09:42.800 --> 00:09:47.440
遍历是的，对链接进行解码，每个链接就像一个单独的链接

00:09:47.440 --> 00:09:53.440
是的，您需要维护

00:09:54.240 --> 00:09:58.240
抱歉，您需要保持小径或呼吸痉挛

00:09:58.240 --> 00:10:01.760
称其为支持专业

00:10:01.760 --> 00:10:06.000
仅选择器或其他选择器

00:10:06.000 --> 00:10:09.279
不，我不，我不知道深度部分来自哪里，但是

00:10:09.279 --> 00:10:12.880
嗯，不是，不是深度，而是实际路径

00:10:12.880 --> 00:10:16.320
就像为什么你需要维护那一部分

00:10:16.320 --> 00:10:20.560
嗯，您通常不需要知道链接的路径以及遍历的时间

00:10:20.560 --> 00:10:24.160
取得链接的块，无论如何，您都有路径，就像我们所有的api一样

00:10:24.160 --> 00:10:27.279
只是为您提供了块中的所有链接，也为您提供了路径

00:10:27.279 --> 00:10:31.440
因为没有理由没有，但是在这种情况下，这是有原因的

00:10:31.440 --> 00:10:36.399
不是因为为什么

00:10:36.399 --> 00:10:41.279
嗯，这整个东西的设计就变成了

00:10:41.279 --> 00:10:44.959
甚至更简单，因为您甚至根本不需要

00:10:44.959 --> 00:10:48.480
想想如何在此编解码器或类似的内容中解码地图

00:10:48.480 --> 00:10:51.200
实际上，仅需要在c中寻找

00:10:51.200 --> 00:10:57.440
任何标记为42的东西，您都不关心它是什么结构

00:10:57.680 --> 00:11:00.800
你只需要你而已

00:11:04.860 --> 00:11:09.170
[笑声]

00:11:10.320 --> 00:11:15.040
取决于预测变量，所以说选择器选择

00:11:15.040 --> 00:11:20.399
在您的对象中存在某些内容，而您只使用了您不能使用的ID

00:11:20.399 --> 00:11:24.160
所以从选定的角度来看，您无法分辨

00:11:24.160 --> 00:11:27.200
如果您要选择这个LED

00:11:27.200 --> 00:11:31.040
是的，这实际上是我问的问题，这是仅用于选择器还是

00:11:31.040 --> 00:11:34.320
您还需要其他东西，因为其中的上下文

00:11:34.320 --> 00:11:40.800
我们需要整件事，选择器还是一个全选

00:11:40.800 --> 00:11:44.399
不，但不一定，我的意思是您可以制作一个特定于一个选择器的选择器。

00:11:44.399 --> 00:11:48.320
路径，然后您需要知道它是的

00:11:48.320 --> 00:11:52.160
在文件硬币的情况下，可能不会是这种情况

00:11:52.160 --> 00:11:54.959
我想说的是

00:11:55.279 --> 00:11:59.760
我的意思是，我们拥有整个选择器引擎，实际上

00:11:59.760 --> 00:12:01.680
在检索市场上使用它，我们还没有

00:12:01.680 --> 00:12:07.040
还探讨了人们将如何处理这个数字，如果您特别

00:12:07.040 --> 00:12:10.160
其中一些像潜在的部分图案例，例如

00:12:10.160 --> 00:12:13.200
我们已经考虑过像递归一样的um

00:12:13.200 --> 00:12:16.959
路径和类似事物中的选择性标准，因此您

00:12:16.959 --> 00:12:20.639
想要它，我的意思是我不反对只拥有

00:12:20.639 --> 00:12:25.040
两种方法，但是给定的是，就像我们不知道编解码器一样

00:12:25.040 --> 00:12:27.360
在其中我们可以轻松解析出链接

00:12:27.360 --> 00:12:30.560
反正没有得到路径信息

00:12:30.560 --> 00:12:35.040
就像我所知道的所有当前编解码器一样

00:12:35.040 --> 00:12:38.959
当您去查看它们以获取所有链接时，即使

00:12:38.959 --> 00:12:43.040
解析出您必须累积链接路径的链接

00:12:43.040 --> 00:12:46.320
所以没有理由不退货，我想

00:12:46.320 --> 00:12:49.680
从理论上讲，将来可能会有一种块格式

00:12:49.680 --> 00:12:53.120
将所有链接放在标头中，不包含指向它们的路径

00:12:53.120 --> 00:12:57.519
当然有可能，但我不确定

00:12:57.519 --> 00:13:02.720
如果我们应该为此优化它，那是因为它将使

00:13:02.720 --> 00:13:06.000
dag更大，因为我们最终将有两种方法

00:13:06.000 --> 00:13:09.440
对于每个编解码器，一个仅用于链接，一个用于路径长度

00:13:09.440 --> 00:13:13.200
不，那很好，我只是想确保已将其考虑在内

00:13:13.200 --> 00:13:16.959
可以满足您的需要，实际上不需要路径

00:13:16.959 --> 00:13:22.639
完全可以满足其中一种用例，但我们要保持灵活性

00:13:22.639 --> 00:13:26.880
嗯，我们在javascript块api中做了同样的事情，将其返回给

00:13:26.880 --> 00:13:29.760
路径也

00:13:32.839 --> 00:13:35.600
嗯，哦，我忘了放一件事

00:13:35.600 --> 00:13:38.000
我应该添加的笔记是，我们确实有dag

00:13:38.000 --> 00:13:42.000
乔瑟·科斯（Jose Cose）上个星期打来的电话，实际上一切进展顺利

00:13:42.000 --> 00:13:47.199
嗯，事情要比我们最初将它们简化为简单得多

00:13:47.199 --> 00:13:54.480
嗯是的，那是最高级的

00:13:54.480 --> 00:13:59.519
deg jose和kosei的数据格式将与dag保持不变

00:13:59.519 --> 00:14:03.279
jose和kosei spec它的外观基本相同

00:14:03.279 --> 00:14:08.240
但是当您使用dag jose或tag cose编解码器时

00:14:08.240 --> 00:14:11.760
这意味着您正在签名的东西是一个链接

00:14:11.760 --> 00:14:15.920
因此您要签名的二进制有效负载应解释为

00:14:15.920 --> 00:14:19.600
链接，并在我们的法典中，我们希望您知道添加一个

00:14:19.600 --> 00:14:22.880
称为链接的有效负载的邻接属性，使其类似于

00:14:22.880 --> 00:14:25.519
您将遍历的已解码数据

00:14:25.519 --> 00:14:28.959
嗯，我认为我们讨论过，还将有一个版本化的版本

00:14:28.959 --> 00:14:35.040
cid，所以它至少暗示了一个版本，我认为我们登陆的版本是

00:14:35.040 --> 00:14:39.440
我们我们说过应该使用这种狗屎吗，是的，我想我们

00:14:39.440 --> 00:14:41.440
必须弄清楚措辞，我想补充一下

00:14:41.440 --> 00:14:47.519
到呃，我想我们将在哪里转储该文档

00:14:47.519 --> 00:14:51.760
嗯，我相信我们有开放和启动的PRS

00:14:51.760 --> 00:14:55.279
对于那些嗯，他们的规格

00:14:55.279 --> 00:14:58.560
真的很复杂，因为他们在谈论替代方案

00:14:58.560 --> 00:15:00.480
之类的东西，但是现在它们应该很多

00:15:00.480 --> 00:15:05.040
比较简单，所以我认为在ipld规格库中应该有一个开放的公关

00:15:05.040 --> 00:15:09.760
今天的jose cosey spec um，那就是我们想说的

00:15:09.760 --> 00:15:13.040
那里的垃圾，实际上确保我们在努力，我认为另一件事

00:15:13.040 --> 00:15:16.480
我正在研究的是切线但是嗯

00:15:16.480 --> 00:15:23.279
ipld的abnf表示法，所以abnf就像所有语法一样

00:15:23.279 --> 00:15:28.480
以获得完全合格的网址，因此必须这样做ii提到了它

00:15:28.480 --> 00:15:31.920
对Dietrich um简要介绍了一下，因为我正在努力获取

00:15:31.920 --> 00:15:36.240
ipfs冒号计划名称已注册，我选择了我

00:15:36.240 --> 00:15:40.480
丢球主要是因为我是完全合格的

00:15:40.480 --> 00:15:44.639
像路径查询的类似片段必须冲洗掉，并且

00:15:44.639 --> 00:15:47.120
规范的当前草案实际上并没有拼写

00:15:47.120 --> 00:15:51.120
那出来，但我想我一直在等着做ipld，直到实际上变得像

00:15:51.120 --> 00:15:55.920
像选择器之类的东西，例如完整路径查询片段

00:15:55.920 --> 00:15:59.920
嗯，我觉得嗯

00:16:01.199 --> 00:16:04.240
我很好奇您的想法，因为它肯定像

00:16:04.240 --> 00:16:08.399
像整个选择器这样的实例就像这样的大图段

00:16:08.399 --> 00:16:11.199
可以肯定会缩短的东西

00:16:11.199 --> 00:16:16.320
基本上就像一个代表选择器的ac id

00:16:16.320 --> 00:16:19.759
对，我们还讨论了选择器和

00:16:19.759 --> 00:16:23.680
选择器查询，可能是稍微不同的架构

00:16:23.680 --> 00:16:27.199
我们也将其嵌入

00:16:28.000 --> 00:16:31.120
为了尽快获得可用的东西

00:16:31.120 --> 00:16:34.959
我们可以考虑只做而不是ipld冒号，而只是cid冒号

00:16:34.959 --> 00:16:38.959
击倒，然后没有选择器，没有任何东西，这只是一个URL方案

00:16:38.959 --> 00:16:43.279
指向可能在过渡期间有用的CD

00:16:43.279 --> 00:16:45.360
因为我不知道我们什么时候才知道

00:16:45.360 --> 00:16:48.800
路径和选择器的东西就像我们每次

00:16:48.800 --> 00:16:53.120
我们打开那个盒子，它的底部看起来比以前更深

00:16:53.120 --> 00:16:57.360
嗯，所以嗯，我的意思是说，即使走了我们也不会

00:16:57.360 --> 00:17:01.279
有一个稳定的规范，而且您知道彼得实际上对此不起作用

00:17:01.279 --> 00:17:04.480
嗯，我们仍然不喜欢它

00:17:04.480 --> 00:17:08.160
是的，是的，这就像是一个真正的

00:17:08.160 --> 00:17:12.319
难题，我老实说

00:17:12.319 --> 00:17:17.439
您正在谈论的一些在选择器中选择的内容

00:17:17.439 --> 00:17:20.480
可能会像我们可能为我们解决其中的一些问题

00:17:20.480 --> 00:17:23.839
就像说你知道什么可能实际上要容易得多

00:17:23.839 --> 00:17:27.919
您只需要将选择器编码为一个我感觉到的对象，然后引用

00:17:27.919 --> 00:17:31.679
它通过cid而不是试图让您知道路径

00:17:31.679 --> 00:17:36.480
作为选择标准um，因为它太复杂了um

00:17:36.480 --> 00:17:40.559
那可能像是合理的解决方案，是的，我想我喜欢那个，我

00:17:40.559 --> 00:17:44.240
像柏林一样跟艾瑞克谈起了那个

00:17:44.240 --> 00:17:47.760
是前一段时间哦，是的，是的，我是说我们也是

00:17:47.760 --> 00:17:52.400
从um的角度来看它，我们想指出的是

00:17:52.400 --> 00:17:56.080
像汽车文件格式的未来版本一样的汽车文件

00:17:56.080 --> 00:18:01.039
um在标头中包含一个选择器，因此选择器基本上是

00:18:01.039 --> 00:18:04.640
创建汽车文件的选择标准，即使它不完整

00:18:04.640 --> 00:18:07.600
图你总是有一个完整的选择器

00:18:07.600 --> 00:18:12.480
嗯，那肯定是一个选择器查询

00:18:12.880 --> 00:18:16.720
我正在努力与一些互操作性

00:18:16.720 --> 00:18:20.960
做了使用json ld的方法，我希望能够

00:18:20.960 --> 00:18:27.840
在呃seabor dagsebor之间转换回json native.json和

00:18:27.840 --> 00:18:30.559
代表这一点，知道我们说的路径

00:18:30.559 --> 00:18:34.400
是的，是的，嗯，链接是斜线链接，

00:18:34.400 --> 00:18:38.240
 json或标签42，而cbor表示为

00:18:38.240 --> 00:18:40.960
在这种情况下，基本上是完全合格的uri

00:18:40.960 --> 00:18:44.080
符合规格

00:18:44.080 --> 00:18:49.919
对对没有人，是的，如果您需要填充

00:18:49.919 --> 00:18:53.679
总是有点困难，嗯，我真的不需要填充

00:18:53.679 --> 00:18:57.280
尽管那会有所帮助，因为那时

00:18:57.280 --> 00:18:59.520
有这么多的健壮性，实际上

00:18:59.520 --> 00:19:04.000
你可以用我做过ipld的dod方法为我特别做

00:19:04.000 --> 00:19:07.760
锚定到特定的区块链实际上是

00:19:07.760 --> 00:19:10.880
重要，因为我与区块链无关

00:19:10.880 --> 00:19:14.880
在进行证明签名并将这些证明锚定到

00:19:14.880 --> 00:19:17.760
存在的证明

00:19:20.960 --> 00:19:25.760
我确实想知道我们是否像一个简单的路径规范那样丢失了

00:19:25.760 --> 00:19:29.679
嗯，因为我们有数据模型，如果我们愿意说护垫只是

00:19:29.679 --> 00:19:32.799
唯一的数据模型，我们不会触及到它们，并且

00:19:32.799 --> 00:19:37.440
那时您就像在选择器中一样，我们应该只能借用

00:19:37.440 --> 00:19:41.200
伯爵之路规则并说，当你落入这之外

00:19:41.200 --> 00:19:45.679
对不起，我们无法传递您的数据，因为我们拥有我的意思是我们拥有数据

00:19:45.679 --> 00:19:49.120
它指定的模型

00:19:49.120 --> 00:19:53.360
不同的潜在键值会起作用

00:19:53.360 --> 00:19:56.400
我不认为我们现在拥有出色的差异化系统

00:19:56.400 --> 00:19:59.760
在整数和字符串之间，这是我唯一的事情

00:19:59.760 --> 00:20:03.440
对嗯感到不舒服，目前的路径是

00:20:03.440 --> 00:20:08.159
我认为基本上是json指针，所以您基本上就像索引到一个

00:20:08.159 --> 00:20:14.720
阵列中的特定项目是的，是的，我喜欢，如果我们有一个

00:20:14.720 --> 00:20:17.840
我愿意放出常规规格的解决方案

00:20:17.840 --> 00:20:21.600
那只是在数据模型上，因为我们也说

00:20:21.600 --> 00:20:25.600
我认为该字符串um映射键需要为utf-8

00:20:25.600 --> 00:20:29.440
在数据模型规范中也是如此，是的，这是很大的

00:20:29.440 --> 00:20:32.720
对我来说这笔交易很关键，因为我提到的cbor允许

00:20:32.720 --> 00:20:36.000
整数作为键，这就是cbore的好处

00:20:36.000 --> 00:20:39.280
所以我认为是的，但是我们不支持

00:20:39.280 --> 00:20:42.720
索引我们从字面上逐字地阻止它在迪克西

00:20:42.720 --> 00:20:47.200
完全正确，我将其反映为基本规格

00:20:47.200 --> 00:20:50.559
反映了这一点，因为我不希望它基本上是ipld，但

00:20:50.559 --> 00:20:54.320
向后兼容或基本上允许

00:20:54.320 --> 00:21:01.039
ipld顶部有一个完整的孔，在这种情况下，cid指向

00:21:01.039 --> 00:21:05.760
拖曳一个海港对象，在这种情况下，您只需要使用

00:21:05.760 --> 00:21:11.039
cbor这种情况下一切正常，只是翻译而已

00:21:11.039 --> 00:21:17.120
在这个大的iple对象和东西之间，我需要一个

00:21:17.120 --> 00:21:20.720
为了让人们知道这是

00:21:20.720 --> 00:21:29.520
MIME类型是应用程序cbor加ipld，或者它在json中，但json开头为

00:21:29.520 --> 00:21:34.159
ipld冒号斜杠斜杠哦，有趣的是，我什至不知道

00:21:34.159 --> 00:21:36.880
实际上是斜杠松弛，因为它不是分层的，对不起

00:21:36.880 --> 00:21:41.200
它是分层的，因为它是一个dag但它不是权威的

00:21:41.200 --> 00:21:46.720
因此，这条规则必须说到

00:21:46.720 --> 00:21:51.200
完全合格的uri所需要的语法

00:21:51.200 --> 00:21:56.080
是ipld物件正确正确

00:21:56.080 --> 00:22:00.320
我的意思是说数据模型还说映射键必须是字符串

00:22:00.320 --> 00:22:05.200
因此，如果我们只是纯粹的数据模型，那么我们就可以区分

00:22:05.200 --> 00:22:09.440
我们仍然需要语法来区分

00:22:09.440 --> 00:22:13.360
来自项目的数组中的项目也来自的数组

00:22:13.360 --> 00:22:16.640
映射中的字符串键，以区分字符串

00:22:16.640 --> 00:22:24.159
来自um的零，是相反的零，是的，所以彼得

00:22:24.159 --> 00:22:26.000
至少在幽灵选择器中

00:22:26.000 --> 00:22:31.760
实施，它作为一种在

00:22:31.760 --> 00:22:36.880
解析器端，因此如果它是数组，则将其视为偏移量

00:22:36.880 --> 00:22:40.320
映射将其视为具有字符串值的键

00:22:40.320 --> 00:22:48.080
哦，真的是三四五，是的，那很聪明，我会怎么想

00:22:50.000 --> 00:22:53.520
不，不，那里没有渔获物，但地图上有渔获物

00:22:53.520 --> 00:23:00.240
字符串应该是utf-8文本，不是必须的，并且实际上有

00:23:00.240 --> 00:23:06.240
现在在规范中说明我正在测试字节字符串

00:23:06.240 --> 00:23:09.760
现在看，我们应该更改规格，因为

00:23:09.760 --> 00:23:13.840
数据模型规范说，他们必须是数据模型所期望的不对不对

00:23:13.840 --> 00:23:16.910
我们，它没有说应该说什么

00:23:16.910 --> 00:23:22.240
[笑声]好的，我们需要改变我们不应该的

00:23:22.240 --> 00:23:25.760
我们没有几种语言的代表，因此

00:23:25.760 --> 00:23:29.280
嗯，这是我们可以确保的唯一方法

00:23:29.280 --> 00:23:35.039
像跨语言竞争者一样，不，不，所以不是，这真的是一个

00:23:35.039 --> 00:23:38.159
真正的好处是，虽然实际上您可以

00:23:38.159 --> 00:23:44.080
定义数据上的行为，而不是对数据的解释

00:23:44.080 --> 00:23:47.600
伯爵的路径还可以，如果您尝试做一个

00:23:47.600 --> 00:23:51.840
包含非字符串的数组不会仅仅失败

00:23:51.840 --> 00:23:54.799
是的，如果您要尝试

00:23:54.799 --> 00:23:58.880
地图，它将只是将其转换，然后这也将迫使人们

00:23:58.880 --> 00:24:06.240
永远无法使用忍者地图键

00:24:06.240 --> 00:24:11.039
嗯，是的，让我们在那时获得该规格

00:24:11.039 --> 00:24:14.799
进行数据模型填充，然后我们可以利用具有

00:24:14.799 --> 00:24:19.039
我们将需要的任何一种uri规范

00:24:19.039 --> 00:24:22.400
对我来说听起来不错，然后您知道

00:24:22.400 --> 00:24:25.440
对于更高级的东西，我们稍后可以找出选择器，就像这样

00:24:25.440 --> 00:24:28.240
仅数据模型

00:24:29.760 --> 00:24:36.480
酷好吧，很棒，很好，聊天其他

00:24:40.000 --> 00:24:46.400
好的，很好，那么，嗯，这是会议的结束，

00:24:46.400 --> 00:24:50.400
我们下周再见面，然后再见

00:24:50.400 --> 00:24:52.720
再见

00:24:53.520 --> 00:24:56.880
你想早点见面吗

00:24:56.880 --> 00:24:59.279
凉爽的

