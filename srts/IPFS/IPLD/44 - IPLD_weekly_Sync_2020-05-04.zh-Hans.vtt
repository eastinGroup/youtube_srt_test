WEBVTT
Kind: captions
Language: zh-Hans

00:00:12.110 --> 00:00:23.250
好的，欢迎大家参加虚假的ILD同步会议

00:00:23.250 --> 00:00:29.880
在20 Fendi上，每周我们都会回顾过去所做的事情

00:00:29.880 --> 00:00:40.079
一周，然后讨论我们可能为与会者准备的所有未结项目

00:00:40.079 --> 00:00:47.100
您的名字在清单上不错，是的，所以我从我自己开始，所以在

00:00:47.100 --> 00:00:52.800
过去一周，我已经完成了关于块API的最后一个图标D的工作，我认为这是

00:00:52.800 --> 00:00:57.210
准备好了，然后我发现显然IP LD也需要通用

00:00:57.210 --> 00:01:01.829
通过Codex，以便它可以传入您自己的当前IP LD的同事表中

00:01:01.829 --> 00:01:08.280
使用马蒂哈希和CID提供的正确表，有点像

00:01:08.280 --> 00:01:11.790
更大的变化，可能需要与其他人进行更多讨论

00:01:11.790 --> 00:01:15.890
贡献者，因此我将首先进行此更改，然后再返回到本书的API

00:01:15.890 --> 00:01:22.530
然后按照Chason规范，我花了一个小时让事情变得更清晰，

00:01:22.530 --> 00:01:28.200
将其收紧，并进行了明确的讨论，我希望我们能够

00:01:28.200 --> 00:01:36.360
可以解决这个问题，只是保持他们追求简单，因为似乎

00:01:36.360 --> 00:01:43.979
在C ID的基本编码上达成协议，但是希望我们继续

00:01:43.979 --> 00:01:51.180
我最喜欢的最简单的解决方案，但是在我的解码东西上可能是C和

00:01:51.180 --> 00:01:55.409
Rods的一项也是，最后你写了，我

00:01:55.409 --> 00:02:02.490
在5种硬币上达成了协议，因为他们想编辑新的新手抄本

00:02:02.490 --> 00:02:10.649
得出的结论很简单，我们仍然不确定为什么

00:02:10.649 --> 00:02:13.860
他们想为自己的东西添加到食典中，但是

00:02:13.860 --> 00:02:18.960
我们相信他们，因此我们同意他们应该使用正确的电缆进行编辑，

00:02:18.960 --> 00:02:24.540
我们仍然希望对真正需要它的原因进行解释，但是我们会看看是否

00:02:24.540 --> 00:02:32.340
到目前为止，这还不算很酷，是我清单上的下一个内容

00:02:32.340 --> 00:02:35.120
是迈克尔

00:02:36.970 --> 00:02:44.740
是的，是的，所以大多数的多格式工作都已完成，所有规范都已实现

00:02:44.740 --> 00:02:49.480
现在，CNE的东西就在那里，有所有的刹车更换和完整的测试覆盖范围

00:02:49.480 --> 00:02:54.670
现在我们在谈论这个二进制的东西，试图弄清楚我们是否可以

00:02:54.670 --> 00:02:56.980
是否删除缓冲API，这是很好的

00:02:56.980 --> 00:03:04.840
就像我们可能知道的那样，是的，我将继续进行下一步，有两个步骤

00:03:04.840 --> 00:03:08.980
开始移植所有编解码器，然后倒入新的模块接口

00:03:08.980 --> 00:03:15.340
所以还有很多工作要做，但是是的，基本接口是

00:03:15.340 --> 00:03:21.780
在那里，它起作用了，而且非常不错，所以人们肯定应该研究它

00:03:21.780 --> 00:03:27.250
我在登革热D方面也取得了更多进步，所以这里有一个索引引擎

00:03:27.250 --> 00:03:34.510
现在，这是一个非常有趣的数据结构，

00:03:34.510 --> 00:03:38.710
进入并将枚举支持添加到我编写的架构验证库中

00:03:38.710 --> 00:03:44.230
因此，我认为模式语言的完整实现

00:03:44.230 --> 00:03:47.920
我很确定我会在这里遗失一些角落，但我想我已经掌握了所有

00:03:47.920 --> 00:03:57.220
他们现在哦，我也训练了他在工作中的Block API上真的很讨厌的错误

00:03:57.220 --> 00:04:02.470
在没有嵌入的简单管道中传递的东西

00:04:02.470 --> 00:04:05.980
在字符串内部的方式，我们实际上将它们弄乱了很多，所以

00:04:05.980 --> 00:04:09.880
这真的很糟糕，为此感到宽慰

00:04:09.880 --> 00:04:29.710
所以现在已经修复，对于IPL来说，这肯定是一个

00:04:29.710 --> 00:04:35.440
一堆很久以前开始的东西，只是那种类型的虚弱

00:04:35.440 --> 00:04:38.800
理论词汇表，在此过程中，人们发表了大量评论

00:04:38.800 --> 00:04:47.050
该小组现已登陆，感谢大家对此发表评论，这也令人恐惧

00:04:47.050 --> 00:04:52.050
试图对类型理论的总结进行任何连贯的讨论，其中

00:04:52.050 --> 00:04:56.529
不要对任何特定的术语给予过多的信任，但仍然会变得超级出色

00:04:56.529 --> 00:05:00.400
具体的和建造的那些很难达到平衡，所以它是

00:05:00.400 --> 00:05:04.719
顺便说一句，也许仍然还不完美，如果有人

00:05:04.719 --> 00:05:10.180
仅凭其后的PR就能获得很棒的图书馆设计建议文档

00:05:10.180 --> 00:05:16.060
也合并了，我开始做大量的示例工作，好吧，我完全没有开始

00:05:16.060 --> 00:05:20.469
在忙忙碌碌地做示例工作时，我填充了主泵，所以这些是测试文件

00:05:20.469 --> 00:05:26.289
可执行文件，也作为文档示例显示

00:05:26.289 --> 00:05:33.129
在线可能会需要更多的东西，但是我已经有了一个起点

00:05:33.129 --> 00:05:37.569
解决Linga API设计问题，我想这是

00:05:37.569 --> 00:05:42.099
我同时尝试的Java Script是该芯片

00:05:42.099 --> 00:05:48.240
解决如何在链接的同时具有合理的接口

00:05:48.240 --> 00:05:55.120
链接代码之间没有真正具体的依赖关系

00:05:55.120 --> 00:05:58.029
这样的事情，以便依存关系树不会传递出去

00:05:58.029 --> 00:06:05.469
手和我为此解决的解决方案目前有效

00:06:05.469 --> 00:06:11.889
没有一个失控的依赖树，但是你也知道

00:06:11.889 --> 00:06:16.180
令人愉悦或简洁的使​​用方式，就像没人真正喜欢它一样

00:06:16.180 --> 00:06:21.339
我自己也包括在内，如果有人想

00:06:21.339 --> 00:06:27.159
看看他们，也许他们会和当地人一起玩我不知道更多

00:06:27.159 --> 00:06:29.310
我想以后仍然需要努力

00:06:29.310 --> 00:06:33.219
一周唯一的好消息是其他许多运输依赖

00:06:33.219 --> 00:06:36.370
IPL d-prime的球现在已经传到了最新一代的球机上，

00:06:36.370 --> 00:06:47.219
请注意汇编器的内容，这对我来说很令人兴奋，谢谢，接下来是

00:06:47.219 --> 00:06:52.800
Rob稍后再输入

00:06:54.520 --> 00:07:00.439
它主要是用比特币消费的，这第一件事是

00:07:00.439 --> 00:07:10.129
多种格式的文件doc着重指出，我们认为我们已经达成目标

00:07:10.129 --> 00:07:13.909
如果我能做到这一点并组建团队，他们已经准备好合并

00:07:13.909 --> 00:07:21.500
我想这不是很不令人满意，但我想我很高兴

00:07:21.500 --> 00:07:28.689
认为这反映了这个问题，我们很想让这个问题

00:07:28.719 --> 00:07:34.699
对我们的模型很满意，但是有很多这样的不同生态系统

00:07:34.699 --> 00:07:38.900
使用那个会想要使用这些东西的人会拥有他们自己的模型

00:07:38.900 --> 00:07:45.110
不一定与我们的100％重叠，所以我不知道是否达到100％

00:07:45.110 --> 00:07:49.669
舒适度是多种格式的最佳目标，就像让我们

00:07:49.669 --> 00:07:55.430
确保它确实通过了一个条，然后和它们的嵌套有点次要

00:07:55.430 --> 00:08:00.400
阈值，如果他们可以根据自己的条件进行辩护，那很好

00:08:00.400 --> 00:08:06.979
所以沃尔克和我做了一些讨论，以描述如何描述以及我们可能如何

00:08:06.979 --> 00:08:11.089
在一些医生的文件中描述这一点，以便也需要完成工作，但是他有

00:08:11.089 --> 00:08:19.310
在两种多种格式上的三个拉取请求以比特币更新表格，所以我

00:08:19.310 --> 00:08:26.180
发现上周我确实使用自己的代码在整个区块链上进行了证明

00:08:26.180 --> 00:08:31.580
认为这一次很令人兴奋，但现在我意识到它实际上

00:08:31.580 --> 00:08:37.370
根本没有进行适当的测试，因此跳过了一些事情，所以

00:08:37.370 --> 00:08:45.380
我也没有做完整的旅行我没有做完整的往返旅行

00:08:45.380 --> 00:08:51.110
需要这样做，ID代码才能代表本机结构，然后Rhian

00:08:51.110 --> 00:08:58.550
再次编写代码，所以我上周终于完成了全部工作，然后我去了

00:08:58.550 --> 00:09:03.230
通过区块链，我发现了一些极端情况，所以我现在可以告诉大家

00:09:03.230 --> 00:09:06.500
他们的比特币区块链中的边缘情况块具有

00:09:06.500 --> 00:09:13.490
他们的新颖性，所以滑轮尝试那些，并把它们放进我的测试夹具应该

00:09:13.490 --> 00:09:19.880
测试框架固定装置，但我可以成功地整体完成它

00:09:19.880 --> 00:09:29.120
现在很多，这是个好消息，这是向前迈出的一大步，我就是

00:09:29.120 --> 00:09:37.880
在眼睛上工作剥了这个东西的前端，我想我是

00:09:37.880 --> 00:09:46.100
所做的就是为Michael的新产品设计它，无论它是什么，

00:09:46.100 --> 00:09:53.480
格式化Michaels从事新界面工作的CID块工作

00:09:53.480 --> 00:09:57.200
多种格式只是所有多种格式，而不是其中一部分

00:09:57.200 --> 00:10:03.410
多种格式，所以我们可以称之为它，几乎是一种块状的东西

00:10:03.410 --> 00:10:08.750
也捆绑在那里，所以基本上是试图从

00:10:08.750 --> 00:10:15.710
您已了解util的旧API，然后进行序列化和解析，这是

00:10:15.710 --> 00:10:20.330
奇怪的结构，并为新块做了一些本机的操作

00:10:20.330 --> 00:10:28.400
API因此对编码进行解码，无论第三个编码是什么，所以因为我需要做

00:10:28.400 --> 00:10:33.740
现在至少有三种不同的类型，所以我有三种不同的编解码器

00:10:33.740 --> 00:10:43.160
比特币，这就是那里的计划，我认为我目前正在整合我的

00:10:43.160 --> 00:10:47.330
在旧的比特币JavaScript库中工作，我还没有将它放在github上

00:10:47.330 --> 00:10:52.190
但我想我只是将其包含在新内容中，将其他两个内容放进去

00:10:52.190 --> 00:10:59.930
还有另外两个同事在那里，确保我正在进行测试

00:10:59.930 --> 00:11:05.120
为此，是的，我认为现在该工作应该很快进行

00:11:05.120 --> 00:11:11.570
我已经完成了那种繁琐而乏味的位格式化工作

00:11:11.570 --> 00:11:15.080
实际上，现在我只能写一些文档，

00:11:15.080 --> 00:11:18.980
一点时间，而且也照顾孩子

00:11:18.980 --> 00:11:29.830
那是我的那是我的一周感谢任何人也有我的更新

00:11:29.830 --> 00:11:36.620
我忘了说一句话，下周基本上也是

00:11:36.620 --> 00:11:40.580
对于观看此内容的人来说，目前粗略地有一个巨大的

00:11:40.580 --> 00:11:44.630
对graphs Inc以及其他相关选择器感兴趣，但它是Remo

00:11:44.630 --> 00:11:48.980
压力，我无法将所有感兴趣的人聚在一起

00:11:48.980 --> 00:11:54.470
之所以实现，是因为他们对事物进行图形化也使用了5个硬币和无效的s

00:11:54.470 --> 00:11:59.210
因此，从两面的事物的生锈方面也有兴趣

00:11:59.210 --> 00:12:05.030
克里斯（Chris）对那浅薄的脚本方面很感兴趣，是的，所以我尝试向李

00:12:05.030 --> 00:12:08.780
收集所有聚集在一起的人，然后继续前进，

00:12:08.780 --> 00:12:13.280
他们并不需要太多的双重努力，例如像我所说的

00:12:13.280 --> 00:12:17.480
关于选择器的人们，目前有参考文献

00:12:17.480 --> 00:12:21.980
实施是在以前，还有测试在进行中，但实际上就像他们在

00:12:21.980 --> 00:12:26.270
编写的go，也许创建一些具有测试功能的东西，

00:12:26.270 --> 00:12:30.800
跨语言使用，等等，像这样的东西，这个中继器是的

00:12:30.800 --> 00:12:35.510
我想让人们聚在一起然后讨论的东西等等，所以期望像

00:12:35.510 --> 00:12:40.250
是的，只是告诉我，然后我将确保您参与其中，然后是的，我

00:12:40.250 --> 00:12:44.030
不会在发生问题的所有问题上发表文章，等等

00:12:44.030 --> 00:12:48.890
我的计划类型不明确，这种情况会在多久之前发生，但可能是这样

00:12:48.890 --> 00:12:53.330
从本周开始，然后继续到下周，是的，也是

00:12:53.330 --> 00:13:00.830
很多人都太忙了，所以我们将看看情况如何，现在我们可以开始了

00:13:00.830 --> 00:13:08.950
问题或其他任何项目

00:13:11.330 --> 00:13:19.420
如果没有问题，我可能会快速谈谈PR上的套牌追逐

00:13:19.420 --> 00:13:24.550
因为看起来又是漫长讨论的开始

00:13:24.550 --> 00:13:29.180
目前，甲板上大通基本上是一种格式，是的，主要是

00:13:29.180 --> 00:13:34.700
调试目的，目前我想收紧规格，我

00:13:34.700 --> 00:13:41.260
以为我们只将CID限制为以base64编码的M

00:13:41.260 --> 00:13:47.840
 C ID的原因是它就像base64一样随处可见

00:13:47.840 --> 00:13:53.870
即使在浏览器中也很容易，问题是您无法编码

00:13:53.870 --> 00:14:00.410
例如CID版本为零的McD，但老实说我没有发现问题

00:14:00.410 --> 00:14:07.040
使用它，因为您可以将C ID编码为CD版本1，然后进行转换

00:14:07.040 --> 00:14:10.250
将其转换为CD版本，如果您的应用程序需要它

00:14:10.250 --> 00:14:16.220
所以我应该很快就看到我们想像的是，有人真正拥有了吗？

00:14:16.220 --> 00:14:21.890
我们为什么应该支持完整的基本编码C ID的充分理由

00:14:21.890 --> 00:14:36.550
大JSON，不仅像base64，而且

00:14:36.790 --> 00:14:41.000
有很多API作为IP FS，似乎他们应该对此发表意见

00:14:41.000 --> 00:14:46.580
就像这样，我认为一堆dag JSON用于一堆

00:14:46.580 --> 00:14:51.650
那些好吧，这是个好点，不应该使用杰克的好放克

00:14:51.650 --> 00:15:00.980
他们曾经调用过的任何地方都非常喜欢JSON表示形式

00:15:00.980 --> 00:15:15.860
像IPL D那样的规范表示法，是像错误一样好，我知道那是

00:15:15.860 --> 00:15:24.320
案件，然后我撤回我的评论，我很惊讶在里面没有人

00:15:24.320 --> 00:15:27.680
使用v-0的世界会以某种JSON的形式看到想法

00:15:27.680 --> 00:15:35.270
在我看来似乎太忙的文档第三个问题是您不

00:15:35.270 --> 00:15:43.340
想要打破ipfs基本上是这样，如果像这样的事情

00:15:43.340 --> 00:15:47.840
使用JSON并看到id为零，我无法想象那是一个空集，

00:15:47.840 --> 00:16:03.170
似乎不可思议，它根本没有解决关于雪人v-0的问题

00:16:03.170 --> 00:16:10.010
有二进制表示形式还是严格地像它们一样的字符串？

00:16:10.010 --> 00:16:17.630
始终是基本58，或者如果它们实际上是零的二进制版本，则类似于

00:16:17.630 --> 00:16:25.100
但是，我的意思是您基于代码的东西是基于58的东西

00:16:25.100 --> 00:16:34.010
但是我们在任何地方都可以做到吗，例如在海边，如果

00:16:34.010 --> 00:16:45.920
二进制和链接Alpha很好，但这是经过解码的东西

00:16:45.920 --> 00:16:54.110
可以说DB 0实际上是一个多重哈希，所以有很多对话

00:16:54.110 --> 00:16:57.650
关于您了解存储更改以及与此相关的信息，我们将使用

00:16:57.650 --> 00:17:03.320
多散列仅此可能不是直接而是间接以某种方式将

00:17:03.320 --> 00:17:06.190
与某事发生冲突

00:17:08.020 --> 00:17:13.270
所以我的理解是，这些更改旨在使

00:17:13.270 --> 00:17:18.410
理解是腿，但去多帽子店的原因是这样

00:17:18.410 --> 00:17:24.310
如果您对同一数据使用CI DV 1或B 0，并且您具有相同的基础

00:17:24.310 --> 00:17:30.500
是的，绝对是我的意思是，如果在商店中我们所拥有的只是一个多

00:17:30.500 --> 00:17:35.660
从您知道的一种代码路径和从另一种代码路径的所有缓存

00:17:35.660 --> 00:17:40.490
突然间，这个东西以前一直是AK um，但现在是

00:17:40.490 --> 00:17:46.010
还要对疾病进行叙述，多缓存可能会使您陷入怪异的境地

00:17:46.010 --> 00:17:50.390
我并不是说我现在可以看到冲突发生的地方，但这只是给了我一个

00:17:50.390 --> 00:17:53.320
不好的感觉

00:17:58.520 --> 00:18:05.390
我不知道我们支持v-0的方式真的很高兴，但是有点

00:18:05.390 --> 00:18:12.950
嗯，到处都是，我知道我不知道这里有什么好的解决方案，但是我

00:18:12.950 --> 00:18:19.010
但是我就像Eric所说的那样，我想我的意思是DB有一些JSON

00:18:19.010 --> 00:18:29.090
从我的PFS输出，我想当然是像c dv0一样使用

00:18:29.090 --> 00:18:38.000
因为我要使用PP api，所以我想那是一个很好的主意

00:18:38.000 --> 00:18:41.360
支持那些人是有意义的，然后我们基本上需要支持

00:18:41.360 --> 00:18:50.600
所有类型的系列，是的，我要检查s API的IP，然后您来自

00:18:50.600 --> 00:18:55.190
在那里，我想其他人可能也期待着，就像我正在尝试的那样

00:18:55.190 --> 00:19:00.980
要记住，我确定我没有完整的摄影记忆，但是

00:19:00.980 --> 00:19:05.559
例如激进项目，我确定他们正在使用一堆

00:19:05.559 --> 00:19:11.170
JSON，他们可能期望迪斯科浴能做

00:19:11.170 --> 00:19:16.460
是的，我的意思是说做到这一点也很不错

00:19:16.460 --> 00:19:20.420
这样，我只是希望我们一如既往地将规格缩小到

00:19:20.420 --> 00:19:25.280
可能不是拥有所有可能的事物，但是如果那肯定是

00:19:25.280 --> 00:19:28.970
用在我不知道的野外，然后只说

00:19:28.970 --> 00:19:37.760
好吧，它是斜线，然后根据其步调将其称为CID，是的，是的，我们

00:19:37.760 --> 00:19:42.350
可能最终会变成此处的一般联盟和描述性规范，而不是

00:19:42.350 --> 00:19:47.000
规范性规范，您不能随便做什么，您不能随便做什么

00:19:47.000 --> 00:19:50.870
对您想要的编码进行编码，因为这样我们就想终止它们，规则就是

00:19:50.870 --> 00:19:54.679
就是说，如果是这些，就足够了，让我们做一个

00:19:54.679 --> 00:20:01.429
没关系，如果我们想要哦，是的，如果我们想要的话，那是真的，如果我们想要

00:20:01.429 --> 00:20:05.240
要拥有它可以唐娜清除代表，我们必须选择一个，但

00:20:05.240 --> 00:20:11.929
然后，但它可能会发现人们是否支持CV没有意义

00:20:11.929 --> 00:20:16.759
零，因为您也可以在它之间转换否否否但您不能

00:20:16.759 --> 00:20:22.309
零只能用五十个BTC表示，所以您仍然拥有

00:20:22.309 --> 00:20:27.289
确定性不，我是说，如果我们要对数据进行全面的分析，尽管

00:20:27.289 --> 00:20:31.220
这就是我的担心，我在这里主要担心的是，如果您希望能够做一个

00:20:31.220 --> 00:20:36.529
完整的往返行程，其中0 0和0出来，您在这里失去活动能力是一样的

00:20:36.529 --> 00:20:45.830
没有正式规则的东西，所以规则是基本上是BTC编码的

00:20:45.830 --> 00:20:51.889
这是流式表示唯一的方式，只有这样，您才能

00:20:51.889 --> 00:20:56.119
可以选择使用任何基本编码表示任何v1，即使您要

00:20:56.119 --> 00:21:04.159
查看v1基本编码的ID，它将不匹配，因此您仍保留V 1或

00:21:04.159 --> 00:21:13.299
V 0是，但他可以，但可以将其转换为CV 0 12

00:21:14.379 --> 00:21:18.889
这是不同的，不是，这实际上是一种运输，这是不同的

00:21:18.889 --> 00:21:27.169
块应该是不同的我只是说我对II这样的想法很满意

00:21:27.169 --> 00:21:34.129
将V 0表示为基数58，而V表示64，因为这样您就保留了

00:21:34.129 --> 00:21:38.570
往返功能，但如果您将所有内容都强制设为64以上

00:21:38.570 --> 00:21:43.309
每个V 0到V 1的所有内容，您都会失去往返行程，因此在任何时候

00:21:43.309 --> 00:21:47.710
你把一个V 0放到那里就变成了V 1而你不知道那是什么

00:21:47.710 --> 00:21:52.909
你不知道这件事是不是一次签证，我认为

00:21:52.909 --> 00:21:56.990
我认为更可能是那种信息的信息

00:21:56.990 --> 00:22:02.059
在离我们像某人更远的地方的道路上至关重要

00:22:02.059 --> 00:22:07.970
写下依赖于V的事实的软件堆栈

00:22:07.970 --> 00:22:12.080
零，然后他在哪里，我知道一切都应该是v1生活，而我

00:22:12.080 --> 00:22:18.679
认为这会破坏太多东西，以至于要记住的是，像那些

00:22:18.679 --> 00:22:21.619
我们现在有了这个新的东西，现在真的在努力减少对他们的依赖

00:22:21.619 --> 00:22:25.430
多种格式的内容，您可以在其中了解对这​​些内容的支持

00:22:25.430 --> 00:22:28.820
人们将放弃对base 58的支持，因为它是唯一的base编码

00:22:28.820 --> 00:22:34.880
这需要很大的深度，所以您最终会遇到我们甚至想要的情况

00:22:34.880 --> 00:22:39.560
尽管我们在杰森编解码器发布的那一天就在死去的同性恋儿子中支持v-0

00:22:39.560 --> 00:22:45.890
如果您尝试解码或使用58编码的CID，则会抛出异常，因为

00:22:45.890 --> 00:22:51.110
人们就像没有实际运送一样，这与我们完全不一样

00:22:51.110 --> 00:22:56.510
摆脱它，就像您仍然会在这个问题上绊倒好吧，所以

00:22:56.510 --> 00:23:04.100
基本上，那么我们基本上使用贝叶斯，所以我们支持CD版本

00:23:04.100 --> 00:23:09.550
版本1我们仅支持基本编码，而版本0我们仅支持基本编码

00:23:09.550 --> 00:23:15.260
支持基础58，这是我们唯一拥有的基础表示

00:23:15.260 --> 00:23:24.050
这就是我们要做的唯一方法，我的意思是，基本上，我们不会，所以我们

00:23:24.050 --> 00:23:29.060
认为我们这样做只是为了支持，这可能是我们不支持的重点

00:23:29.060 --> 00:23:42.710
支持base 32编码版本一个系列不好，是的，好的

00:23:42.710 --> 00:23:46.880
让我想一想，这也让我结识了，因为我

00:23:46.880 --> 00:23:53.390
希瑟（Heather）的想法在代码go中动摇了，所以go CID库

00:23:53.390 --> 00:23:56.720
具有CID中所有其他元数据的结构，并且

00:23:56.720 --> 00:24:03.230
根据哈希长度和多编解码器包括版本和多国语言，并且

00:24:03.230 --> 00:24:11.030
不包括基本权利，因此代表了我拥有的所有代码

00:24:11.030 --> 00:24:14.270
这取决于那些已经存在了很长时间的ID库，并且

00:24:14.270 --> 00:24:19.910
顺便说一句不包含我的任何意见，那么基础就不是一部分

00:24:19.910 --> 00:24:23.860
因此，基础实际上不适合任何数据模型

00:24:23.860 --> 00:24:32.060
所以它仍然是基数，仍然是多基数编码，它仍然具有前缀

00:24:32.060 --> 00:24:37.100
告诉您基本编码是什么，但是Ghost CID库没有

00:24:37.100 --> 00:24:40.370
再好又坏，这不是我的意思，我告诉你

00:24:40.370 --> 00:24:48.920
不是别人的东西，所以它只是忽略了自由选择权，而是做任何事情

00:24:48.920 --> 00:24:54.280
您告诉它要做不知道无法解码您无法解码字符串或否

00:24:54.280 --> 00:24:59.780
它不保留那个花瓶曾经用过的东西的记忆哦，是的，不，那个

00:24:59.780 --> 00:25:01.670
新的CID库也不执行此操作

00:25:01.670 --> 00:25:06.440
那是10，这是一个糟糕的决定，是的，不，

00:25:06.440 --> 00:25:10.280
这样做是因为我们不想要的是您想要像确定性行为那样的亚当

00:25:10.280 --> 00:25:15.800
极端的API，您不希望它喜欢，不，我完全同意

00:25:15.800 --> 00:25:22.430
我认为，就像我对本规范的看法一样，如果它是多种的，

00:25:22.430 --> 00:25:25.610
被编码的解码器，您只是要将其传递给一个多基本编码器

00:25:25.610 --> 00:25:30.590
并没有实际检查它是否编码不正确，所以类似

00:25:30.590 --> 00:25:36.260
确定性密钥排序所面临的情况，我们最终会遇到

00:25:36.260 --> 00:25:41.780
在解码器上支持确定性行为，我们只需要喜欢

00:25:41.780 --> 00:25:46.970
指定并尝试确保所有最终编码者都做同样的事情，并做

00:25:46.970 --> 00:25:50.150
它是确定性的，所以我们真正要说的是最终编码器应该

00:25:50.150 --> 00:25:57.680
始终在v1的多基数之前使用基础知识，然后在零的情况下使用基数执行B

00:25:57.680 --> 00:26:03.560
看到我犹豫的最后一件事是，我们经历了

00:26:03.560 --> 00:26:09.410
为了使base 32成为所有地方的默认编码，我们付出了很多努力，例如

00:26:09.410 --> 00:26:16.760
2字符串的默认值将返回基数32或abt的基数，看看它是否为B零，并且

00:26:16.760 --> 00:26:19.730
这就像一个很好的非常简单的操作，您可以不用

00:26:19.730 --> 00:26:23.960
检查任何东西，您现在必须检查一下，Dubey 64

00:26:23.960 --> 00:26:28.610
明确地，我知道我们将以甲板JSON格式保存字节，

00:26:28.610 --> 00:26:33.440
就像我们经历了很多痛苦一样，将所有内容转移到32位

00:26:33.440 --> 00:26:39.380
默认情况下可以创建漂亮的网址，我只是想知道我们是否应该吃掉

00:26:39.380 --> 00:26:46.010
并使其以32为基数，以便在任何地方都保持一致

00:26:46.010 --> 00:26:49.310
我使用base 64的原因基本上是

00:26:49.310 --> 00:26:54.890
几乎每天英语都有空间64支持建筑，这与

00:26:54.890 --> 00:26:59.450
标准库之类的东西，就好像很容易使用它们

00:26:59.450 --> 00:27:04.840
这样说，即使您没有完整的东西，也不要随意使用它，并且

00:27:04.840 --> 00:27:12.230
不用32步速，所以这就是我这样做的原因，它具有很好的人类可读性

00:27:12.230 --> 00:27:19.460
我的意思是说对于32岁的孩子来说，我的工作非常细微

00:27:19.460 --> 00:27:23.540
表示JavaScript中的代码不需要任何依赖关系，而只是

00:27:23.540 --> 00:27:28.160
非常非常小的函数，并且在默认情况下设置了基本编码，因为

00:27:28.160 --> 00:27:38.840
没有深度，我有点困惑，尽管那不是那种

00:27:38.840 --> 00:27:48.440
不需要人们输入数字的目标是什么

00:27:48.440 --> 00:28:01.160
在JavaScript中使用，可以打出6位数字，因为您可以执行

00:28:01.160 --> 00:28:09.500
实际上，您知道几乎字节级转换为以32为基数到以64为基数，但是您

00:28:09.500 --> 00:28:16.730
不能以此为基础58我们实际上需要将整个事物表示为基础

00:28:16.730 --> 00:28:21.950
猜对，是的，这就是我要说的

00:28:21.950 --> 00:28:26.150
人们在游泳时会发现许多功能

00:28:26.150 --> 00:28:30.800
他们的发货仍然会得到异常解码或可能的结束编码

00:28:30.800 --> 00:28:34.250
数据库，如果我们试图使用零，因为他们将没有

00:28:34.250 --> 00:28:39.050
就是地下室，所以不是其中一种方法

00:28:39.050 --> 00:28:46.280
这实际上是定义两个固定和编码

00:28:46.280 --> 00:28:53.000
例如，看到一个数据库始终是base64，因为这只是您所知道的

00:28:53.000 --> 00:28:59.950
更短，看到一个DB 0总是基于32，那就是

00:29:00.230 --> 00:29:04.700
是的db0不能基于32，您不能基于32，您只能基于

00:29:04.700 --> 00:29:11.630
基于58 BTC，因为它又一次像是疯狂的骇客，但好处是

00:29:11.630 --> 00:29:21.919
是的，因为我们的讨论非常忙，所以我们很感叹

00:29:21.919 --> 00:29:26.330
明确指出，我们赢得的版本将基于58，因为没有其他方法

00:29:26.330 --> 00:29:35.440
现在我们讨论版本v1b以64为基础还是以32为基础，但是我的意思是

00:29:35.440 --> 00:29:43.549
迈克尔早些时候提出的观点基本上是毫无疑问的，因为如果

00:29:43.549 --> 00:29:48.340
有人需要支持说dv0的任何形状或形式，他们需要有大的na

00:29:48.340 --> 00:29:54.049
是的，我知道我实际上不知道是否大数字是

00:29:54.049 --> 00:29:57.320
被吸引我的意思是首先像我们在平台上获得学位一样

00:29:57.320 --> 00:30:02.450
现在我们在平台中有大整数，现在依赖关系被拉入

00:30:02.450 --> 00:30:07.730
实际上被称为基础X，就像一个但植入了多个基础

00:30:07.730 --> 00:30:11.980
您可能需要在幕帘中编码大JSON的炊具

00:30:11.980 --> 00:30:19.400
规范，您将需要大的提名方式，因为它代表整数

00:30:19.400 --> 00:30:28.580
以JSON中的大数字表示，因此您只是作为一种信息而已，因此我们目前正在为您

00:30:28.580 --> 00:30:32.450
意味着除了基本上，您将需要大量支持才能

00:30:32.450 --> 00:30:48.100
正确地通过甲板追逐是的，很大的数字就像是可用的

00:30:48.100 --> 00:30:53.299
是的，这是您的政策，但是无论如何，是的，这是什么呢？主要是我们

00:30:53.299 --> 00:30:59.240
我们使用bignum代表宗教，我们将其投入使用，因此当前

00:30:59.240 --> 00:31:06.890
规格，因此它可以说是这样，您知道吗，杰森（Jason）杰森（Jason）确实做了

00:31:06.890 --> 00:31:11.150
决定数字不是多少，所以我们说输入您想要的任何数字

00:31:11.150 --> 00:31:13.970
进入您的空中追逐，也要在12月继续追逐

00:31:13.970 --> 00:31:17.060
并且需要确保以您的语言表示数字

00:31:17.060 --> 00:31:22.330
基本上是什么，所以目前如果您使用JSON浏览器，则可以使用

00:31:22.330 --> 00:31:27.260
您基本上无法通过他们追逐或本机进行，因为可能会有很大的

00:31:27.260 --> 00:31:31.640
大整数，哦，因为这只是为了以防万一

00:31:31.640 --> 00:31:35.980
整数好吧，是的，签约我一直在处理的方式只是说

00:31:35.980 --> 00:31:40.880
有一条好路，那你想让大数字很好地支持吗？

00:31:40.880 --> 00:31:46.130
您将必须选择加入内容，但是您可以解析这些内容

00:31:46.130 --> 00:31:49.400
在本机上只是您可能无法从中获得大量数字，所以就像您一样

00:31:49.400 --> 00:31:54.820
以这些库的使用者的身份进行了交谈，是的，那么麻烦

00:31:54.820 --> 00:31:59.300
它的生活就像CID版本零的事情，如果我们可以使它可插拔的话

00:31:59.300 --> 00:32:05.230
希望支持CID版本零或抛出异常，这完全取决于您

00:32:05.230 --> 00:32:10.490
是的，stupido，您的意思是不，并问您关于

00:32:10.490 --> 00:32:15.200
我确实做了很多事情，就像我写的只是说

00:32:15.200 --> 00:32:23.960
几乎就像现在基本上CAG为零的方式等效于

00:32:23.960 --> 00:32:32.570
几乎是bignum的依赖，是的，所以实际上我说这是我们

00:32:32.570 --> 00:32:39.890
应该可能会更改规范，但像一般而言，所有编解码器都需要

00:32:39.890 --> 00:32:45.440
往返而没有任何损失，您的哈希值会持续存在或发生变化

00:32:45.440 --> 00:32:48.380
应该能够始终解码，然后再次编码，并且始终保持不变

00:32:48.380 --> 00:32:53.300
东西对地图的排序有影响，它也有

00:32:53.300 --> 00:32:57.650
代表数字在JavaScript中的含义，因为如果四舍五入

00:32:57.650 --> 00:33:01.700
数字，那么当您想到那是

00:33:01.700 --> 00:33:06.770
问题，例如，如果有人知道您是否我们不是在说您必须怎样做

00:33:06.770 --> 00:33:09.620
为了保持数字，我们只是在说

00:33:09.620 --> 00:33:14.030
就像您的编码器和解码器需要可靠地产生相同的

00:33:14.030 --> 00:33:21.290
即使您已经死亡或引发异常，我也不会

00:33:21.290 --> 00:33:25.030
知道支持那个权利

00:33:25.770 --> 00:33:33.570
好吧，我将回到基本编码，所以我是说我不在乎

00:33:33.570 --> 00:33:40.200
base64我们的基地32名匕首人都很有名，我只是看到基本知识

00:33:40.200 --> 00:33:45.300
所以，基本上，好吧，关键是我也想对我们做64位基数，因为我们进行了编码

00:33:45.300 --> 00:33:51.210
将这个base 64二进制化，所以无论如何，在编码之前都需要一个基础知识，所以我

00:33:51.210 --> 00:33:55.410
认为也可以将编码器城市作为基地是有道理的，因为我们有

00:33:55.410 --> 00:34:02.760
无论如何，是的，我的意思是很好，我只是在考虑我们

00:34:02.760 --> 00:34:07.740
我们正在尝试让Jason拥有这个不错的属性，您可以将其打印在

00:34:07.740 --> 00:34:12.570
可读形式，如果CID是我的基数32，那么将会更多

00:34:12.570 --> 00:34:18.600
可识别的，我不知道那还会扩大范围，所以我不知道

00:34:18.600 --> 00:34:24.240
当您考虑说唱而并非您时，它更具可读性

00:34:24.240 --> 00:34:28.200
难道您不想要CID的大小，就像您要保存十个字符一样吗？

00:34:28.200 --> 00:34:36.020
最多不超过五个字符，但值得注意的是，不是，不是

00:34:36.020 --> 00:34:43.290
七个字符是对不，不只是我认为它像11或

00:34:43.290 --> 00:34:49.370
有些东西，但更重要的是，它们不仅是人类可读的

00:34:49.370 --> 00:34:53.179
网关，您知道本地安装以及任何支持

00:34:53.179 --> 00:34:59.310
子域会看到基于ID的ID，这是两个编码的，我们需要支付64，所以您不能这样做

00:34:59.310 --> 00:35:03.630
我们可以的是，这不是塞进浏览器的邻近文档

00:35:03.630 --> 00:35:06.630
一定伤害了甲板杰森，但这并不是我们真正关心的问题，因为

00:35:06.630 --> 00:35:13.020
这些东西被隐藏了，是的，所以这很好，那么我们要进行的权衡是什么

00:35:13.020 --> 00:35:18.620
造成的是，我们将以块格式吃掉字节以保存我们的e-base

00:35:18.620 --> 00:35:22.320
稍后在我们对它们进行处理时进行编码，因为

00:35:22.320 --> 00:35:26.010
基本编码在解析时会被缓存，因此我们

00:35:26.010 --> 00:35:29.580
基本上不需要再做一次，所以有点像

00:35:29.580 --> 00:35:32.850
计算方面的效率提高，但我们实际上是在增加为什么

00:35:32.850 --> 00:35:40.310
我们谈论追逐的效率，而我追逐的效率不是

00:35:41.450 --> 00:35:49.829
也压缩思考，所以不完全是重点

00:35:49.829 --> 00:35:55.049
关于摘要，它是代表数据模型的一种格式，您可以

00:35:55.049 --> 00:36:00.210
我猜主要是出于调试目的或在平台上进行交换而使用它

00:36:00.210 --> 00:36:03.769
你真的没有像Seabury编码器之类的东西，但是他

00:36:03.769 --> 00:36:07.710
有限的平台，因此我认为将Missy剥离是有道理的

00:36:07.710 --> 00:36:13.829
依赖于您需要的外部事物，因此，如果您只需要base64

00:36:13.829 --> 00:36:18.510
编码用于解码二进制文件，您已经需要拥有

00:36:18.510 --> 00:36:23.789
CD的另一种基本编码器，如果您想使用同一编码器，则可以使用同一编码器。

00:36:23.789 --> 00:36:26.789
解码它们，如果您不想触摸或解码它们，您已经

00:36:26.789 --> 00:36:31.339
无论如何都不需要解码，所以以32或64为基数都没有关系

00:36:31.339 --> 00:36:38.970
是的，这是我的意思，但是我的意思是，我可以想象

00:36:38.970 --> 00:36:42.720
哪里有玉蛋，杰森·达拉（Jason Darla），这真令人讨厌

00:36:42.720 --> 00:36:45.900
寻找调试或正在浏览的东西，您会进入

00:36:45.900 --> 00:36:49.890
这些CI天，您必须将它们拉出并解码基础，以便重新编码

00:36:49.890 --> 00:36:54.539
您只是想看看自己喜欢的CID是什么

00:36:54.539 --> 00:36:58.440
变得像在海边处理你必须经过的地方，那是我要进入的壁橱

00:36:58.440 --> 00:37:03.329
对这样的事情是很不错的，是的，就像我猜的那样

00:37:03.329 --> 00:37:07.950
将来您会习惯以棉花支付62，如果您回到KC

00:37:07.950 --> 00:37:14.210
就像哦，嘿，这是CID，然后你好吧，我可以看到这一点很好

00:37:14.210 --> 00:37:20.250
基数64和基数32以及显然的解码器都非常小，所以它不是

00:37:20.250 --> 00:37:26.670
实际上，所以我不担心除了基数58以外的其他东西

00:37:26.670 --> 00:37:30.720
那就是那实际上是一种真正的痛苦，我们可以做到这一点吗？

00:37:30.720 --> 00:37:40.920
另一个痛苦是我没有看过代码，但是好吧，这些好吧，所以

00:37:40.920 --> 00:37:54.599
然后我们对CD使用32期编码吗？是的，我的意思是像

00:37:54.599 --> 00:38:00.029
二进制文件就像二进制文件一样，所以可能又在想着如何像链子一样

00:38:00.029 --> 00:38:02.910
用于您可能永远不会解码

00:38:02.910 --> 00:38:08.609
像您看到的base64编码字符串这样的二进制内容，我们不在乎

00:38:08.609 --> 00:38:13.619
也许是的，从实用的角度来看，很好，我的意思是当你

00:38:13.619 --> 00:38:19.200
将您自动解码的块解码到缓冲区中没有任何点

00:38:19.200 --> 00:38:22.740
但是，如果您要调试某些东西，那么您就不会在看那个东西了。

00:38:22.740 --> 00:38:28.500
所以这没关系，好​​吧，好吧，我们认为好吧，那我

00:38:28.500 --> 00:38:38.130
将根据规范进行PR，说CID版本零是基于58编码的CID

00:38:38.130 --> 00:38:45.990
版本一是空间32编码的，基本上，是的，这很棒，而且

00:38:45.990 --> 00:38:51.359
那么您就可以对自己的日常活动进行规范的表示，因为往返

00:38:51.359 --> 00:39:02.490
是的，很酷的事情，所以我想这节省下来了，就像我不喜欢两个小时

00:39:02.490 --> 00:39:12.119
每个人都在github上讨论它，我想是的，很酷，是的，我会这样做

00:39:12.119 --> 00:39:14.579
明天很酷，谢谢你抽时间

00:39:14.579 --> 00:39:26.789
讨论这个，是的，有很酷的东西，好吧，例如对不起

00:39:26.789 --> 00:39:31.380
继续这个想法，迈克尔，我认为，所以只看一下基本

00:39:31.380 --> 00:39:35.460
用JavaScript编码的东西，您可以看到我们有一条快速之路

00:39:35.460 --> 00:39:40.109
对于base64和base 32，因为这相当容易，但是对于base 58和

00:39:40.109 --> 00:39:45.089
其他新颖的基础，我们必须去使用这个不大的基础X库

00:39:45.089 --> 00:39:49.289
但这是另一种依赖，只是想知道这是否值得我们

00:39:49.289 --> 00:39:56.250
仅在这种情况下实施我们自己的最低基本58比特币BTC编码器

00:39:56.250 --> 00:40:00.089
您需要支持的地方，因为那里有很多地方

00:40:00.089 --> 00:40:03.900
您仍然需要v-0支持，应该是

00:40:03.900 --> 00:40:09.210
像低音32和原生一样容易，所以也许我们应该致力于实现自己的

00:40:09.210 --> 00:40:15.900
插入的快速路径不错56 58 BTC，我看到的是我想的任何东西

00:40:15.900 --> 00:40:19.619
我已经有一个被我删除的第一句咒语删除了

00:40:19.619 --> 00:40:24.619
认为已经有一个我称为PS 58的东西

00:40:24.619 --> 00:40:28.650
我敢肯定有，但是你知道我们是否可以将这些东西嵌入我们的库中

00:40:28.650 --> 00:40:32.970
就像基本上一样-在58基地BTC即将出现

00:40:32.970 --> 00:40:36.299
永远对我们来说，我们应该只吞下

00:40:36.299 --> 00:40:40.920
这个事实，如果我们使其他所有东西都可以用这两个东西插入

00:40:40.920 --> 00:40:44.010
可以做出紧凑的表示，我们随身携带的所有东西

00:40:44.010 --> 00:40:47.150
我认为我认为这是不合理的

00:40:47.150 --> 00:40:52.950
是的，base64实现实际上可能会被

00:40:52.950 --> 00:40:57.839
在浏览器中使用浏览器默认功能，就像现在

00:40:57.839 --> 00:41:07.559
该功能模仿，我敢打赌它是PTA，我的意思是值得，值得

00:41:07.559 --> 00:41:12.119
看看现在的迈克尔，您正在使您的东西变得更可插拔，让我们来看一下

00:41:12.119 --> 00:41:18.109
这些常见案例与罕见案例之间的对比，我们可以在本地进行运送吗？

00:41:18.109 --> 00:41:25.079
快速而紧凑，是的，我的意思是说，这样打开我们就可以运送成型品

00:41:25.079 --> 00:41:31.410
格式化的东西，因为已经有一个基本的58实现，

00:41:31.410 --> 00:41:35.460
需要该深度，显然默认情况下未加载该深度，或者

00:41:35.460 --> 00:41:39.480
任何东西都有一个像

00:41:39.480 --> 00:41:42.630
多格式斜杠基础知识，就像一组合理的默认值

00:41:42.630 --> 00:41:46.829
没有依赖关系，如果我们将其替换为

00:41:46.829 --> 00:41:50.760
没有任何外部依赖项，那么我将其添加到基本

00:41:50.760 --> 00:42:00.779
设置为使我们有58个基数的大多数人，是的，基础知识无处不在，因为

00:42:00.779 --> 00:42:05.630
很好，因为cos又好玩，这还不错，不是因为它不是巨大的依赖，而是

00:42:05.630 --> 00:42:10.980
它是通用的，也许我们不需要通用

00:42:10.980 --> 00:42:17.980
情况，但是如果您选择特殊情况，也许您会遗传

00:42:17.980 --> 00:42:35.020
我可能不值得在这里过多地停留，然后其他任何事情都可以

00:42:35.020 --> 00:42:40.100
感谢大家的包边和面试，我们接下来再见

00:42:40.100 --> 00:42:45.370
一周然后准时再见大家

