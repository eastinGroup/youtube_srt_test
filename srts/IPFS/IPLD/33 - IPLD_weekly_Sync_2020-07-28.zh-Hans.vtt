WEBVTT
Kind: captions
Language: zh-Hans

00:00:02.240 --> 00:00:05.120
欢迎大家参加本周的ipld会议

00:00:05.120 --> 00:00:11.759
2020年7月27日，每周我们都会浏览这些内容

00:00:11.759 --> 00:00:14.240
过去一周我们一直在做的工作

00:00:14.240 --> 00:00:19.439
以及我们可能要讨论的任何未解决问题或任何引擎

00:00:19.439 --> 00:00:24.080
嗯，我从我自己开始

00:00:24.080 --> 00:00:30.960
我主要从事rust multihash um和um的工作

00:00:30.960 --> 00:00:36.719
所以故事是，罗斯·玛蒂（Ross martij）拥有大量公关

00:00:36.719 --> 00:00:41.440
没有分配太多，只是坚持分配

00:00:41.440 --> 00:00:44.879
然后有一些讨论

00:00:44.879 --> 00:00:49.360
然后人们得到了

00:00:49.840 --> 00:00:54.719
互相恼，所以公关被关闭了，但是这个主意还是不错的

00:00:54.719 --> 00:00:58.480
当它被重新染成一种叫做“微小杂散”的东西时

00:00:58.480 --> 00:01:02.160
现在，我仍然基本上希望获得这种代码

00:01:02.160 --> 00:01:07.040
上游进入正常的锈杂散，所以我与

00:01:07.040 --> 00:01:10.960
此公关的创建者，我已经提出了请求

00:01:10.960 --> 00:01:16.000
因为代码有点我太复杂了

00:01:16.000 --> 00:01:19.040
我真的不能说出原因，但是

00:01:19.040 --> 00:01:23.439
它没有点击，这很奇怪，然后我花时间去

00:01:23.439 --> 00:01:28.640
真的深入研究这也导致一些文件我

00:01:28.640 --> 00:01:31.680
还没有发布，但是它在我的机器上

00:01:31.680 --> 00:01:35.520
一般情况下，多哈希库应该做什么

00:01:35.520 --> 00:01:40.159
嗯，因为有些功能我可能不太明显

00:01:40.159 --> 00:01:44.640
哪个库应该支持，而我正在研究它是如何工作的，等等

00:01:44.640 --> 00:01:47.600
在嗯，我终于想出了一种方法，我

00:01:47.600 --> 00:01:52.000
认为它更简单，所以我提出了这个拉取请求

00:01:52.399 --> 00:01:55.439
这也链接在注释um中

00:01:55.439 --> 00:01:59.360
我认为这是一种简单的方法，它与

00:01:59.360 --> 00:02:03.119
到旧的，但我觉得有点容易

00:02:03.119 --> 00:02:06.159
完全摆脱了

00:02:06.159 --> 00:02:10.800
代码表，因为通常在上个月的上游，我们有一个代码表

00:02:10.800 --> 00:02:15.280
然后将哈希值分配给特定代码，然后

00:02:15.280 --> 00:02:17.520
现在有点像相反

00:02:17.520 --> 00:02:25.360
然后用rust magic将代码分配给多对冲代码

00:02:25.360 --> 00:02:28.720
标头，然后魔术般地一切正常

00:02:28.720 --> 00:02:33.200
这是生成的代码，我认为事情更加明显

00:02:33.200 --> 00:02:37.840
嗯，还是很复杂，但是如果有人想检查一下

00:02:37.840 --> 00:02:42.879
嗯，有空就可以发表评论了，没有任何评论

00:02:42.879 --> 00:02:46.239
文档在那里，所以可能仍然很难遵循

00:02:46.239 --> 00:02:51.040
但这将是即将到来的承诺，并希望

00:02:51.040 --> 00:02:55.280
它足够坚固，然后可以向上游移动

00:02:55.280 --> 00:03:00.879
嗯，是的，这就是我所拥有的，当然，下周我可能还会从事

00:03:00.879 --> 00:03:04.800
那些东西

00:03:04.800 --> 00:03:08.239
我列表上的下一个是eric

00:03:10.560 --> 00:03:15.920
所以我再次做了很多文档，并对高级数据进行了更多研究

00:03:15.920 --> 00:03:18.640
布局，其中一些出现在文档的

00:03:18.640 --> 00:03:23.360
文档仓库中的内容，其中一些与

00:03:23.360 --> 00:03:29.360
杆，我一直在野外看着它们的手

00:03:29.360 --> 00:03:32.799
在一些文件硬币的东西和莲花代码库和

00:03:32.799 --> 00:03:37.040
那个领域的东西，只是试图提取一些类似的理解

00:03:37.040 --> 00:03:41.360
在实践中，那些人已经在处理这些结构了，

00:03:41.360 --> 00:03:46.400
就像从中获取有关用户故事的信息一样

00:03:46.400 --> 00:03:49.680
真的很有趣，事实证明他们是

00:03:49.680 --> 00:03:54.400
做很多事情，实际上我不知道简单到底是不是

00:03:54.400 --> 00:03:57.519
一句话，但他们以非常直接的方式解决了许多问题

00:03:57.519 --> 00:04:00.400
如果我们不这样做，可能会打折

00:04:00.400 --> 00:04:04.480
看到人们以这种方式解决实际问题

00:04:04.480 --> 00:04:08.000
是的，这很有趣，我做了更多的工作

00:04:08.000 --> 00:04:11.840
在golang kogen的东西上有一些公关

00:04:11.840 --> 00:04:16.320
无聊的错误修复程序不看它，但也许还有另一个公关

00:04:16.320 --> 00:04:20.320
有趣的是，我清理了那一代

00:04:20.320 --> 00:04:23.199
模式架构足以使它实际上是一个提交

00:04:23.199 --> 00:04:26.320
你可以看看，这可能是

00:04:26.320 --> 00:04:32.080
因为它现在似乎可以工作了，所以很快就要去掌握

00:04:32.320 --> 00:04:38.479
此处描述的架构之间存在一些细微的差异

00:04:38.479 --> 00:04:42.240
这些功能和架构架构文档

00:04:42.240 --> 00:04:46.400
在规范中，其中有两个用于

00:04:46.400 --> 00:04:49.520
我在gen um的代码中，其中有两个会变成pr

00:04:49.520 --> 00:04:53.199
在规格，无论不久的将来，所以你

00:04:53.199 --> 00:04:56.080
如果需要的话，可以通过查看该代码来预览这些内容

00:04:56.080 --> 00:04:59.680
您可以移动它并显示在光谱中

00:04:59.680 --> 00:05:11.840
就是这样

00:05:18.080 --> 00:05:24.080
好的，对不起，我点击了ii，我想放大

00:05:24.080 --> 00:05:27.600
前景，然后它告诉我，哦，你不能

00:05:27.600 --> 00:05:31.360
最小化缩放，但此窗口隐藏在后面

00:05:31.360 --> 00:05:35.520
原来的窗户，所以我不能取消静音，因为

00:05:35.520 --> 00:05:40.000
您不能将窗口最小化在前面，但是无论如何我都这样认为

00:05:40.000 --> 00:05:46.639
是的，我名单上的下一个是

00:05:46.639 --> 00:05:51.199
是的，我的更新将非常短，但实际上我没有机会

00:05:51.199 --> 00:05:54.880
在上周评估的任何东西上工作

00:05:54.880 --> 00:05:59.440
我本质上是在从事我的猎鹰测试员认证工作

00:05:59.440 --> 00:06:05.600
空气报价，嗯，我们基本上是在做各种

00:06:05.600 --> 00:06:09.360
方法和设计假设如何进行测试以及如何进行

00:06:09.360 --> 00:06:13.120
呃，将uh falcon与demo一起使用

00:06:13.120 --> 00:06:18.479
嗯，这涉及大量的会议，澄清和诸如此类的事情

00:06:18.479 --> 00:06:22.160
我猜唯一的是与ipod相关

00:06:22.160 --> 00:06:26.240
嗯，我试图忽略实现自己的

00:06:26.240 --> 00:06:33.039
坎皮计算器呃，因为包括莲花在内的东西超级好

00:06:33.039 --> 00:06:38.960
它基于rastafari，而且超级资源密集，所以我只想

00:06:38.960 --> 00:06:42.880
选择有多难

00:06:42.880 --> 00:06:49.280
看着标尺写在javascript中的东西我实际上

00:06:49.280 --> 00:06:53.360
不仅会遇到小文件的不一致问题，而且还会与

00:06:53.360 --> 00:07:00.319
特定尺寸的非常接近汽车的任何汽车文件

00:07:00.319 --> 00:07:04.080
限制或碎片，所以现在我实际上正在下载几个

00:07:04.080 --> 00:07:07.840
有点与描述相符的汽车文件，看是否

00:07:07.840 --> 00:07:14.479
我们的公司计算不正确，呃，如果我确实找到这样的文件，我们

00:07:14.479 --> 00:07:17.680
现在可以弄清楚谁是不对的，是否是莲花

00:07:17.680 --> 00:07:23.039
还是以前的事，但是是的，我有潜力

00:07:23.199 --> 00:07:31.120
谢谢你，接下来是克里斯

00:07:31.120 --> 00:07:36.400
嘿，伙计们，所以上周我在做一些

00:07:36.400 --> 00:07:39.840
对dumbo drop进行更多重构以立即统一配置

00:07:39.840 --> 00:07:42.400
这有点像环境变量中的某些内容

00:07:42.400 --> 00:07:46.800
命令行参数中的内容，我认为还有其他内容

00:07:46.800 --> 00:07:54.639
所以我要清理它，还致力于使它更加

00:07:54.639 --> 00:07:59.919
确定性的um处理，所以现在还不是确定性的

00:07:59.919 --> 00:08:02.400
我的意思是说可以，但是我认为会更好一些，我认为我们可以做一些

00:08:02.400 --> 00:08:05.440
确定性的改变，这将使一些

00:08:05.440 --> 00:08:10.720
事情在这里有些工作，而在某种应用程序上也需要工作

00:08:10.720 --> 00:08:14.560
面向开发人员的文档，因此只需仔细考虑

00:08:14.560 --> 00:08:19.120
典型的开发人员，如果他们要IPO

00:08:19.120 --> 00:08:24.400
应用程序他们怎么能做到这一点，所以我喜欢一些有趣的种类

00:08:24.400 --> 00:08:29.360
关于配置um的工作开始

00:08:29.360 --> 00:08:32.399
放在点文件中的东西或其他东西

00:08:32.399 --> 00:08:37.360
像您如何登录到ipld一样进行日志记录

00:08:37.360 --> 00:08:40.399
输入文件输出文件实际上很酷，但是

00:08:40.399 --> 00:08:44.399
但是，一个问题是我一直在思考，我一直喜欢发现新事物

00:08:44.399 --> 00:08:47.440
的东西，我不能像自旋锁那样进入

00:08:47.440 --> 00:08:51.120
我写页面的地方，然后喜欢重写它，因为我想要

00:08:51.120 --> 00:08:54.880
我认为有一种更好的演示方式，所以我不高兴我不高兴

00:08:54.880 --> 00:08:57.920
愿意提交，但嗯

00:08:57.920 --> 00:09:00.720
你知道那是我一直对我拥有的另一件事感到沮丧

00:09:00.720 --> 00:09:03.360
一些更高的分心，所以一些东西

00:09:03.360 --> 00:09:06.160
继续，我上周花了我的时间

00:09:06.160 --> 00:09:09.600
嗯，我也有机会开始与dagde一起玩

00:09:09.600 --> 00:09:12.880
嗯，因为你知道跟迈克尔说话的一件事

00:09:12.880 --> 00:09:16.800
我想做的是服用典型的小飞象

00:09:16.800 --> 00:09:20.560
您在其中进行配置记录的应用程序设计以及所有这些

00:09:20.560 --> 00:09:23.200
那种驱动它的东西是传统的

00:09:23.200 --> 00:09:27.839
文件，看看是否可以将所有百分百的内容都移到ipld和dag中

00:09:27.839 --> 00:09:31.440
db是我们使之成为可能的关键部分之一，因为

00:09:31.440 --> 00:09:34.720
嗯，您必须像必须命名对象那样进行构建，否则

00:09:34.720 --> 00:09:38.560
将这些名称写到文件中，因此这里的目标是

00:09:38.560 --> 00:09:43.440
是所有配置，所有输入文件，所有日志，所有内容都在一个

00:09:43.440 --> 00:09:46.800
一个ipld，我们广泛使用dagdb

00:09:46.800 --> 00:09:50.880
嗯，有点像呃，我个人认为那就像

00:09:50.880 --> 00:09:57.519
一个关键的缺失部分，使IPL真正更容易在完整版本中使用

00:09:57.519 --> 00:09:59.519
感觉像很多标准的东西

00:09:59.519 --> 00:10:01.839
应用程序使我对此感到非常兴奋

00:10:01.839 --> 00:10:05.839
嗯，无论如何，那是我的更新

00:10:07.120 --> 00:10:12.079
谢谢你，接下来是罗德

00:10:14.320 --> 00:10:20.560
嗯，好吧，你花了一个

00:10:20.560 --> 00:10:28.959
ipfs.org中的远硬币汉普顿um中的时间

00:10:28.959 --> 00:10:33.760
它的名称是gohampt ipld um，关于将其移至

00:10:33.760 --> 00:10:39.519
该文件硬币falcoid项目组织和嗯，所以我打开了一个问题

00:10:39.519 --> 00:10:42.640
在那里使它正式化，似乎围绕该协议达成了一些协议

00:10:42.640 --> 00:10:46.560
与该团队相关的原因之一是

00:10:46.560 --> 00:10:50.000
它在您知道它在ipfs.org中的位置

00:10:50.000 --> 00:10:56.399
历史原因，但它的名称也是um，我们也将其链接到我们的哈希图中

00:10:56.399 --> 00:11:00.240
规范，令人困惑，听起来像是

00:11:00.240 --> 00:11:03.600
某人可以用于ipld的通用手

00:11:03.600 --> 00:11:08.480
这还不错，或者只是什么而已

00:11:08.480 --> 00:11:11.920
由文件硬币驱动，基本上是硬币想要和需要的距离

00:11:11.920 --> 00:11:17.040
进入那个东西，其他一切都是次要的

00:11:17.040 --> 00:11:21.360
它的布局略有不同，而且这个问题

00:11:21.360 --> 00:11:26.079
不断出现的上下文um您如何

00:11:26.079 --> 00:11:30.640
当你加载这个东西的时候，你怎么知道它使用的是什么参数

00:11:30.640 --> 00:11:36.560
能够阅读um的结构，而这采用了这种方法

00:11:36.560 --> 00:11:39.519
它总是来自您正在加载的代码

00:11:39.519 --> 00:11:42.800
这样，当您加载此东西时，您将知道

00:11:42.800 --> 00:11:46.480
参数是创建它的对象，您无需在任何地方找到它们

00:11:46.480 --> 00:11:51.040
在数据本身中，而在hashmap spec和um中

00:11:51.040 --> 00:11:54.959
在其他地方，我们采取了这些方法

00:11:54.959 --> 00:11:58.720
在加载它们时更加通用和自我描述

00:11:58.720 --> 00:12:01.760
了解它们是如何创建的将很有帮助，因为

00:12:01.760 --> 00:12:05.279
没有这些信息，您将无法阅读

00:12:05.279 --> 00:12:09.200
加载时可能没有该信息

00:12:09.200 --> 00:12:12.560
所以这与这个有很大的差异，并且不会改变

00:12:12.560 --> 00:12:15.600
使用Filecoin是因为Filecoin对

00:12:15.600 --> 00:12:18.000
版本控制以及该信息来自何处

00:12:18.000 --> 00:12:23.279
字节的重要性，因此这和um都缺乏

00:12:23.279 --> 00:12:26.399
最好不要给人以这样的印象：

00:12:26.399 --> 00:12:31.600
人们可能会依赖um，而eric一直在说我们不是

00:12:31.600 --> 00:12:38.639
拥有一个新的um太远了，用户只能从架子上取下来

00:12:38.639 --> 00:12:41.519
并使用它，希望它会被移动

00:12:41.519 --> 00:12:47.600
拉请求号52那里只是剁碎的块，装满了um

00:12:47.600 --> 00:12:51.600
呃文档，只是我已经遍历了文档中的代码

00:12:51.600 --> 00:12:58.720
添加了一些um周围的文档um在其中找到了很多待办事项

00:12:58.720 --> 00:13:03.600
需要测试的东西一些看起来像错误的东西

00:13:03.600 --> 00:13:09.200
嗯，它花费了一些非常有趣的东西

00:13:09.200 --> 00:13:14.800
与eric um谈论这个东西，另一件事我

00:13:14.800 --> 00:13:17.839
当时在与当地人进行了很好的聊天

00:13:17.839 --> 00:13:22.880
vulcanizeddb这些家伙正在做um他们

00:13:22.880 --> 00:13:27.519
结合ipld和cryptocurrency区块链

00:13:27.519 --> 00:13:34.240
和postgres进行查询和验证

00:13:34.240 --> 00:13:38.560
工作，因此ipld派上用场了，因为它有助于

00:13:38.560 --> 00:13:43.360
证明的东西，因为这些区块链包含这些言语树，

00:13:43.360 --> 00:13:47.920
您可以做一些证明，因此将所有内容粘贴在postgres中很有趣，

00:13:47.920 --> 00:13:49.839
这种观点，但这也是一个很好的方法

00:13:49.839 --> 00:13:54.000
保留数据并格式化它，这很有趣

00:13:54.000 --> 00:13:56.720
嗯，事实证明他们与我一直在做的工作有很多重叠之处

00:13:56.720 --> 00:14:00.480
我一直在做比特币和zcash的区块链

00:14:00.480 --> 00:14:02.320
他们已经把它放在一边，即使他们有

00:14:02.320 --> 00:14:04.639
一些支持，他们就像我们一样

00:14:04.639 --> 00:14:07.920
不是还没有完成，但是他们一直在做以太坊工作，而我还没有

00:14:07.920 --> 00:14:10.560
完成了所有以太坊的工作，

00:14:10.560 --> 00:14:15.440
原来是一场噩梦，嗯，他们已经花了一些老

00:14:15.440 --> 00:14:21.920
实施的ipld工作理论将全部重新实施或升级为

00:14:21.920 --> 00:14:24.720
实际在当前条件下充分工作

00:14:24.720 --> 00:14:28.839
他们甚至实现了自己的以太坊数据

00:14:28.839 --> 00:14:34.480
用于表示以太坊状态的um格式

00:14:34.480 --> 00:14:38.959
这有点复杂，所以他们有主要的以太坊客户端的分支

00:14:38.959 --> 00:14:42.320
他们正在用来提取状态信息的

00:14:42.320 --> 00:14:46.720
和嗯，真的很有趣，我想

00:14:46.720 --> 00:14:52.480
嗯，我正在做以太坊归档工作，我需要依靠它们

00:14:52.480 --> 00:14:58.720
在做um是否是um试图让他们参与

00:14:58.720 --> 00:15:06.000
或者只是使用他们的工作，然后就像我们所说的那样

00:15:06.000 --> 00:15:11.760
um进行流式传输或um提取其ipld工作，因为正确

00:15:11.760 --> 00:15:15.839
现在它被深深地嵌入在一个回购协议中，

00:15:15.839 --> 00:15:19.440
做所有这些工作，但是得到那些会很高兴

00:15:19.440 --> 00:15:23.040
像编解码器一样，我们甚至谈到了做那些

00:15:23.040 --> 00:15:28.720
ipld prime的编解码器，所以嗯，以太坊是那里的主要编解码器

00:15:28.720 --> 00:15:32.880
但他们也做了一些有关比特币的工作

00:15:32.880 --> 00:15:37.199
否则，嗯，是的，

00:15:37.199 --> 00:15:40.240
我想拍摄一个很好的合作空间

00:15:40.240 --> 00:15:45.920
嗯，我是否又在海港度过了一段时间

00:15:45.920 --> 00:15:52.639
我正在抓住边缘修修补补，我正在跑的主要之一

00:15:52.639 --> 00:15:59.360
sibo规范附带的测试套件只是为了确保我在轨道上

00:15:59.360 --> 00:16:03.759
现在我正在决定

00:16:03.759 --> 00:16:08.959
是否打扰不确定长度的支撑

00:16:08.959 --> 00:16:12.399
这个东西，如果任何东西的长度如此之大

00:16:12.399 --> 00:16:20.000
数组，字符串，字节字符串或映射，它们有两种模式

00:16:20.000 --> 00:16:23.199
我们只是说前面的长度，或者你说

00:16:23.199 --> 00:16:26.880
长度不确定，等我休息一下

00:16:26.880 --> 00:16:30.720
嗯，这对流媒体很有帮助，但对dax电子书却不利

00:16:30.720 --> 00:16:34.320
因为这意味着您可以拥有的版式中的变化

00:16:34.320 --> 00:16:38.399
任何给定的数据量um，所以对于出租车板我不想要

00:16:38.399 --> 00:16:40.959
我希望能够将其关闭，但

00:16:40.959 --> 00:16:45.839
能够使用测试装置来确保我

00:16:45.839 --> 00:16:48.720
与所有内容兼容，在那里拥有覆盖范围是一件很不错的事情

00:16:48.720 --> 00:16:51.920
所以我已经在其中发展了这样的想法

00:16:51.920 --> 00:16:56.000
严格性和标志以打开和关闭功能

00:16:56.000 --> 00:17:00.240
嗯，如果我完全实现它们的话，这将是其中之一

00:17:00.240 --> 00:17:05.760
对于dag sequal，我们可以说不，你既不能那样写，也不能

00:17:05.760 --> 00:17:08.079
您可以像这样读取数据并摆脱

00:17:08.079 --> 00:17:13.039
嗯，所以我的意思是这是其中之一，这真的很有教育意义

00:17:13.039 --> 00:17:18.559
根据um格式，理想的ipld格式

00:17:18.559 --> 00:17:22.000
和嗯，以及如何在其状态下不使用海滨

00:17:22.000 --> 00:17:26.240
甚至我们一直在使球变得更加严格

00:17:26.240 --> 00:17:31.679
也许不是吧，也许是因为我们看到了问题

00:17:31.679 --> 00:17:37.520
就像rust实现um，当使用姓氏时

00:17:37.520 --> 00:17:40.559
有很多方法，这并不理想

00:17:40.559 --> 00:17:47.200
为了我们的严格规范，甚至是falcoin sibor

00:17:47.200 --> 00:17:51.520
编码器正在执行，根本不执行任何严格性检查，因为

00:17:51.520 --> 00:17:54.799
他们在表演，就像

00:17:54.799 --> 00:17:59.679
他们的头等大事，所以它会读取草率的数据

00:17:59.679 --> 00:18:03.200
对于他们的区块链来说可能是一个问题，这是一个不同的问题

00:18:03.200 --> 00:18:07.440
嗯，但目前它也只是在地图中未正确对键进行排序

00:18:07.440 --> 00:18:12.720
所以它甚至都不会写数据记录添加到xc或spec中

00:18:12.720 --> 00:18:19.440
这就是为什么seabor不是ipld的绝佳解决方案，而是

00:18:19.440 --> 00:18:23.919
也许我们可以像z-war一样进行某种进化

00:18:23.919 --> 00:18:28.320
不仅严格，而且只是删除功能

00:18:28.320 --> 00:18:31.919
而且您无法靠近这些功能去

00:18:31.919 --> 00:18:35.200
是有效的，但是我在想，我在想一个嗯

00:18:35.200 --> 00:18:38.880
而不是黑暗的海球，就像黑暗的海华尔街使一个全新的

00:18:38.880 --> 00:18:42.720
超级严格的多编解码器编解码器

00:18:42.720 --> 00:18:45.440
您不能做所有这些事情来实现这一点，

00:18:45.440 --> 00:18:49.520
您必须删除功能，并且必须对所有内容进行验证

00:18:49.520 --> 00:18:53.200
是直接的还是严格的，也许可以代表

00:18:53.200 --> 00:18:57.120
我们对数据格式um的下一个发展，而不是

00:18:57.120 --> 00:19:01.840
全力以赴，但实际上却是非常严格的

00:19:01.840 --> 00:19:05.600
cbore中的空间，您可以称其为二氧化条

00:19:05.600 --> 00:19:10.559
做这个东西进出抱歉彼得

00:19:10.559 --> 00:19:14.880
哦，我只是想说一遍，我们已经在规范中就说过，例如c战争，

00:19:14.880 --> 00:19:19.600
已经确实说无限期地不允许

00:19:19.600 --> 00:19:24.799
需要使用最短的整数，所以我们已经很严格了，但是

00:19:24.799 --> 00:19:28.559
如果你说这很重要，那现在是一个问题

00:19:28.559 --> 00:19:31.840
规范很严格，但是没有什么足够严格的了

00:19:31.840 --> 00:19:34.880
他们都没有做所有这些事情，我们有这个浮动

00:19:34.880 --> 00:19:39.280
问题是实时的，我们拥有真实的数据

00:19:39.280 --> 00:19:43.600
用出租车生产，但就像当文件硬币上线时

00:19:43.600 --> 00:19:47.120
生产dag cbo块，它将永远存在

00:19:47.120 --> 00:19:51.360
如果排序保持原样，则根据

00:19:51.360 --> 00:19:55.760
规范我们如何处理实时数据

00:19:55.760 --> 00:19:58.400
我们无法更改，而我们的规格说明了一件事，然后我们

00:19:58.400 --> 00:20:02.320
开始打开我们的呃dax siebel Codex，使其更加严格

00:20:02.320 --> 00:20:06.880
读取数据是如何工作的，那太疯狂了

00:20:06.880 --> 00:20:09.760
着陆，这样就好了，您正在读取文件硬币数据

00:20:09.760 --> 00:20:12.240
因此，请关闭您的严格性检查

00:20:12.240 --> 00:20:15.679
我的意思是在所有想要严格的地方

00:20:15.679 --> 00:20:18.159
做任何与你有关的事

00:20:18.159 --> 00:20:20.960
严格的加密货币有点

00:20:20.960 --> 00:20:26.240
在那里很重要，所以无论如何我们只有另一枚硬币

00:20:26.240 --> 00:20:31.200
做得好，我确实想知道是否

00:20:31.200 --> 00:20:35.440
会是这种情况，但是CBO代码编码器非常好

00:20:35.440 --> 00:20:38.320
它实际上并没有实现太多

00:20:38.320 --> 00:20:41.280
嗯嗯，不是，我不认为它输入了

00:20:41.280 --> 00:20:44.640
浮动所有um，并且实现了足够的效果

00:20:44.640 --> 00:20:47.600
理想的情况就是这种严格性

00:20:47.600 --> 00:20:49.679
担心我，因为没有停止的余地

00:20:49.679 --> 00:20:56.559
其他遥远的玉米客户则无法产生像整数一样的um，将每个整数编码为

00:20:56.559 --> 00:21:00.559
即使是64位um，即使

00:21:00.559 --> 00:21:03.039
他们不应该按照严格的规则

00:21:03.039 --> 00:21:06.880
但是其他所有符号编解码器也是如此

00:21:06.880 --> 00:21:10.799
他们都会读取错误的数据，然后说是的，我不在乎

00:21:10.799 --> 00:21:14.000
嗯，没有人会拒绝它，说嘿，这是不对的，这本不应该

00:21:14.000 --> 00:21:17.760
像这样被编码这个哈希对于这组是错误的

00:21:17.760 --> 00:21:20.159
数据

00:21:22.960 --> 00:21:26.880
嗯，无论如何，最后一件事是um在继续这些杂乱无章

00:21:26.880 --> 00:21:31.760
在空间记录请求中拉出两个八三四，嗯，注意一些

00:21:31.760 --> 00:21:35.120
这个javascript数字疯狂的原因，因为那是我们运行的另一个领域

00:21:35.120 --> 00:21:37.520
陷入困境，我们将与每个陷入困境

00:21:37.520 --> 00:21:44.159
编解码器，这是我要讨论的javascript数字布局，

00:21:44.159 --> 00:21:48.400
总体而言，关于类型的细节也是如此

00:21:48.400 --> 00:21:50.480
相对于未输入类型以及数字存在的问题

00:21:50.480 --> 00:21:54.640
但是javascript是一种非常具体的谈论方式，我们并不是真的

00:21:54.640 --> 00:21:57.600
我是否认为我们还有其他未键入的内容

00:21:57.600 --> 00:22:03.840
dax的实现相等，也许在那里，但无论如何

00:22:03.840 --> 00:22:07.039
哦，那是我

00:22:07.200 --> 00:22:15.200
谢谢，接下来是michael yeah嘿yeah抱歉在git​​hub上发表评论

00:22:15.200 --> 00:22:20.000
嗯，好吧，嗯，做了些东西

00:22:20.320 --> 00:22:24.720
嗯，是的，每个人都必须向我道歉

00:22:24.720 --> 00:22:28.640
上周呃，我以为我不会弄清楚这个并得到

00:22:28.640 --> 00:22:33.280
一切都可以用esm来构建所有不同的东西

00:22:33.280 --> 00:22:37.840
无论如何，您都会受到欢迎，嗯，有一个叫做limbo的工具，我们可以

00:22:37.840 --> 00:22:40.799
用来管理那些构建，现在一切都很棒

00:22:40.799 --> 00:22:45.360
嗯，这让我总体上在考虑这个问题，因为它就像

00:22:45.360 --> 00:22:48.320
要管理的构建很多，这就像很多额外的东西要管理

00:22:48.320 --> 00:22:52.720
所以我开始考虑这个，我开始制造这个叫做

00:22:52.720 --> 00:22:56.559
ipjs基本上就像一个构建系统来处理此问题

00:22:56.559 --> 00:23:00.159
我们在内部也可能遇到的实际问题可以使用

00:23:00.159 --> 00:23:03.840
数据结构是ipld，可以具有本机包格式，因此

00:23:03.840 --> 00:23:07.679
除了制作可以像我们需要的那样容易在npm发布的内容

00:23:07.679 --> 00:23:11.120
现在是统一的，是普遍的

00:23:11.120 --> 00:23:14.240
javascript，我们也有向我们开放的未来

00:23:14.240 --> 00:23:17.679
我们可以使用所有新的esm和所有这些数据来做非常酷的事情

00:23:17.679 --> 00:23:20.240
结构，所以我写了一堆代码，并做了

00:23:20.240 --> 00:23:24.720
的演示，并在um周围发送了

00:23:24.720 --> 00:23:27.919
酷，然后我写了一堆

00:23:27.919 --> 00:23:30.559
在其他地方的其他代码，我认为我修复了许多错误

00:23:30.559 --> 00:23:36.480
在块和多种格式和dag db到处，我写了一些文档，但

00:23:36.480 --> 00:23:42.159
是的，那就是我，我不知道下一个是谁

00:23:42.159 --> 00:23:49.760
是的，是的，所以

00:23:49.760 --> 00:23:54.080
任何要讨论的项目

00:23:59.360 --> 00:24:06.320
不，我实际上以某种方式可以放好一些议程项目

00:24:06.559 --> 00:24:11.520
好的，对不起，我现在看到他们了，好的，嗯

00:24:12.559 --> 00:24:17.039
是的，是的，是的，只是我要移交给你，我认为那是比较容易的确定

00:24:17.039 --> 00:24:19.679
是啊，嗯，我去过的一件事

00:24:19.679 --> 00:24:22.880
想着你就知道这样的例子，但是来自一个应用程序

00:24:22.880 --> 00:24:27.440
很多时候的发展观点文本数据得到

00:24:27.440 --> 00:24:31.279
用gzip或其他压缩文件压缩，一旦您移至ipld

00:24:31.279 --> 00:24:37.840
嗯，你知道的，可以g-zip压缩并粘贴成一个原始块

00:24:37.840 --> 00:24:42.080
或者你可以希望有一个大商店

00:24:42.080 --> 00:24:45.520
会自动压缩内容，但正如您所知，有些块

00:24:45.520 --> 00:24:48.720
可能比其他方法更具可压缩性，所以您不会遇到问题

00:24:48.720 --> 00:24:51.919
如果没有任何提示，则不知道是否应该尝试

00:24:51.919 --> 00:24:56.159
在不浪费时间的情况下压缩它，所以我不知道我是否确定

00:24:56.159 --> 00:25:00.400
关于压缩，但是根据我的想法，好像

00:25:00.400 --> 00:25:05.360
呃，你知道dag seaboard gzip编解码器会很有意义或类似的东西

00:25:05.360 --> 00:25:09.919
所以本质上是数据被压缩，但是

00:25:09.919 --> 00:25:15.039
您实际上可以跟随链接，但是您必须先在编解码器中将其解压缩

00:25:15.039 --> 00:25:19.440
但是你可以做到的，你可以通过类似的东西有效地了解漂亮的内存和CPU

00:25:19.440 --> 00:25:22.559
 gzip这是非常快的嗯，这将使您能够

00:25:22.559 --> 00:25:26.400
嗯，你知道然后开发人员会选择好吧，我知道这会发生

00:25:26.400 --> 00:25:31.279
成为高度可压缩的数据结构，因此它将使用该结构，但如果

00:25:31.279 --> 00:25:35.200
这并不是说您有咬合阵列或嵌入其中的东西

00:25:35.200 --> 00:25:39.039
您的C板上有压缩块或其他东西

00:25:39.039 --> 00:25:42.480
您只能使用典型的dag c板，您将无法获得好处，因此

00:25:42.480 --> 00:25:46.559
你们就回声说了什么

00:25:46.720 --> 00:25:50.159
嗯，在我们开始回答之前，我有一个问题

00:25:50.159 --> 00:25:54.840
这个问题经常出现

00:25:54.840 --> 00:26:01.679
呃，在你的思想克里斯中，你通过介绍这个解决了什么

00:26:01.679 --> 00:26:09.120
编解码器，所以我要解决的是嗯，我猜

00:26:09.120 --> 00:26:13.360
对高度可压缩的事物进行更有效的压缩，因此

00:26:13.360 --> 00:26:16.880
当您想到应用程序开发人员时

00:26:16.880 --> 00:26:20.000
想要尽可能多地移动

00:26:20.000 --> 00:26:23.440
进入ipld的一件事，他们将迅速采取行动

00:26:23.440 --> 00:26:27.840
你知道现在绊脚石会很好，我使用了更多

00:26:27.840 --> 00:26:33.919
数据存储比我之前要好，因为它无法压缩，所以我

00:26:33.919 --> 00:26:35.919
认为您知道允许开发人员拥有

00:26:35.919 --> 00:26:39.520
对压缩数据的一些控制

00:26:39.520 --> 00:26:43.200
而且仍然保持ipld linkability，我认为是

00:26:43.200 --> 00:26:46.400
你知道如果你只是损失了你所损失的部分

00:26:46.400 --> 00:26:53.840
数据压缩并放入roblox中，我认为这是我要解决的问题

00:26:56.480 --> 00:27:01.520
迈克尔，你承认你要回答这个问题还是

00:27:01.520 --> 00:27:04.559
对不起，我错过了它，我仍然在评论这个愚蠢的事情

00:27:04.559 --> 00:27:09.840
好的，对不起，有一个编解码器

00:27:10.960 --> 00:27:16.159
没有，我以为你想去那就是为什么我问

00:27:16.480 --> 00:27:19.679
所以彼得实际上只是想了一堆这样的东西

00:27:19.679 --> 00:27:23.360
最近在其他频道发短信，所以也许他会超级准备回答

00:27:23.360 --> 00:27:26.640
它，但始终是反作用力

00:27:26.640 --> 00:27:35.360
令人难以置信的是，如果您对压缩进行哈希处理

00:27:35.360 --> 00:27:38.640
很有可能在下游产生大量的悲伤，因为

00:27:38.640 --> 00:27:44.080
您再也无法改变压缩率，并以理想的方式刷新它

00:27:44.080 --> 00:27:50.240
压缩算法大约为零，就像不是

00:27:50.240 --> 00:27:54.000
人们会争论某些数据的理想压缩

00:27:54.000 --> 00:27:57.919
直到实际时间结束

00:27:57.919 --> 00:28:01.200
在这种情况下，请创建新的编解码器，这是一个令人信服的原因，我认为gzip是如此

00:28:01.200 --> 00:28:03.919
流行，然后您所有的链接断开，所有

00:28:03.919 --> 00:28:10.559
您的详细休息时间，是的，链接

00:28:10.640 --> 00:28:15.440
是的，所以我会说几句话，因为是的，我

00:28:15.440 --> 00:28:19.120
确实有几个线程在不同的地方，所以他们没有

00:28:19.120 --> 00:28:22.960
容易发现，但嗯，就像它只是一种

00:28:22.960 --> 00:28:26.320
对于um存储抽象和网络而言，显而易见的轻而易举

00:28:26.320 --> 00:28:29.120
实现压缩的抽象，就像

00:28:29.120 --> 00:28:32.799
如果您有一家商店，并且担心尺寸限制之类的问题，

00:28:32.799 --> 00:28:37.360
愿意为存储字节交换计算以实现压缩

00:28:37.360 --> 00:28:40.080
对，然后您可以按所有内容而不管编解码器如何

00:28:40.080 --> 00:28:42.000
那就像你想获得胜利的地方

00:28:42.000 --> 00:28:45.520
以及您处于最佳位置的位置决定您是否想要

00:28:45.520 --> 00:28:48.320
权衡的um运输都应该实施

00:28:48.320 --> 00:28:51.360
基本压缩，因为我们已经优化了类似的库来进行传输

00:28:51.360 --> 00:28:54.720
像没有人懒惰一样没有理由

00:28:54.720 --> 00:29:00.799
嗯，现在就是这种情况嗯，并不意味着

00:29:00.799 --> 00:29:03.360
我并不是说我反对任何形式的

00:29:03.360 --> 00:29:07.520
编解码器中的压缩我只是反对一般

00:29:07.520 --> 00:29:10.720
压缩解决方案，然后采用编解码器，然后进行

00:29:10.720 --> 00:29:14.799
并采用格式等序列化库，然后将它们配对

00:29:14.799 --> 00:29:18.399
一起为一个新的编解码器，因为它创建像一个

00:29:18.399 --> 00:29:20.480
每次压缩都有大量编解码器

00:29:20.480 --> 00:29:23.840
然后在它们之间创建的所有数据都无法复制

00:29:23.840 --> 00:29:27.600
嗯，我们没有他们想要的统一地址，但是如果您想像

00:29:27.600 --> 00:29:30.559
就像一种新的块格式，例如我们正在编写一个

00:29:30.559 --> 00:29:34.960
新的块格式，我们可能会有某种形式的类似应用程序

00:29:34.960 --> 00:29:37.360
就像我们将在其中的特定压缩

00:29:37.360 --> 00:29:42.320
我们将可以说，就像哦，就像你知道是否有cid出现

00:29:42.320 --> 00:29:45.279
在同一块中有数百次没有理由将其写成数百次

00:29:45.279 --> 00:29:47.919
在同一块中的时间，就像我们可以写一次，然后我们可以

00:29:47.919 --> 00:29:51.039
维护对它的引用，我们可以像创建一个真正优化的一样

00:29:51.039 --> 00:29:54.480
正确的区块格式，您可以在一些

00:29:54.480 --> 00:29:57.919
如果您喜欢其他um格式的库

00:29:57.919 --> 00:30:02.080
hp 2 um中的http标头压缩，我也认为它在http中

00:30:02.080 --> 00:30:04.640
3.它非常特定于标题，就像

00:30:04.640 --> 00:30:07.520
它足够了解问题空间，因此可以像

00:30:07.520 --> 00:30:11.840
高效的特定于应用程序的解决方案，因此我们可能会发现，将来我们可能会

00:30:11.840 --> 00:30:15.600
就像哦，它自己压缩一点的块格式

00:30:15.600 --> 00:30:19.440
因为我们知道什么是块格式

00:30:19.440 --> 00:30:23.200
但实际上没有必要使用通用压缩，因为

00:30:23.200 --> 00:30:27.679
作为编解码器作者，我们并不是处于最佳位置以了解何时有人

00:30:27.679 --> 00:30:30.880
想要交易通用压缩的计算

00:30:30.880 --> 00:30:36.399
库，用于存储需求，反之亦然，但是对于开发人员

00:30:36.399 --> 00:30:41.520
选择要使用的编解码器，这样您就可以知道他们是否经常知道

00:30:41.520 --> 00:30:44.799
是否可压缩，所以他们可以选择说您知道这是

00:30:44.799 --> 00:30:49.200
高度可压缩的数据，我愿意为此付出代价。

00:30:49.200 --> 00:30:51.440
但是他们将把这些数据放到网络中，

00:30:51.440 --> 00:30:54.320
他们将把它发送给其他人，而您只是为所有人做出了决定

00:30:54.320 --> 00:30:57.120
其他人对，而像开发商一样

00:30:57.120 --> 00:30:59.600
选择他们的块存储，如果他们想打开压缩

00:30:59.600 --> 00:31:02.080
在他们的盒子商店里，他们得到了所有这些压缩

00:31:02.080 --> 00:31:06.720
他们所有的存储空间，而且他们已经能够做出权衡

00:31:06.720 --> 00:31:10.320
隔离自己而不是隔离那些

00:31:10.320 --> 00:31:13.360
然后走出网络

00:31:14.880 --> 00:31:18.000
这是一个相似的东西，是不一样的

00:31:18.000 --> 00:31:24.399
但这是同一类的问题

00:31:24.399 --> 00:31:27.519
昨天我觉得这麻是嗯，所以

00:31:27.519 --> 00:31:34.480
在说说杂音3的hamp规范中，

00:31:34.480 --> 00:31:38.240
特定类型的杂音3的64位版本。

00:31:38.240 --> 00:31:41.279
嗯，现在它在mm3中的x64版本是

00:31:41.279 --> 00:31:45.200
可以使用的算法，这很棒，因为您知道这是一个

00:31:45.200 --> 00:31:49.679
这不是一个加密的um哈希，它只是通用的一个很好的哈希函数

00:31:49.679 --> 00:31:53.279
使用，然后filecoin现在正在讨论

00:31:53.279 --> 00:31:55.760
事实上，他们刚刚合并，他们打算将其切换为

00:31:55.760 --> 00:31:58.240
加密安全哈希，以便它们

00:31:58.240 --> 00:32:02.000
避免人们可能在哈希哈希冲突中遇到的问题

00:32:02.000 --> 00:32:04.159
实际操纵第三的知识

00:32:04.159 --> 00:32:09.760
强制哈希冲突很大，结果是，嗯

00:32:09.760 --> 00:32:13.200
所以杰里米对此做了一些测试，结果证明

00:32:13.200 --> 00:32:18.480
在平均机器上，shah 256比谋杀3更快

00:32:18.480 --> 00:32:21.360
嗯，因为计算机为此进行了优化

00:32:21.360 --> 00:32:26.880
嗯，所以在这种情况下，作为开发人员，您认为自己是

00:32:26.880 --> 00:32:31.360
做出延伸到整个堆栈的决策，但其他人

00:32:31.360 --> 00:32:34.559
堆栈的不同级别上的决策也

00:32:34.559 --> 00:32:38.399
以不同的方式进行优化，在这种情况下，您将拥有操作系统

00:32:38.399 --> 00:32:42.159
和专门针对shop256的硬件供应商

00:32:42.159 --> 00:32:45.600
作为开发人员，我们认为哦，不，我们将获得一个更简单的哈希，但实际上

00:32:45.600 --> 00:32:48.080
效率不高，因此与

00:32:48.080 --> 00:32:50.320
压缩堆栈的不同层

00:32:50.320 --> 00:32:54.240
这些层中涉及的不同人员已经在做出决策

00:32:54.240 --> 00:32:58.559
有时最好将这些决定推迟到

00:32:58.559 --> 00:33:02.000
股票我不是对您的建议说不，我只是说这是

00:33:02.000 --> 00:33:04.470
迈克讲的方式很复杂

00:33:04.470 --> 00:33:08.480
[音乐]并且坦白地说，我认为

00:33:08.480 --> 00:33:12.799
我们最有可能从这种压缩中获胜的地方

00:33:12.799 --> 00:33:17.440
可能实际上不是像dag seabor那样，就像你知道的那样。

00:33:17.440 --> 00:33:20.399
本机编码的块结构，但只是原始位

00:33:20.399 --> 00:33:23.919
所以我不会好奇像什么原始的话题进行对话

00:33:23.919 --> 00:33:26.960
耶稣编解码器看起来像是

00:33:26.960 --> 00:33:30.080
比压缩更胜一筹

00:33:30.080 --> 00:33:34.080
就像大多数人一样，海港对您来说真的很像

00:33:34.080 --> 00:33:37.760
在他们的数据存储中，如果他们有大量的数据，则主要是原始数据块

00:33:37.760 --> 00:33:39.600
像所有数据一样，这当然是正确的

00:33:39.600 --> 00:33:46.720
流程很好，所以我认为我们要做的一件事

00:33:46.720 --> 00:33:50.559
有一个答案是是否有开发人员

00:33:50.559 --> 00:33:55.360
觉得他们的解决方案

00:33:55.360 --> 00:33:59.600
um需要压缩，否则就像ipld是我们需要的非入门表格

00:33:59.600 --> 00:34:06.399
关于如何做到这一点的一些指导，所以你知道

00:34:06.399 --> 00:34:09.839
我们是否认为我说的很好？

00:34:09.839 --> 00:34:13.520
我感动了头，有两种策略可以做到，一种可以

00:34:13.520 --> 00:34:16.800
扩展块接口以提示说

00:34:16.800 --> 00:34:20.000
该块是可压缩的，您应该尝试压缩块存储，因为

00:34:20.000 --> 00:34:22.399
我们不想做的是有一家盒子商店

00:34:22.399 --> 00:34:25.839
自动神奇地找出一个块是否可压缩，因为那可以

00:34:25.839 --> 00:34:30.079
浪费大量的CPU时间，特别是当开发人员可以

00:34:30.079 --> 00:34:34.720
提供某种提示，例如，您知道浏览器中的内容协商

00:34:34.720 --> 00:34:37.520
就像嘿，这就是我想要的，你应该给

00:34:37.520 --> 00:34:40.639
给我，如果你有那样的话，但我也可以支持这些

00:34:40.639 --> 00:34:44.000
嗯，这是您不想让服务器不得不执行的相同类型的想法

00:34:44.000 --> 00:34:49.119
你知道猜错了，我的意思是如果我们做一个原始的

00:34:49.119 --> 00:34:52.240
gzip可以解决这个问题，或者您会说您会看着它说

00:34:52.240 --> 00:34:55.839
嘿，我不需要压缩，我会说像我不知道

00:34:55.839 --> 00:34:59.040
威胁是在哪里，但是我们谈论了这个，并且谈论了

00:34:59.040 --> 00:35:02.480
就像让我们的商店默认为

00:35:02.480 --> 00:35:05.119
压缩，实际上有反对意见

00:35:05.119 --> 00:35:09.760
人们不得不默认启用它，因为他们大多拥有视频数据或

00:35:09.760 --> 00:35:12.400
他们大多有其他已经压缩的数据，他们不想要

00:35:12.400 --> 00:35:17.280
浪费时间，所以又像我想的那样

00:35:17.280 --> 00:35:20.640
我们可能必须提供的最好的地方是

00:35:20.640 --> 00:35:23.839
现在在存储指令中，嗯，我

00:35:23.839 --> 00:35:27.119
想一下，我们的团队目前无法管理这些存储抽象

00:35:27.119 --> 00:35:32.880
他们主要是在ipfs方面，所以不是，不是

00:35:32.880 --> 00:35:40.000
让我们处理但不幸的是，我是说我认为我们应该

00:35:40.000 --> 00:35:43.040
因为我觉得这种感觉独立于ipfs，所以您应该能够

00:35:43.040 --> 00:35:45.839
构建一个ipld应用程序，并且没有任何ipfs

00:35:45.839 --> 00:35:48.880
没事儿

00:35:49.599 --> 00:35:55.440
好吧，太好了，是的，我的意思是像我一样

00:35:55.440 --> 00:35:59.040
阻止标记db中的抽象，并且

00:35:59.040 --> 00:36:03.280
它目前没有压缩功能，就像我很想看看

00:36:03.280 --> 00:36:05.440
将压缩添加为

00:36:05.440 --> 00:36:07.599
那里有特色，您实际上可能会想知道

00:36:07.599 --> 00:36:12.160
基本上抽象出来，有一个讨论，我会链接到它

00:36:12.160 --> 00:36:17.680
嗯，在jsiphs lite中有一个关于该api应该在哪里讨论的问题

00:36:17.680 --> 00:36:19.359
去，他们应该做的一些事情

00:36:19.359 --> 00:36:22.400
处理，这包括他们真的在考虑什么障碍

00:36:22.400 --> 00:36:24.960
商店抽象看起来像是因为Rockaway一直在做工作

00:36:24.960 --> 00:36:29.040
嗯，把大商店放到工人那里

00:36:29.040 --> 00:36:33.119
这样您就可以更轻松地共享它了，这就是为什么像那些

00:36:33.119 --> 00:36:35.359
cid的变化就像我们可以达到的目的一样

00:36:35.359 --> 00:36:39.440
非常容易地在整个工作范围内共享嗯，但是像呃

00:36:39.440 --> 00:36:43.280
我们应该进入您知道的想法和潜在特征的清单

00:36:43.280 --> 00:36:48.240
在那里也进行压缩，否则，您就可以这样做

00:36:48.240 --> 00:36:51.280
有一个带有可选提示的直块api

00:36:51.280 --> 00:36:54.400
就像您传递的可选内容一样，可能会有这样的提示，那就是

00:36:54.400 --> 00:36:56.400
一种方式，另一种方式，我不希望你们考虑

00:36:56.400 --> 00:37:00.640
这，但是您实际上可能在应用程序端具有多个块

00:37:00.640 --> 00:37:04.079
存储，这样您就知道不会压缩另一个

00:37:04.079 --> 00:37:07.680
您可以选择将cid保存到这一

00:37:07.680 --> 00:37:11.200
而不是那个，然后在您拥有的多个块存储之间进行汇总

00:37:11.200 --> 00:37:13.760
做正确的查找，所以如果您不知道哪个块存储

00:37:13.760 --> 00:37:15.839
然后您只需检查所有这些，直到找到它

00:37:15.839 --> 00:37:18.320
你们有没有考虑过像鸟巢这样的设计模式

00:37:18.320 --> 00:37:20.400
我也想问一个问题，你们对多重有何看法

00:37:20.400 --> 00:37:23.920
阻止那些可能不是统一的ipfs方式的存储

00:37:23.920 --> 00:37:28.800
我是否想将它们视为不是并行的，而是更多地放在

00:37:28.800 --> 00:37:31.839
之所以相互重叠，是因为就像我通常在块状存储上放一个lru一样

00:37:31.839 --> 00:37:34.480
无论如何，所以已经有了某种层次感

00:37:34.480 --> 00:37:38.079
就像每个实际的存储系统都被包裹一样

00:37:38.079 --> 00:37:42.720
就像是一个内存缓存层，所以这就是我的想法

00:37:42.720 --> 00:37:44.880
就像将它们堆叠在一起一样

00:37:44.880 --> 00:37:48.640
这也是为什么我非常坚定地认为

00:37:48.640 --> 00:37:52.240
我们的块存储抽象应该继续使用cid，而不是

00:37:52.240 --> 00:37:56.160
分解为多哈希层，因为我们实际上可以将cid用作

00:37:56.160 --> 00:37:58.640
提示正确，我的意思是您配置时可以看到

00:37:58.640 --> 00:38:01.440
对于存储，您可以说像压缩这些一样

00:38:01.440 --> 00:38:05.920
编解码器，但不是这些编解码器，因为我们不知道它们是否压缩得好，还是我们

00:38:05.920 --> 00:38:09.280
知道他们没有，像这样的事情，而你却失去了

00:38:09.280 --> 00:38:13.440
如果仅考虑数据的粒度

00:38:13.440 --> 00:38:16.640
从多重哈希的角度来看

00:38:16.839 --> 00:38:19.839
嗯

00:38:20.079 --> 00:38:23.920
哦，抱歉，我认为在ipod prime中，我们有

00:38:23.920 --> 00:38:27.760
应该允许多个日志存储id的东西

00:38:27.760 --> 00:38:31.520
像这样的链接上下文参数

00:38:31.520 --> 00:38:36.640
允许您查看链接周围的一些直接上下文

00:38:36.640 --> 00:38:40.720
您将要做某事，所以您可以去寻找其他信息

00:38:40.720 --> 00:38:43.760
那里暗示着，如果你有模式，你可以看看

00:38:43.760 --> 00:38:47.119
输入是，或者您可以查看一些同级字段以获取有关的提示

00:38:47.119 --> 00:38:51.040
你想如何存储东西，我认为它可以用于

00:38:51.040 --> 00:38:54.079
这不完全是最初的意图，但它应该适合

00:38:54.079 --> 00:38:58.240
试试我喜欢这个主意会很有趣

00:38:58.560 --> 00:39:02.240
该计划的一部分实际上会很棒

00:39:03.040 --> 00:39:05.920
就像我从应用程序开发人员的观点说的那样，我认为我们

00:39:05.920 --> 00:39:08.720
需要对他们如何能有一个很明确的答案

00:39:08.720 --> 00:39:11.920
完成它，所以我认为我们不必

00:39:11.920 --> 00:39:15.599
今天将其散列出来，但我知道这将是一个障碍

00:39:15.599 --> 00:39:18.640
特别是我的意思可能是一些最初的

00:39:18.640 --> 00:39:22.079
ipfs的用例与数据无关

00:39:22.079 --> 00:39:25.440
非常可压缩，就像你知道电影或

00:39:25.440 --> 00:39:28.480
我不知道已经压缩过的文件是什么

00:39:28.480 --> 00:39:32.240
已经压缩了，但是当我考虑使用它时

00:39:32.240 --> 00:39:36.240
像dag db一样，我的意思是您可能会想到用例，其中

00:39:36.240 --> 00:39:39.599
我敢打赌数据是高度可压缩的dagdo可能是非常可压缩的

00:39:39.599 --> 00:39:43.040
如果你有一个非常大的数据库，你就会知道

00:39:43.040 --> 00:39:47.359
今天我们知道很多数据库确实会压缩数据，因为它们

00:39:47.359 --> 00:39:52.560
从中获得很多好处，而当您

00:39:52.560 --> 00:39:55.599
将不可压缩的数据粘贴到数据库中

00:39:55.599 --> 00:39:59.680
正在压缩，您知道这不好，无论如何还是他们

00:39:59.680 --> 00:40:03.119
可能不会压缩类似uh的内容，您知道二进制交易会将其保留为

00:40:03.119 --> 00:40:07.280
但是，无论如何，我想我们应该知道，也许以后我们可以对此进行修改，但是

00:40:07.280 --> 00:40:10.880
嗯，我认为与此有关的一件事

00:40:10.880 --> 00:40:16.400
我似乎对迈克尔感到困惑，为什么ipfs拥有

00:40:16.400 --> 00:40:22.240
盒装api时ipld不应依赖于ipfs

00:40:22.240 --> 00:40:25.680
似乎我们应该定义ipld块存储api

00:40:25.680 --> 00:40:32.400
 ipfs实现ipld应该是完全独立的

00:40:32.400 --> 00:40:35.359
从像我建立的块存储中，它应该不存在

00:40:35.359 --> 00:40:40.560
首先是块存储，所以让我们像这样放松一下

00:40:40.560 --> 00:40:43.440
一点，所以我ipld就像一套

00:40:43.440 --> 00:40:47.280
数据序列化规范等等

00:40:47.280 --> 00:40:50.480
是一些甚至根本不考虑存储而要做的事情

00:40:50.480 --> 00:40:53.760
当我们谈论内容时，您知道我们堆栈的一半内容

00:40:53.760 --> 00:40:56.720
我们的堆栈，然后我觉得总体来说就像我们需要记住的是

00:40:56.720 --> 00:40:59.359
是只实施其中很小一部分的人

00:40:59.359 --> 00:41:02.960
嗯，我们需要与他们保持兼容，这就像

00:41:02.960 --> 00:41:06.880
那些存在的感觉就像是一件好事，这不像他们不喜欢竞争

00:41:06.880 --> 00:41:14.160
嗯，所以在我们的堆栈中，我们确实有几个块抽象

00:41:14.160 --> 00:41:20.000
嗯，在大多数情况下，这些块抽象对应

00:41:20.000 --> 00:41:23.760
存放通常不属于他们的地方的存储层

00:41:23.760 --> 00:41:28.240
ipld撰写，因为iplb努力维护

00:41:28.240 --> 00:41:32.240
um与存储和网络层的不可知关系

00:41:32.240 --> 00:41:35.440
那样就是那样，我们真的不想发表意见

00:41:35.440 --> 00:41:38.800
关于您如何存储数据的信息，这并不意味着我们不是

00:41:38.800 --> 00:41:41.839
给您一个可以很容易存储的抽象

00:41:41.839 --> 00:41:44.960
或者我们甚至可能无法使用某些库来简化该库的工作

00:41:44.960 --> 00:41:47.599
未来，我们完全可以，我们可以完全做出一些阻碍

00:41:47.599 --> 00:41:50.079
这样做的抽象并将它们作为库发布出来，没有任何东西

00:41:50.079 --> 00:41:55.200
阻止我们这样做实际上只是一个项目，

00:41:55.200 --> 00:41:59.760
像规范级别一样，我们不应该具有约束力或承担任何责任

00:41:59.760 --> 00:42:03.040
特定类型的存储抽象或任何​​特定类型的网络

00:42:03.040 --> 00:42:06.640
抽象我们有解析器抽象吗

00:42:06.640 --> 00:42:09.440
因为我认为除非您您不能真正进行链接

00:42:09.440 --> 00:42:14.000
可以解析链接，这需要访问块存储

00:42:14.000 --> 00:42:17.920
是的，所以在javascript中，这是一个单一功能

00:42:17.920 --> 00:42:24.640
它需要一个cid并返回一个块，因此在很多方面

00:42:24.640 --> 00:42:27.119
这就是它所使用的js卡座

00:42:27.119 --> 00:42:31.440
um eric的系统要复杂得多

00:42:31.440 --> 00:42:35.839
没有eric像它一样被加载

00:42:35.839 --> 00:42:39.920
是的，这仍然没关系，但这在克里斯之前就已经提出了，因为

00:42:39.920 --> 00:42:43.680
我们仍然需要这个来做诸如共享测试图片之类的事情，

00:42:43.680 --> 00:42:48.079
就像我想继续尝试它一样，当我想测试图书馆和

00:42:48.079 --> 00:42:51.680
有一个我可以从中拉出积木的地方

00:42:51.680 --> 00:42:54.000
嗯，这只是一种通用的方式

00:42:54.000 --> 00:42:57.359
交流如何存储汽车文件是一个很好的例子，因此

00:42:57.359 --> 00:43:00.319
与汽车文件的东西，我也做了拉链车

00:43:00.319 --> 00:43:03.760
我围绕着相同的东西建立了接口

00:43:03.760 --> 00:43:07.599
阻止ipfs使用的存储接口，它们确实很笨重

00:43:07.599 --> 00:43:13.280
只是做块存储，所以让我想要很多东西

00:43:13.280 --> 00:43:17.520
清洁工说这是一个ipld块存储，这就是我们与之交互的方式

00:43:17.520 --> 00:43:20.000
它，关于功能的种类已经进行了一些很好的讨论

00:43:20.000 --> 00:43:22.160
我们想要的是，有一些东西会很好

00:43:22.160 --> 00:43:24.400
挑了一天，但肯定不会

00:43:24.400 --> 00:43:27.520
堆栈不可或缺的一部分，这将是我们拥有并使用的东西

00:43:27.520 --> 00:43:31.680
因为这很有用，是的，哦，我应该澄清一下

00:43:31.680 --> 00:43:34.079
一点点到目前为止我们所做的一切

00:43:34.079 --> 00:43:37.760
iqb堆栈中的极有意不可知

00:43:37.760 --> 00:43:41.119
这并不意味着我们不会做一些使之成为现实的工作。

00:43:41.119 --> 00:43:44.240
如果您看一下dagdb，那就更好了，那里有一个存储

00:43:44.240 --> 00:43:46.640
比实际要复杂得多的抽象

00:43:46.640 --> 00:43:49.440
维护链接之类的索引

00:43:49.440 --> 00:43:52.480
你可以在我所在的jso3 lite的线程中查找

00:43:52.480 --> 00:43:56.400
谈论其中的一些，像这样可能需要唤醒它的方式

00:43:56.400 --> 00:44:01.359
在ipfs中进入ipfs的原因是因为没有在该图上建立索引的链接

00:44:01.359 --> 00:44:05.680
你不能做非常高效的垃圾收集和操作

00:44:05.680 --> 00:44:10.400
而且我有一个完整的复制系统，它的完整性很好

00:44:10.400 --> 00:44:13.760
真的也要依赖这些链接

00:44:13.760 --> 00:44:17.119
看一棵树，找出我有哪些数据我有哪些数据

00:44:17.119 --> 00:44:20.319
需要我不必真正检索和解析每个块像

00:44:20.319 --> 00:44:22.960
在大型图表中，这确实非常昂贵，其中包含很多

00:44:22.960 --> 00:44:26.720
复制是你最终得到的

00:44:27.280 --> 00:44:31.119
是的，我想补充一下，哦，我实际上想补充一些想法

00:44:31.119 --> 00:44:36.560
是的，所以，嗯，几件事

00:44:36.560 --> 00:44:39.680
回到你说过的事情，与之合作的开发人员不想

00:44:39.680 --> 00:44:43.520
让这些东西占据一堆空间

00:44:43.520 --> 00:44:46.960
您正在暗中考虑此次救援的存储部分

00:44:46.960 --> 00:44:49.440
您不是在谈论ipld的大商店吗？

00:44:49.440 --> 00:44:52.720
自己说，您将必须立即进行减压以

00:44:52.720 --> 00:44:54.800
基本上像这样的链接和东西

00:44:54.800 --> 00:44:57.920
所以那是你要改变的一件事

00:44:57.920 --> 00:45:01.440
无需实际了解实施细节

00:45:01.440 --> 00:45:05.440
需要ipld将比较压缩与

00:45:05.440 --> 00:45:10.800
ipod排名第一，第二位是很多节省空间的地方

00:45:10.800 --> 00:45:14.800
在许多情况下实际上来自剥离压缩

00:45:14.800 --> 00:45:18.000
就像那是匕首拖延了这么长时间的一部分

00:45:18.000 --> 00:45:24.880
我需要写一个遗传解压缩器

00:45:24.880 --> 00:45:29.440
透明并吐出解压缩的对象

00:45:29.440 --> 00:45:34.079
代表了以前压缩过的东西，所以举个例子

00:45:34.079 --> 00:45:41.119
um dab程序包启动zim维基百科转储中的gc文件

00:45:41.119 --> 00:45:46.319
它们都不经​​常包含在庞大的存储库中

00:45:46.319 --> 00:45:50.319
相同的数据，将永远不会重复，因为它是

00:45:50.319 --> 00:45:54.000
如此压缩，如果您将其解压缩，您将最终

00:45:54.000 --> 00:45:57.280
包含所有这些的存储库

00:45:57.280 --> 00:46:02.160
已经为您解开了它的大小的一小部分

00:46:02.160 --> 00:46:05.599
需要托管数据的压缩版本

00:46:05.599 --> 00:46:09.359
这是非常重要的，这是第二点

00:46:09.359 --> 00:46:13.680
三个呃，以便您拥有一个编解码器

00:46:13.680 --> 00:46:17.760
可以验证就像rad在说什么

00:46:17.760 --> 00:46:21.680
与sibo实现一起，您需要

00:46:21.680 --> 00:46:26.400
具有超标准的

00:46:26.400 --> 00:46:29.520
参数冻结压缩算法

00:46:29.520 --> 00:46:32.560
您会认为gz在那儿，您永远都知道

00:46:32.560 --> 00:46:37.359
嗯，这是一种众所周知的格式，所有内容都可以产生相同的gzip流

00:46:37.359 --> 00:46:40.640
从同一输入绝对是错误的

00:46:40.640 --> 00:46:43.680
到我实际上有锁链的地步

00:46:43.680 --> 00:46:47.119
与呃cloudsports通讯的人写

00:46:47.119 --> 00:46:53.680
内部的这个标准gzip在同一个库的版本之间进行转换

00:46:53.680 --> 00:46:57.280
输出以相同的参数变化，我基本上

00:46:57.280 --> 00:47:00.319
跟他建立了联系，就像好吗，实际上有一些东西

00:47:00.319 --> 00:47:03.359
您保证您不会碰我，我可以真正依靠

00:47:03.359 --> 00:47:07.520
答案是“否”且参数相同我不能保证

00:47:07.520 --> 00:47:10.880
实际文本的实际压缩结果为

00:47:10.880 --> 00:47:13.920
最终将是相同的，所以它超级好

00:47:13.920 --> 00:47:16.000
重要的是要记住，您基本上

00:47:16.000 --> 00:47:20.319
如果您使用编解码器，则必须具有完整的规范

00:47:20.319 --> 00:47:24.240
该编解码器的压缩实现是什么

00:47:24.240 --> 00:47:27.599
否则没人会验证你的身份

00:47:27.599 --> 00:47:30.720
您在路上的街区，否则您将不得不喜欢

00:47:30.720 --> 00:47:34.480
你知道整个uh算法不是当每个人都将其插入时

00:47:34.480 --> 00:47:37.680
他们得到相同的东西，哪个是相同的东西

00:47:37.680 --> 00:47:40.400
您只需看一下它称为的规范

00:47:40.400 --> 00:47:44.559
嗯，我想讲的最后一点

00:47:44.559 --> 00:47:47.839
那是那个吗

00:47:47.920 --> 00:47:51.920
压缩，如果我们在谈论有用的压缩算法

00:47:51.920 --> 00:47:55.440
运输时，通常会对它们进行调整，

00:47:55.440 --> 00:48:00.319
先包含gzip，然后再广泛包含

00:48:00.319 --> 00:48:06.160
以及最近浏览器支持的其他任何功能

00:48:06.160 --> 00:48:10.720
经过优化，不会在他们花费太多时间的情况下

00:48:10.720 --> 00:48:14.160
觉得他们根本无法压缩某些东西

00:48:14.160 --> 00:48:17.680
该管道的所有内容均用于所有反式目的

00:48:17.680 --> 00:48:22.800
免费不仅是免费的

00:48:22.800 --> 00:48:25.520
与信令量相比绝对免费

00:48:25.520 --> 00:48:29.359
以及您必须随身携带的额外物质

00:48:29.359 --> 00:48:34.160
区分压缩此部分，但不压缩此部分

00:48:34.160 --> 00:48:37.839
因此，所有这些都是您需要放在一起才能完成的

00:48:37.839 --> 00:48:41.599
这样的编解码器会让您知道这不是

00:48:41.599 --> 00:48:45.599
不可逾越，但它比它看起来更具参与性

00:48:45.599 --> 00:48:49.119
浮出水面，这就是我对此的想法

00:48:49.119 --> 00:48:52.559
我认为一般来说，现在的答案是

00:48:52.559 --> 00:48:57.119
文档，因为我认为会有很多开发人员出现

00:48:57.119 --> 00:49:02.160
我想压缩我的东西，让我们光顾，然后挥手说

00:49:02.160 --> 00:49:04.880
哦，那是其他地方，我认为这是错误的。

00:49:04.880 --> 00:49:07.920
这不是一个令人满意的答案，但是如果我们可以接受一些教育的话

00:49:07.920 --> 00:49:12.160
这里是关于那些微妙的嗯彼得

00:49:12.160 --> 00:49:15.359
那那真的很好，所以我应该说我只是不

00:49:15.359 --> 00:49:19.359
原因是的，我们需要一些解释

00:49:19.359 --> 00:49:24.640
的位置，说看，我们首先你知道你应该

00:49:24.640 --> 00:49:26.960
询问您是否真的想要在这一层，因为

00:49:26.960 --> 00:49:30.960
它可以在其他层完成，而b可能已经完成

00:49:30.960 --> 00:49:34.480
在其他层次上，您甚至没有意识到它，然后

00:49:34.480 --> 00:49:37.680
谈论这些决定的困难谈论事实，你

00:49:37.680 --> 00:49:40.400
可以做到，如果您正在做某事，您今天就可以做到

00:49:40.400 --> 00:49:42.400
有原始的叮咬，你想压缩

00:49:42.400 --> 00:49:45.119
它只是g-zip，然后再将其编码为raw和

00:49:45.119 --> 00:49:48.800
如果那样的话，然后讨论与该特定问题融合的问题

00:49:48.800 --> 00:49:50.960
问题，但也许是因为视频数据

00:49:50.960 --> 00:49:54.960
没关系，因为那里总有太多疯狂

00:49:54.960 --> 00:49:57.920
所以有很多我们可以在这里记录

00:49:57.920 --> 00:50:01.119
好吧，我想实际上还有一点

00:50:01.119 --> 00:50:04.559
加快前进的速度rad带来的东西

00:50:04.559 --> 00:50:09.920
记录的目的，原因是航天飞机56更多

00:50:09.920 --> 00:50:14.240
比暖和的哈希更有效率是因为所有从事猎鹰工作的开发人员都有

00:50:14.240 --> 00:50:17.200
这些特定名称的cpus实际上具有

00:50:17.200 --> 00:50:21.280
整个指令只是为了计算航天飞机56而没有

00:50:21.280 --> 00:50:26.079
否则好吧，顺便说一句电源

00:50:26.079 --> 00:50:30.960
标准化的未来，您将永远不会看到布雷克2或

00:50:30.960 --> 00:50:36.000
blake 3s是CPU的一部分，因为它们没什么用，所以

00:50:36.000 --> 00:50:39.119
某种压缩算法似乎是合理的

00:50:39.119 --> 00:50:45.040
效率较低的将在五年内找到方法

00:50:45.040 --> 00:50:49.200
一些cpu，然后还有你所有的um

00:50:49.200 --> 00:50:53.280
关于此的特定思考现在正在编码一个您永远无法使用的缓存

00:50:53.280 --> 00:50:58.160
变化，所以不太舒服，我们花了很多时间

00:50:58.160 --> 00:51:01.839
关于这一点，但我认为我同意作为应用程序的标尺

00:51:01.839 --> 00:51:06.880
开发人员来吧，我们确实需要给他们指引方向，所以也许

00:51:06.880 --> 00:51:10.640
我们可以做的一件事是，下周，如果你们有面条的话

00:51:10.640 --> 00:51:13.920
并想好我们会怎样，你会知道我们是什么

00:51:13.920 --> 00:51:16.480
统一您知道消息传递而不是不

00:51:16.480 --> 00:51:20.800
做到这一点，你怎么做？嗯，我认为那会很好，也许我们

00:51:20.800 --> 00:51:24.480
可以拿起它，如果这很酷，是的，它经常出现

00:51:24.480 --> 00:51:27.920
我们确实需要处理它

00:51:30.079 --> 00:51:33.520
我一直都在用它，但是我想我很快就使用了另一个

00:51:33.520 --> 00:51:37.200
没有针对的设计模式或最佳做法的目录

00:51:37.200 --> 00:51:42.880
ipld之类的东西现在可以在任何地方使用

00:51:44.000 --> 00:51:51.920
哪个堆栈新去旧去新javascript老javascript新新javascript rust

00:51:51.920 --> 00:51:56.160
他们是如此不同，我认为这实际上是独立于语言的

00:51:56.160 --> 00:52:00.720
有点像，如果你要去，例如，想要获得最大

00:52:00.720 --> 00:52:02.800
重复数据删除，您不想放任何类似的东西

00:52:02.800 --> 00:52:05.760
您想将其放置在更高级别的对象中的时间戳，以及

00:52:05.760 --> 00:52:07.599
链接到我，这意味着一定有像你这样的事情

00:52:07.599 --> 00:52:10.319
伙计们想过，你就像哦，这就是

00:52:10.319 --> 00:52:14.000
这样不要很好地使用浮点数，

00:52:14.000 --> 00:52:17.280
因此，模式成为了很多模式思考的一部分

00:52:17.280 --> 00:52:20.880
甚至文档都指出了其中一些最好的方法

00:52:20.880 --> 00:52:24.000
实践方案实际上以多种方式编码了最佳实践

00:52:24.000 --> 00:52:29.040
嗯，是的，您最好对此进行更高级的讨论，但是我

00:52:29.040 --> 00:52:33.680
想一想，如果您阅读了架构文档，您将已经很适合

00:52:33.680 --> 00:52:37.760
考虑设计决策

00:52:38.559 --> 00:52:43.599
好吧，我们正在慢慢地耗尽时间。

00:52:43.599 --> 00:52:49.440
还有其他什么要说的吗？我想说我想做现场笔记

00:52:49.440 --> 00:52:53.680
在文档底部尽可能多的

00:52:53.680 --> 00:52:56.559
希望这是我认为该文档的金矿

00:52:56.559 --> 00:53:03.119
我们都同意我们需要写哦谢谢

00:53:03.359 --> 00:53:11.200
嗯，这使您成为本次会议的正式通知者

00:53:12.839 --> 00:53:15.839
嗯

00:53:18.160 --> 00:53:21.599
好吧，我猜这个星期就这么多了

00:53:21.599 --> 00:53:29.839
嗯，下周见，大家再见

