WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.759 --> 00:00:11.120
显然，我们生活在youtube上，欢迎来到ipld每周

00:00:11.120 --> 00:00:17.920
同步将是2021年1月11日

00:00:19.840 --> 00:00:26.000
我将首先进行每周更新

00:00:26.800 --> 00:00:33.520
好的，所以我的一周主要是在西雅图附近，我终于完成了

00:00:33.520 --> 00:00:38.079
我过去一直在修补海滨图书馆

00:00:38.079 --> 00:00:41.680
年um

00:00:42.160 --> 00:00:45.200
所以那是现在出版的，我有一个

00:00:45.200 --> 00:00:53.840
pr for ipld dax cbor javascript较新的javascript编解码器

00:00:53.840 --> 00:00:57.680
嗯，那是那个库中的第13个问题，可怜的

00:00:57.680 --> 00:01:01.039
关于即将发生什么变化的注释，因此

00:01:01.039 --> 00:01:04.080
打破，因为有更严格的要求

00:01:04.080 --> 00:01:10.000
嗯，这是那里的主要内容，还有一些性能说明

00:01:10.000 --> 00:01:14.720
在那里，我也做了第二次提交

00:01:14.720 --> 00:01:19.119
昨天代表南和无穷大

00:01:19.119 --> 00:01:23.920
我有下一个项目的东西是一个糟糕的问题规格回购

00:01:23.920 --> 00:01:29.600
第344号，这个问题是关于nan和

00:01:29.600 --> 00:01:33.920
无穷大和负无穷大，并表示我们将其排除在外

00:01:33.920 --> 00:01:37.320
数据模型，还有一些其他说明

00:01:37.320 --> 00:01:44.320
有关um数字类型integer和float的澄清词

00:01:44.320 --> 00:01:47.520
欣赏一些眼睛，但一旦那是

00:01:47.520 --> 00:01:51.280
如果我们同意那是前进的道路，则合并

00:01:51.280 --> 00:01:54.640
老实说，我知道我有一些强烈的想法

00:01:54.640 --> 00:01:58.960
最初的讨论，我有点担心

00:01:58.960 --> 00:02:02.880
这个嗯，但我可以将其锁定

00:02:02.880 --> 00:02:06.799
并完成它嗯

00:02:06.799 --> 00:02:10.640
我昨天在做一些实验

00:02:10.640 --> 00:02:14.720
我发现那个即使cbor

00:02:14.720 --> 00:02:18.879
为这三件事保留特定的令牌

00:02:18.879 --> 00:02:22.560
nan无穷大和负无穷大um，因为它是

00:02:22.560 --> 00:02:29.840
忠实地解码ieee 754，它将也解码任何

00:02:29.840 --> 00:02:33.519
转换成这些的其他位布局

00:02:33.519 --> 00:02:36.959
事情，所以不只是这不只是一个

00:02:36.959 --> 00:02:40.480
通过海滨获取这些东西的方法尤其是有很多方法

00:02:40.480 --> 00:02:43.360
dan，因为nan我真的认为这只是一个后备

00:02:43.360 --> 00:02:48.239
所有不是浮点数的东西都是适当的浮点数，以便

00:02:48.239 --> 00:02:52.000
所以就像任何说它是浮动的东西一样

00:02:52.000 --> 00:02:59.680
在无法正确解码为呃尾数的指数的sibor中

00:02:59.680 --> 00:03:07.760
以一种干净的方式最终会变成nan，然后是一系列的价值观

00:03:07.760 --> 00:03:10.800
也将以无穷大和负无穷大结束

00:03:10.800 --> 00:03:14.080
所以我们谈论的是非常广泛的

00:03:14.080 --> 00:03:17.360
的字节数将变成这些东西

00:03:17.360 --> 00:03:20.400
因此，我们与这些产品之间的距离还有很长的路要走

00:03:20.400 --> 00:03:27.920
一个数据，一个字节的布局，适合编解码器使用，所以我想这是一个理由

00:03:27.920 --> 00:03:33.280
在这个um上扣动扳机，我没看过go，如果go

00:03:33.280 --> 00:03:37.120
成为最草率的javascript，如果走了一点，我也不会感到惊讶

00:03:37.120 --> 00:03:41.680
呃，比JavaScript多了

00:03:41.680 --> 00:03:46.239
javascript趋向于很容易抛出nan

00:03:46.239 --> 00:03:50.799
嗯，最后还有一个拉取请求

00:03:50.799 --> 00:03:54.799
规格回购三四五这是额外的严格性

00:03:54.799 --> 00:03:59.360
如我所知，对匕首或只是其他一些小细节的说明

00:03:59.360 --> 00:04:02.640
随着我的头脑深入到这个空间，还有更多类似的东西

00:04:02.640 --> 00:04:08.000
您知道，就像标签号一样，您可以在

00:04:08.000 --> 00:04:12.959
与其他整数一样，您可以将其最小化

00:04:12.959 --> 00:04:17.600
可能，或者您可以将其设置为64位，并且仍然是相同的数字，因此我们

00:04:17.600 --> 00:04:22.240
可以说标签42并将其表示为64位

00:04:22.240 --> 00:04:25.280
所以甚至有很多方法可以代表

00:04:25.280 --> 00:04:29.919
标签42的方式不多，有几种方法可以代表它

00:04:29.919 --> 00:04:34.240
嗯，所以只是澄清一下，我们只导出一个标签

00:04:34.240 --> 00:04:40.320
42，它必须是八个字节八个位，这是

00:04:40.320 --> 00:04:45.120
那会是什么，是的，疯狂

00:04:45.120 --> 00:04:51.199
反正就是我，我是丹尼尔

00:04:52.639 --> 00:04:59.360
很酷，所以今天我要简短，我在几个小时前说过

00:04:59.360 --> 00:05:02.639
因为他们遇到badge问题，所以有司机

00:05:02.639 --> 00:05:07.440
用于该数据存储的go ipfs，以及

00:05:07.440 --> 00:05:11.280
他们做这个时髦的事情，目前请使用版本1

00:05:11.280 --> 00:05:14.880
和上游版本2，而他们即将发布版本3

00:05:14.880 --> 00:05:19.199
而且这些发行版中的每个发行版都不会跟着sember播放，因此它们会中断

00:05:19.199 --> 00:05:22.720
向后兼容，只要他们想要，这很有趣

00:05:22.720 --> 00:05:26.639
请问他们为版本1和版本2创建了单独的存储库

00:05:26.639 --> 00:05:30.080
所以他们去修改所有的东西，他们担心如何

00:05:30.080 --> 00:05:33.440
会寻找模块，所以我想我们想出了办法

00:05:33.440 --> 00:05:37.680
那会很好，至少不会像我们那样

00:05:37.680 --> 00:05:41.120
要说基本上是一个回购，然后是版本1跟踪badge

00:05:41.120 --> 00:05:45.440
版本1版本2跟踪badge版本2，依此类推，如果

00:05:45.440 --> 00:05:48.240
你用它，然后你去得到一些更新

00:05:48.240 --> 00:05:51.120
可能会因为because可能已损坏而中断

00:05:51.120 --> 00:05:54.639
但是您无法解决此问题，因为如果上游中断，

00:05:54.639 --> 00:05:59.120
你在做什么，所以我想只要他们

00:05:59.120 --> 00:06:02.240
发出警告，例如嘿，您知道在更新此内容时要小心

00:06:02.240 --> 00:06:06.880
或badge，因为不是，它不会跟随呃，我认为那是

00:06:06.880 --> 00:06:11.600
好的权衡，我看到我的脸在手掌[音乐]

00:06:11.600 --> 00:06:15.520
我就像我不知道为什么不使用它作为主要发行版本

00:06:15.520 --> 00:06:18.880
打破变化的信号，就像您拥有无限数量的

00:06:18.880 --> 00:06:23.440
像他妈的这样的数字会像点一样使用它们

00:06:23.440 --> 00:06:26.000
这些大型版本的主要

00:06:26.000 --> 00:06:29.440
当您不使用它们来表示其他任何东西时

00:06:29.440 --> 00:06:32.479
让我们参加一个聚会，让你喜欢的蛋糕他妈的

00:06:32.479 --> 00:06:37.280
我发现我发现经常与某人不合作的人

00:06:37.280 --> 00:06:40.800
变得非常讨厌更改您的版本，所以

00:06:40.800 --> 00:06:44.800
是的，我的意思是说老实话，我不认为这就是why的原因

00:06:44.800 --> 00:06:48.479
我认为这就是他们这样做的原因，我认为他们只是讨厌别人

00:06:48.479 --> 00:06:50.960
因为你看他们的主要产品叫做

00:06:50.960 --> 00:06:57.520
我认为是d图，其版本字面称为20.07.3版

00:06:57.520 --> 00:07:01.440
那就像一个2020年的日历年

00:07:01.440 --> 00:07:05.440
7月，然后0.3只是因为他们喜欢免费的我猜

00:07:05.440 --> 00:07:08.560
嗯，所以我爱他们，他们正在用这个来做

00:07:08.560 --> 00:07:11.919
多年，然后他们就像我们只是忘了y2k发生了，我们只是

00:07:11.919 --> 00:07:16.080
第一个数字要用两位数字，所以从技术上讲，

00:07:16.080 --> 00:07:19.520
不，你只被允许在1月1日打破东西，然后就结束了

00:07:19.520 --> 00:07:26.160
不是，您无论如何都不允许使用12个月，所以无论如何都对不起您的切线

00:07:26.160 --> 00:07:30.400
我也很喜欢eric对新的流利包装做了什么

00:07:30.400 --> 00:07:34.479
ipld prime，所以我对此有一些想法，但我不想结束

00:07:34.479 --> 00:07:37.840
我们决定不覆盖我的更改

00:07:37.840 --> 00:07:42.960
在他的上面，所以我发表了一篇论文，从本质上讲，它公开了一个新的

00:07:42.960 --> 00:07:46.960
相当相似，但有一些变化，基准几乎是

00:07:46.960 --> 00:07:49.520
洗一下，即使我认为api更好一点

00:07:49.520 --> 00:07:52.800
性能大致相同

00:07:54.479 --> 00:07:57.840
我也开始写我去过的go dog的ci最佳做法

00:07:57.840 --> 00:08:01.919
谈论了很长时间，所以我和迈克尔和埃里克交谈，我们

00:08:01.919 --> 00:08:05.840
决定我们只是将markdown文件粘贴到ipld repo中

00:08:05.840 --> 00:08:08.960
然后我们可以开始为我们的团队参考

00:08:08.960 --> 00:08:12.080
然后，如果运作良好，而其他类似ipfs的团队希望

00:08:12.080 --> 00:08:16.080
也开始关注它，这也很好，我认为这也将是

00:08:16.080 --> 00:08:20.160
对马丁来说是好事，他正在做一些自动化的事情

00:08:20.160 --> 00:08:23.440
github动作的分布，所以至少要这样做

00:08:23.440 --> 00:08:26.800
可以将该文档用作参考，这就是为什么您

00:08:26.800 --> 00:08:31.280
应该做这个或那个等等

00:08:31.280 --> 00:08:34.399
我也开始看着包边的文件硬币

00:08:34.399 --> 00:08:38.719
特别是它的所有测试，因为如果我想与之兼容

00:08:38.719 --> 00:08:43.680
我希望理想情况下能够对我的定制实现进行所有测试

00:08:43.680 --> 00:08:46.880
但我不清楚这样做最简单的方法是什么，因为他们确实

00:08:46.880 --> 00:08:50.720
有很多测试，但它们与他们的紧密联系

00:08:50.720 --> 00:08:54.480
节点实现，所以我不清楚

00:08:54.480 --> 00:08:57.600
如果有人有最简单的方法，请让我知道

00:08:57.600 --> 00:09:02.080
我还做了很多补丁以减少兽医警告的数量

00:09:02.080 --> 00:09:05.600
ipld主代码生成器生成的

00:09:05.600 --> 00:09:09.279
嗯，我只删除了3000个中的大约500个

00:09:09.279 --> 00:09:12.720
但它比听起来好多了，因为其中很多是这样产生的

00:09:12.720 --> 00:09:18.720
嗯，我会说我已经完成一半了，对我来说就是这样

00:09:19.120 --> 00:09:26.000
我在那儿有一些评论，只是关于快点的东西，嗯。

00:09:26.000 --> 00:09:28.480
我对原著发表的评论之一，我开始写这篇文章，但我

00:09:28.480 --> 00:09:31.519
我以为只是谈论就容易了

00:09:31.519 --> 00:09:35.040
我评论过的原始玩笑之一是

00:09:35.040 --> 00:09:39.760
um作为用户，您作为

00:09:39.760 --> 00:09:43.680
您正在处理中，您会看到何时出现错误，因此

00:09:43.680 --> 00:09:49.680
如果您有一些条件逻辑，那么您可以处理类似

00:09:49.680 --> 00:09:53.760
大多数情况下，您只会忽略错误，然后像这样处理顶部

00:09:53.760 --> 00:09:58.080
您已经完成了自己的版本，但是在某些情况下，您会说

00:09:58.080 --> 00:10:03.120
好吧，如果我到了这一点，并且有一个错误，我真的不想要

00:10:03.120 --> 00:10:06.399
在这里做这个事情，因为它不是项目强大的，它是

00:10:06.399 --> 00:10:09.600
你知道它会做一些我不能退出的事情

00:10:09.600 --> 00:10:13.200
嗯，所以我真的需要知道这是否是这件事

00:10:13.200 --> 00:10:15.839
成功的话，我想这样做，如果不成功，我绝对不会

00:10:15.839 --> 00:10:18.640
想要这样做，就像您可能要垃圾收集一样

00:10:18.640 --> 00:10:22.720
您的数据存储之类的东西，就像它

00:10:22.720 --> 00:10:25.600
事务性事物，现在您所处的位置

00:10:25.600 --> 00:10:28.079
冒泡到顶部的区域，您将有机会看到它在哪里

00:10:28.079 --> 00:10:32.480
所以说您流失的机会更加流利

00:10:32.480 --> 00:10:35.120
那是我对此的唯一评论，我真的不知道这有什么大不了的

00:10:35.120 --> 00:10:37.680
因为如果那样的话

00:10:37.680 --> 00:10:40.640
那也许你还是不会使用那个包

00:10:40.640 --> 00:10:44.800
也许您希望大多数使用中出现错误的情况都会导致

00:10:44.800 --> 00:10:48.800
无论如何有些恐慌，这只是我对此的反馈

00:10:48.800 --> 00:10:52.399
随心所欲

00:10:52.399 --> 00:10:56.959
嗯，我对另一种大麻有另一条评论，但

00:10:56.959 --> 00:11:00.640
任何回应，我只是要简短地说

00:11:00.640 --> 00:11:03.600
我认为应该没有尝试过，但是我认为应该有可能只是因为

00:11:03.600 --> 00:11:06.640
接口本质上与eric的减号相同

00:11:06.640 --> 00:11:10.880
错误指针，因此您可能需要一些代码

00:11:10.880 --> 00:11:14.480
像三个级别的下来，只是手动使用ipld素数

00:11:14.480 --> 00:11:18.720
只会返回错误的api，然后如果您想冒泡的话

00:11:18.720 --> 00:11:23.760
就像我的api一样讽刺

00:11:23.760 --> 00:11:27.600
同样，您可以进行多次演唱

00:11:27.600 --> 00:11:32.320
是的，好吧，汉普顿的事，也许是最好的

00:11:32.320 --> 00:11:35.680
做到这一点的方法是um，我知道其中很多

00:11:35.680 --> 00:11:43.440
实际上，很多测试实际上都集中在非常细微的细节上

00:11:43.440 --> 00:11:47.360
但是你至少可以为其中一些人做些什么

00:11:47.360 --> 00:11:54.480
运行测试并打印出一个以id为根的cid

00:11:54.480 --> 00:11:58.880
然后这就是您所关心的，因此您可以运行相同的逻辑

00:11:58.880 --> 00:12:02.560
获得相同的CID都很好，我知道一些测试

00:12:02.560 --> 00:12:06.959
我认为是依靠root cid，然后有很多测试

00:12:06.959 --> 00:12:10.160
还有我实际检查过你的

00:12:10.160 --> 00:12:16.079
您的字节布局手动um，这样可能也很有用，但我会

00:12:16.079 --> 00:12:18.720
说root cid给您您真正需要的一切

00:12:18.720 --> 00:12:23.519
如果您没有获得相同的root cid，则您没有获得相同的表格

00:12:23.519 --> 00:12:27.440
所以也许就是这样

00:12:27.600 --> 00:12:30.720
是的，听起来不错，谢谢

00:12:31.279 --> 00:12:38.399
迈克尔，你起来了，下一个吧，好吧，坚持

00:12:38.399 --> 00:12:44.880
好吧，嗯，好吧，所以一堆ip sql的东西嗯

00:12:44.880 --> 00:12:51.760
所以是的，您现在可以um导入大多数csvs um并从中获取一个sql数据库

00:12:51.760 --> 00:12:54.800
然后可以将该数据库导出为汽车文件

00:12:54.800 --> 00:13:00.480
可以执行sql查询并仅为查询导出汽车文件，因此

00:13:00.480 --> 00:13:04.959
嗯，从字面上看，就像一个很小的子集，只是基本上满足了该查询

00:13:04.959 --> 00:13:08.399
我们现在有sql查询的默克尔证明，嗯，这是

00:13:08.399 --> 00:13:14.880
美丽，我还添加了加密，我们将讨论这种方法

00:13:14.880 --> 00:13:18.560
加密，然后在通话结束时执行um

00:13:18.560 --> 00:13:21.519
更大的事情就像我们可能实际上就是这样

00:13:21.519 --> 00:13:24.399
做fld块层加密，所以我会讲一点

00:13:24.399 --> 00:13:28.480
稍后，但是您可以针对以下任何一种导出呃加密的汽车文件

00:13:28.480 --> 00:13:32.880
事情，然后通过呃解密那些车做查询

00:13:32.880 --> 00:13:35.839
嗯，你实际上可以乘那辆车

00:13:35.839 --> 00:13:41.440
文件并将其固定在ipfs中，并在加密的图形周围复制

00:13:41.440 --> 00:13:47.199
很好，嗯，那是一件非常有趣的事

00:13:47.199 --> 00:13:51.760
嗯，我还添加了一个命令行界面

00:13:51.760 --> 00:13:55.519
呃像create和insert之类的突变以及所有类似的东西um

00:13:55.519 --> 00:13:58.560
所以是的，如果您续集真的来了，我认为下一组

00:13:58.560 --> 00:14:02.639
我要做的事情可能是um像键值一样的键值存储

00:14:02.639 --> 00:14:05.440
表格基本上可以利用相同种类的列

00:14:05.440 --> 00:14:09.440
基于模式但在键值存储上进行索引，然后

00:14:09.440 --> 00:14:14.000
让各列使用um路径作为各列的名称

00:14:14.000 --> 00:14:17.920
这样我们就可以基本上将任意的dags放入键值存储中

00:14:17.920 --> 00:14:20.639
然后遍历将起作用，然后您可以使用以下命令查询它们

00:14:20.639 --> 00:14:24.639
常规sql，因为这些列索引将对其进行规范化

00:14:24.639 --> 00:14:31.440
这样会非常热，嗯，最后一件事是

00:14:31.440 --> 00:14:36.399
我在星期六谈论可乐，所以mikola就像这样

00:14:36.399 --> 00:14:40.720
玩这个中文游戏，他们在编码所有的中文

00:14:40.720 --> 00:14:45.040
游戏数据为json和类似自定义的数据

00:14:45.040 --> 00:14:49.600
数据结构um，但它们只是在使用，并且正在使用fpfs，但它们是

00:14:49.600 --> 00:14:52.320
只是将所有内容编码为原始字节，然后它们就像

00:14:52.320 --> 00:14:54.560
谈论这些原始字节的cid

00:14:54.560 --> 00:14:56.639
我们正在谈论他想做的一些事情

00:14:56.639 --> 00:14:58.959
我当时很了解他的构建流程如何运作

00:14:58.959 --> 00:15:03.199
事实证明，就像他们实际上每次重建所有游戏资产一样

00:15:03.199 --> 00:15:06.320
时间，他们改变了一切，所以他们有这样的庞大的身材

00:15:06.320 --> 00:15:09.120
他们必须重新运行的管道，这真的很昂贵

00:15:09.120 --> 00:15:13.199
并且因为他们因为他们有离线案例和其他东西

00:15:13.199 --> 00:15:17.279
整个构建管道也存在于浏览器中，所以很多

00:15:17.279 --> 00:15:21.120
已经在webassembly中了，所以他就像已经中途了

00:15:21.120 --> 00:15:25.279
到一个用ipld做事的webassembly构建系统，我们开始

00:15:25.279 --> 00:15:28.320
谈论一些基本水平

00:15:28.320 --> 00:15:32.399
他需要开始的原语就像只是引用这些

00:15:32.399 --> 00:15:36.320
Webassembly在数据本身中发挥作用，并可能在做

00:15:36.320 --> 00:15:40.160
东西更懒惰地重建，如果没有的话，也许不重建

00:15:40.160 --> 00:15:45.360
您需要像这样的东西，所以注释中有一个链接

00:15:45.360 --> 00:15:48.880
嗯，但是我写了一个草图，就像我们最底层的图元一样

00:15:48.880 --> 00:15:51.199
想要为此使用它，这只是一个真正的

00:15:51.199 --> 00:15:54.959
像简单的sebor对象，在它上面的一个库中，我在哪里

00:15:54.959 --> 00:15:58.079
就像您知道要使用fbl一样

00:15:58.079 --> 00:16:00.959
你知道二进制的大块之类的东西，但是嗯

00:16:00.959 --> 00:16:04.959
这很有趣，就像我认为我们真的在考虑它

00:16:04.959 --> 00:16:08.240
就像试图提出整个主机环境一样

00:16:08.240 --> 00:16:12.000
webassembly函数的调用方式就像让别人处理一样

00:16:12.000 --> 00:16:16.399
就像我们需要做的一样，就像链接到人们将要编译的二进制文件一样

00:16:16.399 --> 00:16:18.639
进入webassembly，然后弄清楚如何运行

00:16:18.639 --> 00:16:21.680
然后他的输入将是另一个cid

00:16:21.680 --> 00:16:25.839
就像输出数据一样，然后您可以拥有多个系统

00:16:25.839 --> 00:16:29.040
如果有意义的话，可以在此之上使用某种工具

00:16:29.040 --> 00:16:32.720
所以这也是一件很酷的事情，但是是的，我们将对加密表进行表

00:16:32.720 --> 00:16:36.079
直到我们在每个人都完成更新之后才能使用它，但这就是

00:16:36.079 --> 00:16:38.800
我在哪里很酷

00:16:41.279 --> 00:16:48.639
好的，彼得，是的，我是下一个，我想是的，所以我一直在努力

00:16:48.639 --> 00:16:53.519
我上周用这些能力工作的东西

00:16:53.519 --> 00:16:56.959
把几乎所有的莲花放到一个单一的

00:16:56.959 --> 00:16:59.519
数据库

00:16:59.839 --> 00:17:07.280
将其切成性能信封，以后可以实际使用

00:17:07.280 --> 00:17:11.839
倒退它实际上可以越过一堆你知道老了

00:17:11.839 --> 00:17:15.640
并在合理的时间摄取它们

00:17:15.640 --> 00:17:20.480
不幸的是，当前的变种很快并且

00:17:20.480 --> 00:17:24.160
在僵局方面经常犯错

00:17:24.160 --> 00:17:33.280
我正在努力解决这个问题

00:17:33.280 --> 00:17:38.960
最初的UM测试来自其他人

00:17:38.960 --> 00:17:43.919
积极的，你基本上得到了一个完整的猎鹰节点

00:17:43.919 --> 00:17:49.200
从开始到结束大概一个小时之内就可以了

00:17:49.200 --> 00:17:53.039
恩与所有与我们拥有的所有数据

00:17:53.039 --> 00:18:00.000
嗯，是的，我唯一要等待的就是rad的输入，如果它

00:18:00.000 --> 00:18:03.440
给了您与事物一起工作所需要的东西

00:18:03.440 --> 00:18:08.480
嗯，我们不必在通话中这样做，是的，希望本周我能

00:18:08.480 --> 00:18:13.120
另一个呃尝试在星期三获得主网

00:18:13.120 --> 00:18:16.240
包括新代码的内容，并了解其进展情况

00:18:16.240 --> 00:18:18.880
这就是我的全部

00:18:19.360 --> 00:18:22.400
他们会在12个月前就猜到，团队的大部分时间都将花在

00:18:22.400 --> 00:18:28.400
在这个时间点花在续集上

00:18:28.400 --> 00:18:31.360
埃里克接下来

00:18:33.440 --> 00:18:37.200
所以我也做了一些总结工作

00:18:37.200 --> 00:18:40.480
这些小的研究峰值可以使我们变得更好

00:18:40.480 --> 00:18:44.400
api可以使用go ipld prime和

00:18:44.400 --> 00:18:47.600
所以是的，丹尼尔和我都在这方面做了自己的小事，我认为

00:18:47.600 --> 00:18:50.799
他们俩都很有趣我的那个会犯更多错误

00:18:50.799 --> 00:18:53.280
在你的脸上

00:18:53.360 --> 00:18:56.640
所以我们现在都得到了公关，我想我们将在上面合并

00:18:56.640 --> 00:19:02.000
嗯，我要把它写在问题上，这会很酷

00:19:02.000 --> 00:19:05.440
在github上，但之前提到的标尺的东西我有一个非常相似的东西

00:19:05.440 --> 00:19:08.240
考虑过um尝试使用更多策略的策略

00:19:08.240 --> 00:19:12.799
对此感到恐慌，它进入这种情况

00:19:12.799 --> 00:19:16.240
几乎让我想起了

00:19:16.240 --> 00:19:18.720
您的工作问题是什么颜色

00:19:18.720 --> 00:19:24.640
这是一个更糟糕的问题，这是一个巧妙命名的博客文章，

00:19:24.640 --> 00:19:30.559
谈论异步功能，我认为主要是javascript，但这是一个

00:19:30.559 --> 00:19:33.840
我有时会在api中查看的模式

00:19:33.840 --> 00:19:37.200
当我编写它们的功能时，我将不得不在头脑中开始标记

00:19:37.200 --> 00:19:39.200
他们用不同的颜色，看看他们是否要

00:19:39.200 --> 00:19:47.039
正确撰写，并且api有时会出现恐慌

00:19:47.039 --> 00:19:50.000
对我来说有点打击

00:19:50.320 --> 00:19:54.960
就像您是否不依赖方法签名来确定是否

00:19:54.960 --> 00:19:58.240
不是这个操作会以某种方式出错

00:19:58.240 --> 00:20:01.280
将必须阅读文档以及可能的正文以查看是否

00:20:01.280 --> 00:20:06.080
可能会感到恐慌，而那些人可能会变得有些奇怪

00:20:06.080 --> 00:20:10.240
因此，如果您有强大的能力，可以像您一样

00:20:10.240 --> 00:20:13.280
你有足够的约定，好吧，我在顶层有此功能，

00:20:13.280 --> 00:20:15.440
然后里面的一切可能会惊慌，我会

00:20:15.440 --> 00:20:23.919
我会知道这一点，然后像有时那样行得通，但随后

00:20:23.919 --> 00:20:28.240
就像抢劫案所暗示的那样，在这种情况下，

00:20:28.240 --> 00:20:33.520
您可能需要知道是否在其他途中遇到了错误

00:20:33.520 --> 00:20:39.039
像是逻辑互动的原因嗯，那么如果您需要这样做

00:20:39.039 --> 00:20:42.320
现在您必须再次调用头脑中的颜色模型

00:20:42.320 --> 00:20:47.919
如果您有尝试这种模式，您也可能会

00:20:47.919 --> 00:20:52.400
通过顶级功能帮助您，将始终在进行错误收集

00:20:52.400 --> 00:20:56.080
嗯，那么您最终会看到该顶级功能

00:20:56.080 --> 00:21:00.720
在几个地方，现在您的缩进在一个地方有两个含义

00:21:00.720 --> 00:21:03.360
无论如何都放在这个quip示例中

00:21:03.360 --> 00:21:08.000
缩进意味着我的数据树结构类似

00:21:08.000 --> 00:21:11.840
现在有一个更深层的孩子嵌套，但是在某些地方，我们会获得

00:21:11.840 --> 00:21:14.880
缩进，我们需要我在这里有错误处理逻辑，并且

00:21:14.880 --> 00:21:18.080
您将再次在脑海中为它们着色这是压痕数据

00:21:18.080 --> 00:21:22.159
结构还是亚伦

00:21:23.039 --> 00:21:28.799
这些只是我认为api仍然有潜力的想法

00:21:28.840 --> 00:21:32.880
认为我在javascript中有类似的事情

00:21:32.880 --> 00:21:38.159
实际上就像获取块会抛出未找到的东西，有时

00:21:38.159 --> 00:21:41.440
您只想知道它是否不存在，所以您最终不得不喜欢尝试

00:21:41.440 --> 00:21:46.080
捕获，但是如果您返回null，那会更干净

00:21:46.080 --> 00:21:49.760
那么您将在javascript中收到其他严重错误，因为像mill一样

00:21:49.760 --> 00:21:53.120
就像它是一个对象，所以事情发生了

00:21:53.120 --> 00:21:56.080
当您退还它时，错误会在其他真正困难的地方发生

00:21:56.080 --> 00:21:58.559
进行调试，因此似乎没有很好的解决方案

00:21:58.559 --> 00:22:01.120
像我还没有找到我喜欢在JavaScript中解决此问题的东西

00:22:01.120 --> 00:22:03.280
然而

00:22:04.159 --> 00:22:07.360
嗯，所以我这周工作的其他内容是

00:22:07.360 --> 00:22:12.720
大多数情况下，我正在尝试使用Guy的模式包

00:22:12.720 --> 00:22:17.679
使用模式dmt包进行pld prime

00:22:17.679 --> 00:22:21.679
这提醒了数据模型树的首字母缩写，这是

00:22:21.679 --> 00:22:25.280
我所说的是代码生成输出的程序包

00:22:25.280 --> 00:22:29.520
使用模式架构，以便程序包可以

00:22:29.520 --> 00:22:32.559
像JSON模式文档一样识别并给您

00:22:32.559 --> 00:22:35.039
事情

00:22:35.600 --> 00:22:39.840
所以这里的追求目的是将这两件事结合在一起

00:22:39.840 --> 00:22:45.120
然后将能够处理json模式文档，例如

00:22:45.120 --> 00:22:49.440
为此运行darm代码生成器，就像隐藏所有这些代码一样，

00:22:49.440 --> 00:22:52.880
这个非常lfo警告的临时api

00:22:52.880 --> 00:22:56.080
以编程方式构造模式信息，我们实际上并没有

00:22:56.080 --> 00:22:59.600
想告诉人们我们希望他们给我们该死的json文档

00:22:59.600 --> 00:23:03.200
我们将使用它，然后给他们结果

00:23:03.280 --> 00:23:08.880
所以这不是我第一次喜欢在这里做骑马比赛，我希望

00:23:08.880 --> 00:23:13.760
这将是最后一次，但这不是以前的方法

00:23:13.760 --> 00:23:19.679
我认为我们可以通过以下方式解决此问题

00:23:19.679 --> 00:23:23.360
在模式dmt包周围编写非常薄的包装器

00:23:23.360 --> 00:23:27.120
因此，您的99个数据仍将以这些生成的类型保存，我们将

00:23:27.120 --> 00:23:29.679
为一些类似的事情写这些非常薄的包装纸

00:23:29.679 --> 00:23:33.360
图形属性，需要更多的指针和

00:23:33.360 --> 00:23:37.120
然后就可以了，所以这将导致很多不变性

00:23:37.120 --> 00:23:40.000
免费的属性会导致我写的不是这样

00:23:40.000 --> 00:23:45.600
太多的代码，因为它不是多余的，只是看起来

00:23:45.600 --> 00:23:49.200
一个不错的方法，它行不通，因为golang有

00:23:49.200 --> 00:23:54.039
导入周期检测器和生成的代码实现

00:23:54.039 --> 00:23:57.360
模式类型的节点

00:23:57.440 --> 00:24:01.120
因此，请让架构包按顺序引用此生成的代码包

00:24:01.120 --> 00:24:07.840
实施自己的东西是一个大老派不悲伤悲伤的长号

00:24:07.840 --> 00:24:15.840
只是我度过了非常难过的一天

00:24:15.840 --> 00:24:18.240
丹妮尔（Danielle）我谈到了解决这个问题的不同方法

00:24:18.240 --> 00:24:20.960
有很多不同的想法，其中一些

00:24:20.960 --> 00:24:27.279
比别人更复杂，聪明，我不知道我在做什么

00:24:27.279 --> 00:24:32.400
现在考虑的想法是要尽量减少复杂性um

00:24:32.400 --> 00:24:35.679
我们想出的一些最花哨的东西都在尝试使用

00:24:35.679 --> 00:24:39.679
um的别名功能可以使周期消失，

00:24:39.679 --> 00:24:42.799
这些都是天才，但有点吓人

00:24:42.799 --> 00:24:46.320
我现在在想的是，我们大约有三个包裹

00:24:46.320 --> 00:24:51.200
其中之一是与之前相同的dmt模式包，以便处理原始json

00:24:51.200 --> 00:24:55.440
数据模式编译器包，这将

00:24:55.440 --> 00:24:59.039
仍然具有导出的功能，可用于以编程方式创建此功能

00:24:59.039 --> 00:25:03.600
完全批准的信息，然后架构包本身将

00:25:03.600 --> 00:25:07.039
只是接口

00:25:07.679 --> 00:25:11.360
这让我很生气，因为编写代码的人

00:25:11.360 --> 00:25:17.440
因为这些软件包的内部超级多余

00:25:17.440 --> 00:25:21.120
模式编译器程序包将包含所有这些我将要执行的本机结构

00:25:21.120 --> 00:25:25.200
必须再次写，几乎与

00:25:25.200 --> 00:25:30.159
生成的dmt结构，我就是这样

00:25:30.880 --> 00:25:34.159
完全可以

00:25:35.840 --> 00:25:41.919
但是导入周期很长，所以就像我一样，这就是我们要做的

00:25:41.919 --> 00:25:46.320
显然，所以当我最终发布此公关文件时

00:25:46.320 --> 00:25:50.480
与其他文件一样，在文档中也附带了很多警告

00:25:50.480 --> 00:25:55.120
使用代码生成工具的开发人员，请不要执行我们在此所做的工作

00:25:55.120 --> 00:26:00.640
因为我们这样做是为了避免周期检测器

00:26:00.640 --> 00:26:04.720
没有人会遇到这个问题，请这样做

00:26:04.720 --> 00:26:12.880
不以这个为例，所以我仍然同意其中的一些

00:26:12.880 --> 00:26:16.720
大概要完成85个，才能完成接下来的几个

00:26:16.720 --> 00:26:20.320
我希望的日子就是这样，它沉没了很多

00:26:20.320 --> 00:26:25.840
我的星期

00:26:26.640 --> 00:26:33.520
好吧，好吧，好吧，丁恩，卡森，你们两个都不想要

00:26:33.520 --> 00:26:35.840
添加您有趣的事物的任何更新

00:26:35.840 --> 00:26:39.840
在本周完成了相关的ipl

00:26:40.320 --> 00:26:43.600
在过去一周中，我对我的直接评价不高

00:26:43.600 --> 00:26:51.120
嗯，在某个时候，如果世界一次，我将回到graphql阶段

00:26:51.120 --> 00:26:54.480
actors v3解决了该更新并提供了帮助

00:26:54.480 --> 00:26:57.279
可能最主要的

00:26:57.919 --> 00:27:04.320
嗯，我为此推了一个公关嘿，如果我们使用bitswap

00:27:04.320 --> 00:27:10.559
下载大块的东西，嗯，不胜感激一些想法

00:27:10.559 --> 00:27:17.840
这两个最大的事情是这样的，我想我仔细检查了一下

00:27:17.840 --> 00:27:22.640
安全属性，基本上可以拍摄256

00:27:22.640 --> 00:27:30.080
处理他们所谓的自由碰撞之类的问题

00:27:30.080 --> 00:27:33.440
然后另一个就像这是正确的事情

00:27:33.440 --> 00:27:36.880
做或喜欢的事情是如果我们做到了

00:27:36.880 --> 00:27:39.919
我们应该躲在被窝里或类似的地方

00:27:39.919 --> 00:27:43.919
你知道告诉别人这是一件好事

00:27:43.919 --> 00:27:48.399
而不是分享，这意味着您知道而不是分享

00:27:48.399 --> 00:27:53.760
呃dag标识符，用于您的文件，您将共享

00:27:53.760 --> 00:27:57.679
文件的规范标识符

00:27:59.200 --> 00:28:02.240
那么您对此有何想法？

00:28:02.240 --> 00:28:09.440
公关好的，我已经在笔记中删除了该链接

00:28:09.840 --> 00:28:20.159
我认为那是一个公共回购协议吗

00:28:20.159 --> 00:28:23.760
从你那里得到任何东西，我主要是

00:28:23.760 --> 00:28:27.279
就在这里，只是为了在后台潜伏，

00:28:27.279 --> 00:28:31.279
嗯，很好，所以我把它留在那儿哦，还有一些令人兴奋的东西，但是

00:28:31.279 --> 00:28:32.640
我会等到我赚了更多

00:28:32.640 --> 00:28:38.320
那里有进步，很酷，还有其他标题吗？

00:28:38.320 --> 00:28:40.240
我们想放的项目，包括这次会议

00:28:40.240 --> 00:28:43.440
嗯，我们将直接合并到下一次会议

00:28:43.440 --> 00:28:46.960
迈克尔还是那是一件单独的事情，不好吧，让我们继续

00:28:46.960 --> 00:28:49.840
录制进行中，是的，您知道要进行另一次录制

00:28:49.840 --> 00:28:52.720
会很烦，嗯，好吧，我要关闭这个

00:28:52.720 --> 00:28:57.520
见面，或者您也想在接下来的事情上做笔记

00:28:57.520 --> 00:29:00.799
嗯，我们可以将其作为本次会议的一部分包括在内

00:29:00.799 --> 00:29:05.679
嗯，好吧，是的，我的意思是就像我说的那样，最初是它自己的

00:29:05.679 --> 00:29:08.960
之所以这样，是因为我想获得一些单独的指导来完成它

00:29:08.960 --> 00:29:12.799
但实际上就像我已经做到了那样，现在已经可以使用了，所以我不

00:29:12.799 --> 00:29:17.039
不需要那个，我真的只需要知道

00:29:17.039 --> 00:29:20.000
这对每个人都有意义，就像我觉得你应该阻止的方式

00:29:20.000 --> 00:29:23.039
加密，因此应添加到所有内容中

00:29:23.039 --> 00:29:27.760
嗯，星期五我和卡森聊了很久

00:29:27.760 --> 00:29:32.159
加密以及一些挑战，而我真正想知道的是

00:29:32.159 --> 00:29:35.600
就像我们如何在ipld中然后在ip sql中一样

00:29:35.600 --> 00:29:38.880
我该如何添加像这样的单层

00:29:38.880 --> 00:29:42.080
加密的方式不像整个复制密钥，

00:29:42.080 --> 00:29:44.240
所有密钥管理，但实际上就像

00:29:44.240 --> 00:29:47.360
我该怎么做块层加密的东西

00:29:47.360 --> 00:29:52.080
嗯，我想就像我们一样，我们陷入了一些奇怪的境地

00:29:52.080 --> 00:29:55.200
一种难以摆脱的递归心理循环

00:29:55.200 --> 00:29:58.480
一个就像我们真的在假设必须要有一些

00:29:58.480 --> 00:30:01.440
链接加载程序中的密钥协商类型

00:30:01.440 --> 00:30:03.520
那将是潜在的，您将需要

00:30:03.520 --> 00:30:05.520
实际上在链接加载器中查找密钥

00:30:05.520 --> 00:30:09.039
um以便遍历这个东西um

00:30:09.039 --> 00:30:14.240
另一个问题是，就像我认为从概念上讲

00:30:14.240 --> 00:30:19.120
我们一直在以错误的方式考虑块存储

00:30:19.120 --> 00:30:23.039
之所以这样，是因为我们倾向于将ipfs用作块的参考点

00:30:23.039 --> 00:30:26.000
店，我们要带走所有其他

00:30:26.000 --> 00:30:29.840
关于ipfs的语义以及我们的假设，那就是如何阻止

00:30:29.840 --> 00:30:34.480
访问工作就像我们真正需要的那样，以便真正构建应用程序并

00:30:34.480 --> 00:30:37.760
构建可靠的服务并构建您可以操纵的数据结构

00:30:37.760 --> 00:30:40.720
我们确实需要将块存储视为可能的最低级别

00:30:40.720 --> 00:30:43.760
像它这样的基本元素基本上需要像设备驱动程序一样运行

00:30:43.760 --> 00:30:46.720
就像这是一个syscall，我会说这个地址，而你给

00:30:46.720 --> 00:30:50.720
我将数据归类到某种程度

00:30:50.720 --> 00:30:53.840
像我们一样，有时我们需要它那么可靠

00:30:53.840 --> 00:30:57.760
正确的um，而当您存储

00:30:57.760 --> 00:31:00.720
就像发生其他事情一样阻止，就像您在一个

00:31:00.720 --> 00:31:03.919
像现在这样的网络基本上已经公开了

00:31:03.919 --> 00:31:07.120
在泄漏方面，您还需要担心所有其他这些事情

00:31:07.120 --> 00:31:10.880
我喜欢这真的不是很现实

00:31:10.880 --> 00:31:14.080
建立一个像这样未加密的数据结构

00:31:14.080 --> 00:31:17.279
然后还使数据结构加密

00:31:17.279 --> 00:31:20.320
如果我不能只从商店中访问未加密的块

00:31:20.320 --> 00:31:23.600
就像我实际上需要那些已经被加密的一样，或者喜欢一些

00:31:23.600 --> 00:31:28.320
那个嗯的计划，所以我最终建立了什么

00:31:28.320 --> 00:31:35.440
嗯，实际上和卡森交谈就像你需要的只是编解码器

00:31:35.440 --> 00:31:38.559
主要的加密密码，就像我现在拥有的一样

00:31:38.559 --> 00:31:44.720
只是aes gcn，所以您有一个带有多编码解码器的cid，说这是aesgcm

00:31:44.720 --> 00:31:48.399
基本上有一个编解码器说

00:31:48.399 --> 00:31:51.840
了解该块格式，因此它说前16个字节

00:31:51.840 --> 00:31:55.360
是初始化向量，其余部分是密码

00:31:55.360 --> 00:31:59.279
因此，就数据模型而言，编解码器返回的内容就像具有

00:31:59.279 --> 00:32:04.000
初始向量和加密字节，因此是数据模型层

00:32:04.000 --> 00:32:07.440
这就是您所看到的全部内容，就像您无法遍历它们，您看不到一样

00:32:07.440 --> 00:32:10.000
链接或其他诸如此类的东西

00:32:10.000 --> 00:32:15.120
但是该编解码器附带了加密和解密功能

00:32:15.120 --> 00:32:18.640
分别调用时以及调用加密时

00:32:18.640 --> 00:32:21.519
调用这些加密解密功能时进行解密

00:32:21.519 --> 00:32:24.960
他们有他们也有指定的块格式

00:32:24.960 --> 00:32:30.000
对于未加密状态，这是为了我可以调用加密或解密

00:32:30.000 --> 00:32:34.080
用钥匙，然后我可以将其传递给初始化向量和字节

00:32:34.080 --> 00:32:40.399
从先前的编解码器正确的嗯，这将返回我的是

00:32:40.399 --> 00:32:45.120
具有cid和字节的新结构，因此这就是

00:32:45.120 --> 00:32:47.919
未加密的块格式正确无误，因此d和

00:32:47.919 --> 00:32:51.279
d加密是否了解初始化向量的密钥和

00:32:51.279 --> 00:32:53.919
字节，然后占用整个blob，

00:32:53.919 --> 00:32:57.600
它从其余字节中解析出cid，然后返回该指令

00:32:57.600 --> 00:33:02.480
本质上是um，所以您总是这样，所以关键信息完全没有了

00:33:02.480 --> 00:33:07.919
um并单独应用，所有这些块均能完美工作

00:33:07.919 --> 00:33:11.039
在ipfs和其他所有人尝试的数据模型层

00:33:11.039 --> 00:33:14.240
复制他们的未加密的，就像你想加密一样

00:33:14.240 --> 00:33:17.679
数据库或查询的所有块，或仅创建一个块的块

00:33:17.679 --> 00:33:21.279
未加密的图形，只要它和该未加密的图形一样长

00:33:21.279 --> 00:33:24.159
就像不保留来自

00:33:24.159 --> 00:33:27.519
初始图，就像没有办法说出这些数据到底是什么

00:33:27.519 --> 00:33:30.960
嗯，然后您只需要确保您为

00:33:30.960 --> 00:33:34.960
根节点的加密CID，未加密，抱歉，因为您要

00:33:34.960 --> 00:33:37.679
如果您将其放入汽车文件或其他东西，或者您有一些东西，则会丢失该参考

00:33:37.679 --> 00:33:40.320
上面的其他图形，这就是ipsql在您执行操作时所执行的操作

00:33:40.320 --> 00:33:46.000
导出一个加密的汽车文件，它使用一个块状树，其cid设置为

00:33:46.000 --> 00:33:49.760
在这些数据上创建一个大图，然后将其放入

00:33:49.760 --> 00:33:52.480
一个新的结构以及另一个根

00:33:52.480 --> 00:33:56.559
参考，然后该块是汽车文件的根，因此当

00:33:56.559 --> 00:34:00.640
我说用ip sql解密等于密钥就可以了

00:34:00.640 --> 00:34:04.640
这个汽车文件将被加密，我将通过整个结构

00:34:04.640 --> 00:34:10.159
抓取具有此多编解码器的所有um块

00:34:10.159 --> 00:34:12.960
然后所有带有该多编解码器的块我将对此解密

00:34:12.960 --> 00:34:16.320
密钥，我要去加密的块

00:34:16.320 --> 00:34:19.440
我们将把它放在一个私人的块存储中

00:34:19.440 --> 00:34:21.919
通常只在内存中，但我将其放在私有块存储中

00:34:21.919 --> 00:34:26.560
在内存中，然后这就是我要查询的内容，因此我需要查询所有相同的代码

00:34:26.560 --> 00:34:29.359
正如我要查询任何其他图形一样

00:34:29.359 --> 00:34:33.520
关于这种块格式的特别之处是，这种处理方式是

00:34:33.520 --> 00:34:36.560
就像它给了法典一样，它给了我们一种方法

00:34:36.560 --> 00:34:39.440
编写包括解密程序在内的加密法典

00:34:39.440 --> 00:34:43.040
与柯达的其余部分并排第二的格式是

00:34:43.040 --> 00:34:48.399
那个，它对如何做其他所有事情都没有意见

00:34:48.399 --> 00:34:51.599
加密层正确，所以如果您要重写图形，那么

00:34:51.599 --> 00:34:54.960
所有的链接都在图中加密，就像不是我在做什么，你可以做

00:34:54.960 --> 00:34:57.520
像这样的格式是一样的

00:34:57.520 --> 00:35:01.599
在它上面分层可以很好，或者您可以做我正在做的事情

00:35:01.599 --> 00:35:03.760
像所有其他这些一样考虑

00:35:03.760 --> 00:35:07.119
复制键语义，因为这将全部作为一个层来实现

00:35:07.119 --> 00:35:11.440
无论如何，它不是，也不必

00:35:11.440 --> 00:35:14.560
由于密钥已完全应用，因此再次进入密钥管理员

00:35:14.560 --> 00:35:17.440
带外，所以如果你想做，如果你想有

00:35:17.440 --> 00:35:21.520
有关如何进行键查找的信息，您只需将其编码到图形中即可，例如

00:35:21.520 --> 00:35:24.480
该信息将位于该用例所需的任何位置

00:35:24.480 --> 00:35:28.839
这与ipld无关，就像那是您正在执行的单独操作

00:35:28.839 --> 00:35:32.960
嗯，所以我喜欢我希望这有意义

00:35:32.960 --> 00:35:35.599
如果您想放松一下，可以很快获得很多信息

00:35:35.599 --> 00:35:39.040
并谈论其他一些观点，例如我很高兴但是

00:35:39.040 --> 00:35:42.800
这真的像是本周我可以去的事情，

00:35:42.800 --> 00:35:46.400
以js多种格式实施，可以成为

00:35:46.400 --> 00:35:49.440
我们的常规块api可以为所有aes函数提供编解码器，

00:35:49.440 --> 00:35:52.480
在浏览器和节点中，我们可以做同样的事情并继续

00:35:52.480 --> 00:35:54.800
像一周这样的黄金时期是这样的

00:35:54.800 --> 00:35:58.079
非常简单的编解码器，可以像所有加密一样

00:35:58.079 --> 00:36:01.440
加密的所有困难部分都像在标准库中一样，我们

00:36:01.440 --> 00:36:04.160
不应该添加不在同一个库中的任何内容，我们可以

00:36:04.160 --> 00:36:12.560
像月内一样发送ipld加密

00:36:12.560 --> 00:36:16.320
它无法很好地扩展，它不喜欢非常大的数据集

00:36:16.320 --> 00:36:21.280
因为如果你要开一家大商店，你说这是我的钥匙

00:36:21.280 --> 00:36:26.320
给我私人街区商店，那里有很多街区，

00:36:26.320 --> 00:36:29.440
通过所有解密进行扫描的初始化

00:36:29.440 --> 00:36:33.440
一切并复制它们的代码，它的成本仅与它一样高

00:36:33.440 --> 00:36:36.079
需要是因为那些加密的块只要

00:36:36.079 --> 00:36:38.400
他们是因为相同的键会有相同的CID

00:36:38.400 --> 00:36:42.000
因此，如果您要带走这些汽车文件，然后将它们放入

00:36:42.000 --> 00:36:45.280
一家公共街坊商店或类似的盒子商店，您将要去

00:36:45.280 --> 00:36:48.000
知道你已经进口的所有cid

00:36:48.000 --> 00:36:49.839
然后放在然后您要把它们放进去

00:36:49.839 --> 00:36:53.200
在也有重复数据删除功能的私有块存储中

00:36:53.200 --> 00:36:56.560
所以我的意思是，没有人可以为未加密的文件创建私有块存储

00:36:56.560 --> 00:36:59.520
磁盘上的数据就像您可以拥有加密的磁盘一样

00:36:59.520 --> 00:37:02.240
还有其他方法可以加密数据以确保数据安全

00:37:02.240 --> 00:37:05.839
不必在他们里面，就像做正确的简单方法一样

00:37:05.839 --> 00:37:08.960
现在和我的

00:37:12.079 --> 00:37:15.119
只是想抛出一个安全聚会

00:37:15.119 --> 00:37:20.640
在星期三，也许值得一看各个人对他们的想法

00:37:20.640 --> 00:37:25.839
想要在2021年摆脱ipfs的安全性，他们脱离了ipfs的计划

00:37:25.839 --> 00:37:29.680
我认为八分之六的过程

00:37:29.680 --> 00:37:33.200
人们要谈论的八件事中，基本上是签名和

00:37:33.200 --> 00:37:38.079
加密ipld数据好吧，所以我

00:37:38.079 --> 00:37:41.440
我不能在这个会议的第一个小时

00:37:41.440 --> 00:37:46.720
所以，是的，现在还为时过早，可以录制下来，可以观看

00:37:46.720 --> 00:37:50.320
是的，这还算不错，因为我认为第一个小时应该是

00:37:50.320 --> 00:37:53.920
主要是来自各种介绍，例如纺织品

00:37:53.920 --> 00:37:59.599
是他们的愿景给一些反馈，例如初步

00:37:59.599 --> 00:38:03.359
东西，所以您可能不会想念太多，而只是想了解其他内容

00:38:03.359 --> 00:38:08.640
通话中的人您刚才在此处描述的内容确实有

00:38:08.640 --> 00:38:13.520
关于其中一些问题的一些问题，例如被解析的东西，但是

00:38:13.520 --> 00:38:18.000
很好，我的意思是我们在星期五进行了对话，但就像

00:38:18.000 --> 00:38:22.480
这与我们为最低级别登陆的内容非常相似

00:38:22.480 --> 00:38:28.720
在块层um加密，然后我们有一些类似的附加功能

00:38:28.720 --> 00:38:30.960
在上面的线程和类似的层

00:38:30.960 --> 00:38:34.320
是的，所以sander已经有了很多go代码

00:38:34.320 --> 00:38:37.920
像那样拉开你知道ipld

00:38:37.920 --> 00:38:41.280
并进行所有这样的包裹和等等等等

00:38:41.280 --> 00:38:44.320
从您的描述方式来看，这不仅是一个好主意，而且

00:38:44.320 --> 00:38:48.800
就像你知道的那样

00:38:48.800 --> 00:38:51.359
有点像工作中最大的问题

00:38:51.359 --> 00:38:54.880
我在星期五提到的是

00:38:55.119 --> 00:38:59.040
您知道您正在尝试使用ipld做加密数据

00:38:59.040 --> 00:39:02.000
结构，您希望它是安全的

00:39:02.000 --> 00:39:06.160
和安全，但同时您希望有人

00:39:06.160 --> 00:39:09.680
能够喜欢为您钉那些块并复制

00:39:09.680 --> 00:39:12.160
他们和那两个是相对的

00:39:12.160 --> 00:39:14.880
力量，但这是你第二次接受这个，就像你知道的那样

00:39:14.880 --> 00:39:21.119
像块之间的关系一样消失的设置对象

00:39:21.119 --> 00:39:25.119
嗯，你知道你已经开始解决这个问题了，那真是太神奇了

00:39:25.119 --> 00:39:29.280
嗯，从我们的角度来看，例如从纺织行业开始，我们想像齐

00:39:29.280 --> 00:39:32.079
提交硬币的东西，您知道我们可以正确地使用我们的文件

00:39:32.079 --> 00:39:37.599
就是这样，所以我们实际上很喜欢打这个

00:39:37.599 --> 00:39:43.040
像几个星期前一样面对我们所做的一切

00:39:43.040 --> 00:39:47.200
在我们重命名之前，我们先加密了链接和所有内容，

00:39:47.200 --> 00:39:51.760
然后基本上像这些顶级捆绑包一样创建，您最终不得不

00:39:51.760 --> 00:39:56.000
就像重新走了很多次，就像爆炸一样

00:39:56.000 --> 00:39:58.320
这些街区，就像疯狂的谈话

00:39:58.320 --> 00:40:03.760
所以是的，总体来说，

00:40:03.760 --> 00:40:08.640
复制模式是您知道我要查询

00:40:08.640 --> 00:40:11.520
对于拥有数据的人，然后

00:40:11.520 --> 00:40:16.640
我想要的是像那些cids那样的集

00:40:16.640 --> 00:40:20.000
以某种包装的形式还给我，嗯

00:40:20.000 --> 00:40:22.880
所以像我在fb续集中所做的那样，有趣的是

00:40:22.880 --> 00:40:25.119
就像您执行查询一样，您会得到一组cid

00:40:25.119 --> 00:40:28.480
您会得到一个仅将所有这些连接在一起的图，但它不知道如何

00:40:28.480 --> 00:40:31.040
他们已连接，因此已被匿名或其他

00:40:31.040 --> 00:40:34.640
是的，太好了，然后您可以固定该图

00:40:34.640 --> 00:40:38.079
现在，如果您要创建复制提示，

00:40:38.079 --> 00:40:41.200
像在此之上创建它，而您正在为此可复制集执行此操作

00:40:41.200 --> 00:40:45.920
对吧，而就像如果您不这样做，最终的结果就是

00:40:45.920 --> 00:40:48.079
就像一堆往返，因为你不能

00:40:48.079 --> 00:40:53.599
与最终用户共享最终键，以查看诸如基础链接之类的链接

00:40:53.599 --> 00:40:58.079
复制与复制器正确嗯是的，所以

00:40:58.079 --> 00:41:02.480
澄清一点，所以在加密时

00:41:02.480 --> 00:41:07.920
就像一个原子加密块，所以我不知道我有一些

00:41:07.920 --> 00:41:13.040
任意ipld结构我认为您正在加密类似

00:41:13.040 --> 00:41:17.440
是和城市的编码字节

00:41:17.440 --> 00:41:22.560
和cid好的，是的，那么那基本上就是您所需要的一切

00:41:22.560 --> 00:41:24.960
像把它拆开并粘贴在您的大块商店中

00:41:24.960 --> 00:41:28.560
是的，未加密的块格式是cid的长度

00:41:28.560 --> 00:41:32.720
cid字节，但实际编码的字节

00:41:32.720 --> 00:41:37.040
但是，是的，所以就像当他们从那出来时

00:41:37.040 --> 00:41:40.160
解密功能只是cid和字节，然后

00:41:40.160 --> 00:41:43.520
您必须要让柯达解码此肯定码，无论

00:41:43.520 --> 00:41:47.200
cnd编解码器说eric像今天早些时候提出来的那样

00:41:47.200 --> 00:41:49.280
但就像这很酷的事情是

00:41:49.280 --> 00:41:53.839
只是透明地允许您想要的任意数量的图层，因为如果

00:41:53.839 --> 00:41:56.960
如果那个cid说哦，这是一个不同的加密

00:41:56.960 --> 00:42:00.000
然后是不同的加密层，所以您可以喜欢

00:42:00.000 --> 00:42:04.160
您知道最终会重新加密图表中碰巧的内容

00:42:04.160 --> 00:42:06.480
甚至不知道它们之前必须被加密

00:42:06.480 --> 00:42:10.319
就像透明地工作一样

00:42:13.599 --> 00:42:18.960
所以我有很多信息呃最后一点，我可能有

00:42:18.960 --> 00:42:21.760
没有处理所有的东西，但我想看看我是否喜欢一些更大的东西

00:42:21.760 --> 00:42:27.680
点，你知道我有一个图

00:42:27.680 --> 00:42:31.920
我想在图上进行某种程度的加密，所以

00:42:31.920 --> 00:42:36.000
我用相同的密钥分别加密所有节点，然后创建一个

00:42:36.000 --> 00:42:39.280
链接到所有块的清单文件，就好像它们

00:42:39.280 --> 00:42:46.240
只是一袋积木，然后我把那个图传给周围

00:42:46.240 --> 00:42:52.880
这是正确的计划，因为那是关于

00:42:52.880 --> 00:42:56.400
这是我认为的用例之一

00:42:56.400 --> 00:43:00.079
用这种方式进行加密的好处是使用多

00:43:00.079 --> 00:43:04.400
编解码器和CD就是这样，您可以

00:43:04.400 --> 00:43:06.800
融入其中，但您不必一定要做

00:43:06.800 --> 00:43:10.000
就像您可以的一样，您可以提出其他方案

00:43:10.000 --> 00:43:12.960
做到这一点就像一个好主意，就像

00:43:12.960 --> 00:43:16.720
我们要去做，但是喜欢这样，例如那个

00:43:16.720 --> 00:43:21.680
清单看起来没有任何意见，只要

00:43:21.680 --> 00:43:23.920
就像是一个已连接且可见的图形

00:43:23.920 --> 00:43:27.440
就像在未加密的情况下将所有内容连接在一起，然后它将复制

00:43:27.440 --> 00:43:30.240
嗯，你甚至不需要编解码器或类似的东西

00:43:30.240 --> 00:43:33.839
我正在使用一个矮矮胖胖的树木，没人能实现

00:43:33.839 --> 00:43:38.160
但是没关系，ipfs会正确解析它，我只是为了一些

00:43:38.160 --> 00:43:44.640
裂变和纯幽灵的附加语境

00:43:44.640 --> 00:43:47.839
正在使用一种叫做“地穴树”的东西，

00:43:47.839 --> 00:43:51.119
这基本上是这个非常具体的实现

00:43:51.119 --> 00:43:57.920
它确实像一堆像黑曜石这样的元数据可以避免的难题

00:43:57.920 --> 00:44:03.359
喜欢泄漏任何东西，他们也有一个结构，

00:44:03.359 --> 00:44:07.680
弄乱了所有块之间的连接，但仍然允许您

00:44:07.680 --> 00:44:11.599
现在的愿景，你不能做国防部，你不能做清单

00:44:11.599 --> 00:44:15.839
因为清单会显示文件的大小

00:44:15.839 --> 00:44:18.880
好吧，是的，这就是我们明天要见面的原因，因为

00:44:18.880 --> 00:44:23.839
根据um

00:44:24.240 --> 00:44:28.319
他们在那里做了一些有趣的工作

00:44:28.319 --> 00:44:32.240
尽量避免在那儿泄漏太多信息，例如您无法获得足够的深度

00:44:32.240 --> 00:44:37.040
进入清单，以了解有关图的任何部分的更多信息

00:44:37.040 --> 00:44:39.599
实际上明确有权查看

00:44:39.599 --> 00:44:42.960
这样的东西是某种魔术，所以我会更多地了解它

00:44:42.960 --> 00:44:47.680
明天，但是，是的，我认为总体语气

00:44:47.680 --> 00:44:49.440
我们将要涉及到很多这样的东西

00:44:49.440 --> 00:44:54.960
是我们将尝试提出一些非常好的建议，例如

00:44:54.960 --> 00:44:59.280
一些描述这些常见模式的词汇

00:44:59.280 --> 00:45:04.319
那就是社区想要的，而这正是我真正的

00:45:04.319 --> 00:45:09.200
想离开接下来的几次会议就像没有权利

00:45:09.200 --> 00:45:13.200
的方法，但是有几个很好的建议会很棒

00:45:13.200 --> 00:45:16.400
是的，似乎有些事情

00:45:16.400 --> 00:45:22.480
清单内容是一种非常常见的方法，其中包含很多

00:45:22.480 --> 00:45:26.319
不同的实现方式，并且喜欢具体的理解

00:45:26.319 --> 00:45:29.200
确保固定和其他形式的应用

00:45:29.200 --> 00:45:33.520
明文组件上的递归遍历提供了一些价值

00:45:33.520 --> 00:45:38.000
这些东西似乎是可重用的，同时似乎

00:45:38.000 --> 00:45:41.839
应用程序正在做的很多这些不同的实现

00:45:41.839 --> 00:45:44.480
不是

00:45:44.880 --> 00:45:47.520
当我们在编程时，当我们在创建规范时，它总是

00:45:47.520 --> 00:45:52.640
重要的是要想知道某个事物是巧合地发散还是像不一样

00:45:52.640 --> 00:45:55.040
实际上，这些东西有专门的理由是不同的

00:45:55.040 --> 00:45:58.560
方向嗯，我认为其中一些事情

00:45:58.560 --> 00:46:01.920
实际上确实有理由专门研究不同的方向，例如在某些方面

00:46:01.920 --> 00:46:06.160
您将需要大量的应用程序以确保文本清晰

00:46:06.160 --> 00:46:11.280
清单什么都不会泄漏，并且通常在同一时间泄漏

00:46:11.280 --> 00:46:13.119
那可能不会免费

00:46:13.119 --> 00:46:16.079
它可能会以相当大的算法复杂度为代价，并且

00:46:16.079 --> 00:46:19.119
有时可能会导致性能复杂化，因为您将要做这些

00:46:19.119 --> 00:46:22.160
在中间进行不同的重新平衡操作以隐藏事物和

00:46:22.160 --> 00:46:26.800
也许有填充，并试图隐藏尤其是在有关

00:46:26.800 --> 00:46:30.800
像我们在这里这样的分布式上下文中的大小是

00:46:30.800 --> 00:46:35.920
真的很敏感，所以是的，有很多不同的东西进入太空，

00:46:35.920 --> 00:46:38.960
尝试找到一些普通的vocab似乎真的很好

00:46:38.960 --> 00:46:42.000
我对此感到很兴奋，是的，我想我想要的东西

00:46:42.000 --> 00:46:46.240
就像我希望ipld附带AES块级加密

00:46:46.240 --> 00:46:49.359
这样就可以构建所有这些系统，而且它们都不像

00:46:49.359 --> 00:46:52.800
分叉或选择退出，或者就像无法使用其他任何一个

00:46:52.800 --> 00:46:55.440
iplt工具，因为这是开始发生的事情

00:46:55.440 --> 00:46:58.560
就在这些东西变得足够先进的地方

00:46:58.560 --> 00:47:01.520
他们是他们，您知道将事物粘贴到这些层中，所以这就像一个

00:47:01.520 --> 00:47:04.240
很干净的表达方式，就像哦，不，这里就像

00:47:04.240 --> 00:47:07.359
工具来完成这一部分，然后

00:47:07.359 --> 00:47:11.839
将其他所有内容都映射在上面就可以了

00:47:11.839 --> 00:47:15.839
为什么这个不同的抱歉继续前进，达伦

00:47:15.839 --> 00:47:20.000
也许我会回答，我发现最独特的一件事是

00:47:20.000 --> 00:47:22.240
迈克尔一直在谈论的话题很有趣

00:47:22.240 --> 00:47:27.040
今天是我们刚才在谈论它

00:47:27.520 --> 00:47:33.440
干净地递归的事实实际上就像是一个好东西

00:47:33.440 --> 00:47:38.400
通过使用okay的规范来确定良好的指标

00:47:38.400 --> 00:47:41.920
将使用多编解码器指标包括

00:47:41.920 --> 00:47:46.800
加密编解码器和我们的定义

00:47:46.800 --> 00:47:50.559
我们现在将使用我们非常有条理的编解码器和ipld定义

00:47:50.559 --> 00:47:56.000
编解码器必须将二进制数据转换为某种数据模型表示形式

00:47:56.000 --> 00:47:59.200
并且应该不带任何其他参数

00:47:59.200 --> 00:48:03.680
除了多编解码器指示器以外，我们正在使用的定义

00:48:03.680 --> 00:48:07.359
现在是当您使用这些加密方法之一时

00:48:07.359 --> 00:48:12.880
密码编解码器数据级别表示

00:48:12.880 --> 00:48:16.480
它产生的只是像这里的分离

00:48:16.480 --> 00:48:20.160
iv组件这是密码文本的其余部分

00:48:20.160 --> 00:48:23.119
不执行单步解密，因为

00:48:23.119 --> 00:48:25.920
实际上将与我们的编解码器定义不兼容，因为它会

00:48:25.920 --> 00:48:28.640
需要更多参数等

00:48:28.640 --> 00:48:33.119
他妈的东西，所以这个定义只是分解成其他

00:48:33.119 --> 00:48:36.480
密文基元实际上非常干净清晰，

00:48:36.480 --> 00:48:39.920
不符合我们的其他定义

00:48:39.920 --> 00:48:43.680
然后将特征检测用作有意步骤

00:48:43.680 --> 00:48:47.040
最重要的是，这是一个加密编解码器

00:48:47.040 --> 00:48:50.720
这是您可以使用的另一个功能，现在将您的钥匙连接到

00:48:50.720 --> 00:48:52.480
这并在功能下进行所有操作

00:48:52.480 --> 00:48:57.359
检测年龄仍然很干净，然后

00:48:57.359 --> 00:48:59.839
现在您有另一种方法可以为您提供另一种数据模型

00:48:59.839 --> 00:49:04.880
表示形式是明文，所以我们

00:49:04.880 --> 00:49:07.599
成功避免了很多问题

00:49:07.599 --> 00:49:10.559
这些建议之前，就像您遇到了这样的尴尬问题

00:49:10.559 --> 00:49:14.480
好吧，如果我确实希望像许多以前的提案一样有密文，该怎么办？

00:49:14.480 --> 00:49:20.000
真的绊倒了，所以很好地解决了是

00:49:20.000 --> 00:49:30.880
我认为这是一件好事

00:49:30.880 --> 00:49:37.119
是的，不错，很酷，但是您这样做很抱歉，我仍然坚持

00:49:37.119 --> 00:49:42.839
你所做的缩放事情会丢失很多图

00:49:42.839 --> 00:49:47.680
um用于未加密的情况，虽然不是

00:49:47.680 --> 00:49:50.640
当您处理大型数据集时，您会喜欢您

00:49:50.640 --> 00:49:54.559
并且您已经获得了此宣言，您需要全部或全部内容才能查看

00:49:54.559 --> 00:49:59.119
您的数据正确正确就需要一切，所以如果我

00:49:59.119 --> 00:50:04.400
如果您有房间，您应该可以，但是如果您导出我的百科全书

00:50:04.400 --> 00:50:08.160
在您的加密方案中，并给我所有块的清单

00:50:08.160 --> 00:50:13.119
我想查找一个页面，我需要所有的块才能到达该页面

00:50:13.119 --> 00:50:16.960
不不不，就像说这是一个汽车文件，所以我做的汽车文件格式

00:50:16.960 --> 00:50:21.119
它将有um个顶级对象来告诉您

00:50:21.119 --> 00:50:26.079
加密的块地址用于该路由，因此您可以只请求一个权利

00:50:26.079 --> 00:50:29.359
然后解析，然后将其解密

00:50:29.359 --> 00:50:32.400
看看链接是什么哦，不，不，你是对的

00:50:32.400 --> 00:50:35.280
这些都处于未加密状态，则无法

00:50:35.280 --> 00:50:38.960
在他们之间，你是对的，你是对的，是的，你确实需要整件事

00:50:38.960 --> 00:50:45.440
您需要整个证明，所以很好，所以继续吧，但是

00:50:45.440 --> 00:50:48.640
这是特定于我执行此操作的方式，但是如果您要执行此操作

00:50:48.640 --> 00:50:52.160
嗯，如果您实际上只是将整个图加密为链接层

00:50:52.160 --> 00:50:55.760
您可以使用相同的编解码器，然后您实际上将得到什么

00:50:55.760 --> 00:50:59.119
将是um加密的地址，而不是像

00:50:59.119 --> 00:51:01.920
您将能够以这种方式构建该图

00:51:01.920 --> 00:51:05.119
并在那里有加密的地址，您可以重写整个图

00:51:05.119 --> 00:51:09.119
嗯，在这里值得一提的是

00:51:09.119 --> 00:51:14.720
考虑访问模式和诸如此类的东西的泄漏

00:51:14.720 --> 00:51:17.680
有危险和原因

00:51:17.680 --> 00:51:21.520
您还取决于用例，例如

00:51:21.520 --> 00:51:24.800
您误解了，因此链接不可见

00:51:24.800 --> 00:51:29.440
是在加密状态下，但是如果我要一件事然后再要求另一块

00:51:29.440 --> 00:51:33.119
你会看到蜘蛛穿过它，你开始变得结构

00:51:33.119 --> 00:51:36.960
是的，我可以从字面上看

00:51:43.200 --> 00:51:48.079
我不介意看到的是权衡的列举

00:51:48.079 --> 00:51:53.359
嗯，我认为那会达到呃，这会影响到某些人的内心

00:51:53.359 --> 00:51:56.160
这是什么建议，为什么会更好

00:51:56.160 --> 00:51:59.520
甚至比其他事情更糟，例如我们在做什么，因为

00:51:59.520 --> 00:52:02.960
无论我们如何加密，加密都将涉及一些严重的取舍。

00:52:02.960 --> 00:52:05.680
嗯，所以很高兴看到这一点，并且

00:52:05.680 --> 00:52:08.400
然后看一下与其他事物相比的取舍，就像我会说其中之一

00:52:08.400 --> 00:52:11.200
专业人士之间的权衡是

00:52:11.200 --> 00:52:15.119
复杂性这似乎实际上是比复杂性要小的解决方案

00:52:15.119 --> 00:52:18.079
过去我们讨论过的其他一些事情，我们逐渐陷入

00:52:18.079 --> 00:52:22.240
这些有关如何嵌入这些的想法，您知道密钥管理

00:52:22.240 --> 00:52:25.520
那样的复杂性，我们会很高兴

00:52:25.520 --> 00:52:30.240
避免，所以我猜想它的其他部分以相同的权衡取舍

00:52:30.240 --> 00:52:32.640
总的来说，有些事情我们可以做，但我认为其他

00:52:32.640 --> 00:52:35.920
一方面是将其植根于特定的用例中，所以

00:52:35.920 --> 00:52:39.359
如果您有两个同时拥有钥匙且正在沉没的人

00:52:39.359 --> 00:52:42.559
就像他们可以有效地同步输入中的增量

00:52:42.559 --> 00:52:46.079
这个世界仍然正确，因为他们可以提出一个三角洲的清单

00:52:46.079 --> 00:52:49.599
已更改的块，然后同步将要添加的其他子卡

00:52:49.599 --> 00:52:53.040
另一件事是，那是

00:52:53.040 --> 00:52:56.079
依赖于特定的用例，而一个人却拥有另一件事

00:52:56.079 --> 00:52:59.680
人正在尝试查看一小部分子集

00:52:59.680 --> 00:53:03.040
大型数据集，而没有正确的整个子集，因此

00:53:03.040 --> 00:53:06.559
如果我们可以提出一些我们认为是的用例

00:53:06.559 --> 00:53:10.480
首先，您了解我们正在启用的功能，然后考虑如何

00:53:10.480 --> 00:53:14.079
加密会影响那些可能在以下方面也有用的加密

00:53:14.079 --> 00:53:18.800
我们如何权衡取舍另一个是随机访问

00:53:18.800 --> 00:53:21.599
就像

00:53:22.400 --> 00:53:26.480
在那儿，您知道在ipfs中有一个类似的概念

00:53:26.480 --> 00:53:30.160
好像不是我不知道

00:53:30.160 --> 00:53:34.000
似乎从头到尾都没有想到

00:53:34.000 --> 00:53:40.400
就是如果您应该让每个人都可以使用随机访问

00:53:40.400 --> 00:53:44.480
到处每个图的块

00:53:44.480 --> 00:53:48.079
就像疯狂的物体一样

00:53:48.079 --> 00:53:51.520
而且您实际想要的东西数量似乎较少

00:53:51.520 --> 00:53:55.359
比那，您可以喜欢以某种方式将它们分组，但是如果我开始

00:53:55.359 --> 00:53:58.720
加密块，然后我剥离所有结构

00:53:58.720 --> 00:54:04.160
然后找到我什至可以要求的人

00:54:04.160 --> 00:54:07.280
事情变得更加复杂，因为如果我想采取像

00:54:07.280 --> 00:54:12.160
加密图的一部分并将其放在另一个图中

00:54:12.160 --> 00:54:15.839
我就像永远不会像我要怎么找到东西一样

00:54:15.839 --> 00:54:19.440
似乎可能是，但是我发现事情将成为一种访问

00:54:19.440 --> 00:54:24.000
模式泄漏是的，这是什么，就像大自然一样

00:54:24.000 --> 00:54:28.079
如果您要进行任何程度的加密，这就是

00:54:28.079 --> 00:54:32.400
就像你无法魔术般地消除所有魔杖般的挥舞

00:54:32.400 --> 00:54:35.920
意思是说，如果您不在意的话，您可以将其消除

00:54:35.920 --> 00:54:39.040
希望人们阅读我的数据以及您不担心的事情

00:54:39.040 --> 00:54:42.880
我是不想让人们知道我访问此加密数据还是我

00:54:42.880 --> 00:54:46.240
不想让人们知道数据量有多大

00:54:46.240 --> 00:54:52.079
对，如果我只是不想让人们阅读我的东西，这不是问题

00:54:52.079 --> 00:54:56.319
是的，所以我认为我们必须弄清楚

00:54:56.319 --> 00:55:03.440
我们想在类似ipld库之间划清界限的地方

00:55:03.440 --> 00:55:07.280
以及我们对某些食典材料的规格

00:55:07.280 --> 00:55:12.000
将具有我们将要清楚并指定的实际功能

00:55:12.000 --> 00:55:16.400
嗯，然后在某些时候这些东西变成了应用程序级逻辑

00:55:16.400 --> 00:55:23.040
也许我们应该对这些潜在用例进行一些描述

00:55:23.040 --> 00:55:27.200
我们会遇到的权衡取舍

00:55:27.200 --> 00:55:30.480
并且我们可能想在ipld文档中提供其中的一些内容

00:55:30.480 --> 00:55:33.680
特别是如果它可以帮助我们描述有助于人们互动的词汇

00:55:33.680 --> 00:55:37.040
那就是在我们的文档中真正值得的时候

00:55:37.040 --> 00:55:41.440
嗯，但是就像光谱的尽头是

00:55:41.440 --> 00:55:44.559
我们写密码学入门教材

00:55:44.559 --> 00:55:48.880
在ipld docs网站上，我认为我们可能不想这样做

00:55:48.880 --> 00:55:51.280
因为

00:55:52.640 --> 00:55:59.280
就像我的意思是那些密码学是的

00:55:59.280 --> 00:56:03.440
嗯，就像我有一堆加密教材一样

00:56:03.440 --> 00:56:06.799
自从我完成这些课程后，它仍然在我的桌面上

00:56:06.799 --> 00:56:11.440
从来没有离开过我的桌面，但是我想将这些东西重新输入到ipld中吗

00:56:11.440 --> 00:56:15.680
完整粒度的文档，不，我不是，这是一个微妙的话题

00:56:15.680 --> 00:56:19.040
应该限制​​我们给它多少呼吸

00:56:19.040 --> 00:56:21.760
就像人们只是去找我们

00:56:21.760 --> 00:56:25.920
必须告诉我们的用户，他们将需要

00:56:25.920 --> 00:56:30.960
意识到诸如访问模式导致的信息泄漏之类的问题

00:56:30.960 --> 00:56:34.000
我们可以在介绍中进行介绍

00:56:34.000 --> 00:56:38.000
确保存在问题知识的方法，但我认为可以

00:56:38.000 --> 00:56:40.240
我们通常会规定解决方案

00:56:40.240 --> 00:56:47.280
哎呀，总的来说不像这样，我的意思是权衡取舍

00:56:47.280 --> 00:56:51.599
我听说过许多不同模式之间的权衡取舍

00:56:51.599 --> 00:56:55.920
此块层加密标准的最高层，但类似于

00:56:55.920 --> 00:57:00.160
我没有看到与块级别的任何权衡

00:57:00.160 --> 00:57:03.599
事情本身就像我们实际上建议实施的

00:57:03.599 --> 00:57:06.880
就像我没有互联网，主要是因为我真的不知道

00:57:06.880 --> 00:57:11.119
就像乌姆一样，这是正确的吗？您知道我们不是

00:57:11.119 --> 00:57:14.400
编码有关我们不参与的密钥的信息

00:57:14.400 --> 00:57:18.319
密钥管理或诸如此类的问题之类的东西

00:57:18.319 --> 00:57:20.640
推迟，目前尚不清楚

00:57:20.640 --> 00:57:24.799
确实要在这一层进行权衡，这是因为我们

00:57:24.799 --> 00:57:27.520
规定如何使用它，我们必须谈论不同之间的取舍

00:57:27.520 --> 00:57:32.240
我同意的方法，我的意思是这仅仅是

00:57:32.240 --> 00:57:36.559
两步法对吧，我的意思是因为如果清单只是一个

00:57:36.559 --> 00:57:41.359
就像被允许像另一个阴影图一样

00:57:41.359 --> 00:57:44.960
当然，但即使是清单也像清单一样

00:57:44.960 --> 00:57:48.960
虽然完全像在这种加密之上，但完全在此之上

00:57:48.960 --> 00:57:51.599
编解码器层

00:57:51.670 --> 00:57:56.000
[音乐]是的，而且ii的声音太酷了

00:57:56.000 --> 00:57:59.040
因为加密块的cid就像两个未加密的cid

00:57:59.040 --> 00:58:02.559
阻止，如果您知道重新编码图形

00:58:02.559 --> 00:58:05.599
可以使用加密链接或仅使用纯链接

00:58:05.599 --> 00:58:09.920
并在其上创建图，就像没有任何改变块的方式一样

00:58:09.920 --> 00:58:13.440
它的水平部分工作正常

00:58:13.680 --> 00:58:16.880
块级编解码器如何工作

00:58:20.880 --> 00:58:25.040
这是因为您在编码时

00:58:25.040 --> 00:58:29.680
当我说想让你知道我想要根块时

00:58:29.680 --> 00:58:32.799
然后我

00:58:33.040 --> 00:58:42.160
我获取了我获取的根块，我将其解密成其类似的清单形式

00:58:42.160 --> 00:58:47.599
然后，然后是的，我要获取，是的，我想我将其获取到了

00:58:47.599 --> 00:58:51.920
清单形式，然后我运行看起来像正常操作的样子

00:58:51.920 --> 00:58:54.799
因为现在我提供的功能就像

00:58:54.799 --> 00:58:58.640
一种特殊的解密功能，允许使用密钥

00:58:58.640 --> 00:59:02.559
与不允许使用密钥的其他ipld层相反

00:59:02.559 --> 00:59:06.079
对对对，您将不得不解密该数据以便查看

00:59:06.079 --> 00:59:09.760
无论如何都要表现出来，这样就已经开始运作了，就像不是常规的

00:59:09.760 --> 00:59:13.680
ipfs遍历操作对，就好像您要对其中的数据应用密钥

00:59:13.680 --> 00:59:16.880
为了解密它，然后当您解密它时，您会觉得好吗

00:59:16.880 --> 00:59:20.319
我现在要处理这些数据吗，这就是所有这些语义的地方

00:59:20.319 --> 00:59:23.839
进来似乎是这样，然后确实喜欢权衡

00:59:23.839 --> 00:59:27.200
反对如果我只是加密所有块的权利

00:59:27.200 --> 00:59:29.520
我正在做我过去的那件事

00:59:29.520 --> 00:59:33.200
通过每个操作的上下文，并且上下文可以包含密钥

00:59:33.200 --> 00:59:36.640
如果密钥是aes密钥，并且看起来像是

00:59:36.640 --> 00:59:40.079
aes通常看起来像是您知道aes编解码器

00:59:40.079 --> 00:59:43.680
然后我应用解密的东西，那就意味着我可以

00:59:43.680 --> 00:59:47.280
我可以做，就像您知道根斜杠a斜杠b

00:59:47.280 --> 00:59:52.960
 C，我喜欢取出数据，而在这里我需要暂停和

00:59:52.960 --> 00:59:56.720
然后喜欢做另一件事

00:59:58.799 --> 01:00:02.720
除非我错过了

01:00:02.880 --> 01:00:05.520
无论您是否做过，都有各种与之互动的方式

01:00:05.520 --> 01:00:10.160
每个块或层的原子加密

01:00:10.160 --> 01:00:12.079
最重要的是，但就您如何创建

01:00:12.079 --> 01:00:14.640
清单文件以及如何将它们绑在一起

01:00:14.640 --> 01:00:19.520
对于基本相同的复制器密钥

01:00:19.520 --> 01:00:22.319
就像这样容易一些，因为您可以指向根节点，然后

01:00:22.319 --> 01:00:24.480
那么你知道那将能够

01:00:24.480 --> 01:00:28.079
遍历um或no no no no，那就是

01:00:28.079 --> 01:00:31.359
另一个键，所以不，不，您仍然需要将所有内容汇总到清单文件中

01:00:31.359 --> 01:00:34.960
即使您绘制完整的图表

01:00:36.799 --> 01:00:39.200
所以我说的是像我们在谈论权衡一样，而你是在说你

01:00:39.200 --> 01:00:42.400
并没有真正看到这像两步走的过程如何导致

01:00:42.400 --> 01:00:46.960
权衡取舍，我是说你知道像duh这样的两步过程

01:00:46.960 --> 01:00:50.880
是导致权衡的原因，这是

01:00:50.880 --> 01:00:53.920
加密块并获取您知道已加密的地址

01:00:53.920 --> 01:00:58.000
块，然后知道像这样是如何将这种格式解码为

01:00:58.000 --> 01:01:02.400
进入解密状态，可以将零件标准化并

01:01:02.400 --> 01:01:04.640
一个不关心其他所有问题的人

01:01:04.640 --> 01:01:06.880
正确的

01:01:09.200 --> 01:01:13.599
关于此加密内容的api的关键见解是

01:01:13.599 --> 01:01:16.960
像是的，我们可以以不

01:01:16.960 --> 01:01:23.359
与我们对法典的定义不参数化并且

01:01:23.359 --> 01:01:28.000
通过将编解码器行为定义为实际上仍然让您

01:01:28.000 --> 01:01:31.680
密文，我们消除了周围的所有歧义

01:01:31.680 --> 01:01:34.960
如果我想看看那可怜的密文，那该怎么办？

01:01:34.960 --> 01:01:38.480
我们以前所有加密货币提案的问题，所以我实际上认为

01:01:38.480 --> 01:01:43.599
这基本上是明确的好，就像我不认为我们已经经历了

01:01:43.599 --> 01:01:48.079
所有的代码api详细信息，特别是关于我们将如何

01:01:48.079 --> 01:01:51.359
如果您有需要的话，可以进行密钥管理

01:01:51.359 --> 01:01:53.760
大图有异构键，您正在尝试逐步解决这个问题

01:01:53.760 --> 01:01:57.680
以一种易于您编码的方式

01:01:57.680 --> 01:02:00.880
我不认为我们已经解决了所有问题，但我也不认为那是

01:02:00.880 --> 01:02:03.920
通常可以解决，因为您可以深入到应用程序逻辑领域

01:02:03.920 --> 01:02:07.599
瞬间，所以我们能做的最好的事情就是弄清楚要使用的api

01:02:07.599 --> 01:02:13.119
给人们并从那里开始用耳朵玩，但是

01:02:13.119 --> 01:02:16.720
我们可以像这样使用多编解码器指标吗

01:02:16.720 --> 01:02:20.720
在提出这个建议之前，我会说我不知道​​并且一直像哇

01:02:20.720 --> 01:02:23.359
nelly，现在我们有了这个建议

01:02:23.359 --> 01:02:27.280
看着它，我在想，是的，我可以签下

01:02:27.280 --> 01:02:29.760
我认为这

01:02:30.559 --> 01:02:35.599
所以这就是我今天脑海中的新鲜事，让我们确保我喜欢

01:02:35.599 --> 01:02:39.359
了解这是什么与众不同

01:02:39.359 --> 01:02:44.720
通过说所有的

01:02:44.720 --> 01:02:49.359
我可能要应用的所有路径遍历或选择器

01:02:49.359 --> 01:02:52.960
在图的解密版本上，仅适用于图

01:02:52.960 --> 01:02:57.280
解密，所以基本上说得到加密

01:02:57.280 --> 01:03:01.200
图形解密它，然后运行与其他选择器不同的选择器

01:03:01.200 --> 01:03:05.200
允许在加密图上运行选择器的建议

01:03:05.200 --> 01:03:08.400
这很好，但前提是他们涉及某种形式的

01:03:08.400 --> 01:03:12.160
极其复杂的同态加密

01:03:12.160 --> 01:03:16.319
就像一个研究领域，不是真的，我是说你可以

01:03:16.319 --> 01:03:20.880
写图是否像我的意思取决于您想要的方式是的，我的意思是如果您

01:03:20.880 --> 01:03:23.920
只需遵循图的路径，每次走路时都在解密

01:03:23.920 --> 01:03:27.920
下一个街区，那么你可以做到这一点

01:03:27.920 --> 01:03:32.319
您仍然可以在此处执行此操作，您必须首先分两个步骤进行操作

01:03:32.319 --> 01:03:34.319
正确的是它需要一个参数

01:03:34.319 --> 01:03:38.720
情况是的，那是坏事

01:03:38.720 --> 01:03:42.079
是的，那是坏事，然后好事是，你可以

01:03:42.079 --> 01:03:45.280
嗯，它的定义也不太好，因为

01:03:45.280 --> 01:03:48.319
就像你仍然有各种各样的问题一样

01:03:48.319 --> 01:03:50.720
那里的钥匙，那么你仍然有很多

01:03:50.720 --> 01:03:55.839
那里的未回答的api问题就像只是编解码器参数没有

01:03:55.839 --> 01:04:00.400
实际上可以帮助任何人，所以就像这样

01:04:00.400 --> 01:04:03.200
我这样做是的，您只是解密所有内容，然后就可以

01:04:03.200 --> 01:04:05.760
如果不这样做，通常会遍历

01:04:05.760 --> 01:04:08.880
如果您将图表重写为链接

01:04:08.880 --> 01:04:14.400
而您想说的是，例如将api添加到链接加载器，以便它可以理解

01:04:14.400 --> 01:04:19.280
这个键你仍然想要一个多编解码器的标识符

01:04:19.280 --> 01:04:23.039
告诉您是否是加密块，以便您知道何时

01:04:23.039 --> 01:04:26.480
如果您进行这支舞蹈，请击中该方块并应用键并换掉参考

01:04:26.480 --> 01:04:32.480
到街区对，就像你仍然

01:04:32.480 --> 01:04:37.039
需要相同的块级标准以及多编解码器标识符才能知道

01:04:37.039 --> 01:04:41.839
何时应用密钥，何时不应用

01:04:42.240 --> 01:04:46.640
是的，您需要是的，您需要一些标识符，以确定为什么不使用多编解码器

01:04:46.640 --> 01:04:54.000
但这不一定像api那样回答

01:04:54.000 --> 01:04:58.000
好吧，如果您要说的是，您希望人们如何与之互动

01:04:58.000 --> 01:05:01.440
不不不，但是在那种情况下你要说的是我要你请客

01:05:01.440 --> 01:05:04.319
加密的块，就像它们处于未加密状态一样

01:05:04.319 --> 01:05:08.400
因此，而不是将数据模型遍历为已解码

01:05:08.400 --> 01:05:11.440
就像iv和字节一样的加密块

01:05:11.440 --> 01:05:15.440
就像实际运行解密程序um，所以您在告诉图形

01:05:15.440 --> 01:05:19.839
遍历引擎就像是，像对待任何加密块一样

01:05:19.839 --> 01:05:23.359
现在，您已经拥有了一个多编码范围，您知道该范围已加密，因此

01:05:23.359 --> 01:05:26.799
这就是您决定是否应用密钥时要检查的内容

01:05:26.799 --> 01:05:32.400
或一边调用某些功能以找到正确的键

01:05:33.039 --> 01:05:36.319
是的，让我对此感到非常高兴的事情实际上是

01:05:36.319 --> 01:05:40.400
现在正在做类似将选择器应用于

01:05:40.400 --> 01:05:43.520
密文实际上定义得很好

01:05:43.520 --> 01:05:47.520
这个提议，因为它适用于当密文

01:05:47.520 --> 01:05:52.079
很好，我们以前没有关于

01:05:52.079 --> 01:05:54.720
我们如何期望与其他任何人一起做到这一点

01:05:54.720 --> 01:05:57.760
我们一直在进行有关加密的讨论，人们一直想提出好的建议

01:05:57.760 --> 01:06:01.680
我们将使用编解码器进行加密，然后在

01:06:01.680 --> 01:06:08.000
编解码器运行时，您将获得明文，这样实际上是个坏主意

01:06:08.000 --> 01:06:11.680
因为如果您想编写一个在密码上起作用的选择器

01:06:11.680 --> 01:06:15.440
您不喜欢的文字是未定义的，不是

01:06:15.440 --> 01:06:19.039
就像api一样，它实际上是未定义的

01:06:19.039 --> 01:06:22.319
因此，现在有了对编解码器的实际定义，

01:06:22.319 --> 01:06:26.799
像可能将密文分块成iv和密文主体

01:06:26.799 --> 01:06:31.599
定义它是否特别有用

01:06:31.599 --> 01:06:38.160
我当然是有争议的，但是我喜欢我认为更有用的部分是

01:06:38.160 --> 01:06:41.440
就像未加密状态一样，

01:06:41.440 --> 01:06:44.480
将块中的cd分开的块格式

01:06:44.480 --> 01:06:47.760
因为这就像对所有这些东西进行编码的另一个烦人的步骤

01:06:47.760 --> 01:06:50.960
就像是如何去如何去真正地去喜欢

01:06:50.960 --> 01:06:55.280
处理解密状态，将其转换回cid和字节

01:06:55.280 --> 01:06:59.839
嗯，是的，但是我的意思是像您在javascript中一样，这将是

01:06:59.839 --> 01:07:02.640
就像我解码一个块一样容易，如果它

01:07:02.640 --> 01:07:06.799
没有正确解密以及价值，然后我可以通过

01:07:06.799 --> 01:07:10.079
密钥并正确获得解密状态并获得减量以查看成语

01:07:10.079 --> 01:07:15.839
这样的字节就像超级超级容易

01:07:19.119 --> 01:07:22.640
我们可能必须开始写一些可以参考的实际类似文本

01:07:22.640 --> 01:07:25.760
为了进一步推动这一讨论，我

01:07:25.760 --> 01:07:28.319
猜猜我会在接下来的几天里写点东西

01:07:28.319 --> 01:07:32.880
这样，即使会议开始时，如果我不在八点的时候，人们也可以

01:07:32.880 --> 01:07:35.119
看见

01:07:38.079 --> 01:07:43.839
酷，我认为我们很好

01:07:51.040 --> 01:07:54.110
[音乐]

01:07:54.960 --> 01:07:59.280
这些令人兴奋的电话经常发生是的，是的，我的意思是每个

01:07:59.280 --> 01:08:02.880
一周，这样您就可以流行起来，欢迎您加入我们

01:08:02.880 --> 01:08:06.960
您的输入可能会非常有价值，嗯，每周的同一时间

01:08:06.960 --> 01:08:10.880
相同的频道，我们还有其他想要的吗？

01:08:10.880 --> 01:08:13.680
在我们关闭彼得之前盖上盖子，你想做漂浮的东西吗

01:08:13.680 --> 01:08:16.319
我认为那是你

01:08:16.400 --> 01:08:20.960
不，我知道我这么晚了，我基本上只是想再次参加比赛

01:08:20.960 --> 01:08:24.239
为什么我们如此着迷于您知道要穿衣服

01:08:24.239 --> 01:08:28.960
同时我们正在记录像是的，是的，您知道不支持

01:08:28.960 --> 01:08:33.279
这个，这个以及这个，几乎我们所有的编解码器都可以完全编码和解码

01:08:33.279 --> 01:08:36.400
他们，但我们不支持这些东西，所以不要像这样依赖它

01:08:36.400 --> 01:08:39.920
那不是规格，不是我们做浮子，不是

01:08:39.920 --> 01:08:43.440
我们不是很稳定地漂浮吗

01:08:44.159 --> 01:08:46.880
我们被稀释了

01:08:47.759 --> 01:08:53.120
更像是我们在很多地方呼唤

01:08:53.120 --> 01:08:56.000
就像我们的文档一样

01:08:56.000 --> 01:09:00.239
说出来，嗯，这不是那样的事情

01:09:00.239 --> 01:09:03.199
浮点数与您所知道的完全相反，您知道我们正在尝试做什么

01:09:03.199 --> 01:09:06.080
ipld with uh你知道uh不变性和一个

01:09:06.080 --> 01:09:11.679
词是代表某种东西，我们几乎走得像我想的那样

01:09:11.679 --> 01:09:15.120
我在你提交的东西中写的是

01:09:15.120 --> 01:09:21.679
一句话不要用这个，所以为什么我们不只是说你知道

01:09:21.679 --> 01:09:24.960
我们劝阻他们，您知道他们在这里是历史文物，我们

01:09:24.960 --> 01:09:28.640
学会了我们的课程，不要继续使用它们，就像为什么

01:09:28.640 --> 01:09:33.520
我们不是在娱乐这个，而不是在公关

01:09:33.520 --> 01:09:37.679
所以这是我的想法，所以我要说的是

01:09:37.679 --> 01:09:43.920
在那儿用过呃，所以我们支持它

01:09:43.920 --> 01:09:47.359
我们只是把浮子放在那里

01:09:47.359 --> 01:09:51.120
认为这是对ie754的一对一映射，这不是

01:09:51.120 --> 01:09:54.800
浮点数在数据模型中，嗯，那里有注释

01:09:54.800 --> 01:09:57.760
嗯嗯

01:09:58.560 --> 01:10:03.679
并且建议在ipld上开发系统时避免使用float值

01:10:03.679 --> 01:10:06.480
和内容寻址系统，因为

01:10:06.480 --> 01:10:08.719
在字节表示中引入可变性

01:10:08.719 --> 01:10:12.159
用于编码具有更大位置的小数的替代方法

01:10:12.159 --> 01:10:15.360
并且在可能的情况下应考虑较小的可变性

01:10:15.360 --> 01:10:18.880
我的想法是，这非常取决于用例

01:10:18.880 --> 01:10:24.880
嗯，在很多用例中，数据的字节收敛不是

01:10:24.880 --> 01:10:27.920
重要，您只想吐出数据并

01:10:27.920 --> 01:10:31.199
转移它并为其提供内容地址，依此类推

01:10:31.199 --> 01:10:33.840
如果您可以用不同的形式做同样的事情怎么办

01:10:33.840 --> 01:10:37.360
嗯，所以这就像一个狭窄的方面

01:10:37.360 --> 01:10:40.560
这是我们主要关注的问题之一，但这是一个狭窄的问题

01:10:40.560 --> 01:10:44.159
对于一组特定的用例，但是有很多用例

01:10:44.159 --> 01:10:47.360
不用担心，人们不会在意我好吧，我想

01:10:47.360 --> 01:10:52.719
编码1.1，谁在乎这不是我能准确做到的事情？

01:10:52.719 --> 01:10:56.239
我只需要大致到达那里，而我曾经在其中工作过

01:10:56.239 --> 01:11:03.520
我做了很多工作，嗯，有些遗传问题

01:11:03.520 --> 01:11:06.800
我以前的生活之一是动物遗传学，我们曾经

01:11:06.800 --> 01:11:10.560
通过所有这些遗传参数来测量动物

01:11:10.560 --> 01:11:13.920
我们将拥有所有这些浮点数，

01:11:13.920 --> 01:11:18.000
在这一点上，您需要的精度非常低，

01:11:18.000 --> 01:11:22.320
所以我就像是的，只要方向正确就可以了

01:11:22.320 --> 01:11:24.400
嗯，外面有很多人

01:11:24.400 --> 01:11:26.560
有很多数据都没关系

01:11:26.560 --> 01:11:30.800
精度不像您的单精度好

01:11:30.800 --> 01:11:33.920
并且您不需要的大致相同的东西

01:11:33.920 --> 01:11:37.920
真正的平等，我不需要将数据形式融合到

01:11:37.920 --> 01:11:40.560
相同数据的相同cid并不是问题

01:11:40.560 --> 01:11:43.840
所以我认为那是我评论这些内容的地方，而且确实在上升

01:11:43.840 --> 01:11:47.040
由用户决定，这就是ipld的精神，我认为我们

01:11:47.040 --> 01:11:49.600
追求我们是否要排除它并说看

01:11:49.600 --> 01:11:52.960
这不是我们将来要支持的东西

01:11:52.960 --> 01:11:59.360
ii认为我们确实在边缘化大量潜在用户群

01:11:59.360 --> 01:12:02.400
知道什么是最适合他们的用例的

01:12:02.400 --> 01:12:07.040
比我们做的要好，但是那我就拥有了

01:12:07.040 --> 01:12:10.880
相反的问题，例如您是否在您想去的地方

01:12:10.880 --> 01:12:13.679
就像铲除周围的数据一样，就像人一样

01:12:13.679 --> 01:12:17.760
你知道只是呃，你知道正确的正确的形状

01:12:17.760 --> 01:12:20.320
嗯，这是我们实际上的事情

01:12:20.320 --> 01:12:24.159
希望他们使用，因为就像他们在没有行李的情况下得到所有行李一样

01:12:24.159 --> 01:12:27.520
任何好处，或者例如您知道什么

01:12:27.520 --> 01:12:30.000
我们在谈论这种加密的东西，就像你不能做任何那件事

01:12:30.000 --> 01:12:32.239
没有明确的定义，你就会知道

01:12:32.239 --> 01:12:37.120
底层数据模型，这些数字只是做同样的事情，所以

01:12:37.120 --> 01:12:41.520
就像当你说我感觉像是我的意思一样

01:12:41.520 --> 01:12:45.280
看起来像有关在ipld中使用它们的说明

01:12:45.280 --> 01:12:48.560
本质上就像是警告，说如果你看起来像

01:12:48.560 --> 01:12:52.640
知道你需要很高的精度

01:12:52.640 --> 01:12:56.080
你实际上不会在语言时期之间得到那个

01:12:56.080 --> 01:12:59.679
像语言一样很难，就像持续浮动一样

01:12:59.679 --> 01:13:02.840
像javascript这样的实现，尤其是

01:13:02.840 --> 01:13:06.880
但是如果您在一个系统中只有一种编程语言，并且

01:13:06.880 --> 01:13:09.760
您只需要来回铲动字节就可以使用字节

01:13:09.760 --> 01:13:13.120
就像你一样，你知道那将与任何东西保持一致

01:13:13.120 --> 01:13:16.239
您的实现是将其粘贴为字节值而不是使用流

01:13:16.239 --> 01:13:18.640
这就是我们警告人们的原因，就像

01:13:18.640 --> 01:13:21.520
如果您可以将它们编码为自己的字节并以这种方式进行解码，

01:13:21.520 --> 01:13:23.440
最终表现出更加一致的行为

01:13:23.440 --> 01:13:26.719
尤其是语言之间

01:13:27.199 --> 01:13:32.320
是的，我们为什么不这么突出

01:13:32.320 --> 01:13:36.400
很好，并且对于我们的任何库都有一定的能力来实际存储它们并

01:13:36.400 --> 01:13:40.000
像我们所有的解码器一样看到它们，就可以恢复它们

01:13:40.000 --> 01:13:42.239
咬，你要咬一口，你就不会浮在水面上

01:13:42.239 --> 01:13:46.800
您将不得不手动进行操作，除了js或golang或其他任何操作，

01:13:46.800 --> 01:13:51.199
这就是我的观点，就像golang解码的编码浮点字节是

01:13:51.199 --> 01:13:54.960
非常一致，像解码浮点表示

01:13:54.960 --> 01:13:57.840
从cbor在javascript之间重新编码

01:13:57.840 --> 01:14:01.760
返回并发送它去就像被搞砸了，就像被搞砸了

01:14:01.760 --> 01:14:06.560
有时会把它转换成整数，如果没有的话

01:14:06.560 --> 01:14:10.640
尾数，就像是的，这就像那个

01:14:10.640 --> 01:14:13.840
这就是为什么最好将它们编码为字节（如果您知道的话）的原因

01:14:13.840 --> 01:14:16.719
即将发生

01:14:16.960 --> 01:14:20.719
我认为我们的实际位置是将帽子挂在

01:14:20.719 --> 01:14:24.719
是我们有一堆ipld的编解码器吗

01:14:24.719 --> 01:14:30.159
认为与之建立良好的接口真的很重要

01:14:30.159 --> 01:14:36.159
漂浮在某种模糊的意义上，那些事情甚至在什么方面都没有达成共识

01:14:36.159 --> 01:14:39.120
浮动意味着他们绝对不同意

01:14:39.120 --> 01:14:44.400
与ieee 7一起，无论他们绝对不同意什么

01:14:44.400 --> 01:14:46.800
各种编程语言实现的方式

01:14:46.800 --> 01:14:51.679
他们一直不同意硅之类的东西

01:14:51.679 --> 01:14:55.600
像智能沙子一样对浮点进行蚀刻，因为这不是

01:14:55.600 --> 01:14:59.840
在不同世代的智能沙子之间或在地球上制造的沙子之间保持一致

01:14:59.840 --> 01:15:04.000
喜欢，我们不愿意向人们宣称这些东西不是

01:15:04.000 --> 01:15:09.600
问题，所以我们将尝试阅读

01:15:09.600 --> 01:15:13.840
其中具有这种格式的文档

01:15:13.840 --> 01:15:19.520
并尝试提供一种尽力而为的方式，供您阅读和操作

01:15:19.520 --> 01:15:23.120
信息，但我们同时要去

01:15:23.120 --> 01:15:27.360
强烈建议您不要生成此类新信息

01:15:27.360 --> 01:15:30.640
因为很难做出有用的承诺

01:15:30.640 --> 01:15:33.120
周围

01:15:34.719 --> 01:15:39.840
但是我们在说我们已经提供了

01:15:40.480 --> 01:15:43.199
就像发生了我想存储，想要存储和想要发生的事情

01:15:43.199 --> 01:15:49.040
像您知道的那样存储，我想正确地开始1.1，并且我的数据模型是字节和

01:15:49.040 --> 01:15:52.560
整数和字符串也都是字节，所以

01:15:52.560 --> 01:15:58.640
我有字节和整数是我和c的id，我想存储1.1

01:15:58.640 --> 01:16:03.520
我的计划是什么，因为我想说的重点是，如果你说

01:16:03.520 --> 01:16:08.480
它是字节，那么这对于

01:16:08.480 --> 01:16:12.800
像你这样说的用户知道我走过的路就像

01:16:12.800 --> 01:16:17.040
根字段一字段两个点，您知道

01:16:17.040 --> 01:16:24.080
从字节转换为浮点数，就像最终取决于

01:16:24.080 --> 01:16:28.320
另外两个因素是它总是会一直存在

01:16:28.320 --> 01:16:32.159
在这种情况下，您会很好，因为它永远都可以

01:16:32.159 --> 01:16:36.480
或者说您拥有1.1很棒，但这实际上是您

01:16:36.480 --> 01:16:39.440
需要担心它会增长到无穷大还是它会像

01:16:39.440 --> 01:16:42.560
如果是相当小的理性，则使用两次胜利并将其称为

01:16:42.560 --> 01:16:46.800
如果您知道的话，请在某个时候完成

01:16:46.800 --> 01:16:51.199
如果您最终认为这将扩大到

01:16:51.199 --> 01:16:54.960
javascript会很不高兴，实际上您确实在乎精度

01:16:54.960 --> 01:16:58.640
您可能想使用bigint或对不起大浮点数，并且喜欢

01:16:58.640 --> 01:17:02.400
正确地将其以字节为单位，就像问题是一些自定义的东西

01:17:02.400 --> 01:17:05.600
同样的问题javascript大于这个，它甚至没有大小

01:17:05.600 --> 01:17:09.360
问题是，就像问题是，如果我给你1.1，

01:17:09.360 --> 01:17:11.360
然后将其交给javascript和javascript

01:17:11.360 --> 01:17:15.520
就像从其中删除0.1，然后对其重新编码并将其发送给您

01:17:15.520 --> 01:17:18.719
你将要得到一个int，你将不再需要一个浮点数

01:17:18.719 --> 01:17:22.000
所以像使一致的float的唯一方法是将其编码为

01:17:22.000 --> 01:17:25.120
字节，然后用javascript将其解编码

01:17:25.120 --> 01:17:28.080
进入float，然后如果它说哦，我有一个整数，我什至没有将其编码为

01:17:28.080 --> 01:17:31.199
ieee浮在这些字节中，然后它将做正确的事，您会吵架

01:17:31.199 --> 01:17:33.199
那样回来是唯一的方法

01:17:33.199 --> 01:17:37.520
实际上可以在语言之间工作，但是可以使用不同的用例

01:17:37.520 --> 01:17:41.600
会找到合适的解决方案，例如

01:17:41.600 --> 01:17:44.960
我认为大多数金融机构确实

01:17:44.960 --> 01:17:47.760
同意我们使用整数，然后除

01:17:47.760 --> 01:17:50.560
当我们需要小数部分时，您可以通过区块链看到它

01:17:50.560 --> 01:17:54.080
从比特币开始的行业，您在哪里

01:17:54.080 --> 01:17:56.960
存储很大的数字，然后将其除以得到

01:17:56.960 --> 01:18:00.400
btc值和文件硬币做相同的事情um

01:18:00.400 --> 01:18:03.920
您只有一台除数一致的设备

01:18:03.920 --> 01:18:08.000
和不同的用法，例如像编码为float一样不是字符串

01:18:08.000 --> 01:18:11.679
不好的选择要么只是取决于您的用例

01:18:11.679 --> 01:18:16.159
所以我想知道这里是否有很多反馈，我想知道是否可以

01:18:16.159 --> 01:18:19.600
如果还有更多的单词要包括在

01:18:19.600 --> 01:18:22.880
数据模型页面的拉取请求转到该pr，

01:18:22.880 --> 01:18:26.239
让我们进一步澄清一下，有关javascript的内容可能值得

01:18:26.239 --> 01:18:29.600
即使我们已经提到过，在该特定部分中进行了扩展

01:18:29.600 --> 01:18:33.440
是在那个页面上，然后实际上要求您

01:18:33.440 --> 01:18:36.239
知道我们可以在上面放更多的例子吗

01:18:36.239 --> 01:18:39.840
我所问的确切领域ii认为我们实际上是广泛的

01:18:39.840 --> 01:18:43.920
同意我的立场是我们

01:18:43.920 --> 01:18:48.880
不要警告别人，不要使用它

01:18:49.360 --> 01:18:52.880
好，那是我提出拉取请求的目的，是因为我们谈论

01:18:52.880 --> 01:18:55.199
关于它，但我们还没有真正在任何地方说过

01:18:55.199 --> 01:18:58.239
我们建议您在我们的文档中找不到它

01:18:58.239 --> 01:19:02.800
反对，是的，绝对是的，我们可以

01:19:02.800 --> 01:19:07.120
其实想提起您在比特币和文件硬币中所提到的方式

01:19:07.120 --> 01:19:11.199
我们做花车就是这样，指向那些东西，然后像你一样说

01:19:11.199 --> 01:19:13.120
知道这就是人们所拥有的

01:19:13.120 --> 01:19:18.159
有点着眼于如何在一些较大的系统中解决这个问题

01:19:18.320 --> 01:19:21.920
我们根本不做浮点数，我们只是整数，只有它们是大头，但是我们

01:19:21.920 --> 01:19:24.640
没有不，它确实会浮动

01:19:24.640 --> 01:19:27.280
虽然它确实会浮动但并不意味着内存

01:19:27.280 --> 01:19:31.199
它使用它使用数据模型作为整数，所以它

01:19:31.199 --> 01:19:35.440
到目前为止，coin使用浮点数，只是在序列化层不使用浮点数

01:19:35.440 --> 01:19:41.440
它不会在内存中进行偶数浮点运算，因为它具有整数

01:19:41.440 --> 01:19:44.159
划分它没有亚原子场

01:19:44.159 --> 01:19:49.440
除法，它总是会耗尽，因为从概念上讲，它会使它浮动

01:19:49.440 --> 01:19:52.000
从某种意义上讲，它具有浮点值

01:19:52.000 --> 01:19:55.679
它将大数字除以其他数字，也许

01:19:55.679 --> 01:20:00.000
具有非整数的数字就是那个使它成为单词的词

01:20:00.000 --> 01:20:04.239
没有什么，但是没有整数，这就是我的意思

01:20:04.239 --> 01:20:08.080
猎鹰绝对不拥有它，拥有它，它拥有浮子，

01:20:08.080 --> 01:20:10.320
有美元和美分的浮动

01:20:10.320 --> 01:20:14.400
当你主要是在谈论那种感觉时就会浮起来

01:20:14.400 --> 01:20:17.520
的花车似乎是其中一些区域之一

01:20:17.520 --> 01:20:23.360
我们再次编写了一些规范文档，但就像说

01:20:23.360 --> 01:20:26.880
不要使用它是不够的，似乎我们实际上

01:20:26.880 --> 01:20:31.679
应该至少提供一些替代建议，因为

01:20:31.679 --> 01:20:36.239
否则人们会很困惑地阅读这些文档

01:20:36.239 --> 01:20:40.000
喜欢，我们不应该尝试明确地回答这个问题

01:20:40.000 --> 01:20:43.600
但是就像我们可能会添加一个段落和一些要点

01:20:43.600 --> 01:20:47.199
例如考虑使用已知除数的定点数学

01:20:47.199 --> 01:20:50.159
与您的情况相关的考虑使用

01:20:50.159 --> 01:20:53.760
小数部分的整个部分都有多个数字

01:20:53.760 --> 01:20:57.840
考虑实施分数

01:20:58.840 --> 01:21:01.840
嗯，因为所有这些方法都是

01:21:01.840 --> 01:21:03.840
在某些情况下或其他类似情况下是合理的

01:21:03.840 --> 01:21:07.520
许多好的计算都使用定点方法

01:21:07.520 --> 01:21:10.560
嗯，也许我们只需要在文档中命名这些令人毛骨悚然的东西，因为

01:21:10.560 --> 01:21:14.400
让人们唱歌说不要使用浮点数，然后

01:21:14.400 --> 01:21:17.840
希望有人能找到正确的维基百科页面

01:21:17.840 --> 01:21:22.880
想法也许这不是很好

01:21:23.520 --> 01:21:26.719
是的，总的来说，我更喜欢这样的团体

01:21:26.719 --> 01:21:30.239
我们真的结婚了吗，因为有足够的浮动，就像周围的方式

01:21:30.239 --> 01:21:33.679
我读你的公关就像是我真正想要的

01:21:33.679 --> 01:21:37.120
人们将我们数据模型的这一部分视为

01:21:37.120 --> 01:21:44.880
好吧，这就是很好的方式，让我们改变，让我们修正措辞

01:21:44.880 --> 01:21:48.880
进行澄清，但您的反馈中就有

01:21:48.880 --> 01:21:55.360
挥之不去的问题

01:21:55.360 --> 01:22:00.480
它是它的真正一部分还是本质上已弃用？

01:22:00.719 --> 01:22:03.760
而且我没有答案，因为这是一个非常好的问题

01:22:03.760 --> 01:22:06.719
因为它确实有点过时了

01:22:06.719 --> 01:22:11.040
嗯，并不是所有的东西都是区块链中的错误，就像上百万美元一样

01:22:11.040 --> 01:22:14.960
像这样的台词有时您可能只是懒惰

01:22:14.960 --> 01:22:18.159
男人，这很酷，但是我们很诡计，但是我们

01:22:18.159 --> 01:22:19.920
我们有点像对待它

01:22:19.920 --> 01:22:23.040
我们想要像整个男人一样拖到一边的不赞成使用的功能

01:22:23.040 --> 01:22:26.639
无限讨论又回到了我们为何专注于

01:22:26.639 --> 01:22:32.480
如果我们不关心的话，那些事情就对了

01:22:32.480 --> 01:22:37.120
好吧，尤其是像南族这样的人，和任何人一样

01:22:37.120 --> 01:22:40.800
你不能解码是南，似乎特别有问题

01:22:40.800 --> 01:22:45.360
就像我们倾向于思考确定性法典一样，因为

01:22:45.360 --> 01:22:49.840
事实是，大多数系统都会处理ieee

01:22:49.840 --> 01:22:52.719
 754，您将在两者之间获得一致的浮动

01:22:52.719 --> 01:22:56.800
系统，但在javascript能源情况下，您仍然可以进行通话

01:22:56.800 --> 01:22:59.679
在不同的系统中大约相同的数字

01:22:59.679 --> 01:23:03.199
在大多数情况下，这就是事实，这不是

01:23:03.199 --> 01:23:06.560
完全不安全，不只是让我们记录一下

01:23:06.560 --> 01:23:10.960
我们将在系统之间获得大量的一致性

01:23:15.520 --> 01:23:21.840
您是否想采用一些

01:23:21.840 --> 01:23:26.800
规范语言，具体取决于我们允许您使用的语言

01:23:26.800 --> 01:23:31.440
知道降落为四个花车

01:23:31.440 --> 01:23:38.159
现在我拥有实现此功能的库，我想进入javascript之类

01:23:38.159 --> 01:23:42.480
适当警告您，如果您快要浮出水面，就像在上发表评论

01:23:42.480 --> 01:23:48.960
处理浮动的功能就像呃，也许三思而后行

01:23:48.960 --> 01:23:53.440
就像规格很棒，不是每个人都阅读规格

01:23:53.440 --> 01:23:57.600
并非所有阅读规格的人都通读规格书

01:23:57.600 --> 01:24:02.320
嗯，关于该函数的评论说，就像您知道的一样

01:24:02.320 --> 01:24:07.600
浮动表示此星号有效，请注意长的星号注意

01:24:07.600 --> 01:24:13.199
当您将两个整数右加点时，不会发生这种情况

01:24:13.199 --> 01:24:17.520
可能会再次有用，这取决于它落在什么地方

01:24:17.520 --> 01:24:21.760
在规格上是的，是因为这是人们的问题

01:24:21.760 --> 01:24:25.840
不像我们放出这段文字，人们不读我们的文字，因为他们不

01:24:25.840 --> 01:24:28.480
转到我们所生活的互联网这个晦涩的角落

01:24:28.480 --> 01:24:32.159
我们认为确实很重要，但是没有人真正在乎

01:24:32.159 --> 01:24:35.440
是的，我的意思是，取决于我们要执行的力度，您可以执行操作

01:24:35.440 --> 01:24:39.520
就像嗯，除非您提供，否则它不会这样做

01:24:39.520 --> 01:24:43.440
某种替代标志，似乎有点敌意

01:24:43.440 --> 01:24:48.480
嗯，所以让我们尝试获得措辞

01:24:48.480 --> 01:24:51.280
首先是权利，也许我们炖了之后，我们就回来了

01:24:51.280 --> 01:25:00.400
更有力的意见还可以吗？

01:25:00.400 --> 01:25:03.360
在我们结束会议之前先谈谈

01:25:03.360 --> 01:25:08.560
这是一个很长的时间，让我们关闭它，YouTube上有一个问题，我可以吗？

01:25:08.560 --> 01:25:14.880
确保在气象数据分析中使用ipld

01:25:14.880 --> 01:25:22.880
是的，这看起来不错，您需要浮子吗，因为您需要浮子，因为

01:25:22.880 --> 01:25:26.480
我造成飓风的翅膀来自

01:25:26.480 --> 01:25:30.400
计算初期的气象数据科学案例研究

01:25:30.400 --> 01:25:32.719
以及精度和浮点数

01:25:32.719 --> 01:25:36.800
当打印在磁带上时，会导致不良的模拟结果

01:25:36.800 --> 01:25:39.199
用不同的精度反馈

01:25:39.199 --> 01:25:42.159
因为它们是以串行形式打印的

01:25:42.159 --> 01:25:46.159
气象数据不应使用浮点数

01:25:46.159 --> 01:25:51.280
计算中的故事以及如何不使用浮点数

01:25:51.280 --> 01:25:58.159
太棒了，这太完美了，我想起很多气象学

01:25:58.159 --> 01:26:00.400
用例是涉及很多数据

01:26:00.400 --> 01:26:04.159
并且您可能想随时间推移保留它，以便您有记录

01:26:04.159 --> 01:26:07.600
这些就是ipld完美的东西

01:26:07.600 --> 01:26:11.040
我想有很多重复的事情

01:26:11.040 --> 01:26:13.520
一遍又一遍地引用，所以这可能是一个真正的主意

01:26:13.520 --> 01:26:20.320
他们获得了重复数据删除免费，反正他说的很好，反馈很好

01:26:20.320 --> 01:26:26.880
好吧，让我们总结一下，感谢您长期与大家见面

