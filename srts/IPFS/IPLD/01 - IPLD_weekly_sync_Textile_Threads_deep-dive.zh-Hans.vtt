WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:03.920
希望基于漂亮的问题，但嗯

00:00:04.560 --> 00:00:08.080
嗯，是的，我的意思是，这可能是因为我

00:00:08.080 --> 00:00:11.360
会录下来并从中制作一些更正式的资料

00:00:11.360 --> 00:00:14.080
所以是的，我的意思是那里的白皮书

00:00:14.080 --> 00:00:19.039
但是除非我每天更新它，否则总是

00:00:19.039 --> 00:00:23.840
落后一点

00:00:25.119 --> 00:00:29.920
好吧，我想我们正在录制它说我们正在录制

00:00:29.920 --> 00:00:33.840
我要按另一个录音按钮，这里没有声音说我住

00:00:33.840 --> 00:00:38.399
屏幕，但不进行录制，因此可以在youtube上直播哦，我们去了

00:00:38.399 --> 00:00:42.000
我也将要录制，只是因为我不相信活物

00:00:42.000 --> 00:00:44.879
无论如何，谢谢大家加入我们，如果

00:00:44.879 --> 00:00:50.480
您正在看这个，这是我们每周都想知道的ipld，尽管我们是

00:00:50.480 --> 00:00:52.800
一点我们不应该拥有一个

00:00:52.800 --> 00:00:55.440
显然，我们已经切换到每第二周一次

00:00:55.440 --> 00:00:59.280
但是我们有纺织领域的好伙伴加入

00:00:59.280 --> 00:01:05.119
谁和我们今天将重点关注um线程，也许还有一点

00:01:05.119 --> 00:01:10.320
存储桶，因此纺织品um数据结构和协议

00:01:10.320 --> 00:01:14.560
用于收集数据和事物的链接

00:01:14.560 --> 00:01:18.720
嗯，所以我们有一堆人

00:01:18.720 --> 00:01:21.840
对线程和um的技术问题感兴趣

00:01:21.840 --> 00:01:25.119
我们很想让这些家伙给我们一个嗯

00:01:25.119 --> 00:01:31.439
一些技术背景比什么更深

00:01:31.439 --> 00:01:36.720
嗯，通过文档，所以我将其交给卡森或

00:01:36.720 --> 00:01:41.520
砂光机，让您指导我们，恩，胡椒粉

00:01:41.520 --> 00:01:46.320
与peppy的问题，因为他们出现很酷是的，我的意思是我认为

00:01:46.320 --> 00:01:48.479
我和桑德拉一直在想我们可能会做的是

00:01:48.479 --> 00:01:54.560
从像高级概念一样的线程开始

00:01:54.560 --> 00:01:57.600
高层次的观点他们解决了什么样的问题

00:01:57.600 --> 00:02:01.520
然后在那之后挖出更深的像

00:02:01.520 --> 00:02:05.600
我们使用的ipld结构，例如

00:02:05.600 --> 00:02:08.879
开发数据结构时遇到的障碍

00:02:08.879 --> 00:02:13.599
就像为什么我们选择一种做事方式

00:02:13.599 --> 00:02:16.560
另一个嗯，因为即使如此，我们可能

00:02:16.560 --> 00:02:19.599
可以说像哦，您知道这里缺少编解码器

00:02:19.599 --> 00:02:22.480
看起来像这样，你知道也许我们可以出去，我会

00:02:22.480 --> 00:02:27.680
构建它或类似的东西，如果看起来合理，

00:02:27.680 --> 00:02:30.879
你桑德拉，你想让我做一个快速的概述吗

00:02:30.879 --> 00:02:34.160
东西然后从那里走，那似乎很合理

00:02:34.160 --> 00:02:38.080
很酷，嗯，所以我只是要快速分享我的屏幕

00:02:38.080 --> 00:02:44.800
嗯，这是我们的um线程白皮书中的图片，但这可能是

00:02:44.800 --> 00:02:49.040
最像有用的上下文，如高级

00:02:49.040 --> 00:02:53.200
线程是什么的概述

00:02:53.200 --> 00:02:56.480
你实际上知道我们想到了呃线程

00:02:56.480 --> 00:03:01.760
复数作为一种权利，现在有两件事，就像数据的线程协议

00:03:01.760 --> 00:03:06.000
交换然后线程数据库，这有点像实际

00:03:06.000 --> 00:03:09.519
实施之上，因此今天我们将重点关注

00:03:09.519 --> 00:03:15.760
对协议和数据结构进行线程化，因此线程实际上就像一个

00:03:15.760 --> 00:03:20.239
关于给定数据集的主题，它具有

00:03:20.239 --> 00:03:25.200
与之相关联的一组单个编写器日志

00:03:25.200 --> 00:03:30.400
因此，您可能有任意数量的同龄人在给定主题上进行交互

00:03:30.400 --> 00:03:34.799
而每个对等端可能正在为

00:03:34.799 --> 00:03:38.560
本质上是这个单一主题数据集的突变

00:03:38.560 --> 00:03:42.560
每个对等方仅对其日志负责，并且仅对其日志负责

00:03:42.560 --> 00:03:46.720
并且只有他们被允许写入给定的日志

00:03:46.720 --> 00:03:50.480
日志本质上是由其对等ID键入的

00:03:50.480 --> 00:03:57.760
或他们的对等ID的公钥，然后该线程作为一个集合是

00:03:57.760 --> 00:04:00.080
基本上是所有这些日志的集合，

00:04:00.080 --> 00:04:03.360
与该日志中涉及的对等方关联的地址，以及

00:04:03.360 --> 00:04:08.799
其他各种元数据，包括一些键，我将在稍后讨论

00:04:08.799 --> 00:04:13.680
然后在实际使用中，您会知道您是否有多个

00:04:13.680 --> 00:04:17.359
在给定的数据集上进行交互，每个数据集都可能会改变其状态

00:04:17.359 --> 00:04:23.199
该数据集位于自己的日志中，然后有些

00:04:23.199 --> 00:04:27.120
数据具体化或具体化的最终结果是

00:04:27.120 --> 00:04:30.560
基本上是折叠该日志的更新以产生

00:04:30.560 --> 00:04:35.040
那些设置为产生最终状态的日志可以在

00:04:35.040 --> 00:04:38.720
一些客户在某个地方编写单个日志，这有点像

00:04:38.720 --> 00:04:43.280
关键，它为我们提供了许多非常有用的属性

00:04:43.280 --> 00:04:47.040
最有用的方法之一是，您可以实质上推迟实现

00:04:47.040 --> 00:04:50.240
查看直到需要的时间，因为

00:04:50.240 --> 00:04:53.919
您知道不会有任何冲突，因为只有一个同伴

00:04:53.919 --> 00:04:57.919
负责他们给定的日志，您可以处理

00:04:57.919 --> 00:05:00.000
永远不会有类似的冲突

00:05:00.000 --> 00:05:03.440
右侧，但是当您在读取侧可能会有冲突

00:05:03.440 --> 00:05:07.039
实际上试图实现这种观点，所以这取决于同行

00:05:07.039 --> 00:05:10.000
落实解决这些冲突的观点

00:05:10.000 --> 00:05:14.160
当它们到达um时，这对于分布式系统来说真的很好，因为您

00:05:14.160 --> 00:05:17.039
基本上不用担心可以交换

00:05:17.039 --> 00:05:20.720
数据，然后再处理类似的问题，这变成了

00:05:20.720 --> 00:05:24.240
我们来自哪里的真正有用的财产

00:05:24.240 --> 00:05:27.520
就像在移动世界中，就像在与同事合作一样

00:05:27.520 --> 00:05:31.919
您不想浪费时间或精力去应对的地方

00:05:31.919 --> 00:05:35.120
提前发生冲突，您最终会遇到这些疯狂的分支

00:05:35.120 --> 00:05:38.400
相反，您可以在阅读时处理它

00:05:38.400 --> 00:05:41.600
和其他团队也提出了类似的想法，但嗯，有一些

00:05:41.600 --> 00:05:46.960
嗯，这里的属性非常好，所以我们可以

00:05:46.960 --> 00:05:49.600
谈论为什么单个作者日志对其他有用

00:05:49.600 --> 00:05:54.479
东西，但这是一个很好的高级概述，所以一个

00:05:54.479 --> 00:05:58.720
日志是由对等ID和标准键入的

00:05:58.720 --> 00:06:01.840
如果我喜欢错过或走过去，请随意进入

00:06:01.840 --> 00:06:06.000
刷掉一些很简单或很抱歉的事情

00:06:06.000 --> 00:06:10.560
但无论如何，我们都有自己的日志，每个对等方都有责任写信给他们

00:06:10.560 --> 00:06:18.080
并且日志本质上是哈希链接哈希链接um仅附加日志

00:06:18.080 --> 00:06:26.800
像象牙块一样，它实际上是

00:06:26.800 --> 00:06:28.720
我们称这些记录为更高的记录

00:06:28.720 --> 00:06:33.120
级别的事物记录，并且每个记录都包含什么

00:06:33.120 --> 00:06:37.520
您可以在此图中看到，它就像

00:06:37.520 --> 00:06:44.080
一些标头信息um，包括密钥或抱歉的时间，我们使用

00:06:44.080 --> 00:06:47.360
宽松的学期时间通常有点像

00:06:47.360 --> 00:06:50.400
嗯，你知道逻辑时钟或类似的东西

00:06:50.400 --> 00:06:53.840
表示时间，不必是挂钟时间

00:06:53.840 --> 00:07:01.440
um，然后是用于加密该记录主体的密钥

00:07:01.440 --> 00:07:04.720
所以您实际上粘贴了密钥，每个密钥都是一个随机生成的密钥

00:07:04.720 --> 00:07:11.120
停留在标题中的时间，然后全部包裹起来

00:07:11.120 --> 00:07:16.560
一个称为读取密钥的附加密钥，您可以在此处看到um和read

00:07:16.560 --> 00:07:21.039
密钥用于对卡在标头中的正文进行加密，或者抱歉，密钥为

00:07:21.039 --> 00:07:24.319
用于解密卡在标头中的正文，读取密钥用于

00:07:24.319 --> 00:07:28.560
本质上包装所有东西以创建记录

00:07:28.560 --> 00:07:34.319
然后添加到您的该单个编写器日志中的每个记录是

00:07:34.319 --> 00:07:38.319
附加包装有复制器密钥

00:07:38.319 --> 00:07:42.240
这种多层次的做事方式的原因是

00:07:42.240 --> 00:07:47.440
允许一个对等体通过或一组对等体通过一个副本，对不起

00:07:47.440 --> 00:07:50.400
以前称为复制器密钥，现在称为服务密钥

00:07:50.400 --> 00:07:54.240
嗯，但无论如何，您都可以将该密钥传递给服务提供商

00:07:54.240 --> 00:07:59.759
该表面提供程序可以跟踪一段时间内的日志更新，而无法

00:07:59.759 --> 00:08:02.879
访问那些日志记录的内容

00:08:02.879 --> 00:08:06.000
嗯，所以他们只需要像一层一样深，这样他们就可以

00:08:06.000 --> 00:08:11.360
他们可以按照哈希链接的哈希值进行操作，但是它们的深度不能超过

00:08:11.360 --> 00:08:15.919
如果未给他们提供read键，则read并提供一些有用的属性

00:08:15.919 --> 00:08:20.000
因为现在我们可以像网络上的不信任服务提供商一样

00:08:20.000 --> 00:08:24.160
只不过是复制线程内容而已，实际上

00:08:24.160 --> 00:08:28.800
直接为喜欢更新或喜欢编辑任何内容做出贡献

00:08:28.800 --> 00:08:33.760
实际的线程内容，是的，那就是哈希

00:08:33.760 --> 00:08:37.760
链接片进入身体本身就可以

00:08:37.760 --> 00:08:40.640
几乎是任何或任何任意数据

00:08:40.640 --> 00:08:45.519
练习这些是ipld块um，因此在理论上

00:08:45.519 --> 00:08:49.600
你本来可以一直有种障碍

00:08:49.600 --> 00:08:53.519
您可能会有像实际ipld一样交换的同龄人

00:08:53.519 --> 00:08:58.080
块体内，但它包裹在一个读取键中，我们可以谈论一下

00:08:58.080 --> 00:09:01.519
因为那是一种类似的设计决策，我们不得不

00:09:01.519 --> 00:09:05.839
处理加密数据

00:09:06.320 --> 00:09:11.360
但我认为这为您提供了大致的总体结构概览

00:09:11.360 --> 00:09:15.040
基本层中的线程实际上是什么

00:09:15.040 --> 00:09:18.240
然后，当然，线程协议定义如下

00:09:18.240 --> 00:09:22.080
您实际上如何在同级之间交换记录

00:09:22.080 --> 00:09:25.519
嗯，你知道，嗯，哪些同伴可以做

00:09:25.519 --> 00:09:29.839
某些东西，嗯，像钉扎等等

00:09:29.839 --> 00:09:34.000
实际发生的数据交换需要使

00:09:34.000 --> 00:09:38.640
分布式网络工作嗯，有一些有趣的事情

00:09:38.640 --> 00:09:45.200
我们在开发线程中发现了um，您知道这是设计为可以运行的

00:09:45.200 --> 00:09:49.040
在对等的基础上，每个对等方都将运行一个线程守护程序

00:09:49.040 --> 00:09:52.480
哪种包装只是ipf或ipfs精简版

00:09:52.480 --> 00:09:56.880
交换数据和所有好东西的同伴

00:09:56.880 --> 00:10:00.160
嗯，但实际上我们也发现您知道人们也想要

00:10:00.160 --> 00:10:04.399
多租户系统，您基本上就像一个线程对等

00:10:04.399 --> 00:10:09.920
实际负责其他对等线程

00:10:09.920 --> 00:10:14.000
这样就呈现出了诸如此类的新设计决策

00:10:14.000 --> 00:10:17.760
最终在此基础上做些，我们可以谈谈

00:10:17.760 --> 00:10:21.440
关于这一点，因为那可能在

00:10:21.440 --> 00:10:26.160
与提出对等协议相比，实践更大的挑战

00:10:26.160 --> 00:10:29.839
这就像是对等的多租户使用

00:10:29.839 --> 00:10:32.079
协议，使事情变得更加棘手

00:10:32.079 --> 00:10:38.480
无论如何，所以我要从高层次的概述中停下来，并将其传递给

00:10:38.480 --> 00:10:41.200
可以更深入地谈谈其中一些内容的沙磨机

00:10:41.200 --> 00:10:44.880
就像我们围绕的关键设计决策

00:10:44.880 --> 00:10:48.880
像键之类的东西，但也

00:10:48.880 --> 00:10:53.040
如果有任何疑问，这是一个阻止我的好地方

00:10:53.040 --> 00:10:57.839
会问我是否可以跳进去，所以当你经历

00:10:57.839 --> 00:11:02.079
um服务键的用途

00:11:02.240 --> 00:11:06.240
您说过，这与确保有人可以复制有关

00:11:06.240 --> 00:11:09.920
结构，而无需看向另一个

00:11:09.920 --> 00:11:15.360
加密的主体，我知道那部分还可以，所以这和它有很大关系

00:11:15.360 --> 00:11:17.600
在哪里

00:11:17.839 --> 00:11:23.360
我猜是因为您担心数据存储块边界

00:11:23.360 --> 00:11:27.600
考虑到某些模型块进行复制

00:11:27.600 --> 00:11:32.560
是的，是的，我想我正在关注你

00:11:32.560 --> 00:11:36.320
好吧，也许这个问题只是一个系列

00:11:36.320 --> 00:11:41.760
的确认也许就是这样，听起来像是那些确认

00:11:41.760 --> 00:11:46.480
是的，没错，我的意思是说，所以钥匙就像那里有一个

00:11:46.480 --> 00:11:48.399
您可以使用的不同层

00:11:48.399 --> 00:11:52.959
特别是身体，所以事实上，水桶就是一个例子，我们可以

00:11:52.959 --> 00:11:55.519
稍后再说，就像是对

00:11:55.519 --> 00:11:59.760
进入身体的东西，但在某些情况下，身体会

00:11:59.760 --> 00:12:05.680
只是喜欢存储在ipfs上的东西的引用

00:12:05.680 --> 00:12:10.000
因此，真正进入该线程的是记帐

00:12:10.000 --> 00:12:16.240
像身体的顺序和结构更新，但是这些

00:12:16.240 --> 00:12:20.000
可能是您知道相当随意的事情

00:12:20.000 --> 00:12:23.440
以及不透明的东西

00:12:23.600 --> 00:12:29.839
那么如果其中的某些内容会发生什么

00:12:29.839 --> 00:12:34.079
主体区域，因此已加密到此密钥，即此处的紫色虚线

00:12:34.079 --> 00:12:38.480
嗯，如果内容很大，会发生什么

00:12:38.480 --> 00:12:42.000
像多个块一样，它超过了一个兆字节，或者是一些连接的

00:12:42.000 --> 00:12:47.440
结构um，如果是这样的话，我们

00:12:47.440 --> 00:12:51.440
如果很大，我们会让用户同时做这两种事情

00:12:51.440 --> 00:12:54.480
那么通常你就像cid一样存储

00:12:54.480 --> 00:12:58.079
引用大事物，然后存储大事物

00:12:58.079 --> 00:13:02.160
在ipfs中，然后并不重要

00:13:02.160 --> 00:13:06.240
就像任何种类的区块链东西一样，您将cid粘贴在其中存储

00:13:06.240 --> 00:13:09.279
另一件事是水桶把那东西包裹起来

00:13:09.279 --> 00:13:15.200
基本上可以处理um除非

00:13:15.279 --> 00:13:18.560
是的，抱歉，卡森打断了我要说的话

00:13:18.560 --> 00:13:22.079
也许有一个明显的区别就像blob数据与

00:13:22.079 --> 00:13:27.519
ipld数据，因为是的，在存储桶中没有意义

00:13:27.519 --> 00:13:34.720
存储像文件一样的数据，因为您不会

00:13:34.720 --> 00:13:38.000
或至少对于水桶没有合并

00:13:38.000 --> 00:13:44.480
在这一层没有像数据一样的blob分辨率，但是您可以想象一些

00:13:44.480 --> 00:13:48.639
具有兆字节应用程序的应用程序

00:13:48.639 --> 00:13:53.279
像分辨率这样有意义的数据

00:13:53.279 --> 00:13:57.120
在um上或实际跟踪该状态

00:13:57.120 --> 00:14:01.519
随着时间的流逝，但就像水桶一样，它只是文件而已

00:14:01.519 --> 00:14:04.800
没有没有像合并文件或

00:14:04.800 --> 00:14:10.959
这样的事情会发生，但是我想回答你的问题

00:14:10.959 --> 00:14:13.680
直接取决于应用程序

00:14:13.680 --> 00:14:20.320
应用程序来决定该主体如何拆分以及如何持久化

00:14:20.320 --> 00:14:23.440
所以我想我要澄清的是，如果您有

00:14:23.440 --> 00:14:28.560
复制密钥，也就是您将其提供给某人的服务密钥，因为

00:14:28.560 --> 00:14:33.839
您希望他们能够自信地复制线程和所有

00:14:33.839 --> 00:14:38.880
它的组成数据块，然后如果有任何复杂的

00:14:38.880 --> 00:14:42.560
该身体区域内部的大型或多块结构

00:14:42.560 --> 00:14:46.800
那么那是一个单独的责任，以找出这是怎么回事

00:14:46.800 --> 00:14:51.760
持久，是的，很酷，是的，这是有道理的

00:14:51.760 --> 00:14:54.560
合理边界

00:14:56.639 --> 00:15:00.240
嗯，我不知道您是否提到过早期的卡森，但只是为了

00:15:00.240 --> 00:15:04.480
阐明一个线程在技术上是一组

00:15:04.480 --> 00:15:11.040
这些单作者记录的是um，所以只是为了澄清一下

00:15:11.040 --> 00:15:14.320
我可能是唯一一个不听你说的人

00:15:14.320 --> 00:15:21.360
我使用术语集，但是是的，这更准确

00:15:21.360 --> 00:15:28.079
嗯，是的，您正在使用dag koze，这是您要使用的

00:15:28.079 --> 00:15:31.839
加密或您要标准化的区块

00:15:31.839 --> 00:15:34.560
格式正确，这是一个很大的问题，那就是

00:15:34.560 --> 00:15:37.279
桑德可以回答，因为有多个级别

00:15:37.279 --> 00:15:43.600
哦，是的，现在回到我们最初执行此操作时，

00:15:43.600 --> 00:15:47.519
那里没有没有

00:15:47.519 --> 00:15:53.519
所以这是以一种粗略的方式完成的，我们基本上只是

00:15:53.519 --> 00:15:59.360
每个对称地加密um，因此每个

00:15:59.360 --> 00:16:03.279
就像身体对称地加密一样

00:16:03.279 --> 00:16:08.000
因此该密钥只有一个基本的对称加密密钥

00:16:08.000 --> 00:16:11.279
以及um和read键以及

00:16:11.279 --> 00:16:18.639
代表，但这是我们希望改进的事情，它正在找出正确的方法

00:16:18.639 --> 00:16:26.160
也许这就是我们可以使用的类似ipld prime编解码器的功能

00:16:26.240 --> 00:16:29.759
因为遍历真的很麻烦

00:16:29.759 --> 00:16:35.360
像您需要的日志一样，您需要拥有正确的算法，知道自己需要

00:16:35.360 --> 00:16:38.480
基本上知道该怎么做，不是

00:16:38.480 --> 00:16:42.959
以任何有用的方式自我描述

00:16:42.959 --> 00:16:46.800
嗯，这是我们很久以来一直想做的事情

00:16:46.800 --> 00:16:50.720
我们只是没有足够的带宽来解决，好吧，真正的

00:16:50.720 --> 00:16:54.160
正确的最佳做法来做日志

00:16:54.160 --> 00:16:58.160
加密嗯，也许我们有一些东西

00:16:58.160 --> 00:17:02.320
可以想像的是

00:17:02.320 --> 00:17:08.160
ipld团队喜欢围绕这种多层设计的最佳实践

00:17:08.160 --> 00:17:10.720
加密

00:17:10.959 --> 00:17:15.679
使用其他同龄人可以理解的编解码器

00:17:15.679 --> 00:17:20.160
以一种可插入的方式，我认为现在可能可用

00:17:20.160 --> 00:17:25.360
我们还没有潜入的东西

00:17:27.839 --> 00:17:33.280
另一件事值得一提，所以卡森所说的开始

00:17:33.280 --> 00:17:37.520
线程是一种多层设置，我们在

00:17:37.520 --> 00:17:41.919
现在谈论的就像日志和记录的编排

00:17:41.919 --> 00:17:45.760
和同行之间的日志真的有点像我们最初的

00:17:45.760 --> 00:17:50.480
这样做的动机可能更容易从

00:17:50.480 --> 00:17:55.280
正在构建mongodb的顶部

00:17:55.280 --> 00:18:01.280
点对点数据库的类似接口

00:18:01.280 --> 00:18:05.919
因为这是我们与之合作时发现的一件事

00:18:05.919 --> 00:18:10.880
试图建立像新兴的web3堆栈的人们

00:18:10.880 --> 00:18:15.120
他们真的只想要一个他们了解的api

00:18:15.120 --> 00:18:21.440
嗯，像蒙哥（Mongo）这样的东西是人们的爱，所以我们试图

00:18:21.440 --> 00:18:26.559
模仿那个um，这就是我们着陆于此的地方

00:18:26.559 --> 00:18:34.240
基于日志的事件源架构，其中

00:18:34.400 --> 00:18:39.600
基本上是一个线程，是这些日志的集合

00:18:39.600 --> 00:18:43.360
代表您是否结合了所有这些技巧

00:18:43.360 --> 00:18:47.679
它们代表可以分解为的某种状态

00:18:47.679 --> 00:18:53.200
集合中的文档，因此就像您知道的一样

00:18:53.200 --> 00:18:57.840
想象一个待办事项应用程序或某个可以做的事情

00:18:57.840 --> 00:19:04.720
是一个日志中的文档，还是多个日志中的协作文档

00:19:04.720 --> 00:19:11.919
以便将这些日志解析为某种状态的方式留在

00:19:11.919 --> 00:19:16.320
卡森提到过的更高层，嗯

00:19:16.320 --> 00:19:22.080
在我们的threaddb设置中，我们称该集合或一个集合

00:19:22.080 --> 00:19:24.960
实例，这就是相似之处

00:19:24.960 --> 00:19:31.679
到漫画数据库开始，所以有点像，如果有帮助

00:19:31.679 --> 00:19:36.640
与此相关的一些背景和动机

00:19:37.760 --> 00:19:41.919
院长，你有一个问题吗，是的，就像你知道的一样

00:19:41.919 --> 00:19:45.360
试图更好地思考什么是什么

00:19:45.360 --> 00:19:52.720
呃，这是用户倾向于碰到的问题吗

00:19:52.720 --> 00:19:56.720
用户倾向于坚持体内的少量数据

00:19:56.720 --> 00:20:01.280
或喜欢，因为它，因为我认为它变得越来越像

00:20:01.280 --> 00:20:04.880
当您不能仅发送复制器密钥和线程时，操作会很复杂

00:20:04.880 --> 00:20:09.360
id并说请为我复制此内容，因为现在您还必须复制

00:20:09.360 --> 00:20:13.919
所有这些就像多余数据的清单一样，这些数据存在于其他地方

00:20:13.919 --> 00:20:18.880
是的，我是说大多数人只是与

00:20:18.880 --> 00:20:24.320
基于json的数据库层，因此它们是

00:20:24.320 --> 00:20:29.200
他们真的不能像json应用程序数据那样放任何东西

00:20:29.200 --> 00:20:36.799
进入这些身体，嗯，是的，我不到一兆字节

00:20:36.799 --> 00:20:41.760
确保这是通常的用例

00:20:41.760 --> 00:20:45.200
嗯，我们有一些像我们这样的重度用户之一

00:20:45.200 --> 00:20:52.400
他们有自己的种类的数据库

00:20:52.400 --> 00:20:58.480
这是基于crdt的，因为

00:20:58.480 --> 00:21:03.200
带有线程的盒子就是它基于json补丁

00:21:03.200 --> 00:21:08.159
嗯，它在处理复杂和

00:21:08.159 --> 00:21:15.919
嗯，对他们来说，他们插入了另一层

00:21:15.919 --> 00:21:22.240
但是，这是类似的事情，线程桶中的小数据是

00:21:22.240 --> 00:21:26.080
处理固定的抽象本质上就像

00:21:26.080 --> 00:21:30.640
用于Blob类型数据

00:21:30.640 --> 00:21:36.240
桶也可以，他们在桶世界中可以做到吗

00:21:36.240 --> 00:21:42.840
复制器会看到密钥，以便他们可以复制密钥

00:21:42.840 --> 00:21:49.039
他们看到的数据，他们看到的是复制器密钥

00:21:49.039 --> 00:21:53.200
和读取密钥，因为它们必须能够

00:21:53.200 --> 00:22:01.039
实际跟踪状态um，但我们实际上没有这个概念

00:22:01.039 --> 00:22:04.960
就像在那个意义上复制一个桶

00:22:04.960 --> 00:22:09.520
桶更像是嗯，您可以添加固定

00:22:09.520 --> 00:22:13.679
服务到一个水桶，否则你和我可以分享一个

00:22:13.679 --> 00:22:18.000
嗯，但是我们还没有

00:22:18.000 --> 00:22:23.600
将复制器功能提取到存储桶世界中

00:22:23.600 --> 00:22:26.480
因为是的，您确实需要查看读取键

00:22:26.480 --> 00:22:31.600
正确地固定水桶，所以没有

00:22:31.600 --> 00:22:34.799
这些不被认为是完整的

00:22:34.799 --> 00:22:40.640
像他们插科打like一样，它们的叶子可能无法分辨，嗯，是否

00:22:40.640 --> 00:22:42.320
在水桶中或其他东西

00:22:42.320 --> 00:22:49.039
在那个身体内，所以我想我们不应该尝试去思考

00:22:49.039 --> 00:22:52.880
这些东西太多了，作为一条路线的全套

00:22:52.880 --> 00:22:55.679
一直到树叶，有一个像

00:22:55.679 --> 00:22:59.760
离散边界，您可以跳出此边界和分辨率

00:22:59.760 --> 00:23:05.200
是您在api层或类似的工作上的责任，是的，是的

00:23:05.200 --> 00:23:09.679
我的意思是我们想了解您所描述的

00:23:09.679 --> 00:23:17.679
嗯，这是我们最初想要构建的东西

00:23:17.679 --> 00:23:22.080
尽管我们不得不想出像这样的加密方案

00:23:22.080 --> 00:23:25.919
嗯，因为那里真的没有东西

00:23:25.919 --> 00:23:30.960
是的，我想说的是，边界是更实际的

00:23:30.960 --> 00:23:37.679
比理论上要好，如果是基于编解码器的话

00:23:37.679 --> 00:23:40.880
其他同伴可以理解他们可以穿越

00:23:40.880 --> 00:23:45.200
他们不必像特定的螺纹墩那样

00:23:45.200 --> 00:23:49.840
令人惊讶的是，我们甚至聊了很多

00:23:49.840 --> 00:23:53.679
使存储桶不像基于文件的存储桶

00:23:53.679 --> 00:24:00.400
api并使其现在仅能理解通用ipld节点

00:24:00.400 --> 00:24:09.200
它基于unix fs api um，所以是一个存储桶

00:24:09.200 --> 00:24:13.200
你知道你是否正在操纵描述统一的dag

00:24:13.200 --> 00:24:16.720
 unix fs [音乐]

00:24:16.720 --> 00:24:22.080
结构或其他文件结构，无论您希望使用哪种结构

00:24:22.080 --> 00:24:25.760
如果那是更多的一部分，那将是非常好的。

00:24:25.760 --> 00:24:29.120
身体，然后您可以更具体地

00:24:29.120 --> 00:24:32.159
您想要复制器复制什么

00:24:32.159 --> 00:24:37.440
嗯，如果您愿意，它将像整个固定一样处理

00:24:37.440 --> 00:24:41.840
以及线程的复制

00:24:41.840 --> 00:24:46.279
所以更多的是本机的东西，而不是这两个不同的地方

00:24:46.279 --> 00:24:49.279
责任

00:24:52.080 --> 00:24:56.080
但是，是的，我的意思是仅仅出于上下文，我们发现

00:24:56.080 --> 00:25:00.000
那就是大多数人真正想要的东西

00:25:00.000 --> 00:25:06.480
易于使用的可变文件系统，您可以同步对等

00:25:06.480 --> 00:25:12.559
我们只是以某种方式将某些事情融合在一起，我们必须做到这一点

00:25:12.559 --> 00:25:18.000
可能，但是是的，愿景更像是一个完整的

00:25:18.000 --> 00:25:21.039
thing的东西

00:25:23.039 --> 00:25:29.679
是很有帮助的，是图形，完整的图形是

00:25:29.679 --> 00:25:33.039
加密那似乎是一点点的场景

00:25:33.039 --> 00:25:37.039
每当我们尝试进行加密时，

00:25:37.039 --> 00:25:40.159
有点使它变得如此复杂以至于很难

00:25:40.159 --> 00:25:43.440
越过那条线，你如何做得好，你在哪里

00:25:43.440 --> 00:25:46.960
把它们包起来，你在哪里暴露它们，你如何允许他们所有这些

00:25:46.960 --> 00:25:51.919
某种东西似乎确实是这里更难的问题之一

00:25:51.919 --> 00:25:57.520
尽管复杂性源于您不知道

00:25:57.520 --> 00:26:02.320
应用程序开发人员需要预先提出权利，例如是否存在限制

00:26:02.320 --> 00:26:05.120
您知道应用程序开发人员需要的子集

00:26:05.120 --> 00:26:11.120
那么这个问题就变得容易多了，是的，

00:26:11.120 --> 00:26:15.440
我们是从这开始的，我的意思是很难平衡

00:26:15.440 --> 00:26:19.840
你真正想看起来像什么，然后你眼前的是什么

00:26:19.840 --> 00:26:23.840
用户正在询问，而不是他们是否在询问您真正的事情

00:26:23.840 --> 00:26:26.799
想要建造，证明建造变得越来越困难

00:26:26.799 --> 00:26:29.039
他们

00:26:30.250 --> 00:26:33.760
[音乐]所以我可能有兴趣听一些

00:26:33.760 --> 00:26:39.039
关于um​​的更多信息，您说您正在放手

00:26:39.039 --> 00:26:43.840
乡亲，您会看到乡亲实际上是在做自己的建筑

00:26:43.840 --> 00:26:50.799
这个线程结构之上的um解决冲突算法

00:26:50.799 --> 00:26:54.240
我很想听听您从中获得的所有教训，就像

00:26:54.240 --> 00:26:58.480
怎么样了，这似乎是一个荒凉的地方

00:26:58.480 --> 00:27:05.200
就我所知，让代码很好繁殖吧

00:27:05.200 --> 00:27:12.320
我认为这是任何类型的UM，除非您认识其他人

00:27:12.320 --> 00:27:18.640
嗯，几乎所有正在执行此操作的类型都一样

00:27:18.640 --> 00:27:24.240
在这一层，是db层，我们也喜欢db

00:27:24.240 --> 00:27:29.600
 api我们也有编解码器的概念，您可以使用可插入编解码器，

00:27:29.600 --> 00:27:34.240
有几个团队已经做到了，然后我相信fleek已经

00:27:34.240 --> 00:27:42.080
实际上在上面做了一些类似uh document crdt的实现，但这是

00:27:42.080 --> 00:27:45.760
有点不同，因为这更像是嗯，甚至像

00:27:45.760 --> 00:27:49.520
删除层，它们就像运送数据一样，然后

00:27:49.520 --> 00:27:53.039
所有crdt的东西都发生在浏览器中

00:27:53.039 --> 00:27:56.559
分开的原因是因为已经有预先烘焙的库可以执行

00:27:56.559 --> 00:27:59.360
这些东西，所以实际上他们只是像分配一样使用线程

00:27:59.360 --> 00:28:02.159
机制，如果你知道我可能在喝酒

00:28:02.159 --> 00:28:04.399
他们到底在做什么，但是

00:28:04.399 --> 00:28:08.320
它有点像被移除的一层，但是任何一种类型都可以

00:28:08.320 --> 00:28:11.039
就像最接近我们的金属材料

00:28:11.039 --> 00:28:14.960
知道嗯，然后我们的信誉是

00:28:14.960 --> 00:28:22.240
就像db API的一种启发性crdt一样

00:28:22.240 --> 00:28:29.279
嗯，您知道我们喜欢推迟的每个冲刺都会变得更加出色

00:28:29.279 --> 00:28:35.039
crdt uh实施um

00:28:35.360 --> 00:28:38.880
恩，你知道这东西的本质，但是恩

00:28:38.880 --> 00:28:41.840
我们已经做了一些我们已经做了一些初步的研究来做这样的

00:28:41.840 --> 00:28:45.520
不透明的crdt操作，已经很漂亮了

00:28:45.520 --> 00:28:49.360
很有希望，但是嗯，从来没有绕过它

00:28:49.360 --> 00:28:53.440
投入生产，那就像完全ipld

00:28:53.440 --> 00:28:56.720
基于crdt的哈希

00:28:56.720 --> 00:29:02.000
结构类型的东西是的，任何类型都是特例，因为

00:29:02.000 --> 00:29:06.480
他们在这一点上做出了尽可能多的贡献

00:29:06.480 --> 00:29:11.520
就像过去六个月以来

00:29:11.520 --> 00:29:16.640
像同行之间的业务流程一样

00:29:16.640 --> 00:29:26.320
um性能增强，所以它们本质上就像

00:29:26.320 --> 00:29:34.720
在我们的团队中，您知道嗯，但我认为可能对乡亲们

00:29:34.720 --> 00:29:37.440
潜入并发展自己的冲突

00:29:37.440 --> 00:29:40.399
解决机制，这是您必须要使用的途径

00:29:40.399 --> 00:29:44.799
之所以采取这种做法，是因为我们并未真正发布宣传或进行任何宣传

00:29:44.799 --> 00:29:49.840
它与实际操作方法不同的文档

00:29:49.840 --> 00:29:54.000
嗯，我的意思是从这个想法开始，但是

00:29:54.000 --> 00:29:58.960
是的，再一次，是的，我的意思是基本上大多数人

00:29:58.960 --> 00:30:03.600
这很有趣，因为我们知道您构建了这样的线程

00:30:03.600 --> 00:30:07.200
你知道更高层次的协议来交流数据集

00:30:07.200 --> 00:30:11.840
同行之间的更新，然后我们建立了一个参考实现

00:30:11.840 --> 00:30:14.960
数据库之上，因为这就是我们所知道的人们想要的

00:30:14.960 --> 00:30:18.799
像这样的人很酷，这个数据库正是我真正想要的，所以我从不

00:30:18.799 --> 00:30:22.399
比任何伟大的东西都要低

00:30:22.399 --> 00:30:25.679
嗯，我们认为很好，您可以在所有不同的同龄人上运行它

00:30:25.679 --> 00:30:28.960
到处走走，他们真的很好，如果你跑了就更好了

00:30:28.960 --> 00:30:32.320
对我们来说，嗯，那么您知道我们就可以了

00:30:32.320 --> 00:30:37.840
我们将拥有中心，我们拥有像数据库api这样的仓库，现在又像一个大型仓库

00:30:37.840 --> 00:30:42.960
我们的大部分用户都像网关一样在使用

00:30:42.960 --> 00:30:51.120
与远程api上的线程进行交互，嗯，您知道那么就像

00:30:51.120 --> 00:30:56.080
集中式系统，在其下方有一堆类似分散的东西

00:30:56.080 --> 00:30:59.360
当然，这样做的好处是，如果他们随时改变主意，

00:30:59.360 --> 00:31:03.440
他们可以参加比赛并继续前进，这很重要

00:31:03.440 --> 00:31:06.559
但您知道我们越容易做出更多的腹肌

00:31:06.559 --> 00:31:09.519
我们越是抽象化我们构建的东西，越多的人只想使用

00:31:09.519 --> 00:31:13.120
抽象，所以这就是为什么我认为

00:31:13.120 --> 00:31:18.720
建立琼柯达相当不受欢迎，我认为这也有帮助

00:31:18.720 --> 00:31:22.000
就像当您在顶部构建事物时

00:31:22.000 --> 00:31:25.760
您还对第一件事有更多了解

00:31:25.760 --> 00:31:30.320
这个东西比你写的时候有用，这意味着像是

00:31:30.320 --> 00:31:34.000
更好一些，因为它是抽象，所以更好，更容易使用

00:31:34.000 --> 00:31:35.679
层，其中一些只是因为您

00:31:35.679 --> 00:31:41.200
肯定比您上次更了解底层是的，可以肯定

00:31:41.200 --> 00:31:44.640
是的，嗯

00:31:45.039 --> 00:31:48.480
这就是现在任何类型的情况

00:31:48.480 --> 00:31:52.080
这可能是他们对线程协议的了解也比或更好。

00:31:52.080 --> 00:31:54.399
我们的确是

00:31:55.120 --> 00:31:59.120
是的，他们推动的力度超过了我们的实际承受能力

00:31:59.120 --> 00:32:04.320
嗯，正在寻找

00:32:06.080 --> 00:32:10.559
是的，只是在编排方面需要改进的地方

00:32:10.559 --> 00:32:14.320
例如按对等对更新分组，他们做了很多这类工作

00:32:14.320 --> 00:32:22.240
已经是um批处理更新，并且基本上像推送一样

00:32:22.240 --> 00:32:26.840
推动您可以通过特定码头获得多少吞吐量

00:32:26.840 --> 00:32:33.919
嗯，实际上它确实对事物进行了优先排序抱歉，是的，他们做了一些有趣的事情

00:32:33.919 --> 00:32:39.360
诸如跟踪线程头之类的东西，有点像哈希

00:32:39.360 --> 00:32:41.760
基于，因此您可以立即查看是否在

00:32:41.760 --> 00:32:46.640
是否与给定线程中的其他同级同步，并决定

00:32:46.640 --> 00:32:49.679
如果您需要从另一个请求更新，请快速

00:32:49.679 --> 00:32:55.039
同行，这是一件非常令人兴奋的事情

00:32:55.200 --> 00:33:01.840
是的，不，我是说对不起，对不起，继续前进罗恩，我只是想知道我们是否可以

00:33:01.840 --> 00:33:05.279
谈谈我们现在不必这样做，但我只想让它有兴趣转向

00:33:05.279 --> 00:33:09.279
um视图实现方面

00:33:09.279 --> 00:33:12.960
以及实用性和性能，以及

00:33:12.960 --> 00:33:16.000
是否将所有此类内容都缓存在哪里？

00:33:16.000 --> 00:33:19.440
工作嗯，这似乎是一个有趣的部分

00:33:19.440 --> 00:33:21.760
之所以这样，是因为随着时间的流逝，您似乎确实知道了

00:33:21.760 --> 00:33:26.720
这些事情将变得越来越大而混乱，您如何处理

00:33:26.720 --> 00:33:29.679
随着时间的推移而变得复杂

00:33:30.000 --> 00:33:36.000
嗯，我可以接受，我会说些什么，然后圣诞老人，您可以纠正我

00:33:36.000 --> 00:33:40.000
是的，这是一件很有趣的事情，基本上绝对可以缓存

00:33:40.000 --> 00:33:43.440
嗯，实际上在我们的参考实现中

00:33:43.440 --> 00:33:49.200
同行，基本上只是不断地实现对

00:33:49.200 --> 00:33:55.200
每次更新并保持参考状态

00:33:55.200 --> 00:34:00.480
实际上很少重建整个历史

00:34:00.720 --> 00:34:04.159
出于性能原因仅出于理想

00:34:04.159 --> 00:34:07.679
在白皮书中，我们提到了快照的

00:34:07.679 --> 00:34:10.879
这样您就可以对状态进行实际快照

00:34:10.879 --> 00:34:15.520
一些类似于确定性间隔um的线程中的所有对等体

00:34:15.520 --> 00:34:18.720
会有效地像是同意，以便他们全都到达同一地点

00:34:18.720 --> 00:34:23.839
同时拍摄快照，我们尚未实施该快照，因为

00:34:23.839 --> 00:34:27.520
所有同龄人都在有效地进行缓存

00:34:27.520 --> 00:34:31.760
是给我们的，但是嗯，就像

00:34:31.760 --> 00:34:34.800
更为有用，因为那样或那样会构成一个真正的快照框架

00:34:34.800 --> 00:34:36.960
有用，因为那时，同龄人基本上可以

00:34:36.960 --> 00:34:40.079
像以前的快照状态一样水合

00:34:40.079 --> 00:34:45.040
之前从未与线程交互过

00:34:45.040 --> 00:34:48.159
然后对诸如此类的东西要好得多

00:34:48.159 --> 00:34:51.200
受限的环境（例如浏览器）

00:34:51.200 --> 00:34:54.960
你知道保持大约六个月的更新可能甚至没有

00:34:54.960 --> 00:34:59.599
可能是因为您的浏览器缓存可能

00:34:59.599 --> 00:35:04.560
放下它，嗯，这些就像敌对的环境一样

00:35:04.560 --> 00:35:10.560
有点像你知道他们从嗯中受益

00:35:10.560 --> 00:35:15.119
快照之类的东西，但是，所以我们在

00:35:15.119 --> 00:35:18.480
但是我们没有实现

00:35:19.520 --> 00:35:22.800
那很酷，因为我觉得那主要是在哪里

00:35:22.800 --> 00:35:28.640
像土地一样的人倾向于喜欢弄清楚还是倒塌是

00:35:28.640 --> 00:35:31.280
如果你不开始垃圾收集

00:35:31.280 --> 00:35:36.240
您知道八个月大的更新，然后喜欢

00:35:36.240 --> 00:35:41.599
就像停止正确工作一样

00:35:42.400 --> 00:35:46.400
不，虽然正确，但完全可行，如果知道acl，线程就会知道

00:35:46.400 --> 00:35:51.040
在一段时间内的所有同龄人

00:35:51.040 --> 00:35:54.720
一部分同s签署了此更新，您可以说这是因为

00:35:54.720 --> 00:35:57.680
他们拥有指向正确位置的所有哈希值

00:35:57.680 --> 00:36:02.079
就像它非常可行，只是需要时间

00:36:02.079 --> 00:36:06.320
做这些事情是的，很难做到正确

00:36:06.320 --> 00:36:09.839
是的，我认为实际上我们有一个

00:36:09.839 --> 00:36:14.880
开始了任何形式的更正式的开发，这是一件事

00:36:14.880 --> 00:36:20.960
他们将开始就像做快照的多信号方式

00:36:21.680 --> 00:36:25.440
然后是的，你可以利用这个机会

00:36:25.440 --> 00:36:29.200
进行关键轮换和其他需要达成共识的事情

00:36:29.200 --> 00:36:35.119
在线程上，是的，您真的撞到了

00:36:35.119 --> 00:36:38.400
基本上是那时的区块链，您必须对此达成共识

00:36:38.400 --> 00:36:42.560
特定时间点的快照

00:36:46.320 --> 00:36:49.520
虽然有作弊代码，但可以使您达成共识

00:36:49.520 --> 00:36:54.880
对，因为你可以说就像这是你被允许的叉子

00:36:54.880 --> 00:36:59.440
在闲暇时跟随叉子，你可以看到有多少人跟随

00:36:59.440 --> 00:37:05.760
是的，叉子绝对是的

00:37:05.760 --> 00:37:12.800
这是我们关于如何做这种事情的最初想法

00:37:12.800 --> 00:37:16.960
是这个吗，只是不断地叉有一个ACL是

00:37:16.960 --> 00:37:22.960
不可变与线程ID相关联，如果您想

00:37:22.960 --> 00:37:28.160
您只需将其派生到线程ID中即可进行修改

00:37:28.160 --> 00:37:38.400
人们可以遵循的规则有新规则，但这也有缺点

00:37:38.400 --> 00:37:43.680
不得不跟踪多件事很烦人

00:37:44.160 --> 00:37:47.680
在此之上还有一些作弊代码，即使这就像

00:37:47.680 --> 00:37:54.800
在线程上，您可以不必使用叉子

00:37:54.800 --> 00:37:57.599
更改线程ID，因为实际上您需要进行分叉

00:37:57.599 --> 00:38:02.480
就像是一组新的钥匙，所以您可以

00:38:02.480 --> 00:38:04.560
有就是你可以有一群人，好吧，我们

00:38:04.560 --> 00:38:08.079
现在要使用这些密钥以及其他不同意的人

00:38:08.079 --> 00:38:11.520
使用这些键可以继续尝试写入线程，但我们都会拒绝

00:38:11.520 --> 00:38:13.680
这些更新，您将无法阅读我们的

00:38:13.680 --> 00:38:16.480
因此更新

00:38:18.720 --> 00:38:22.000
这样您就可以像模拟那样

00:38:22.000 --> 00:38:28.320
线程也以这种方式分叉，所以只说一点细节

00:38:28.320 --> 00:38:31.520
像查看实现一样

00:38:31.520 --> 00:38:37.520
目前有效，所以实现发生在

00:38:37.520 --> 00:38:42.720
应用程序层，我们在代码库中将其称为

00:38:42.880 --> 00:38:50.160
线程可以连接一个应用程序，以便它

00:38:50.160 --> 00:38:55.760
当日志进入时，记录进入日志中或新日志到达时

00:38:55.760 --> 00:39:00.079
验证可以推送到应用程序层，而应用程序层可以

00:39:00.079 --> 00:39:07.520
根据它可以决定的规则

00:39:07.520 --> 00:39:14.079
如果是的话，它将处理物化

00:39:14.400 --> 00:39:17.680
所以有点像双向桥

00:39:17.680 --> 00:39:22.240
在应用程序层和网络层之间

00:39:22.240 --> 00:39:26.079
而当玩家决定可以的时候，这就是新状态

00:39:26.079 --> 00:39:31.520
只是我们只是在转储json而已，所以目前所有json都在

00:39:31.520 --> 00:39:35.839
应用层嗯，我们只是将其转储到呃

00:39:35.839 --> 00:39:42.480
转到数据存储区，然后可以像读取数据一样读取

00:39:42.480 --> 00:39:46.160
蒙哥感觉API

00:39:47.440 --> 00:39:51.200
并且只是为了澄清目前没有办法

00:39:51.200 --> 00:39:55.440
您可以加入一个线程，而不必从一开始就追赶

00:39:55.440 --> 00:39:59.520
所以目前，如果您要连接到线程，则必须

00:39:59.520 --> 00:40:03.280
重播全部内容以适应

00:40:03.280 --> 00:40:06.000
是的，是的

00:40:07.119 --> 00:40:10.560
是的，所以这是很多人使用的另一个原因

00:40:10.560 --> 00:40:15.359
像集线器或其他运行中的对等点是，他们可以

00:40:15.359 --> 00:40:18.400
他们可以有一些像半参与的同龄人

00:40:18.400 --> 00:40:21.680
因此您有一个可查询中心的网络应用

00:40:21.680 --> 00:40:27.760
就像当前状态一样，然后像推送更新一样添加到该状态，即

00:40:27.760 --> 00:40:30.800
为了避免这种情况

00:40:31.599 --> 00:40:35.520
没错，是的，我是说您再次拥有区块链

00:40:35.520 --> 00:40:42.480
轻节点和完整节点100是的，是的，这很公平

00:40:42.480 --> 00:40:45.599
听起来确实很难解决，但是

00:40:45.599 --> 00:40:52.480
这不是解决不了的权利，这些实际上有多大

00:40:52.480 --> 00:40:54.400
这些越来越像是人

00:40:54.400 --> 00:40:57.280
在此基础上构建非常庞大的数据集

00:40:57.280 --> 00:41:03.359
很好，再次使用了这个um fleek，任何类型的我们

00:41:03.359 --> 00:41:08.160
最大的用户，这样

00:41:08.160 --> 00:41:13.119
他们不熟悉的任何类型的模型就像

00:41:13.119 --> 00:41:20.319
基于概念的应用程序或概念样式的应用程序，以使其建模的方式

00:41:20.319 --> 00:41:24.400
是概念上的每个数据库说话还是每个

00:41:24.400 --> 00:41:29.680
每个页面都有自己的线程，因此在那里发生的任何更新

00:41:29.680 --> 00:41:35.280
嗯，进入那个线程，你可以想象你知道成千上万的

00:41:35.280 --> 00:41:40.800
编辑很容易发生，人们可以

00:41:40.800 --> 00:41:45.920
几百个，我想他们甚至说有些人喜欢上千个

00:41:45.920 --> 00:41:51.200
线程，所以这些东西变成了它

00:41:51.200 --> 00:41:54.720
挑战很快变成

00:41:55.040 --> 00:42:00.640
向同伴推送更新，这变得非常

00:42:00.640 --> 00:42:04.480
如果你总是做密集的繁重的事情

00:42:04.480 --> 00:42:11.119
必须询问同伴并接收更新以及多个线程和um

00:42:11.119 --> 00:42:16.079
特别是在多租户设置中，它变得非常繁琐

00:42:16.079 --> 00:42:21.280
嗯，这就是我们开始进行范围界定的方法，例如如何分解

00:42:21.280 --> 00:42:26.160
多租户节点成多个

00:42:26.160 --> 00:42:34.720
嗯，就像很多不同的过程一样，因为我猜

00:42:34.720 --> 00:42:40.560
抱歉，不要继续，我只是这个问题

00:42:40.560 --> 00:42:44.640
组织，所以我想在某个时候可以选择

00:42:44.640 --> 00:42:51.040
装入一个线程要多少钱，而不是像您这样拥有单独的线程

00:42:51.040 --> 00:42:54.480
可以像任何类型的东西一样管理

00:42:54.480 --> 00:42:57.760
大概在一个线程中只是更新所有内容

00:42:57.760 --> 00:43:01.920
在这些海量文件中，但是嗯，那么他们必须让你知道

00:43:01.920 --> 00:43:06.400
成千上万的线程有没有任何意义

00:43:06.400 --> 00:43:10.000
嵌套线程是否可以在其中跟踪线程？

00:43:10.000 --> 00:43:12.960
线程还是有更好的机制

00:43:12.960 --> 00:43:16.800
跟踪喜欢或做的线程数

00:43:16.800 --> 00:43:20.000
应用程序的关注点取决于您想要的灵活性

00:43:20.000 --> 00:43:25.200
我认为它总是归结为事实

00:43:25.200 --> 00:43:29.680
没有隐私

00:43:29.680 --> 00:43:32.880
所以一个线程是，如果你有一个线程的钥匙

00:43:32.880 --> 00:43:38.160
那么您就拥有了线程的键，因此通常应用程序决策是

00:43:38.160 --> 00:43:42.319
就像我想要分享的东西一样

00:43:42.319 --> 00:43:46.319
还有我想保密的东西，所以如果你只有一个线程

00:43:46.319 --> 00:43:50.960
对于每个用户，他们将所有东西都放在那里

00:43:50.960 --> 00:43:56.000
那么它要么是公共的，要么是私有的，所以它变得像

00:43:56.000 --> 00:43:59.280
您如何在构想上建立某些东西

00:43:59.280 --> 00:44:04.720
创建一个小页面并共享，只要您知道该页面的一部分即可；或者

00:44:04.720 --> 00:44:10.880
你知道，人们总是想要像他们想做的

00:44:10.880 --> 00:44:16.160
Google文档样式，例如与特定人员共享或

00:44:16.160 --> 00:44:19.359
仅共享有权访问该链接的人，并且

00:44:19.359 --> 00:44:27.520
恩，我希望

00:44:27.520 --> 00:44:30.960
您知道我认为有一些方法可以使线程更灵活，以便它们可以

00:44:30.960 --> 00:44:36.560
处理嗯，他们不必如此，所以我猜

00:44:36.560 --> 00:44:40.079
备份，所以有两种方法可以处理这个问题

00:44:40.079 --> 00:44:45.520
使用更细的acl，然后您必须处理类似的密钥

00:44:45.520 --> 00:44:50.480
轮换更频繁，或者您只需轮换

00:44:50.480 --> 00:44:53.680
拥有一个线程很便宜，这是我们的一种途径

00:44:53.680 --> 00:44:57.119
现在进行探索，就好像没有理由你不会拥有一百万

00:44:57.119 --> 00:45:01.760
节点上的线程数量下降的情况更多

00:45:01.760 --> 00:45:05.839
下来想保持一个线程有多昂贵

00:45:05.839 --> 00:45:12.720
迄今为止，基本编排日志的成本是多少

00:45:12.800 --> 00:45:16.960
这就是我们的近期目标是围绕这些事情进行扩展

00:45:16.960 --> 00:45:22.240
是为了使它不关心您有多少个线程

00:45:22.240 --> 00:45:27.440
不，你并没有超越某些机器边界

00:45:27.440 --> 00:45:31.359
例如您的cpu或资源边界与数字

00:45:31.359 --> 00:45:36.720
是的，因为实际上一个线程是

00:45:36.720 --> 00:45:40.480
一组键就好像没有太多

00:45:40.480 --> 00:45:44.160
而不是按键，还有更多类似的东西需要跟踪

00:45:44.160 --> 00:45:49.599
跟踪像纯正的广告地址和东西一样，但是就像

00:45:49.599 --> 00:45:53.839
拥有另一个类似的线程，它们引用了很多相同的东西

00:45:53.839 --> 00:45:56.800
数据基本上就像创建一个

00:45:56.800 --> 00:46:01.520
几个随机密钥，那么昂贵就变成了

00:46:01.520 --> 00:46:04.640
编排这些内容，如果可以的话

00:46:04.640 --> 00:46:08.000
您可以使用线程进行智能处理的方法，因为您有很多

00:46:08.000 --> 00:46:11.359
就像您拥有一个社交网络，您的同龄人一样

00:46:11.359 --> 00:46:14.240
与之互动，因此您可以，您可以接受

00:46:14.240 --> 00:46:19.200
优势，如你所愿传播

00:46:19.200 --> 00:46:23.520
同步算法，然后变得像oh yeah一样便宜很多

00:46:23.520 --> 00:46:26.319
如果您想将某项范围限定为键，则使其成为线程

00:46:26.319 --> 00:46:30.960
只是使它成为线程是的，这就是我们所处的位置

00:46:30.960 --> 00:46:36.000
我想尝试向前迈进

00:46:36.000 --> 00:46:38.880
这些关于您在何处划分事物的架构选择

00:46:38.880 --> 00:46:41.760
您如何构造事物最终会成为一个问题

00:46:41.760 --> 00:46:44.960
用户最终是否不得不处理许多此类架构

00:46:44.960 --> 00:46:49.040
关于他们如何构造对这些事物的使用的疑问，或者您是

00:46:49.040 --> 00:46:52.800
发现很多用例都很明显

00:46:52.960 --> 00:47:00.560
嗯，我认为这是一个很好的问题，我想您知道我们的大多数用户

00:47:00.560 --> 00:47:04.800
通过数据库api与线程进行交互，然后通过

00:47:04.800 --> 00:47:08.960
问题就像我将如何构造数据一样，它们将是同样的问题

00:47:08.960 --> 00:47:12.240
会问一个mongodb之类的，我应该有多少个收藏

00:47:12.240 --> 00:47:16.400
这些收藏集应该看起来像um吗，我可以参考一个吗？

00:47:16.400 --> 00:47:19.680
另一个收集类型中的收集类型，例如那些建筑类型

00:47:19.680 --> 00:47:23.760
我们没有得到的问题，例如我应该如何使用

00:47:23.760 --> 00:47:28.640
因为我们没有那么多用户，所以经常处理协议问题

00:47:28.640 --> 00:47:33.359
在这个水平上进行互动，但我们确实有像任何类型的人

00:47:33.359 --> 00:47:37.520
他们回到我们身边，基本上说我们正在使用这样的线程

00:47:37.520 --> 00:47:41.680
如果对我们来说使用这样的线程会更容易

00:47:41.680 --> 00:47:44.800
我们看了看，说是的，这是个好主意

00:47:44.800 --> 00:47:50.160
嗯，我们应该尝试这样做，所以您知道这就像在哪里

00:47:50.160 --> 00:47:53.440
人们进来，但在大多数情况下

00:47:53.440 --> 00:47:58.240
javascript SDK和我最喜欢的问题

00:47:58.240 --> 00:48:02.559
在mongodb工作的人会回答同样的问题

00:48:02.559 --> 00:48:05.680
也许有点不同，因为我们在谈论分布式系统

00:48:05.680 --> 00:48:10.800
但是，然后您知道我试图说我们试图做的很好

00:48:10.800 --> 00:48:14.800
你知道现在线程不是那么便宜

00:48:14.800 --> 00:48:19.599
因此，您可能希望将更多收藏夹放入线程中

00:48:19.599 --> 00:48:23.359
或者您可能希望让一个用户负责这些收藏，并且

00:48:23.359 --> 00:48:26.160
您知道一个用户b可以执行某些操作，但最后

00:48:26.160 --> 00:48:30.880
一天更多的是关于如何为我的数据库构建数据库

00:48:30.880 --> 00:48:36.400
应用程序然后我如何优化线程

00:48:36.400 --> 00:48:40.480
人们是否更关注线程的深度

00:48:40.480 --> 00:48:45.520
或喜欢或通过线程的吞吐量

00:48:45.599 --> 00:48:49.680
这是一个有趣的问题，可能是一样的

00:48:49.680 --> 00:48:51.920
因为如果您知道您的吞吐量很高，并且将其放置一会儿

00:48:51.920 --> 00:48:57.280
虽然那真的很深，但是是的，我认为这是正确的

00:48:57.359 --> 00:49:02.559
是的，我认为他们俩是同一个人

00:49:02.559 --> 00:49:09.200
我们所有人都是如此，快照内容绝对是我们的阻碍

00:49:09.200 --> 00:49:15.359
嗯，看到像的那一刻

00:49:15.359 --> 00:49:20.079
是的，让人们真正打开他们的水闸

00:49:23.280 --> 00:49:26.800
这是与此分开的

00:49:26.800 --> 00:49:30.800
这是一个更大的问题还是与我尝试的相同或不同的问题

00:49:30.800 --> 00:49:34.720
一次运行这么多线程

00:49:35.119 --> 00:49:38.720
好吧，我认为他们实际上是分开的

00:49:38.720 --> 00:49:45.839
因为后者更多是关于以下事实：

00:49:45.839 --> 00:49:52.720
编排基于线程，因此它尝试同步线程

00:49:52.720 --> 00:49:59.200
与尝试在共享线程的同级之间同步更新

00:49:59.200 --> 00:50:03.040
有了这个意义，我们已经做了一些工作

00:50:03.040 --> 00:50:07.920
在这个方向上已经像每个对等的批处理更新

00:50:07.920 --> 00:50:14.720
您正在跨线程交谈，并且喜欢提示

00:50:14.720 --> 00:50:18.000
以及所有您可以想象的东西

00:50:18.000 --> 00:50:21.599
作为改进[音乐]

00:50:21.599 --> 00:50:25.760
但是目前它仍然有点像线程，所以在那里

00:50:25.760 --> 00:50:29.599
具有多个线程的某些昂贵性来自于它

00:50:29.599 --> 00:50:34.800
只是每个线程都增加了一些乘数，就像

00:50:34.800 --> 00:50:38.240
ter不休，你的笔记是

00:50:38.559 --> 00:50:44.559
不管以何种方式在这些线程中有多少对等端

00:50:44.559 --> 00:50:49.680
是的，应该更多

00:50:49.680 --> 00:50:53.760
与更多同龄人交流的成本很高

00:50:53.760 --> 00:50:57.839
像你知道多少个线程

00:50:57.839 --> 00:51:01.440
事后看来很明显，但这就是我们

00:51:01.440 --> 00:51:04.880
我们最初的实施

00:51:04.960 --> 00:51:09.359
是的，我的意思是，这是实现细节，而不是

00:51:09.359 --> 00:51:16.319
是的，就像实际的问题一样，但是很容易地说

00:51:17.359 --> 00:51:20.960
正确的，我有更多的东西

00:51:20.960 --> 00:51:23.599
我知道我们正在跑步，我们正在与时间赛跑，这里还有更多

00:51:23.599 --> 00:51:28.000
我想要涵盖的事物，并希望确保其他事物包括

00:51:28.000 --> 00:51:31.599
迈克尔现在嗯，还有他们的机会之一是我们

00:51:31.599 --> 00:51:33.760
并没有真正涉及到水桶

00:51:33.760 --> 00:51:38.880
和ii只是没有任何东西，我在这里没有很多关于水桶的心理映射

00:51:38.880 --> 00:51:42.559
除此之外，所有其他都是unix fs表示形式，例如

00:51:42.559 --> 00:51:45.760
这是大的物化的统一

00:51:45.760 --> 00:51:49.359
集合um与线程的关系是什么

00:51:49.359 --> 00:51:53.599
你在做什么，就像在存储pb一样

00:51:53.599 --> 00:51:56.160
这些事情，或者您在做其他可以做的事情

00:51:56.160 --> 00:52:00.800
从线程模型中实现unix fs或有什么关系

00:52:00.800 --> 00:52:02.960
究竟是什么桶，它们是什么

00:52:02.960 --> 00:52:05.839
与线程的关系

00:52:06.319 --> 00:52:13.599
是的，因此存储桶是基于线程构建的，因为它的根

00:52:13.599 --> 00:52:19.920
unix fs dag在一个线程中进行跟踪，这实际上就是它的所在

00:52:19.920 --> 00:52:24.400
结束um，除非您获得复制

00:52:24.400 --> 00:52:28.480
您知道的片段减去该线程的固定历史

00:52:28.480 --> 00:52:33.359
可以使用

00:52:33.359 --> 00:52:36.240
螺纹结构

00:52:36.559 --> 00:52:39.680
但除此之外，您还可以想象建造水桶

00:52:39.680 --> 00:52:46.319
没有威胁历史记录跟踪um

00:52:46.319 --> 00:52:49.520
因为是的，存储桶的架构是

00:52:49.520 --> 00:52:56.240
基本上只是一个条目，再加上一些我们跟踪的元数据

00:52:56.240 --> 00:53:01.680
有关存储桶中路径um的元数据，例如您可以添加

00:53:01.680 --> 00:53:05.760
路径um的任何应用程序元数据

00:53:05.760 --> 00:53:08.880
加密密钥，这是另一回事

00:53:08.880 --> 00:53:13.839
因此，unix只是专门讨论存储桶

00:53:13.839 --> 00:53:19.200
这是一个具有内置加密功能的UNIX fs dag

00:53:19.200 --> 00:53:25.839
基于路径的加密um是全节点加密，因此我们正在加密

00:53:25.839 --> 00:53:32.079
该dag unix fps标记中的每个节点都是多键的，因此我可以共享

00:53:32.079 --> 00:53:38.000
与您在Unix fs标签中的一个文件

00:53:38.000 --> 00:53:42.640
这样您就可以通过该结构进行加密

00:53:42.640 --> 00:53:47.839
并加密我要与您共享的叶子文件

00:53:47.839 --> 00:53:51.599
里面有一个ACL，它也是它的一部分

00:53:51.599 --> 00:53:54.480
线程架构

00:53:55.520 --> 00:53:59.119
所以就像在unix fs上加糖一样

00:53:59.119 --> 00:54:04.640
基本上就是一个水桶，然后像它与一个水桶的关系一样进行回顾

00:54:04.640 --> 00:54:09.040
线程是跟踪的架构

00:54:09.040 --> 00:54:15.760
在线程中，它可以像

00:54:15.760 --> 00:54:21.200
基本上，所以如果卡森和我

00:54:21.200 --> 00:54:29.040
共享一个桶对等，然后我将通过接收更新

00:54:29.040 --> 00:54:35.839
通过他通过该哈希在存储桶中进行的更改的线程

00:54:35.839 --> 00:54:39.359
如果我想更改或有关路径更改的元数据

00:54:39.359 --> 00:54:41.680
实际得到那些文件，我必须将其从

00:54:41.680 --> 00:54:44.720
ipfs网络

00:54:45.119 --> 00:54:50.559
因此存储桶守护程序在文件级别处理固定

00:54:50.880 --> 00:54:55.920
然后是关于水桶的其他事情，例如我们暴露一个ipns

00:54:55.920 --> 00:55:00.240
可以找到最新版本的密钥

00:55:00.240 --> 00:55:07.119
嗯，我们有一个，我们构建了一个固定api，可让您

00:55:07.119 --> 00:55:12.480
在标准固定规范上与存储桶进行交互

00:55:12.480 --> 00:55:16.160
嗯，是的，就像糖在上面一样

00:55:16.160 --> 00:55:22.640
unix fs基本上是熟悉s3或其他类似软件的人

00:55:22.640 --> 00:55:27.440
对象存储他们想要的东西

00:55:27.440 --> 00:55:32.240
当他们开始使用unix fs时立即

00:55:33.520 --> 00:55:37.359
对，所以基本上这是人们为所有事物添加的unix fs值

00:55:37.359 --> 00:55:42.880
确实要在实际使用中是的，是的，是的

00:55:43.280 --> 00:55:47.200
是的，我想要的另一件事是我只是想快速

00:55:47.200 --> 00:55:53.280
触及的是您的路线图或您对优先事项的感觉

00:55:53.280 --> 00:55:55.680
听起来像是用于线程的开发

00:55:55.680 --> 00:55:58.960
快照很重要，因为它们确实还有其他功能

00:55:58.960 --> 00:56:04.480
感到迫切需要继续工作，所以

00:56:04.480 --> 00:56:09.760
嗯，我们今天和明天实际上在做些路

00:56:09.760 --> 00:56:14.480
在内部围绕线程进行映射和计划只是为了找出答案

00:56:14.480 --> 00:56:20.079
它适合我们的堆栈

00:56:20.079 --> 00:56:24.400
我们谈论的一件事就是切断数据库层，

00:56:24.400 --> 00:56:30.160
更多地关注网络层，因为

00:56:30.160 --> 00:56:34.480
我们经常遇到的是人们要求

00:56:34.480 --> 00:56:39.680
有点像复杂的数据库之类的东西，嘿，我该怎么做自定义索引

00:56:39.680 --> 00:56:42.079
就像我们提供了非常基本的索引

00:56:42.079 --> 00:56:46.559
机制，但如果人们想做习惯或

00:56:46.559 --> 00:56:52.079
复合索引或类似的聚合器或任何种类的类似复合体

00:56:52.079 --> 00:56:57.680
数据库东西被烘焙成诸如postgres之类的东西

00:56:57.680 --> 00:57:02.880
几十年的发展，就像我们从来没有我们永远不会去

00:57:02.880 --> 00:57:10.000
做到实际上您就知道，所以我们认为有一种方法可以

00:57:10.000 --> 00:57:12.720
并可能创建更高级的连接器

00:57:12.720 --> 00:57:16.640
通过更多地关注网络层来访问数据库

00:57:16.640 --> 00:57:21.680
如此紧密地关系只是这个线程结构

00:57:21.680 --> 00:57:25.359
这是另一件是我们感动的东西

00:57:25.359 --> 00:57:31.760
就像您如何使线程便宜

00:57:31.760 --> 00:57:35.280
这样人们在设计自己的产品时就不必担心

00:57:35.280 --> 00:57:37.200
他们不必思考的应用程序

00:57:37.200 --> 00:57:41.119
好的，我只希望每个用户拥有10个线程

00:57:41.119 --> 00:57:45.040
诸如此类的东西摆脱了这种限制

00:57:45.040 --> 00:57:51.440
嗯，这是我们需要的任何类型的东西

00:57:51.440 --> 00:57:56.559
大量的用户，然后是最后一种

00:57:56.559 --> 00:58:00.079
优先事项很好，我不会说其他优先事项中的最后一个

00:58:00.079 --> 00:58:06.319
是多租户设置，以便人们可以使用

00:58:06.319 --> 00:58:10.799
线程的复制部分更有效

00:58:10.799 --> 00:58:18.000
这有点像基本的um分解一个线程节点

00:58:18.000 --> 00:58:25.040
分为多个职责，然后基本上

00:58:25.040 --> 00:58:30.640
多租户层的编排机制规模

00:58:30.640 --> 00:58:35.760
然后我会说我想到的最后一个

00:58:35.760 --> 00:58:42.319
卡森可能以任何方式转变，但正在重做我们的这种加密方法

00:58:42.319 --> 00:58:45.280
设置并尽力做到最好

00:58:45.280 --> 00:58:49.599
考虑到所有正在进行的开发，请练习ipl d方式

00:58:49.599 --> 00:58:54.559
自从我们最初做这个um以来，那真是太神奇了，这是

00:58:54.559 --> 00:58:57.119
我曾经谈论过的卡森，如果有的话

00:58:57.119 --> 00:59:01.760
只是一个您可以用来附加的库

00:59:01.760 --> 00:59:06.720
登录ipld，然后您就可以烘烤了

00:59:06.720 --> 00:59:12.000
加密，就像多层一样

00:59:12.000 --> 00:59:16.160
加密，如果您想我的意思是基本上您是从属地知道的

00:59:16.160 --> 00:59:21.280
登录ipld就像一个简单的事情

00:59:21.280 --> 00:59:27.280
您只是将根链接在一起，但是至少有一些您想要的东西

00:59:27.280 --> 00:59:32.480
我们想要像这样的加密分层，所以如果有一些

00:59:32.480 --> 00:59:36.000
这样的独立库，我们可以做出贡献或

00:59:36.000 --> 00:59:41.440
你们所有人都写过我们可以使用的数字，这真是一件了不起的事情

00:59:41.440 --> 00:59:46.720
在um上进行协作，是的，这四，五件事是

00:59:46.720 --> 00:59:51.599
主要部分是的，是的，我的意思是我绝对

00:59:51.599 --> 00:59:56.400
对您有兴趣的人

00:59:56.400 --> 01:00:01.920
迈克尔最近所做的aes uh法典资料，喜欢利用

01:00:01.920 --> 01:00:03.920
就像对整个事情进行标准化一样

01:00:03.920 --> 01:00:08.160
嗯，虽然像单身作家一样

01:00:08.160 --> 01:00:13.920
哈希链接日志有点像显而易见的，有一个像

01:00:13.920 --> 01:00:17.680
新的日志插入记录非常不错，就像

01:00:17.680 --> 01:00:20.799
有，它会让你知道会

01:00:20.799 --> 01:00:23.920
建立线程确实很容易，但是会使其他想要的人

01:00:23.920 --> 01:00:27.680
建立类似的东西，还有其他东西的看法

01:00:27.680 --> 01:00:31.200
是的，无论如何，有些事情很酷

01:00:31.200 --> 01:00:36.720
标准化，例如您知道多少您在某个特定位置反向链接

01:00:36.720 --> 01:00:40.319
允许并行遍历的时间间隔和

01:00:40.319 --> 01:00:45.760
智能方式其他方式进行验证

01:00:45.760 --> 01:00:49.920
记录得更快，你知道像这样的事情

01:00:49.920 --> 01:00:53.680
只是让它像一个标准，这将是很酷的

01:00:53.680 --> 01:01:00.480
现在我们内部很多工作是

01:01:00.480 --> 01:01:03.440
更专注于文件硬币方向

01:01:03.440 --> 01:01:06.480
所以我们在，但我们仍然像我们的心仍在

01:01:06.480 --> 01:01:11.760
线程，我们有大量使用线程的用户，我们希望最终

01:01:11.760 --> 01:01:18.319
以某种方式弥合差距以提交硬币

01:01:18.319 --> 01:01:25.040
我们已经讨论了很多，但是是的，这只是归结为

01:01:25.040 --> 01:01:30.240
像资源和时间的划分

01:01:30.240 --> 01:01:34.400
因此，就我们感兴趣的方向而言，这是

01:01:34.400 --> 01:01:37.440
我们正在研究这个普遍的问题

01:01:37.440 --> 01:01:43.200
是的，并且希望为

01:01:43.200 --> 01:01:46.240
生态系统，那么我们如何实例化一个

01:01:46.240 --> 01:01:52.160
合理的标准，可以满足一组基本的用例和

01:01:52.160 --> 01:01:55.520
你们在创造某些东西方面已经在生态系统中做了最多的工作

01:01:55.520 --> 01:02:00.960
实际的数量以及我们正在尝试找出的内容

01:02:00.960 --> 01:02:03.440
什么是基本用例

01:02:03.440 --> 01:02:08.480
我们关心的是什么，我们有多少复杂性

01:02:08.480 --> 01:02:12.640
我们可以忍受这个

01:02:12.640 --> 01:02:17.119
我的直觉是，您知道要针对其进行优化的线程

01:02:17.119 --> 01:02:21.039
对于一组用例来说，这可能是一个超集

01:02:21.039 --> 01:02:26.640
我们正在寻找的东西，所以我试图弄清楚那是什么

01:02:26.640 --> 01:02:28.640
区别在于那里有什么三角洲，

01:02:28.640 --> 01:02:33.280
线程中是否有某些东西，也许是我们可以使用的线程子集

01:02:33.280 --> 01:02:37.760
看起来像提取一样

01:02:37.760 --> 01:02:41.200
或者您知道在其中一部分上进行标准化，或者

01:02:41.200 --> 01:02:45.119
还是实际上需要像um这样的整体

01:02:45.119 --> 01:02:47.760
那就是我们正在考虑的那一刻，所以我想你

01:02:47.760 --> 01:02:52.000
知道我们希望有更多关于UM的对话

01:02:52.000 --> 01:02:59.200
是的，在这里我也有其他一些疯狂的东西

01:03:00.240 --> 01:03:04.799
和迈克尔正在研究一些更近期的术语，以及他在哪里

01:03:04.799 --> 01:03:08.000
有兴趣消费我认为线程

01:03:08.000 --> 01:03:13.680
现在有些东西，是的，或者像它们潜在地解决了一些问题

01:03:13.680 --> 01:03:18.960
问题或其中的一部分，但我有点先需要您的输入

01:03:19.440 --> 01:03:26.319
非常酷，很乐意提供输入内容，嗯，你们都看了多少

01:03:26.319 --> 01:03:30.640
erc 721规格nfc规格

01:03:30.640 --> 01:03:35.760
[音乐]没有很多细节，但我知道我知道

01:03:35.760 --> 01:03:39.520
存在以及它在相当多事物中的意义

01:03:39.520 --> 01:03:44.640
人们似乎认为受协议保护的人不是

01:03:44.640 --> 01:03:49.200
就像一个大的一样，嗯，你知道就像没有保证的唯一性

01:03:49.200 --> 01:03:52.480
像唯一性一样的任何地方

01:03:52.480 --> 01:03:55.119
您实际上无法预测的连锁交易

01:03:55.119 --> 01:03:59.200
因此，如果您正在查看nft或nft类的元数据

01:03:59.200 --> 01:04:04.000
或您无法从中获得的任何资产成为可认证的结构

01:04:04.000 --> 01:04:10.880
嗯，这是一个问题，唯一的问题是

01:04:10.880 --> 01:04:15.440
真的很像告诉您nft是这个令牌uri，我们

01:04:15.440 --> 01:04:19.599
像现在这样推动人们标准化使用ipfs urls人们

01:04:19.599 --> 01:04:22.720
已经在做这样的事情了，但是现在就像你一样很清楚

01:04:22.720 --> 01:04:26.000
需要这样做，而规范中提到的也许是您

01:04:26.000 --> 01:04:29.680
想要将其指向符合此特定条件的metadata.json文件

01:04:29.680 --> 01:04:31.680
模式，但有很多人不

01:04:31.680 --> 01:04:34.640
这样做，然后有几个人破坏了整个规范，这实际上是

01:04:34.640 --> 01:04:38.000
烦人的嗯，但我意识到的一件事

01:04:38.000 --> 01:04:41.280
是那个数字，因为那是一个ipfs网址，然后

01:04:41.280 --> 01:04:45.680
它里面的东西，我们可以用它来有效地编程

01:04:45.680 --> 01:04:49.440
新的编解码器，我们可以使用新的编解码器唱歌

01:04:49.440 --> 01:04:52.160
基本上表明我们正在做的其他功能

01:04:52.160 --> 01:04:56.079
如果有意义的话，在nfts周围的链条内部

01:04:56.079 --> 01:05:00.160
嗯，就像我们可以做的一件事就是，我们可以创建一个规范，例如

01:05:00.160 --> 01:05:05.200
可变的nft，其中ipfs网址是新的

01:05:05.200 --> 01:05:09.119
我们确定的编解码器，它始终是

01:05:09.119 --> 01:05:11.599
仅包含字节的身份多哈希

01:05:11.599 --> 01:05:14.960
所以现在整个前缀都正确了

01:05:14.960 --> 01:05:18.880
一直到你知道长度才有效

01:05:18.880 --> 01:05:21.839
像键值存储区这样的前缀几乎正确

01:05:21.839 --> 01:05:25.200
在链条上，因为您可以看任何链条，

01:05:25.200 --> 01:05:28.559
你可以像谁是第一个这样做的人一样好

01:05:28.559 --> 01:05:32.000
特定的标识符权利，那么实际上就是

01:05:32.000 --> 01:05:35.280
像那个主要拥有者，然后是整个保管链

01:05:35.280 --> 01:05:39.760
该特定链中的那个钥匙属于那里

01:05:39.760 --> 01:05:42.799
然后您可以使用发布信息，也可以发布信息

01:05:42.799 --> 01:05:46.319
到nft地址um以便进行更新

01:05:46.319 --> 01:05:49.839
而且您甚至可以做类似的事情，只允许所有者更新

01:05:49.839 --> 01:05:52.480
就像您可以的那样，您可以在其中使用某种工具

01:05:52.480 --> 01:05:55.039
嗯，但是一旦您开始进行更新，并拥有了很长的时间

01:05:55.039 --> 01:05:57.920
像我开始思考的那样，实际上需要更新的运行数据结构

01:05:57.920 --> 01:06:00.160
关于线程和线程所遇到的一些问题

01:06:00.160 --> 01:06:04.559
嗯，我认为这里的一些区别是，就像你想

01:06:04.559 --> 01:06:07.760
好吧，就是您要实际利用现有的

01:06:07.760 --> 01:06:11.520
um所有权信息，以便获得您不喜欢的许可

01:06:11.520 --> 01:06:14.960
它之外的工具，您也希望不依赖任何工具

01:06:14.960 --> 01:06:17.520
外部工具，例如用于该工具的任何脱链工具

01:06:17.520 --> 01:06:21.760
嗯，这很酷，但它的变化就像我的一些方式

01:06:21.760 --> 01:06:24.480
认为您可能会使用威胁，我不知道你们是否想到过

01:06:24.480 --> 01:06:30.400
关于这个怪异的空间，是的，我的意思是，这就是嗯

01:06:30.400 --> 01:06:34.880
呃和以太做了

01:06:34.880 --> 01:06:41.599
um spec可以正常工作，所以您实际上变异了呃

01:06:41.599 --> 01:06:49.280
给定的像以太坊地址的分散身份标识符文件

01:06:49.280 --> 01:06:57.359
通过将不同的喜欢的更新发布到该地址，然后发布事件

01:06:57.359 --> 01:07:01.200
然后可以查询和解决该智能合约上的内容

01:07:01.200 --> 01:07:06.720
如此有效地解析实际文档，您就有可变的

01:07:06.720 --> 01:07:12.160
文档，您可以随着时间的推移进行更改，并且可以有效地进行调整

01:07:12.160 --> 01:07:16.079
基本上像线程记录更新这样的更新，但是

01:07:16.079 --> 01:07:19.760
他们是原生的以太坊事件

01:07:19.760 --> 01:07:23.440
因此您可以进行查询，这很酷，因为它要花钱

01:07:23.440 --> 01:07:30.160
突变该nft或该文档确实需要花费很多，但是很便宜

01:07:30.160 --> 01:07:33.839
来查询它，所以对dods非常有用，因为

01:07:33.839 --> 01:07:36.640
您喜欢比自己更频繁地解决问题的方式

01:07:36.640 --> 01:07:40.880
更新是的，是相同的设置，我

01:07:40.880 --> 01:07:44.640
认为我认为这变得非常有趣

01:07:44.640 --> 01:07:49.680
就像在nfts的呃背景中一样，因为如果你看

01:07:49.680 --> 01:07:51.920
艺术家和不同的人正在与他们做些什么

01:07:51.920 --> 01:07:54.960
嗯，他们就像在创建这类一次性资产，然后

01:07:54.960 --> 01:07:59.280
出售它们的二级市场，但如果您有一个可变的市场，

01:07:59.280 --> 01:08:03.599
只有拥有者可以对其进行更改，您才能开始创建像um artistic这样的作品

01:08:03.599 --> 01:08:07.440
传播并作为一部分出售的作品

01:08:07.440 --> 01:08:10.079
病毒性传播，并将其作为病毒性传播的一部分

01:08:10.079 --> 01:08:13.920
然后因为您拥有每笔销售的一定比例的合同

01:08:13.920 --> 01:08:16.880
实际上，这比这些大门票更赚钱

01:08:16.880 --> 01:08:19.120
正确的销售权，例如您拥有真正传播开来的东西

01:08:19.120 --> 01:08:22.839
您实际上从中获得了巨大的价值

01:08:22.839 --> 01:08:26.719
嗯，就像我的一个朋友一样，是的，我在

01:08:26.719 --> 01:08:30.799
在grimes nft上工作，我们一直在谈论像混音带，

01:08:30.799 --> 01:08:33.759
就像拥有它时一样，您可以将曲目添加到其中，并且人们会跟随

01:08:33.759 --> 01:08:40.319
这些混音带当它们流行时会产生更大的转售价值，是的

01:08:40.400 --> 01:08:43.759
我曾经想过像上周那样

01:08:43.759 --> 01:08:51.040
nft转售，我只是假设该百分比是在

01:08:51.040 --> 01:08:54.640
像艺术家可以制作的可以继续制作的

01:08:54.640 --> 01:09:00.400
销售额的一小部分，但是嗯，事实并非如此

01:09:00.400 --> 01:09:03.120
不幸的是它在合同中

01:09:03.120 --> 01:09:06.319
在合同中写出来，所以你必须定义正确

01:09:06.319 --> 01:09:09.920
就像现在有一个事实上的标准

01:09:09.920 --> 01:09:13.440
我只是拿我认为百分之十的意思是这样

01:09:13.440 --> 01:09:16.719
但您会看到其他人喜欢铸造他们，就像将自己融入

01:09:16.719 --> 01:09:20.880
这些合同你当然会喜欢

01:09:20.880 --> 01:09:24.640
嗯，您会发现有时候艺术家那里没有这种东西，但是

01:09:24.640 --> 01:09:28.000
我认为您嗯，可以做很多类似的很酷的事情

01:09:28.000 --> 01:09:30.480
你可以的，我的意思是你可以分散不同的付款方式

01:09:30.480 --> 01:09:34.080
百分比放到不同的钱包和东西上，花费更多的钱

01:09:34.080 --> 01:09:36.480
创建它是因为有更多数据要输入

01:09:36.480 --> 01:09:40.719
但是你知道如果你想看上它，你可以

01:09:46.319 --> 01:09:51.120
是的，我们已经进行了一次侧面讨论

01:09:51.120 --> 01:09:57.679
线程在线程周围执行了一段时间，以便线程对等方可以公告

01:09:57.679 --> 01:10:01.120
服务呃，其中一项服务可能是

01:10:01.120 --> 01:10:05.360
像水桶API或

01:10:06.640 --> 01:10:12.320
您可以想象的其他任何东西，例如媒体编码或类似的东西

01:10:13.600 --> 01:10:21.199
但是，是的，我不知道这是否值得，我想去另一个兔子洞

01:10:21.679 --> 01:10:26.880
是的，我认为我一直在解决的一个问题是

01:10:26.880 --> 01:10:31.840
您拥有正确的链上和链下数据，并且

01:10:31.920 --> 01:10:35.280
就像您知道的，如果您解析链，您可以选择其中的一些链

01:10:35.280 --> 01:10:38.800
进入离线状态或进入关闭状态

01:10:38.800 --> 01:10:41.840
是的，但是当你转瞬即逝的时候

01:10:41.840 --> 01:10:45.840
链下数据引用，您不一定有办法

01:10:45.840 --> 01:10:49.520
打电话回去，就像对它进行身份验证一样，这个

01:10:49.520 --> 01:10:51.760
当您构建一些更高级的设备时，这会成为一个问题

01:10:51.760 --> 01:10:54.400
工作流就像我想做的一件事

01:10:54.400 --> 01:10:58.159
就像相对较早地提出了一个起源的规范

01:10:58.159 --> 01:11:02.480
指向创世块的属性（以nfts为单位）

01:11:02.480 --> 01:11:07.280
铸造的链条，所以如果您得到nft

01:11:07.280 --> 01:11:11.120
您现在可以随时对整个所有权链进行身份验证

01:11:11.120 --> 01:11:14.560
对于这nft um，您实际上可以携带该上下文

01:11:14.560 --> 01:11:18.400
而现在就像您可以从字面上就像让他们喜欢，如果有人

01:11:18.400 --> 01:11:20.719
在像这样的侧链中非常受欢迎

01:11:20.719 --> 01:11:24.239
您可以在以太坊中铸造它，然后像肯定的那样去出售它

01:11:24.239 --> 01:11:28.159
那是因为人们会认为以太坊是真正的那个

01:11:28.159 --> 01:11:30.960
因为没有人在检查所有的侧链，看看是否有旧的

01:11:30.960 --> 01:11:34.960
这些相同实体的版本就像是真正的问题

01:11:34.960 --> 01:11:38.400
是的，实际上我打过一个电话

01:11:38.400 --> 01:11:42.400
今天早些时候

01:11:42.400 --> 01:11:47.040
被认为是一种好处，但也

01:11:47.040 --> 01:11:53.840
像是一项非常严重的福利，因为它使um

01:11:53.840 --> 01:11:56.400
让他们更轻松地移动，就像您想移动它一样

01:11:56.400 --> 01:11:59.840
可以使用相同的地址，但随后再标记

01:11:59.840 --> 01:12:03.600
墓碑右侧，旧墓碑指向另一个墓碑

01:12:03.600 --> 01:12:07.920
um链，但就像您必须知道要去验证该链上的

01:12:07.920 --> 01:12:10.560
进行查找，您将看到的就像您知道的

01:12:10.560 --> 01:12:13.280
一旦事情变得足够流行，人们就会喜欢尝试将它们偷走

01:12:13.280 --> 01:12:15.920
除非有解决方案，否则以太坊链

01:12:15.920 --> 01:12:19.440
所以您知道是否要在侧链中铸造它们，例如将侧链放入

01:12:19.440 --> 01:12:23.199
在那个财产中，然后您就会知道有人想要对其进行身份验证

01:12:23.199 --> 01:12:25.679
如果将它们转移到以太坊，它将通过侧链

01:12:25.679 --> 01:12:28.880
看到转让，然后他们会去看看以太坊链

01:12:28.880 --> 01:12:36.239
如果有人试图窥探它，您可以在一个新的um uri中进行窥探

01:12:36.239 --> 01:12:40.000
是的，超级酷，我认为我们要做的一件事

01:12:40.000 --> 01:12:43.280
从线程中丢失，就像清除

01:12:43.280 --> 01:12:50.159
用例，您知道我们可以真正团结起来，因为您可以想象

01:12:50.159 --> 01:12:53.360
事情不同，如是否喜欢或要

01:12:53.360 --> 01:12:58.159
为物联网或某物设计，或为之设计

01:12:58.159 --> 01:13:04.640
nft跟踪或um，所以出现了轻微的瘫痪

01:13:04.640 --> 01:13:10.800
围绕一些决策，就像没有超级清晰的用例一样

01:13:10.800 --> 01:13:15.440
嗯，现在我们主要是受到大量用户的驱动

01:13:15.440 --> 01:13:22.880
嗯，是的，那是我的意思，是的，我们可以做到

01:13:22.880 --> 01:13:26.320
聊一些其他的nft想法，或

01:13:26.320 --> 01:13:30.800
我很想听听你们是否有事情可以告诉我们

01:13:30.800 --> 01:13:37.600
您的收藏资料，我们可以阅读有关的内容，但我们正在努力

01:13:37.600 --> 01:13:41.520
你知道它是什么的基础，我们甚至

01:13:41.520 --> 01:13:44.880
现在在谈论，所以我想也许

01:13:44.880 --> 01:13:48.800
也许在与您的下一次对话中

01:13:48.800 --> 01:13:52.000
我们正在思考的用例

01:13:52.000 --> 01:13:55.840
一样重要，然后看那些与

01:13:55.840 --> 01:13:59.120
你所拥有的，然后像那样，因为

01:13:59.120 --> 01:14:01.520
然后这应该使事情对我们所有人显而易见，那就是

01:14:01.520 --> 01:14:06.320
对我们来说，下一步是概述这些用例

01:14:06.320 --> 01:14:09.360
我们认为这很重要，是的，我的意思是很好

01:14:09.360 --> 01:14:12.800
然后有一些类似的交集

01:14:12.800 --> 01:14:16.800
那里的工作，那么我们也许可以将其作为标准

01:14:16.800 --> 01:14:19.920
我们采用的方法，然后在

01:14:19.920 --> 01:14:25.679
是的，这真的很有趣，是这样，最近发布的方式是

01:14:25.679 --> 01:14:29.679
那个这个集合的概念

01:14:29.679 --> 01:14:32.480
数据，尤其是您知道的ipld集合

01:14:32.480 --> 01:14:36.080
东西早早就被人捣烂了

01:14:36.080 --> 01:14:40.840
在ipfs设计过程中，再也没有真正回过头来，这是

01:14:40.840 --> 01:14:44.719
就像是像你这样的人来

01:14:44.719 --> 01:14:48.800
解决这个问题的方法，嗯，真的

01:14:48.800 --> 01:14:54.960
拥有被um广告作为标准的东西会很好，这就是这个

01:14:54.960 --> 01:14:56.800
建议您这样做，然后我们

01:14:56.800 --> 01:15:01.760
你知道交流关于如何做到的讨论吗？

01:15:01.760 --> 01:15:05.440
与不同的服务部门进行交流，以了解如何使用这些东西以及如何烘烤它们

01:15:05.440 --> 01:15:08.159
进入其他各种事物，例如filecoin

01:15:08.159 --> 01:15:12.560
如何将它们构建到销钉数据中

01:15:12.560 --> 01:15:14.800
榫钉之类的东西有一个整体

01:15:14.800 --> 01:15:17.440
整个事情范围，如果你有一个

01:15:17.440 --> 01:15:20.719
定义事物集合的单一方法

01:15:20.719 --> 01:15:24.800
那么你可以做很多事情，可以释放很多力量，这就是

01:15:24.800 --> 01:15:28.960
我们在想我的意思是这与我们与dids谈论的是同一件事

01:15:28.960 --> 01:15:31.840
对，这就像您知道您是否拥有某种

01:15:31.840 --> 01:15:34.480
定义什么是集合，然后您可以实现该集合

01:15:34.480 --> 01:15:38.960
在以太坊上，您可以在哈希链接中​​实现它

01:15:38.960 --> 01:15:42.960
ipfsc ids，您可以在爆米花上做到，到处都可以做到

01:15:42.960 --> 01:15:46.000
这真是令人兴奋

01:15:47.440 --> 01:15:51.199
对于我们使用cid的使用量来说，似乎已经严重缺乏开发

01:15:51.199 --> 01:15:53.280
甚至像一些更基本的

01:15:53.280 --> 01:15:58.239
问题是什么是一堆小动物的最小表示

01:15:58.239 --> 01:16:01.920
什么样的东西就像一个很好的多块数据结构来存储一个

01:16:01.920 --> 01:16:05.280
大量的cid，因为像突变率一样可怕

01:16:05.280 --> 01:16:09.920
就像嗯，是的，和

01:16:09.920 --> 01:16:13.199
我不认为我们与其他人相距甚远

01:16:13.199 --> 01:16:17.199
在我写的那个zag规范中，

01:16:17.199 --> 01:16:20.800
仅利用排序来消除前缀和

01:16:20.800 --> 01:16:24.880
其他一些东西，例如，您可以剃掉15个

01:16:24.880 --> 01:16:28.800
大小像一堆cds um，但除此之外，我不喜欢

01:16:28.800 --> 01:16:35.840
甚至不知道您将成为一个新的编解码器，但是

01:16:36.560 --> 01:16:40.480
好吧，嗯，你们中有人有其他想要的问题吗？

01:16:40.480 --> 01:16:47.760
在um之前已经介绍过，我想只是在um的网络方面

01:16:47.760 --> 01:16:51.679
是的，如果您需要一些东西，您想通过事物进行交流

01:16:51.679 --> 01:16:56.719
我有空，但我没有忘记我们的谈话

01:16:56.719 --> 01:17:01.360
嗯，尝试用存储桶发布许多IP记录

01:17:01.360 --> 01:17:04.719
嗯ii应该给你带来一些惊喜

01:17:04.719 --> 01:17:11.040
很快，嗯，是的，我

01:17:11.040 --> 01:17:14.560
我也觉得我很想从事出色的可变性方面的工作，但

01:17:14.560 --> 01:17:18.159
这些都是不变的事情，需要首先得到照顾

01:17:18.159 --> 01:17:23.120
嗯，所以在任何时候，那都是你们

01:17:23.120 --> 01:17:28.719
集思广益，我很想呃能够听，是的，我们已经开始

01:17:28.719 --> 01:17:33.360
用任何东西做一点地面测试工作

01:17:33.360 --> 01:17:37.120
键入只是基本测试一下

01:17:37.120 --> 01:17:41.280
他们一直在做的改进

01:17:41.280 --> 01:17:49.040
我们很乐意就像把你知道的八卦酒吧扔在那里

01:17:49.040 --> 01:17:55.040
并能够理想地使我们喜欢玩八卦上几乎没有变化的游戏

01:17:55.040 --> 01:17:59.600
到处都是酒吧，就像看到这些东西在

01:17:59.600 --> 01:18:05.440
在试运行中扩展um，因为我知道我们一样

01:18:05.440 --> 01:18:07.679
有一群人

01:18:07.679 --> 01:18:12.800
做很多的测试试验场

01:18:12.800 --> 01:18:16.400
特别是在提交代币发行的几个月前，

01:18:16.400 --> 01:18:20.159
如果我们锤击这个，并且我们会努力做到对这个网络真的很刻薄

01:18:20.159 --> 01:18:24.880
仍然坚持好吧，他们做得很好

01:18:24.880 --> 01:18:29.199
嗯，所以你应该能够测试那些更大的东西

01:18:29.199 --> 01:18:34.000
有趣的一件事是，它现在就屹立不倒

01:18:34.000 --> 01:18:38.239
八卦子节点拥有的最大主题数

01:18:38.239 --> 01:18:41.920
能够告诉你它在乎

01:18:41.920 --> 01:18:47.199
嗯，所以，如果您正在运行一个试图监听一百万个节点的节点

01:18:47.199 --> 01:18:50.560
主题和最大邮件大小就像

01:18:50.560 --> 01:18:53.679
几兆，你会开始变得非常难过

01:18:53.679 --> 01:18:58.719
对对对，结果就是像多租户这样的东西

01:18:58.719 --> 01:19:02.080
您拥有这些复制器的地方，而这正是我们所看到的

01:19:02.080 --> 01:19:08.000
那里的问题，我们不想，我们不想像不得不保留

01:19:08.000 --> 01:19:13.760
向100知道的云提供商注资

01:19:13.760 --> 01:19:17.600
演出存储设备正确，特别是因为您真的不需要

01:19:17.600 --> 01:19:20.640
100 gig的存储盒是方形的，而您真正的是

01:19:20.640 --> 01:19:25.760
这里需要大量的CPU，嗯，所以

01:19:25.760 --> 01:19:29.199
我们可以在这里讨论做类似水平缩放的方法

01:19:29.199 --> 01:19:34.320
我的意思是，如果我们真的想，我们可以找到增加数量的方法

01:19:34.320 --> 01:19:37.440
像修改后的八卦子一样能够处理

01:19:37.440 --> 01:19:41.280
您知道更多主题，更多订阅，但感觉就像

01:19:41.280 --> 01:19:44.480
这里可能有一些很好的方法可以进行水平缩放

01:19:44.480 --> 01:19:47.520
也许就像呃，该协议警告您喜欢

01:19:47.520 --> 01:19:51.600
在继续之前，让我们考虑一下是否还有另一种方法可以做到这一点

01:19:51.600 --> 01:19:56.640
嗯，是的，你知道，如果你们想走，你们知道

01:19:56.640 --> 01:20:00.239
集思广益一些选择，我们可以，我们绝对可以

01:20:00.239 --> 01:20:05.840
通过那些很棒的东西进行交谈

01:20:07.120 --> 01:20:10.480
可能把它包起来了，非常感谢您的时间

01:20:10.480 --> 01:20:15.360
嗯，但我想我们会要求您更多的时间在

01:20:15.360 --> 01:20:19.440
不久的将来，这真是令人着迷，是的，我的意思是

01:20:19.440 --> 01:20:21.360
是桑德拉的事，我一直想做

01:20:21.360 --> 01:20:25.040
无论如何，关于线程的更多外展和

01:20:25.040 --> 01:20:28.960
看到标准化点在哪里，这很好，很好

01:20:28.960 --> 01:20:33.120
时机太希望了，这是有用的，我们不是

01:20:33.120 --> 01:20:37.040
太喜欢粗鲁或不回答

01:20:37.040 --> 01:20:40.960
很好，我喜欢这里的自由格式，因为

01:20:40.960 --> 01:20:44.880
查看文档是一回事，因为它通常以用户为中心，然后

01:20:44.880 --> 01:20:48.239
白皮书是关于它的学术问题

01:20:48.239 --> 01:20:51.520
这让我只想非常具体

01:20:51.520 --> 01:20:54.880
细节，所以我认为自由格式真的很有帮助

01:20:54.880 --> 01:21:00.239
是的，很酷，很好，谢谢

01:21:00.239 --> 01:21:07.199
大家谢谢你谢谢你的收看

01:21:07.199 --> 01:21:10.480
直播再见

