WEBVTT
Kind: captions
Language: zh-Hans

00:00:11.120 --> 00:00:14.920
欢迎大家参加本周的ipld同步会议

00:00:14.920 --> 00:00:22.320
这是2021年3月1日，就像我们每周一样

00:00:22.320 --> 00:00:25.760
回顾过去一周我们一直在努力的工作

00:00:25.760 --> 00:00:29.039
以及我们计划进行的工作，然后进行讨论

00:00:29.039 --> 00:00:36.960
任何开放的议程项目，我都是从我自己开始的，

00:00:36.960 --> 00:00:43.360
 js多种格式的东西可用于js ipfs，但我

00:00:43.360 --> 00:00:48.640
从s的js ipfs unix开始，我做了一个小小的尝试

00:00:48.640 --> 00:00:52.160
刚刚使用协议缓冲区的补丁将新的

00:00:52.160 --> 00:00:55.840
一个，但后来我决定只是因为就像我整合时一样

00:00:55.840 --> 00:00:58.879
将其集成到ipfs中，整个过程就像

00:00:58.879 --> 00:01:02.079
cid是不同的，依此类推，我只是想获得

00:01:02.079 --> 00:01:07.200
将所有json多种格式转换为jsc调整cfs

00:01:07.200 --> 00:01:13.439
它起作用了，所以分支i中没有js ipal d

00:01:13.439 --> 00:01:17.439
但是，嗯，所以我们将看看它是如何工作的

00:01:17.439 --> 00:01:21.840
与js ipfs和有趣的事情

00:01:21.840 --> 00:01:26.560
我认为是那个，我们在谈论，也像抽象或

00:01:26.560 --> 00:01:32.720
缺少jsc multiformus没有的片段，并且

00:01:32.720 --> 00:01:38.720
所以js ipld所做的基本上是结合了编码

00:01:38.720 --> 00:01:42.320
建立块并将它们存储在磁盘上的一件事，感觉就像是

00:01:42.320 --> 00:01:45.759
奇怪的是，所有这些都捆绑在一件事中，但是

00:01:45.759 --> 00:01:49.040
当我分开或换新东西时，我

00:01:49.040 --> 00:01:52.720
发现它实际上非常有用并且

00:01:52.720 --> 00:01:56.159
主要用于编写测试，因为您只是

00:01:56.159 --> 00:02:01.040
总是执行与您总是进行编码相同的步骤获得cid

00:02:01.040 --> 00:02:05.360
将其存储在某个地方，就像一个步骤一样，非常方便

00:02:05.360 --> 00:02:09.520
所以我还是不确定像是还是我们应该以

00:02:09.520 --> 00:02:13.920
同样的抽象可能不会被称为js ipld，但也许

00:02:13.920 --> 00:02:17.760
其他的东西，或者这将是我不知道的js ipfs的一部分，但这就像

00:02:17.760 --> 00:02:21.040
事实证明它非常有用

00:02:21.040 --> 00:02:29.360
一步一步有这个嗯是的，我会的

00:02:29.360 --> 00:02:35.840
在下个星期继续进行下去，看看进展如何，并希望

00:02:35.840 --> 00:02:39.519
是的，我得到了一些有用的东西

00:02:39.680 --> 00:02:43.519
嗯，接下来是艾瑞克

00:02:46.080 --> 00:02:52.640
现在我要报告这个星期的新鲜事，但我会

00:02:52.640 --> 00:02:55.760
简要提醒乡亲，以防他们感兴趣

00:02:55.760 --> 00:02:59.120
我做了一些关于夹具文件格式的探索报告

00:02:59.120 --> 00:03:04.800
如果有人想对此发表评论，那已经有一段时间了

00:03:04.800 --> 00:03:08.000
果阿人民的链接系统已经盛行，但尚未正式启动

00:03:08.000 --> 00:03:11.920
降落了，但据我所知，可以继续使用

00:03:11.920 --> 00:03:16.959
嗯，它尚未降落的原因是我与

00:03:16.959 --> 00:03:20.560
对我们的维护感兴趣的其他人

00:03:20.560 --> 00:03:25.920
像um go multihash这样的其他go库，尤其是

00:03:25.920 --> 00:03:29.040
最后我意外地将其替换了一半

00:03:29.040 --> 00:03:32.959
在此公关和指导期间

00:03:32.959 --> 00:03:37.760
嗯，我听起来我们已经同意

00:03:37.760 --> 00:03:40.319
实际上将尝试更新一堆东西并进行多哈希处理

00:03:40.319 --> 00:03:44.480
上游，这有点令人兴奋，因为它

00:03:44.480 --> 00:03:49.920
我们较旧的图书馆之一，因此高度依赖

00:03:49.920 --> 00:03:53.200
我们必须非常小心进行更改

00:03:53.200 --> 00:03:55.599
嗯，但这可能就是我要做的

00:03:55.599 --> 00:04:00.560
直到下个礼拜

00:04:00.560 --> 00:04:05.120
作为链接系统的一部分，我做了一些工作

00:04:05.200 --> 00:04:09.120
开始使用一堆标准库哈希接口

00:04:09.120 --> 00:04:12.400
标准库中的常见问题

00:04:12.400 --> 00:04:16.720
并支持流式哈希，我在制作方面做了很多工作

00:04:16.720 --> 00:04:23.440
导入路径，以便您可以编译程序

00:04:23.440 --> 00:04:25.600
而不是依赖于一堆

00:04:25.600 --> 00:04:29.919
不寻常的哈希函数，例如，甚至不寻常，但不是

00:04:29.919 --> 00:04:34.400
标准库，所以像镜头三不在正在运行的标准库中，所以

00:04:34.400 --> 00:04:37.360
如果您使用它，将会带来更多的运输依赖

00:04:37.360 --> 00:04:42.240
um尝试将所有内容迁移到合理的插件系统中，以便您

00:04:42.240 --> 00:04:43.600
可以选择是否要

00:04:43.600 --> 00:04:45.840
将它们放在您的运输依赖树中

00:04:45.840 --> 00:04:50.800
并以您的二进制文件结尾，因此go的当前状态为多哈希

00:04:50.800 --> 00:04:53.919
迫使您在二进制文件中拥有所有这些东西

00:04:53.919 --> 00:04:57.600
我们将修复该问题，这将是我的电话

00:04:57.600 --> 00:05:03.039
提前一周，然后应该重新确定链接系统的内容

00:05:03.039 --> 00:05:04.960
最重要的是它应该没有任何外向

00:05:04.960 --> 00:05:11.840
变化真的只是把事情放在上游

00:05:15.440 --> 00:05:20.400
酷的下一个是

00:05:22.840 --> 00:05:27.600
嗯，我猜想提供的更新

00:05:27.600 --> 00:05:31.520
我们去过哪里，这是很多报道

00:05:31.520 --> 00:05:37.600
代表汉娜和亚历克斯·乌姆做我自己

00:05:37.600 --> 00:05:41.919
现在已经形成了称为ipfs go fetcher的形状

00:05:41.919 --> 00:05:48.160
它提供了ipld灌注的提取接口um

00:05:48.160 --> 00:05:53.600
这将使我们能够从

00:05:53.600 --> 00:05:57.520
当前使用的基于go merkle dag的获取接口um

00:05:57.520 --> 00:06:04.840
通过ipfs，所以这是下一步ipfs或iplt primary和ipfs的工作

00:06:04.840 --> 00:06:09.280
嗯，如果您对该界面的外观有意见

00:06:09.280 --> 00:06:14.240
像那个仓库就是放他们的地方

00:06:15.680 --> 00:06:19.520
接下来发生的事情，并希望在下一个地方到位

00:06:19.520 --> 00:06:22.479
这星期的几天

00:06:23.759 --> 00:06:31.440
使用eric提到的lynx系统分支，我们要么

00:06:31.520 --> 00:06:35.840
制作一个新界面可能不在该回购中，但我认为我们还没有弄清楚

00:06:35.840 --> 00:06:39.280
到底是哪个回购才最有意义

00:06:39.280 --> 00:06:42.960
对于当前的添加和删除界面，谷歌迈克尔·达格

00:06:42.960 --> 00:06:47.600
公开了um，所以我们发现该接口

00:06:47.600 --> 00:06:51.280
那就是merkle dag实际上是三个截然不同的界面

00:06:51.280 --> 00:06:58.319
嗯，我想根据sid来获取一些数据，

00:06:58.319 --> 00:07:02.000
既尝试从您的本地数据存储中获取它，也可能

00:07:02.000 --> 00:07:05.840
调用网络事物以通过bitswap获取它，或

00:07:05.840 --> 00:07:08.880
graphsync或它将完成整个网络任务

00:07:08.880 --> 00:07:13.440
所以这就是gofetcher，是我想获取数据的地方

00:07:13.440 --> 00:07:19.039
嗯，那里有一组仅用于本地数据存储的接口

00:07:19.039 --> 00:07:22.080
就像我想将此数据添加到我的本地数据存储中，我想

00:07:22.080 --> 00:07:24.960
从我的本地数据存储中删除此数据

00:07:24.960 --> 00:07:28.240
嗯，那真的是编解码器序列化的事情

00:07:28.240 --> 00:07:33.199
存储um的链接系统与之接近，并且它可以

00:07:33.199 --> 00:07:37.039
将dag序列化为字节流，但是我们想

00:07:37.039 --> 00:07:42.080
将dag序列化到您的数据存储中，所以这是一个

00:07:42.080 --> 00:07:44.879
稍微高一点的东西就建立在它上面，所以我们将其放在

00:07:44.879 --> 00:07:47.919
在某处并从数据存储中删除dag

00:07:47.919 --> 00:07:52.080
请嗯，然后第三个像我

00:07:52.080 --> 00:07:55.680
得到了unix fs，我想将文件添加到目录中，所以

00:07:55.680 --> 00:08:02.080
一组突变的事物，而这些可能只是发生在

00:08:02.160 --> 00:08:06.560
ipl ipld最主要的东西，否则我们可能会有一些帮助功能

00:08:06.560 --> 00:08:11.840
嗯，帮助迈向半标准的做事方式

00:08:11.840 --> 00:08:14.240
事情，这样我们就不必多次更改它

00:08:14.240 --> 00:08:18.400
无论如何放置um充气

00:08:18.400 --> 00:08:22.479
我上周所做的工作是我拿到了编解码器，

00:08:22.479 --> 00:08:26.800
来自ipfs的git对象的非标准思考方式

00:08:26.800 --> 00:08:30.080
我在ipld主要节点而不是ipl上重建了它

00:08:30.080 --> 00:08:35.839
格式化节点，还有一个公关，也可以对此使用评论

00:08:36.159 --> 00:08:41.839
还有更多

00:08:42.479 --> 00:08:50.640
事情从其他任何人那里得到的更新，我们都去了

00:08:50.640 --> 00:08:54.560
gen项目，因此也可以随意添加引擎项目

00:08:54.560 --> 00:08:58.959
所以我那里有像丹尼尔（Danielle）这样的更新

00:08:58.959 --> 00:09:03.519
谈论悟空套牌PB

00:09:03.680 --> 00:09:07.360
是的，所以起初我要在松弛的情况下对此进行ping操作，但是我认为我

00:09:07.360 --> 00:09:11.040
也许因为这是星期一，所以我最好把它带到这里

00:09:11.040 --> 00:09:15.519
嗯，所以回顾一下上周将要问的是，两者之间有什么区别

00:09:15.519 --> 00:09:20.000
goy pld prime proto和go kodakeck pb，因为它们都很简单

00:09:20.000 --> 00:09:25.120
实施卡座PB UM编解码器，我不想说规格，因为我认为

00:09:25.120 --> 00:09:28.640
那只是后者，但本质上我们必须选择一项权利，因为

00:09:28.640 --> 00:09:32.640
我想同时保持这点和汉娜上周说的话

00:09:32.640 --> 00:09:36.080
难道我们哪一个都不重要

00:09:36.080 --> 00:09:41.040
选择它，只要它与unix fs数据一起使用并使用ipld prime

00:09:41.040 --> 00:09:44.240
嗯，所以我开始我接好了这个任务

00:09:44.240 --> 00:09:47.600
让我们决定我们要利用哪个优势

00:09:47.600 --> 00:09:51.600
花娜写的第一本是我用的

00:09:51.600 --> 00:09:55.920
unix fs使用的代码，这是来自gomer的称为ag的代码

00:09:55.920 --> 00:10:01.519
但这不是api明智的做法，就ipld prime而言不是很好，但它

00:10:01.519 --> 00:10:04.240
还引入了go merkle dac作为依赖项，以便

00:10:04.240 --> 00:10:09.040
递归模块依赖性从技术上讲不是问题

00:10:09.040 --> 00:10:12.160
可以正常工作，但从长远来看，这将是一个问题

00:10:12.160 --> 00:10:16.880
会引起像um这样的问题吗？

00:10:16.880 --> 00:10:21.040
在模块级别上不是很好的依赖关系，另一个

00:10:21.040 --> 00:10:25.920
是dac pb，这是Rod在某个时候写的um，问题是

00:10:25.920 --> 00:10:30.480
实际上与Unix fs数据兼容

00:10:30.480 --> 00:10:34.560
所以我所做的是在gomercl中有一个叫做pb的软件包

00:10:34.560 --> 00:10:37.760
它有一个名为testcompat的表驱动测试

00:10:37.760 --> 00:10:42.240
它使用gomerkeldaq中那个pb的编码器和解码器

00:10:42.240 --> 00:10:46.959
它有很多测试用例，例如没有链接，有很多数据等等。

00:10:46.959 --> 00:10:50.480
等等，我基本上重写了使用

00:10:50.480 --> 00:10:54.480
该PB，它主要工作，有一些测试

00:10:54.480 --> 00:10:57.279
没有错误的情况

00:10:57.279 --> 00:11:00.959
这是棘手的一点，这是我想问大家的地方

00:11:00.959 --> 00:11:04.959
如果您认为这会导致读写unix效果方面的问题

00:11:04.959 --> 00:11:08.480
数据，一些失败的测试是

00:11:08.480 --> 00:11:12.240
期望他们像有

00:11:12.240 --> 00:11:16.480
一个零链接片，而不是一个空链接片

00:11:16.480 --> 00:11:19.920
很好，因为它们编码为相同的东西和protobuf

00:11:19.920 --> 00:11:22.959
因此，这只是代表他们并离开的一种不同方式，但只要

00:11:22.959 --> 00:11:26.160
他们对相同的东西进行编码

00:11:26.160 --> 00:11:32.399
良好的编码级别，其他失败的测试用例类别

00:11:32.959 --> 00:11:36.560
哦，我可能需要重新读一遍我的道歉

00:11:36.560 --> 00:11:44.399
另一个失败的测试用例本质上是无效链接，所以链接

00:11:44.399 --> 00:11:48.880
缺少哈希这样的东西，所以我想

00:11:48.880 --> 00:11:52.320
问题那里我看到规范确实说它确实说

00:11:52.320 --> 00:11:55.600
从技术上讲，哈希是可选的，但不应这样处理

00:11:55.600 --> 00:11:58.959
在读取和写入节点但有人验证时

00:11:58.959 --> 00:12:04.079
Unix fs v1是否具有此类链接

00:12:04.560 --> 00:12:09.839
不，这是一个问题，现在您正在接触，这是一件好事

00:12:09.839 --> 00:12:13.920
因此，关于dak pb规范的问题的一部分只是获得输入

00:12:13.920 --> 00:12:17.519
将堆栈放入unix fs和实际使用标签pb的人员中

00:12:17.519 --> 00:12:20.639
因此，关于可以做什么和可以做出很多勇敢的假设

00:12:20.639 --> 00:12:28.000
不存在以及如何处理它，而只是获得诸如um之类的答案

00:12:28.000 --> 00:12:31.760
呃发生了什么事，因为

00:12:32.160 --> 00:12:36.560
如果我得到的哈希值不是有效的多重哈希值，会发生什么情况

00:12:36.560 --> 00:12:40.720
还是零字节，就像我该怎么办

00:12:40.720 --> 00:12:46.000
嗯，嗯，我很可能在野外的任何地方遇到这种情况

00:12:46.000 --> 00:12:49.360
获得答案的可能性非常困难

00:12:49.360 --> 00:12:51.360
所以有一些勇敢的假设

00:12:51.360 --> 00:12:54.880
该规范可能会出现问题

00:12:54.880 --> 00:13:00.800
嗯，这不是一成不变的规范，这是我们尽力而为

00:13:00.800 --> 00:13:04.480
将旧的dag pb的世界连接到这个新的数据世界

00:13:04.480 --> 00:13:08.240
模型，就是这样，就是这样

00:13:08.240 --> 00:13:12.959
dag它是什么去编解码器dag pb烘烤在那

00:13:12.959 --> 00:13:18.880
规范，因为现在是go code，现在是ipld prime proto

00:13:18.880 --> 00:13:22.160
它基本上只是说这是迈克·达格（Michael dag）正在做的

00:13:22.160 --> 00:13:25.920
这个pb节点pb链接的东西让我们将其包装起来

00:13:25.920 --> 00:13:30.000
从它出来，根本不做任何假设，所以有

00:13:30.000 --> 00:13:33.360
你知道吗默克尔天给你的东西会花掉一切

00:13:33.360 --> 00:13:37.120
默克尔天给你的基本上就是

00:13:37.120 --> 00:13:40.959
在没有检查的情况下从字节中产生的意识流

00:13:40.959 --> 00:13:45.600
就像是原始的Pb和um

00:13:45.600 --> 00:13:48.880
在那里，我们知道情况并非如此，因为

00:13:48.880 --> 00:13:54.639
在编码方面，有一些规则，是的，它很复杂，但是如果您去

00:13:54.639 --> 00:13:57.920
到该链接的位置，现在有点隐藏了，因为

00:13:57.920 --> 00:14:00.959
doc更新了，但是我在那里写了很多东西

00:14:00.959 --> 00:14:07.040
关于差异和嗯，这很好是你

00:14:07.040 --> 00:14:10.639
现在谈及进入现实世界的数据，我不能说

00:14:10.639 --> 00:14:14.079
确定您看到失败的测试是否确实是

00:14:14.079 --> 00:14:17.279
解释现实世界中的事物，或仅仅考虑存在于现实世界中的事物

00:14:17.279 --> 00:14:19.680
用怀疑的方式编码我的怀疑

00:14:19.680 --> 00:14:23.920
后来，这是他们在其中看到的东西

00:14:23.920 --> 00:14:26.880
在代码中看到的，哦，我们应该将其作为边缘案例进行测试

00:14:26.880 --> 00:14:30.480
但这是否会从现实世界的数据中产生

00:14:30.480 --> 00:14:35.839
我怀疑不是，是的，那也是我的假设

00:14:35.839 --> 00:14:38.959
因为我不知道一个案例

00:14:38.959 --> 00:14:42.320
嵌入式链接会很有用，我是说我唯一可能的情况

00:14:42.320 --> 00:14:46.880
想到的是，我们解码了一些我们无法真正使用的数据，但让我们对其进行编码

00:14:46.880 --> 00:14:50.240
再次将其传递到其他地方，但是如果您这样做，那么您也可能会

00:14:50.240 --> 00:14:55.199
知道使用原始字节，是的，我不知道，所以我猜是什么

00:14:55.199 --> 00:14:59.120
我要做的就是继续这样做，但是对不起

00:14:59.120 --> 00:15:02.720
继续使用u go codec.pb，但在这种情况下，

00:15:02.720 --> 00:15:05.680
确实发现unixfs确实使用了这种

00:15:05.680 --> 00:15:09.440
半断断续续的数据，我想我们将进入

00:15:09.440 --> 00:15:13.040
使规范滞后于实际上与的Unix兼容

00:15:13.040 --> 00:15:16.480
好的，是的，这是完全合理的，并期望一旦我们击中

00:15:16.480 --> 00:15:18.880
在现实世界中，我们发现这些假设并没有

00:15:18.880 --> 00:15:20.800
成立，那么我们将对其进行更改，您将看到

00:15:20.800 --> 00:15:23.519
现在还有其他几个重要的地方，甚至还有一个

00:15:23.519 --> 00:15:27.839
关于js ipf中出现的t大小可选性的讨论

00:15:27.839 --> 00:15:32.320
ipfs大小方面，因为去年发​​生了这种断言，

00:15:32.320 --> 00:15:36.399
嘿，让我们做一些我们不需要的东西

00:15:36.399 --> 00:15:40.480
正确编写的实现，但我们将其中一个放进去

00:15:40.480 --> 00:15:43.759
无论如何，并默认为零，像这样

00:15:43.759 --> 00:15:47.040
但规范说这东西是可选的

00:15:47.040 --> 00:15:50.399
所以应该在上方的一层处理

00:15:50.399 --> 00:15:54.720
如果您真的只想插入零，则应该这样做，但是现在

00:15:54.720 --> 00:15:57.519
这是演员的讨论，是否应该在规范中进行编码，

00:15:57.519 --> 00:16:03.199
将其设为非可选，并将其默认设置为零

00:16:04.000 --> 00:16:11.600
我的意思是我很酷，你可以拥有，这不是我的问题，唯一的另一件事

00:16:11.600 --> 00:16:16.399
我本来要说的是汉娜说的是goy pld prime proto

00:16:16.399 --> 00:16:20.240
为了提高性能有一些捷径，所以她说我们可能想

00:16:20.240 --> 00:16:22.959
如果我们最终将其中一些移植到dakp

00:16:22.959 --> 00:16:28.480
使用wpb，所以您可能会看到一些公关的问题，也不要将我视为阻止者，例如

00:16:28.480 --> 00:16:31.279
只是做你需要做的才能使它工作，我

00:16:31.279 --> 00:16:36.160
是的，那是我，所以我们很可能

00:16:36.160 --> 00:16:40.800
嗯，我们最喜欢吗，最有可能会使用套牌PV吗，因为我真的不能

00:16:40.800 --> 00:16:43.600
比我已经做的更多的实验，就像你说的那样很难

00:16:43.600 --> 00:16:48.160
告诉测试是否由真实数据驱动

00:16:48.160 --> 00:16:53.839
这实际上是另一件事，所以um go merkle dag pb还具有其他功能

00:16:53.839 --> 00:16:56.079
我作为规格一部分放入的测试

00:16:56.079 --> 00:17:00.000
过程，嗯，这将再次是

00:17:00.000 --> 00:17:03.440
甚至很难弄清歧义是什么

00:17:03.440 --> 00:17:06.880
因为当我进行测试工作时，实际上是在测试边缘

00:17:06.880 --> 00:17:09.760
你的边缘知道什么是光伏链接在光伏链接中未知

00:17:09.760 --> 00:17:13.600
在不同的状态下，这东西会产生什么

00:17:13.600 --> 00:17:15.760
在几个不同的州，您可以得到

00:17:15.760 --> 00:17:19.439
来自不同数据的相同字节，因此这是

00:17:19.439 --> 00:17:22.640
达到这样的规格，我们应该有一种方法来获得

00:17:22.640 --> 00:17:26.240
相同的数据，例如一个数据等于一个字节

00:17:26.240 --> 00:17:32.000
嗯，这整个区域周围一直有松动

00:17:32.000 --> 00:17:35.840
从protobuf继承下来的很长一段时间

00:17:35.840 --> 00:17:38.080
只是从你知道，让我们做到这一点

00:17:38.080 --> 00:17:41.679
工作并继续前进，这些事情在这些早期的早期事情中是足够公平的

00:17:41.679 --> 00:17:44.480
但是你知道我们只是到现在为止

00:17:44.480 --> 00:17:49.280
回去尝试并使其正式化，是的，我刚刚意识到我使用的测试

00:17:49.280 --> 00:17:52.320
是你写的试战，那是我的

00:17:52.320 --> 00:17:56.720
你去对了，那些和那些你会看到那些测试的

00:17:56.720 --> 00:18:00.480
已在我的Go编解码器pb中镜像，但我已发表评论

00:18:00.480 --> 00:18:04.559
我断言的一些不应该过去

00:18:04.559 --> 00:18:08.720
所以有相同的测试

00:18:08.720 --> 00:18:12.000
嗯，编解码器dp格式略有不同，但是有一个

00:18:12.000 --> 00:18:14.880
删除了几个，我想我还认为它们仍在文件中，我只是记下了笔记

00:18:14.880 --> 00:18:18.480
说这不应该是坏的，这样

00:18:18.480 --> 00:18:21.760
紧凑测试是我测试的极限

00:18:21.760 --> 00:18:26.720
去奇迹dag pb做，然后我对什么有意见

00:18:26.720 --> 00:18:31.760
它不应该这样做，并且在go code pv中这样做非常有趣

00:18:31.760 --> 00:18:36.320
很好玩哦，天哪，我刚刚意识到我应该在跟你说话之前

00:18:36.320 --> 00:18:39.440
这是因为我最终完成的桌子基本上是

00:18:39.440 --> 00:18:44.000
无论如何，你拥有的是同一个人

00:18:44.000 --> 00:18:47.280
认为有什么测试，顺便说一下，这些测试是

00:18:47.280 --> 00:18:50.880
也反映在javascript中，所以有三个go实例

00:18:50.880 --> 00:18:56.480
merkle dag pb拥有最轻松和宽广的视野

00:18:56.480 --> 00:19:01.360
好的，嗯，最后一个问题答应了，您认为我应该进行的其他测试

00:19:01.360 --> 00:19:05.039
看一下，因为除了试战之外，我还没有真正找到任何测试

00:19:05.039 --> 00:19:10.720
似乎没什么值得的，迈克尔·达格没事

00:19:10.720 --> 00:19:17.120
嗯ii可以看一看javascript的一面，所以我不会期望很多

00:19:17.120 --> 00:19:21.360
那里很好的测试，但仍然可能对

00:19:21.360 --> 00:19:25.679
看看我怎么办，是的，我可以找出我们是否有测试，或者基本上是这样

00:19:25.679 --> 00:19:28.880
可能我们在unix fs中进行了测试，而不是

00:19:28.880 --> 00:19:33.679
比在dag yeah中是正确的，因为这是东西

00:19:33.679 --> 00:19:35.840
我当时正经历着这个，我只是渴望

00:19:35.840 --> 00:19:39.120
现实世界的数据，就像我从哪里得到

00:19:39.120 --> 00:19:42.480
具有代表性的现实世界数据，而不仅仅是从某人身上随机挑选

00:19:42.480 --> 00:19:45.120
dag好像它不存在，没有被编码在

00:19:45.120 --> 00:19:49.120
测试，这是一个真正的问题，嗯，我最想看到的是什么

00:19:49.120 --> 00:19:53.280
测试所有边缘的真实数据，但没有人真正收集到

00:19:53.280 --> 00:19:58.400
真的很难像一天之类的东西一样收集

00:19:58.400 --> 00:20:01.919
为此真的要做很多研究

00:20:02.000 --> 00:20:08.480
um danielle以防万一

00:20:08.480 --> 00:20:15.280
目前，go编解码器平台pb与javascript相同，并且

00:20:15.280 --> 00:20:18.320
基本上这就是我目前正在努力将新的编解码器纳入其中的工作

00:20:18.320 --> 00:20:22.640
unisfs，以防万一您由于类似边缘情况或

00:20:22.640 --> 00:20:26.000
任何喜欢记笔记的东西，以便我们也可以

00:20:26.000 --> 00:20:28.480
然后更新javascript版本，因为

00:20:28.480 --> 00:20:36.720
是的，嗯，很酷的，是的，所以很好，是的

00:20:36.720 --> 00:20:41.280
不前进，就像是让该区域随时对我执行ping操作一样，所以我不确定

00:20:41.280 --> 00:20:44.480
像是谁负有正式责任，或者像是要ping我，我会

00:20:44.480 --> 00:20:47.919
确保是的，我们在

00:20:47.919 --> 00:20:50.400
javascript

00:20:51.360 --> 00:20:55.039
很酷的呃，我只是想问问呃老鼠，你能澄清一下吗

00:20:55.039 --> 00:20:59.840
当您说出现实世界中的数据时时时彩

00:20:59.840 --> 00:21:06.640
你到底是什么意思，好吧，我的意思是dag pb是最

00:21:06.640 --> 00:21:09.600
在ipfs中使用编解码器，是的，就像其他

00:21:09.600 --> 00:21:14.000
甚至没有写我们想要的那么多的提法

00:21:14.000 --> 00:21:17.760
堤坝的e42，所以这些东西在野外

00:21:17.760 --> 00:21:21.919
被推来推去，呃，撞到了边缘

00:21:21.919 --> 00:21:27.440
我们有这些，我们在装饰方面有一个非常草率的编解码器

00:21:27.440 --> 00:21:31.840
现在，所以在解码上去merkle dagpb

00:21:31.840 --> 00:21:35.919
会不会有很多方法，只是会说

00:21:35.919 --> 00:21:41.039
是的，听起来不错，我会用很酷的，它会解码非常草率的字节

00:21:41.039 --> 00:21:43.919
在最终代码方面，可以预见的是

00:21:43.919 --> 00:21:46.320
结束码，但解码非常独立

00:21:46.320 --> 00:21:49.679
不确定性，因此进入

00:21:49.679 --> 00:21:52.400
规范正在关闭其中一些漏洞并说

00:21:52.400 --> 00:21:56.080
好吧，我们不应该看到这种形式的字节

00:21:56.080 --> 00:22:01.679
嗯，因为我们我看不到我们拥有的编码器

00:22:01.679 --> 00:22:05.919
生产它们，但这是一个非常勇敢的假设

00:22:05.919 --> 00:22:10.559
那些东西不存在，因为还有其他东西

00:22:10.559 --> 00:22:14.480
创建dag pp数据，并且还有很多历史wpb

00:22:14.480 --> 00:22:19.760
仍然存在的数据以及如此真实的世界，这意味着这些pg铅的东西

00:22:19.760 --> 00:22:22.240
那里人们在ipfs上四处走动，这可能

00:22:22.240 --> 00:22:26.799
已经存在了很多年，这限制了我们所做的工作

00:22:26.799 --> 00:22:29.600
但是如何过滤掉并找到有趣的东西，

00:22:29.600 --> 00:22:32.159
代表

00:22:33.200 --> 00:22:35.919
这基本上就是我要问的原因，因为像代表什么

00:22:35.919 --> 00:22:38.559
意思是因为像我一样，你知道我第一次学习的时候

00:22:38.559 --> 00:22:43.919
关于ipfs，我做了很像奇怪的protobuf东西的粪便，

00:22:43.919 --> 00:22:46.720
表示正确，我的意思是它们仍然在github上，您仍然可以像导入它们一样

00:22:46.720 --> 00:22:49.440
之类的东西，但这并不意味着您应该支持他们

00:22:49.440 --> 00:22:52.960
嗯，从这个角度来看，是的，但是现在是的

00:22:52.960 --> 00:22:57.760
它可以回答我的问题，你知道吗

00:22:57.760 --> 00:23:02.559
我忘记了它与哪个子系统有关

00:23:02.559 --> 00:23:08.880
嘴唇内部的p2p完全是基于该pb的protobuf

00:23:08.880 --> 00:23:15.520
没有我们的Unix，我知道那里有一些原型的东西

00:23:15.520 --> 00:23:19.919
我不知道他们使用的是日期铅，但我从来没有加紧努力，我从来没有

00:23:19.919 --> 00:23:23.919
提升到unix fs的水平，这是我打算到达那里的意图

00:23:23.919 --> 00:23:28.400
嗯，因为就像我们做的是这种奇怪的洋葱一样

00:23:28.400 --> 00:23:33.360
用pvp解码嗯是的，请记住

00:23:33.360 --> 00:23:36.559
ii不幸的是，我不记得确切的那个子系统

00:23:36.559 --> 00:23:41.200
是一回事，但是如果是的话，如果他们是你，如果

00:23:41.200 --> 00:23:45.679
他们现在正在使用go代码，因为它甚至都不是javascript代码

00:23:45.679 --> 00:23:49.520
在当前状态下，这说明了规格说明

00:23:49.520 --> 00:23:53.200
现在可以工作了，但是

00:23:53.200 --> 00:23:55.919
ipv很有趣，因为我们正在谈论的是本来可以

00:23:55.919 --> 00:24:00.320
创建于五年前，我很想获得一些

00:24:00.320 --> 00:24:05.200
那些数据，看看里面是否有任何新颖性

00:24:05.200 --> 00:24:09.279
但这不会发生

00:24:11.919 --> 00:24:18.799
诸如此类的数据最终会以某种跨语言的方式出现吗？

00:24:18.799 --> 00:24:24.799
因为我想知道锈ipfs人是否显然有他们的

00:24:24.799 --> 00:24:29.520
自己的dagpb编码器东西，我的意思是我已经看过

00:24:29.520 --> 00:24:33.039
而且我认为我已经修复了一些问题，但是我从来没有真正喜欢过像

00:24:33.039 --> 00:24:35.679
它实际上是如何工作的，或者它是否做正确的事

00:24:35.679 --> 00:24:40.320
嗯，我会认为它可能不会做与其他事情相同的事情

00:24:40.320 --> 00:24:43.200
有人这样做，我想那是有道理的

00:24:43.200 --> 00:24:46.720
因为它们有点像我仍然会尽早考虑它们，所以我认为

00:24:46.720 --> 00:24:50.559
像打破他们的东西应该不算太糟糕

00:24:50.559 --> 00:24:54.240
猜猜，但我想我们也应该将其保留在雷达上，或者像我将其保留

00:24:54.240 --> 00:24:56.799
我们应该也有固定装置的雷达

00:24:56.799 --> 00:25:00.960
让他们看到他们在做什么，我想知道是否有

00:25:00.960 --> 00:25:06.400
浮动的所有旧的um打开奇异的dag文件

00:25:06.400 --> 00:25:09.600
因为他们本来会很早

00:25:09.600 --> 00:25:13.760
dag结构化数据的用户和创建者

00:25:13.760 --> 00:25:19.440
可以用于固定装置，它们可以很好地提供

00:25:19.440 --> 00:25:21.600
现在访问他们已经关闭了

00:25:21.600 --> 00:25:29.039
向下移动一点点我不知道我只是把它扔了

00:25:29.039 --> 00:25:33.679
跨语言测试功能，我将其交给eric

00:25:33.679 --> 00:25:38.240
这是他的责任，现在我的计划是

00:25:38.240 --> 00:25:43.760
我正在努力去达杰森，我想把那个头衔提高，所以我

00:25:43.760 --> 00:25:48.240
然后可以使用追逐（dag chasing）来坐回其他东西，

00:25:48.240 --> 00:25:53.279
在dag jason中表示事物并将其用作测试用例

00:25:53.279 --> 00:26:00.080
围绕um推送其他格式，这是一个循环的事情，但是jason不是

00:26:00.080 --> 00:26:05.679
完全完成它在go ipld prime中不起作用，这还剩下

00:26:05.679 --> 00:26:11.840
现在是地板，但是eric接管了那支警棍

00:26:17.440 --> 00:26:23.120
好的，很酷，是的，我只是想起了我，

00:26:23.120 --> 00:26:27.840
即使在生锈的ipld中，也有一个甲板PB编解码器，我可能应该检查一下

00:26:27.840 --> 00:26:32.799
是的，嗯，酷，什么都可以

00:26:32.799 --> 00:26:39.440
否则让我检查议程，没有任何人有其他任何事情吗

00:26:39.440 --> 00:26:43.120
项目或想要讨论我有的任何东西

00:26:43.120 --> 00:26:48.080
几个问题，是的，所以我有一个问题要问

00:26:48.080 --> 00:26:52.159
eric um about and if

00:26:52.159 --> 00:26:55.200
嗯，迈克尔在这里，我想请他但是

00:26:55.200 --> 00:27:01.279
因此，纺织团队发现自己需要散列一致性排序

00:27:01.279 --> 00:27:06.640
数据结构，我一直在玩它的​​javascript东西

00:27:06.640 --> 00:27:10.960
只是很可爱，实际上是卡盘，我认为迈克尔的矮胖

00:27:10.960 --> 00:27:14.799
树木库是一个很好的实现

00:27:14.799 --> 00:27:18.240
你知道某事的任何go实现吗

00:27:18.240 --> 00:27:21.840
这样，即使我可以继续

00:27:23.679 --> 00:27:27.120
嗯，我不知道我不认为我们已经写了一篇

00:27:27.120 --> 00:27:30.880
我不知道这可能不是很困难

00:27:30.880 --> 00:27:35.120
超级努力，我不，我不认为，所以我的意思是我知道有一个

00:27:35.120 --> 00:27:40.720
在那篇论文中，我将你们链接到呃，我不记得那是什么

00:27:40.720 --> 00:27:44.480
该文件是什么，但无论如何，该文件的实现

00:27:44.480 --> 00:27:49.440
就像已经实施了一些类似的想法，所以我

00:27:49.440 --> 00:27:52.960
猜一堆烂意大利面可以用来做点什么

00:27:52.960 --> 00:27:55.120
兼容，但我只是想知道，因为我们会

00:27:55.120 --> 00:28:00.240
如果我们不存在的话，那就去做

00:28:00.240 --> 00:28:05.679
认为我们当时是迈克尔正在努力巩固一些东西

00:28:05.679 --> 00:28:10.159
喜欢尝试真正达到我们想要的某个终点

00:28:10.159 --> 00:28:14.960
这感觉足够好，然后也许建议去做工作

00:28:14.960 --> 00:28:18.720
提供了它的多种实现

00:28:18.720 --> 00:28:22.880
嗯，那是在迈克尔推我的那一刻搁置的

00:28:22.880 --> 00:28:25.679
以为他是你知道他对ip有兴趣

00:28:25.679 --> 00:28:30.960
续集，他仍然在追求这一点，但是um michael的优先级排序

00:28:30.960 --> 00:28:35.840
改变了很多，我们有些也改变了，所以如果你真的结束了

00:28:35.840 --> 00:28:38.399
进一步追求这一点，如果可以的话，那将是很棒的

00:28:38.399 --> 00:28:43.679
让我们处于循环中，我们也许能够将许多点连接在一起

00:28:43.679 --> 00:28:48.320
不错，是的，我的意思是，如果这样做的话，这将是非常小的事情

00:28:48.320 --> 00:28:51.840
只是为了满足我们的主要需求而实施

00:28:51.840 --> 00:28:55.600
它可以为其他事物提供一些基准

00:28:55.600 --> 00:28:58.799
因为最终它最终可能会变成一个非常懒惰的数据

00:28:58.799 --> 00:29:03.440
我们需要的结构，所以它会很小

00:29:03.440 --> 00:29:07.200
就像拿一些数据算出

00:29:07.200 --> 00:29:09.919
它属于的树，然后就这样，直到我们永远

00:29:09.919 --> 00:29:16.080
必须去，但无论如何还是有用的

00:29:16.159 --> 00:29:21.600
是的，所以我们最近对大麻做了一些新的实施

00:29:21.600 --> 00:29:25.600
东西，所以它也是一棵哈希树，但不是

00:29:25.600 --> 00:29:29.679
这几乎与排序正确相反，因此可能不是确切的实现

00:29:29.679 --> 00:29:32.880
您想要嗯，但我们正在努力其中之一

00:29:32.880 --> 00:29:35.200
真的是最近，丹尼实际上只是

00:29:35.200 --> 00:29:39.440
包上一堆东西，所以很可能会

00:29:39.440 --> 00:29:42.240
也是我们如何做的一个很好的例子

00:29:42.240 --> 00:29:47.919
然后再执行分片逻辑，我敢肯定会做到这一点

00:29:47.919 --> 00:29:52.159
不同，但其他类似的代码组织可能会很多

00:29:52.159 --> 00:29:55.520
非常可重用，因此可能会有所帮助哦，那将非常有帮助

00:29:55.520 --> 00:29:58.640
我应该在哪里找那个

00:29:58.640 --> 00:30:06.240
嗯，我认为是github.com ipld破折号adl-hampt或其他东西

00:30:06.240 --> 00:30:09.679
假设我们的命名方案是

00:30:09.679 --> 00:30:12.240
持续的

00:30:14.000 --> 00:30:20.799
这不是我猜错了，我们会在某个地方找到它

00:30:41.360 --> 00:30:45.760
太好了，那将非常有帮助嗯

00:30:45.760 --> 00:30:50.000
然后我的另一个问题更多是评论

00:30:50.000 --> 00:30:53.440
我所说的实际上是评论形式的问题

00:30:53.440 --> 00:30:56.240
通常你会在会议上和别人假装的东西上让他们

00:30:56.240 --> 00:31:00.799
问一个问题，但实际上是对某事发表一些评论

00:31:00.799 --> 00:31:04.240
你介绍了，但是我只想提一提

00:31:04.240 --> 00:31:08.720
可能有一些现实世界中的凯西

00:31:08.720 --> 00:31:14.080
在某些最初我们编写了javascript的类型中输入hack

00:31:14.080 --> 00:31:21.039
名为ipfs lite um的实现，现在已迁移到

00:31:21.039 --> 00:31:26.080
一些ipfs存储库，它的名称就像ipl ipfs

00:31:26.880 --> 00:31:32.240
我认为是dag服务，在某些测试中，有一堆非常丑陋的东西

00:31:32.240 --> 00:31:36.880
讨厌的东西使一些块API的东西

00:31:36.880 --> 00:31:45.120
与Unix FS读写器等旧版UM一起工作

00:31:45.120 --> 00:31:48.640
嗯，现在有点过时了，但是可能

00:31:48.640 --> 00:31:51.760
好像不是最新的多格式js内容

00:31:51.760 --> 00:31:57.679
但可能会有一些评论，例如请注意，这是因为

00:31:57.679 --> 00:32:03.600
诸如库之类的cid与那些注释之间的不兼容性可能是

00:32:03.600 --> 00:32:09.519
有价值，所以只想指出一点

00:32:10.880 --> 00:32:15.519
也有点像那个界面

00:32:15.519 --> 00:32:23.519
我刚刚最近重做了，嗯，我有点希望ipfs js ipfs

00:32:23.519 --> 00:32:28.399
以这种可组合的方式构建了他们喜欢的dag服务，以便您

00:32:28.399 --> 00:32:35.120
可以换一个um，所以如果你在那儿乱糟糟的

00:32:35.120 --> 00:32:38.320
嗯，喜欢做那个真是太好了

00:32:38.320 --> 00:32:42.720
dag解析器更可插入，只是一个建议

00:32:42.720 --> 00:32:48.799
因为我知道莱克利也需要他的一些工作

00:32:48.799 --> 00:32:51.279
所以[音乐]

00:32:51.279 --> 00:32:54.159
那是我的评论

00:32:54.399 --> 00:32:59.840
我们提议进行某些工作的任务之一是

00:32:59.840 --> 00:33:02.480
使整个事情变得更容易组合

00:33:02.480 --> 00:33:05.519
只是让我们停止做这堆巨石而已

00:33:05.519 --> 00:33:08.640
这样，您就可以利用自己关心的有用信息

00:33:08.640 --> 00:33:10.880
为您的应用程序然后将它们拼凑在一起

00:33:10.880 --> 00:33:15.039
是的，这是我们很多人真正的理想

00:33:15.039 --> 00:33:18.399
真的很想瞄准，但是在那方面有很多工作

00:33:18.399 --> 00:33:23.120
我们必须确保与其他所有事项相比，这是合法的优先事项

00:33:23.120 --> 00:33:26.000
我们本可以做对的事情，但这确实是很多反馈，

00:33:26.000 --> 00:33:28.880
也许我应该把它记下来，以便为您提供咨询服务

00:33:28.880 --> 00:33:32.480
这个难题的最大部分是，您说的很好的dag服务是

00:33:32.480 --> 00:33:37.519
之所以如此庞大，是因为它包含了您实际上只真正拥有的许多东西

00:33:37.519 --> 00:33:41.840
需要ipfs在类似轻量级的浏览器环境中执行操作，我需要获取一些

00:33:41.840 --> 00:33:45.120
小伙子们拉在一起，展示一些东西

00:33:45.120 --> 00:33:48.799
对你来说，我所需要的就像访问一个

00:33:48.799 --> 00:33:53.279
块存储和我住p2p主机和dag服务，

00:33:53.279 --> 00:33:55.760
知道如何应对这些，仅此而已

00:33:55.760 --> 00:33:59.760
我不需要固定api我不需要您知道ipns

00:33:59.760 --> 00:34:03.600
我不需要pub sub我不需要像所有这些其他子模块一样

00:34:03.600 --> 00:34:05.840
拿一半的时间我不

00:34:05.840 --> 00:34:08.559
甚至需要把它

00:34:08.720 --> 00:34:11.839
所以就像我几乎不需要

00:34:11.839 --> 00:34:15.359
你知道我需要最小限度的交换，然后

00:34:15.359 --> 00:34:19.040
就像额外的奖金一样，是我将其拉开的原因之一，

00:34:19.040 --> 00:34:22.800
重建我们自己的是因为我们想要一个图而不是位交换

00:34:22.800 --> 00:34:27.679
同步到图沉没类型uh协议，因为

00:34:27.679 --> 00:34:32.639
我们的两个同伴，我们知道他们正在跟踪相同的dag，因此

00:34:32.639 --> 00:34:36.800
像更一般的位交换一样没有意义，他们可能也只是

00:34:36.800 --> 00:34:40.879
一起进行同步，因此能够像这些组件一样进行交换

00:34:40.879 --> 00:34:49.839
显然也很好

00:34:50.720 --> 00:34:53.919
很酷，是的，这种事情已经

00:34:53.919 --> 00:34:57.440
自从我加入协议实验室并从事ipld工作以来，就在我的议程上

00:34:57.440 --> 00:35:01.119
就像哦，我只是需要ipld而我不需要所有这些

00:35:01.119 --> 00:35:05.200
ipfs只是网络存储ipld

00:35:05.200 --> 00:35:11.920
但是，是的，所以最终我们会看到

00:35:11.920 --> 00:35:17.839
嗯，酷，还有其他

00:35:19.520 --> 00:35:26.880
不，那么谢谢大家的参与，下周再见

