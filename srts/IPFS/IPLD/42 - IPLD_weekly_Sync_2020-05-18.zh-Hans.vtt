WEBVTT
Kind: captions
Language: zh-Hans

00:00:17.090 --> 00:00:28.590
欢迎大家参加本周的IPL同步会议，也许是2020年18日，

00:00:28.590 --> 00:00:33.600
每周我们都会回顾过去一周中所做的事情，然后

00:00:33.600 --> 00:00:42.360
这有我们可能遇到的未解决的问题，或者可以回答问题，依此类推，我

00:00:42.360 --> 00:00:48.030
需要打开支付的鸡蛋，是的，所以我从我自己做的事情开始，

00:00:48.030 --> 00:00:58.590
我们将在剩下的内容中继续这样做，我只保留了指向另一个链接的链接。

00:00:58.590 --> 00:01:05.600
锈IPL D的实现，这很有趣，因为它正在使用

00:01:05.600 --> 00:01:14.039
进行文明调查，但是从与做这件事的人交谈开始，

00:01:14.039 --> 00:01:18.119
确实做得很好，所以我仍然需要更仔细地检查一下，但是

00:01:18.119 --> 00:01:22.580
这只是一种不同的方法，是的，请随时检查一下我

00:01:22.580 --> 00:01:30.630
肯定会仔细看看，除了我还没做过

00:01:30.630 --> 00:01:38.220
过去一周内，很多iPad都在工作，大部分时间是FICO，其他东西和坏东西

00:01:38.220 --> 00:01:45.210
正如克里斯所承诺的那样，我已经查看了图表，看到了东西以及

00:01:45.210 --> 00:01:54.990
状态如此之远，据我所知，它实际上只有东西

00:01:54.990 --> 00:01:59.159
在锈病世界的早期进行，而且似乎还有更多的聚会

00:01:59.159 --> 00:02:03.869
感兴趣，但现在它真的可以归结为写信的人的安全链

00:02:03.869 --> 00:02:10.110
当一个叫做森林工作的排列在

00:02:10.110 --> 00:02:13.380
选择器，现在继续进行嫁接工作，这样将会有质朴的选择

00:02:13.380 --> 00:02:19.380
种植工艺品墨水，然后在我没有或没有的笔录上

00:02:19.380 --> 00:02:26.070
所以是的，基本上就是这样，当很多人兴奋和开始时，它就开始了

00:02:26.070 --> 00:02:29.250
想做点什么，现在基本上只是一个

00:02:29.250 --> 00:02:36.480
模仿，似乎是的，但是如果我听到其他声音，我当然会更新

00:02:36.480 --> 00:02:40.560
您在这一个上，但它可能仍然很有趣

00:02:40.560 --> 00:02:45.780
与这些人一起退房，因为他们可能还会

00:02:45.780 --> 00:02:51.570
找到问题或有趣的事情，是的，我也期望甚至

00:02:51.570 --> 00:02:54.270
如果我们有一个规范，它可能会改变

00:02:54.270 --> 00:03:03.600
我们会看到我可以问一个问题吗

00:03:03.600 --> 00:03:11.100
是的，您好，我可以像参加锈蚀蟹槽的工作一样好

00:03:11.100 --> 00:03:16.500
或这些监视，因此，如果有独立会议或每周下沉会议

00:03:16.500 --> 00:03:26.040
我可以加入其中，或者是私人的，或者没有串珠的东西

00:03:26.040 --> 00:03:32.340
所以就像我们只是喜欢，因为他们可能会考虑在5个硬币上这样做，所以

00:03:32.340 --> 00:03:36.870
因此，他们不是这样，所以他们对集成不感兴趣

00:03:36.870 --> 00:03:42.150
我承认他们只是在玩东西的时候才打架，所以我希望例如

00:03:42.150 --> 00:03:46.440
[音乐]渴望矩阵对ipfs感兴趣

00:03:46.440 --> 00:03:50.100
我想他是，但我还没有收到他的回音，所以我希望

00:03:50.100 --> 00:03:54.120
基本上他会有点向外看，就像你的激光ipfs和

00:03:54.120 --> 00:03:58.110
确保它也可以在那里工作，但我不知道我能告诉我们，所以您只能这样做

00:03:58.110 --> 00:04:02.040
真的以为发生的机会就是，如果人们和他们基本做到了

00:04:02.040 --> 00:04:07.709
这样，如果他们有问题，他们只会问随机的人，这主要是

00:04:07.709 --> 00:04:15.390
它真的没有类似的结构化方式来处理它

00:04:15.390 --> 00:04:19.109
是的，他们将开放源代码，他们的图表会考虑关闭的关系

00:04:19.109 --> 00:04:25.200
资料来源不像他们在露天工作，所以就像所有这些东西都是露天的一样

00:04:25.200 --> 00:04:30.150
有没有收割者的链接，您可以提供，是的，我可以

00:04:30.150 --> 00:04:33.330
放在便签上，就像在他们的纤维邀请函上一样

00:04:33.330 --> 00:04:36.540
所以它不是单独的存储库，而是在他们的fyke白色东西上

00:04:36.540 --> 00:04:44.850
将在其中解释为什么我可能不增加大量会议

00:04:44.850 --> 00:04:48.569
他们正在围绕这一过程做这个非常具体的目标

00:04:48.569 --> 00:04:56.639
像一个回购协议一样，也许还可以，我的意思是我很了解

00:04:56.639 --> 00:05:01.740
事情似乎在哪里，我似乎需要对此​​有所了解

00:05:01.740 --> 00:05:07.800
一点点，但是我想沃尔克如果人们回来了，你知道正在尝试

00:05:07.800 --> 00:05:14.039
用图Sinkin ipfs或其他任何让我知道我在做的事情做更多的事情

00:05:14.039 --> 00:05:19.259
有兴趣帮我，我只是不知道我不知道我进步了多少

00:05:19.259 --> 00:05:27.780
我想我自己没有人可以跟我聊天，所以我不知道你是否看过一些

00:05:27.780 --> 00:05:32.430
这些讨论和IRC总的来说，但是我们确实有一堆

00:05:32.430 --> 00:05:35.580
认为是同一项目的某人也非常担心

00:05:35.580 --> 00:05:39.810
确保您的测试装置是从选择器部分出来的

00:05:39.810 --> 00:05:45.599
绘图的重要先决条件，我不记得我们是否

00:05:45.599 --> 00:05:50.009
那些被拉到另一个仓库中的人，或者如果他们已经准备好了，但是有

00:05:50.009 --> 00:05:54.750
我们讨论过的一堆不错的JSON规范文件，例如super

00:05:54.750 --> 00:05:59.969
用于定义选择器应该做什么的文字向量，我真的

00:05:59.969 --> 00:06:03.479
如果他们不是另一个仓库，他们会很兴奋，但是您可以复制

00:06:03.479 --> 00:06:09.360
贴上它们，然后不戳那个人和IRC，我正打算改造一个

00:06:09.360 --> 00:06:14.009
一堆正在进行的测试也要使用它们，因为它们是更好的选择

00:06:14.009 --> 00:06:25.740
格式比我现在进行的手柄测试还好，谢谢小

00:06:25.740 --> 00:06:30.419
胜利好吧，我应该继续说下去吗，是的，我希望太阳不会

00:06:30.419 --> 00:06:34.430
只是因为那是指向测试向量存储库的链接

00:06:34.430 --> 00:06:42.300
是的，是的，所以请继续埃里克，我可以测试任何安全的斜线

00:06:42.300 --> 00:06:45.539
是我的屏幕区域之外的东西，是的，很酷，很好，

00:06:45.539 --> 00:06:52.500
存在，所以本周除了自我报告之外，我没有更多的事情要报告了

00:06:52.500 --> 00:06:56.989
这样的讨论仍在继续，而且真的很棒

00:06:56.989 --> 00:07:04.739
最近需要担心的技术性事情，这很有趣，上坡是最好的

00:07:04.739 --> 00:07:08.279
开始萌芽并更改长文档，现在知道这可能是

00:07:08.279 --> 00:07:12.749
早该发布足够多的标签了，现在我不记得了

00:07:12.749 --> 00:07:19.739
他们的意思是，所以我开始做笔记，并提出一些累积的计划，

00:07:19.739 --> 00:07:24.929
他们正在尝试改变一些意图，

00:07:24.929 --> 00:07:29.219
更改之前需要从消费者那里进行任何形式的重构

00:07:29.219 --> 00:07:33.299
我只是把它们扔掉了，所以这份文件至少要到现在为止，但是

00:07:33.299 --> 00:07:46.469
是的，这些树木的地方我和是的，谢谢，我做的太多了

00:07:46.469 --> 00:07:55.739
事情在同一时间，哦，我从强尼那里看到了事情，是的，你怎么样

00:07:55.739 --> 00:08:00.779
也所以我一直在C孔工作，订购了出租车板，特别是

00:08:00.779 --> 00:08:07.499
与COE签署事物是一种超级签署，所以我想我在其中加入了一个链接

00:08:07.499 --> 00:08:11.039
这是我正在使用分散标识符处的di D进行的工作

00:08:11.039 --> 00:08:18.779
规范，所以我在IP ID上使用IP LD，因此IP创意基本上将其发布

00:08:18.779 --> 00:08:24.659
IP LD作为特定格式的文档，其中包含密钥

00:08:24.659 --> 00:08:29.759
IP NS名称空间的加密密钥，然后基本上是

00:08:29.759 --> 00:08:35.550
格式化了：IP ID：和到现在基本上是公钥的哈希

00:08:35.550 --> 00:08:38.789
您的标识符，因此大部分工作正在进行中

00:08:38.789 --> 00:08:44.069
关于解决不同的方法之间的问题，我当然认为您

00:08:44.069 --> 00:08:47.910
知道dag c4 aka IP LD是一种更好的方法，但实际上

00:08:47.910 --> 00:08:52.050
我需要将其纳入核心规范中，所以我有一个积极的方向

00:08:52.050 --> 00:08:58.709
请求，并且主要围绕本地人看到的代表不佳

00:08:58.709 --> 00:09:04.410
然后，实际上更具体的dag看到了更多的表示形式，即IP LD和

00:09:04.410 --> 00:09:08.519
我现在唯一真正遇到的问题是，我之前提到过

00:09:08.519 --> 00:09:12.470
几个月前就是这样，您可以剥离其他所有其他标签

00:09:12.470 --> 00:09:19.790
而不是标签42，那么它破坏了看板舒适的能力

00:09:19.790 --> 00:09:25.790
标签98带有嵌入标签中的语义类型进行签名，我仍然

00:09:25.790 --> 00:09:29.059
有点挣扎着我们，也许有办法解决这个问题

00:09:29.059 --> 00:09:34.730
基本上是在牌组Ybor之外签署东西，并且不使用标签，但是如果

00:09:34.730 --> 00:09:38.319
您有机会做的请阅读我的请求请求，我希望收到任何反馈

00:09:38.319 --> 00:09:42.740
这建立在我正在处理该纸上以重新启动

00:09:42.740 --> 00:09:46.389
相信阿根廷从未发生过

00:09:49.689 --> 00:09:54.740
如果您要完全制作新的编解码器，则可以设置全新的规则，例如

00:09:54.740 --> 00:10:01.699
好吧，不必是Dec Zeebo，也可以是de Jose与某人建立关系

00:10:01.699 --> 00:10:05.959
出租车牌，但关于标签的规则不同，是的，我想我们实际上提到了

00:10:05.959 --> 00:10:09.470
几周前基本上是这样，实际上我认为

00:10:09.470 --> 00:10:16.220
可能是Comeau的编解码器，可以使您在工作中感到舒适，所以您知道一些

00:10:16.220 --> 00:10:19.459
虽然他们合并在桌子上，我想他们会

00:10:19.459 --> 00:10:24.829
我很发声，所以我们有出租车去坐那辆过山车

00:10:24.829 --> 00:10:34.040
是的，非常好，那是我需要的，是的，所以如果我加入不是的电话

00:10:34.040 --> 00:10:40.069
你是约翰尼吗，那是其他人，所以他们在这里重叠了

00:10:40.069 --> 00:10:44.720
我知道，所以三个盒子的人实际上也在接这个

00:10:44.720 --> 00:10:49.610
dag签约dag Seaguar的想法很温馨，所以我已经看到很多

00:10:49.610 --> 00:10:55.699
这样，这样就产生了信任的先前重新启动名称，我

00:10:55.699 --> 00:10:59.600
实际谈到IP OD是本机格式，以及我们实际上是如何做的

00:10:59.600 --> 00:11:04.370
这个和克里斯蒂安·菲茨和我实际上是一起写了一篇论文，

00:11:04.370 --> 00:11:10.959
多伦多会议，那是我想迁移到的三个方框

00:11:13.889 --> 00:11:23.139
是的，所以现在有用于编解码器舒适的编解码器，他们选择了您，但是您还是选择了

00:11:23.139 --> 00:11:28.660
念给他们听，所以对于Seaboard来说，是的，这是完美的

00:11:28.660 --> 00:11:34.779
完全正确需要的东西我们还没有关于这些东西的任何规格，所以我

00:11:34.779 --> 00:11:40.420
猜是的，所以如果有人愿意，因为我猜是这样，据我所知

00:11:40.420 --> 00:11:51.269
基本上主要是西伯利亚，加上这笔额外的嘿奖金

00:11:51.269 --> 00:11:58.179
豪言壮语，但正如烂话所说，你可以想出任何办法

00:11:58.179 --> 00:12:03.879
因此，例如，您也可以允许其他所有内容，哦，是的，然后

00:12:03.879 --> 00:12:06.730
我实际上基本上只是拼写出来的文章看到了无聊和

00:12:06.730 --> 00:12:11.799
用于标记的语义类型，但在其下方实际上添加了一个部分作为

00:12:11.799 --> 00:12:15.970
据dag所知，bar是Seaborg和我的一种更受约束的风味

00:12:15.970 --> 00:12:22.419
我想我特别指出了实例键不能满足的所有约束

00:12:22.419 --> 00:12:27.809
是整数，它们只能是字符串中的确定性顺序

00:12:27.809 --> 00:12:35.860
表示法和唯一使用标记的42来拖延战争，但我会

00:12:35.860 --> 00:12:40.299
我希望确保就我所知，我没有遗漏任何东西

00:12:40.299 --> 00:12:48.489
点只能是编码的64位，所以我就可以

00:12:48.489 --> 00:12:51.669
请仔细阅读以确保我不会错过任何较难的约束条件

00:12:51.669 --> 00:12:56.679
实际上会使它具体用于dag看到更多的浮点是一个棘手的问题

00:12:56.679 --> 00:13:03.189
因为目前我们需要定义两个不同的规则，而我

00:13:03.189 --> 00:13:07.660
想想如果我只是说如果你基本上我们只是说所有浮点数

00:13:07.660 --> 00:13:13.059
将是64位，我认为这可以解决问题，但请告诉我是否不是

00:13:13.059 --> 00:13:17.379
情况就是这样，所以目前不会，因为javascript会做的很小

00:13:17.379 --> 00:13:23.259
可能并且go将执行64位操作，这就是我们必须解决的差异

00:13:23.259 --> 00:13:27.670
与甲板西摩，我们还没想到我们没有

00:13:27.670 --> 00:13:35.430
决定了我们将要跌倒的那个方向，因为我们真的很奇怪

00:13:36.870 --> 00:13:41.800
实际上不相信这是正确的，只是很明显

00:13:41.800 --> 00:13:49.330
一切都很好，是的，我们现在基本上是与

00:13:49.330 --> 00:13:55.030
dag看到男孩子不做花车，这是尖峰，我认为文件没有

00:13:55.030 --> 00:13:58.600
需要浮点数，实际上它实际上只是加密密钥材料，

00:13:58.600 --> 00:14:02.950
我认为对我来说真的不是那么紧急

00:14:02.950 --> 00:14:08.400
但我认为，如果我实际上暂时拥有一些东西，

00:14:08.400 --> 00:14:13.080
我认为这会给我足够的帮助，我应该得到贴纸

00:14:13.080 --> 00:14:19.650
因此，这取决于您使用的是哪种语言在大多数情况下，我会生锈

00:14:19.650 --> 00:14:27.700
是的，我现在可能仍然坚持使用64位的go版本，我想我们会

00:14:27.700 --> 00:14:31.780
如果我们做出不同的决定，别忘了润滑你

00:14:31.780 --> 00:14:41.590
在更好的方式上，我尝试做出一个决定，只是改用Nvidia新产品

00:14:41.590 --> 00:14:47.800
东西，您知道便利准备就绪的宝贝，新的洪水形式来自

00:14:47.800 --> 00:14:58.210
英伟达实际上产生了我碰到的那个东西，我也在做一些机器学习

00:14:58.210 --> 00:15:04.300
东西和NVIDIA我有较旧的显卡，因此实际上就像自动

00:15:04.300 --> 00:15:24.190
转换为32基，国米完全把我搞砸了，是的，是的，我想我是

00:15:24.190 --> 00:15:28.870
只是要在这里记一个便笺，然后从我的脑海中弄出来

00:15:28.870 --> 00:15:34.920
回想一下我今天想谈的要点

00:15:41.220 --> 00:15:50.350
好吧，所以我一直在做这个比特币的事情，随着我的进步，我继续前进

00:15:50.350 --> 00:15:59.320
在思考这一切是为了消费这是什么，但它是为了存档

00:15:59.320 --> 00:16:05.590
目的真的是说我们可以拿走比特币区块链并保存

00:16:05.590 --> 00:16:15.520
它以您所知的形式永久存在于内容寻址表中，因此这意味着

00:16:15.520 --> 00:16:21.940
这不仅仅是一个让我们做一些实用的项目

00:16:21.940 --> 00:16:26.650
使它在整个区块链上都可行，所以我已经做到了，但是我

00:16:26.650 --> 00:16:32.110
在处理整个区块链时继续前进，继续寻找独角兽

00:16:32.110 --> 00:16:39.700
暴露出来，然后打破我所做的假设，并且

00:16:39.700 --> 00:16:45.010
那里有些棘手的东西是我必须做的

00:16:45.010 --> 00:16:50.440
的决定我不介意备份，因为那里有很多

00:16:50.440 --> 00:16:55.210
关于内容寻址的一些哲学方面，我觉得

00:16:55.210 --> 00:17:04.060
就像我需要的，我需要与他人分享一些知识，因此，第一个

00:17:04.060 --> 00:17:10.589
首先要解决的主要问题是为什么要把它拆散

00:17:10.589 --> 00:17:16.870
因此，比特币会在您解决这些问题的意义上阻止我们处理的内容

00:17:16.870 --> 00:17:25.600
通过哈希将其阻止，然后您可以通过哈希在其系统中查找它们，但是

00:17:25.600 --> 00:17:30.880
我不知道的哈希只是纯哈希，它是一个双字符

00:17:30.880 --> 00:17:36.250
所有这些的前80个字节中有256个，然后您就拥有了

00:17:36.250 --> 00:17:41.800
块本身内的dag结构，其中任何80个字节都包含一个哈希

00:17:41.800 --> 00:17:47.330
哈希交易的二叉树Merkle树

00:17:47.330 --> 00:17:51.450
有一种方法可以采取，您可以说

00:17:51.450 --> 00:17:59.159
比特币块的构建是一个哈希，这就是我们所说的哈希

00:17:59.159 --> 00:18:05.429
函数，因此即使它可能是256的char，我们也可以使用该顶级哈希

00:18:05.429 --> 00:18:10.320
可以说很好，它实际上是比特币哈希，并且它对整个哈希表进行哈希处理

00:18:10.320 --> 00:18:15.539
阻止，所以这是您可以说的一种方法，但似乎并非如此

00:18:15.539 --> 00:18:19.889
令人满意的，因为那确实超出了我们所能做的限制

00:18:19.889 --> 00:18:26.490
调用哈希函数，但是您知道什么是哈希函数

00:18:26.490 --> 00:18:29.669
最近，我们正在寻找一些用于文件清洁的东西以及房子的用途

00:18:29.669 --> 00:18:37.320
补丁函数所谓的哈希函数的边界是什么，所以如果

00:18:37.320 --> 00:18:40.559
我们采用说的方法，让我们说我们想把它拆开

00:18:40.559 --> 00:18:48.740
进入内容地址块，其中内容地址是

00:18:48.740 --> 00:18:57.690
将Shire倍增至块的256哈希值，这是因为比特币使用了

00:18:57.690 --> 00:19:01.799
如果您使用相同的地址来解决这些块，它将在内部执行

00:19:01.799 --> 00:19:06.600
算法来修饰所有这些块，所以这是一个标准的比特币块

00:19:06.600 --> 00:19:11.880
比特币区块的老式简单版本，您可以在其中

00:19:11.880 --> 00:19:15.870
标头已解决，因此您可以将其拉成一块，然后

00:19:15.870 --> 00:19:21.210
得到了这个像树一样的IPL D结构，您可以在其中吃一个链接

00:19:21.210 --> 00:19:26.669
另一个是默克尔，从某种意义上说，这东西与所有

00:19:26.669 --> 00:19:34.769
本身的其他部分在一个封闭的单元中，因此链接到该单元的头

00:19:34.769 --> 00:19:42.419
二进制奇迹树的根，然后在其中，或者遍历节点，然后

00:19:42.419 --> 00:19:48.919
获取包含这些交易ID的基础，

00:19:48.919 --> 00:19:57.120
 wg6各个交易的哈希，因此您可以遍历

00:19:57.120 --> 00:20:00.360
本身会阻止，但不会存储二进制形式的比特币块

00:20:00.360 --> 00:20:04.740
所有的树中间结构都是隐式的，因为所有字节都是

00:20:04.740 --> 00:20:09.890
在那里，您可以对其进行逆向工程，以便在那里存在，但我正在做的是

00:20:09.890 --> 00:20:13.710
将它们视为块，所以我要为它们创建块，然后

00:20:13.710 --> 00:20:17.570
存储它们，他们知道64字节长，因为两个哈希值放在一起

00:20:17.570 --> 00:20:22.980
所以我得到了这棵64字节的块树，然后您实际上可以

00:20:22.980 --> 00:20:29.309
使用IP LD工具浏览它，您可以像对待它一样对待它

00:20:29.309 --> 00:20:34.650
所有其他IP LD东西，除了不是我们正常的dag形式，所以您

00:20:34.650 --> 00:20:39.000
不喜欢在其中对任意类型进行排序，但是您可以将其解码为

00:20:39.000 --> 00:20:44.970
您将要为我们的建筑设计相同的结构，所以这里有

00:20:44.970 --> 00:20:50.850
一堆假设让我很高兴能进攻，但是

00:20:50.850 --> 00:20:58.470
那是最高级别，然后被隔离开来，把事情搞砸了

00:20:58.470 --> 00:21:02.700
因为segue正在解决这个问题，人们正在使用证人数据

00:21:02.700 --> 00:21:05.970
内部交易以非传统方式修改交易

00:21:05.970 --> 00:21:12.150
健康的采矿者基本上是在滥用结构，因此他们

00:21:12.150 --> 00:21:17.070
说得好，让我们从该顶级中删除见证人数据，然后打包

00:21:17.070 --> 00:21:22.080
它变成了另一种结构，实际上，这意味着

00:21:22.080 --> 00:21:30.150
块是相同的，但内部包含不同的内容

00:21:30.150 --> 00:21:35.360
地址结构，如果您要分解它，我们最终得到的是

00:21:35.570 --> 00:21:43.410
是这里，我们有两个内部二叉树Merkle树，所以我们仍然有

00:21:43.410 --> 00:21:48.570
第一个，但第一个仅与我们的交易哈希

00:21:48.570 --> 00:21:53.490
见证数据，以便建立第一个默克尔结构并获得TX Mochel

00:21:53.490 --> 00:21:57.780
根，您将所有交易取走，将证人数据从哈希中删除

00:21:57.780 --> 00:22:02.280
他们，然后您获得他们的TX ID，这就是您看到的TX ID

00:22:02.280 --> 00:22:07.350
要去一个区块链资源管理器并搜索您的特定交易

00:22:07.350 --> 00:22:12.300
可以使用第一个级别的TX ID，但随后的见证数据是

00:22:12.300 --> 00:22:15.540
附加，并通过对

00:22:15.540 --> 00:22:20.010
使用见证数据进行交易，然后是交易哈希，因此他们

00:22:20.010 --> 00:22:23.340
得到了TX ID和TX哈希两个不同的东西

00:22:23.340 --> 00:22:27.900
有见证人的人没有见证人的人，并不是每笔交易都会

00:22:27.900 --> 00:22:33.060
拥有见证人数据，因此在很多情况下这两件事都是相同的

00:22:33.060 --> 00:22:37.710
交易，随着时间的推移，越来越多的交易拥有见证数据，因此我们可以看到

00:22:37.710 --> 00:22:46.500
越来越多的差异，因此，如果要创建这种结构，该怎么办

00:22:46.500 --> 00:22:50.730
这两个树都隐含在块中，如果我们将它们拔出，

00:22:50.730 --> 00:22:55.560
为它们创建单独的IP LD块，然后您会得到这种双重结构，其中

00:22:55.560 --> 00:22:59.850
要进入第二个交易，您必须完成第一笔交易

00:22:59.850 --> 00:23:06.530
coinbase，那里有一个包含38个字节的小字段

00:23:06.530 --> 00:23:14.220
以特殊的6个字节为前缀的字符串，然后剩余的32个字节为

00:23:14.220 --> 00:23:23.340
散列，并且该散列属于第二个结构的标题，而不是

00:23:23.340 --> 00:23:28.590
相当默克尔根的头部，但它也包含了一部分

00:23:28.590 --> 00:23:31.950
当您重建非性爱获得的块的二进制形式时

00:23:31.950 --> 00:23:36.180
重新连接到硬币底座，因此如果您将其哈希两次，硬币底座本身

00:23:36.180 --> 00:23:40.980
有无证人数据，它会有不同的哈希值，因为它有

00:23:40.980 --> 00:23:46.470
目击者以这种随机数的形式见证了一切，因为那是

00:23:46.470 --> 00:23:50.640
一种自我参照的东西，硬币基数在此秒内没有出现

00:23:50.640 --> 00:23:55.500
默克尔树，因此您可以看到这里的第一个条目只是一个空帽子

00:23:55.500 --> 00:24:00.720
只是零，所以硬币底座会出现一次，但是它确实有见证

00:24:00.720 --> 00:24:07.590
您必须先从此处检索的数据，然后再进行一些交易

00:24:07.590 --> 00:24:14.010
只能从此默克尔树的底部寻址完整格式，但是

00:24:14.010 --> 00:24:18.300
其他人将两者都出现，所以一旦没有交易

00:24:18.300 --> 00:24:21.840
见证它的外观，它们的TX ID和其哈希值是相同的

00:24:21.840 --> 00:24:25.730
因此它们将在这两个默克尔结构中均出现

00:24:25.730 --> 00:24:30.270
这也意味着您将在内部重复一些

00:24:30.270 --> 00:24:34.110
该二进制Merkle树的块，所以您可以看到我在这里标记了这些块6

00:24:34.110 --> 00:24:39.240
 ＆6是相同的，因为这只是一回事，所以您一定会得到

00:24:39.240 --> 00:24:44.750
通过重复结构的这些部分而发生的这种压实

00:24:45.080 --> 00:24:52.159
因此，当您尝试

00:24:52.159 --> 00:24:59.250
将比特币分解为您不愿意的内容地址结构

00:24:59.250 --> 00:25:06.380
说比特币块编码算法本身就是一个哈希函数

00:25:06.380 --> 00:25:12.360
哪个有效，所以我已经全部工作了，尽管我正在分解

00:25:12.360 --> 00:25:17.490
区块链进入这些东西，并且大多数情况下都很好用，但事实证明

00:25:17.490 --> 00:25:23.220
有很多独角兽打破了我非常有趣的假设

00:25:23.220 --> 00:25:28.409
到目前为止，我不得不处理它确实破坏了其中一些

00:25:28.409 --> 00:25:39.029
接近其中之一是硬币基部中的这个38字节的小字符串，

00:25:39.029 --> 00:25:44.179
说啊，这是一个Sigrid街区，您将不得不导航到另一个

00:25:44.179 --> 00:25:52.470
其他二叉树Merkle树来获取某些交易的真实形式

00:25:52.470 --> 00:25:56.730
确实在秘密之前先露面，因为它不是非标准的

00:25:56.730 --> 00:26:03.090
有人曾经说过在某些交易中被滥用的字符串，并且它们出现了

00:26:03.090 --> 00:26:11.940
在搜索之前，您可以在不是段的块中找到该字符串，因此当

00:26:11.940 --> 00:26:16.770
当您解析这些块时，您就变成了一个新池塘

00:26:16.770 --> 00:26:20.640
导航，所以我要做的就是重组整个比特币区块时

00:26:20.640 --> 00:26:24.630
将从标题一直导航到TX扑克，一直向下到

00:26:24.630 --> 00:26:30.659
那个二叉奇迹树得到了硬币的基础，然后说这是一个秘密块

00:26:30.659 --> 00:26:34.860
如果是的话，我要去第二次默克尔拿走所有的交易

00:26:34.860 --> 00:26:37.770
比第一个结构要好，因为我知道

00:26:37.770 --> 00:26:43.049
那里的每个基地的完整形式将在那里，但当您到达

00:26:43.049 --> 00:26:47.370
硬币基，然后对其进行解码，您将获得一个IPL变形器，其中包含一个

00:26:47.370 --> 00:26:55.919
对这个见证人承诺事物的CID有很多地方可以创建一个

00:26:55.919 --> 00:27:02.130
CID指向什么都没有，因为不是它不存在，也没有办法

00:27:02.130 --> 00:27:05.370
知道何时解码该事物是否存在的唯一方法

00:27:05.370 --> 00:27:10.080
知道是要尝试从您存储这些内容的任何地方加载它，因为我们说

00:27:10.080 --> 00:27:15.809
存储一个平均ipfs，您将进行遍历，您将获得硬币基数

00:27:15.809 --> 00:27:19.049
会向您展示这个见证人的承诺

00:27:19.049 --> 00:27:23.340
然后您就必须说好了，让我们尝试从ipfs加载它

00:27:23.340 --> 00:27:28.200
网络，如果无法加载，如果没有加载，则可能不是

00:27:28.200 --> 00:27:34.799
神圣的锅座，如果它确实装了，那肯定是，但这使责任自负。

00:27:34.799 --> 00:27:39.480
加载机制将为您正确地失败，而不仅仅是那个障碍

00:27:39.480 --> 00:27:45.179
碰巧我存储这些东西的方式在ipfs中不存在

00:27:45.179 --> 00:27:48.779
存在，所以我们就像我知道所有事物都存在一样，我将这些

00:27:48.779 --> 00:27:53.610
在一起，但这并不能保证发行版中的内容

00:27:53.610 --> 00:27:57.809
它们将存在的机制，以便指示这些事物的状态

00:27:57.809 --> 00:28:03.779
结构化取决于您是否可以加载此东西，对不起naka和我

00:28:03.779 --> 00:28:08.279
然后向您提出问题，因为如果您发现它不是神圣的

00:28:08.279 --> 00:28:18.480
阻止，但是有一个具有此ID的交易，所以如果您

00:28:18.480 --> 00:28:25.730
加载了交易的CID，然后将其取回，您知道它是

00:28:25.730 --> 00:28:35.159
发生了一笔非神圣的交易，对不起，这是神圣的。

00:28:35.159 --> 00:28:42.990
承诺的事，即使哈希指向其他意思，我也是，所以你，所以你

00:28:42.990 --> 00:28:49.270
基本上是向神圣之城发出请求，因为它的前缀是

00:28:49.270 --> 00:28:53.590
是的，然后您有一些时间，然后再次尝试获取

00:28:53.590 --> 00:29:01.270
现在进行交易银行业务之所以如此，因为因为这件事不是

00:29:01.270 --> 00:29:07.060
指向默克尔路线，所以我可以在这里区分这件事

00:29:07.060 --> 00:29:12.190
尽管在这里我有三种不同的多编解码器

00:29:12.190 --> 00:29:16.750
标头，这是我们要去比特币阻止交易和内部

00:29:16.750 --> 00:29:22.510
这些二元Merkle树的一部分，我们称之为比特币交易，但是

00:29:22.510 --> 00:29:25.360
硬币基所指向的东西就是所谓的东西

00:29:25.360 --> 00:29:30.820
见证人的承诺，所以我将它们存储为多编解码器见证人

00:29:30.820 --> 00:29:37.390
承诺是的，并且这意味着当我执行负载时，它仅是

00:29:37.390 --> 00:29:40.960
CID带有见证人承诺的编码，它不是比特币块比特币

00:29:40.960 --> 00:29:44.590
交易，因此它必须是见证方对它的承诺

00:29:44.590 --> 00:29:49.350
成功加载，从而限制了其他事物的范围

00:29:49.350 --> 00:29:57.340
所以它是一个二进制文件存在还是不存在，是的，但是如果您基本上是这样，则尝试

00:29:57.340 --> 00:30:00.460
找回它，您什么​​也收不回来问题是您不知道是否

00:30:00.460 --> 00:30:04.390
这是如果您无法检索到它，或者不是在那里，那就是问题所在

00:30:04.390 --> 00:30:12.130
是的，但是您知道当您为见证人承诺创建CID时，您可以

00:30:12.130 --> 00:30:21.310
还创建事务的CID，因为如果这样，然后尝试检索

00:30:21.310 --> 00:30:26.830
交易，如果该交易存在，那么它不是见证人

00:30:26.830 --> 00:30:35.620
承诺不，你不能不难过，这是因为这是最大的挑战

00:30:35.620 --> 00:30:43.600
这是因为它们以二进制形式形成了哈希和交易ID日期

00:30:43.600 --> 00:30:49.870
不要露面，因为您会孵化哈希哦，它本身就关闭了，所以您

00:30:49.870 --> 00:30:54.670
不能仅仅凭空构造一个CID，

00:30:54.670 --> 00:30:58.690
您所拥有的信息以及我们所拥有的只是这些一点信息

00:30:58.690 --> 00:31:02.170
但是如果到达硬币库，如果失败了，您可以尝试加载

00:31:02.170 --> 00:31:04.390
目击者提交，它使您失败，只是备份并说

00:31:04.390 --> 00:31:07.840
好吧，让我们假设这不是一个神圣的障碍，我们将回到上面

00:31:07.840 --> 00:31:11.950
其他二元默克尔从那里解决所有其他交易，您将

00:31:11.950 --> 00:31:17.830
得到您将能够加载所有交易的不良形式

00:31:17.830 --> 00:31:23.260
所有交易的非见证形式可能不是

00:31:23.260 --> 00:31:26.860
仅仅包含很多信息就不够了，因为它们包含了所有

00:31:26.860 --> 00:31:32.560
硬币值，公钥和其他东西，只是您缺少了一些

00:31:32.560 --> 00:31:37.870
信息还可以，那么发生什么秘密仍然像它可能发生的那样

00:31:37.870 --> 00:31:45.820
您是见证人承诺链接，基本上您无法加载它，因为它

00:31:45.820 --> 00:31:51.100
存在，但您可以调整摘要，然后回去尝试加载

00:31:51.100 --> 00:31:57.030
进行交易，尽管有见证人承诺，但交易将成功

00:31:57.030 --> 00:32:00.340
所以几乎似乎您需要该方案的分支逻辑

00:32:00.340 --> 00:32:03.610
关键时刻的表示表示数据模型，这是

00:32:03.610 --> 00:32:07.600
就像在w3c中一样，他们喜欢一种算法方法，他们在

00:32:07.600 --> 00:32:12.040
他像rdf一样解析json-ld的抽象

00:32:12.040 --> 00:32:16.870
归一化算法基本上只是一个四步解析算法，

00:32:16.870 --> 00:32:20.440
所以您需要像一个相邻的方案，实际上您基本上可以像您所知道的那样做

00:32:20.440 --> 00:32:25.150
如果该字段存在，那么实际上意味着要采用这种格式或类似的格式

00:32:25.150 --> 00:32:29.920
是可选的枚举类型吗？

00:32:29.920 --> 00:32:33.310
实际上，无论是方案表示，还是

00:32:33.310 --> 00:32:37.990
建立在其上的脚手架，然后像K一样有分支逻辑

00:32:37.990 --> 00:32:44.140
JSON模式具有这样的特性，所以它不是纯模式，因为它是内置的

00:32:44.140 --> 00:32:47.500
这是这里的挑战，也许不是我有另一件事

00:32:47.500 --> 00:32:52.930
被覆盖了，这就是我们试图将这些东西编码在它们的字节中

00:32:52.930 --> 00:32:59.770
格式，以便开始块ID匹配比特币区块链

00:32:59.770 --> 00:33:05.320
使用，因此我们不想修改这些字节，那么交易ID为

00:33:05.320 --> 00:33:12.370
一样，所以您可以从网上某处获取一个块ID 0 0 0 0 0啦啦，您

00:33:12.370 --> 00:33:16.330
可以将吃的东西变成CID，然后解决这些问题，

00:33:16.330 --> 00:33:20.830
对于交易女士也一样，您可以从其他任何地方从网络上获取它们

00:33:20.830 --> 00:33:22.929
让您知道也许您正在查询区块链

00:33:22.929 --> 00:33:27.220
哦，我会请您知道PLD，而且我有能力不询问

00:33:27.220 --> 00:33:32.940
在那里，所以我们没有组成新的ID，所以我们必须使用原始字节格式

00:33:32.940 --> 00:33:37.690
比特币用户，这意味着我们不能插入任何其他有用的东西

00:33:37.690 --> 00:33:44.740
这里的信息将使一个分支草药计划者，所以这可能是

00:33:44.740 --> 00:33:48.820
实际上生成它实际上有一个架构，您实际上可以

00:33:48.820 --> 00:33:57.870
这样做确实具有多步骤算法方法，因为是的，我

00:33:57.870 --> 00:34:02.529
那会很好，但我想您知道生成这些东西的合并吗？

00:34:02.529 --> 00:34:07.899
可能只是手头的编码逻辑刚从中脱颖而出

00:34:07.899 --> 00:34:17.770
因为有这些独角兽，所以控制好吧，是的，我基本上要问

00:34:17.770 --> 00:34:24.450
问题真的是比特币中的模式信号骗局是

00:34:24.450 --> 00:34:28.149
本质上被区块链的高度所占据

00:34:28.149 --> 00:34:33.700
所以是的，从这个高度向下想念宇宙，请使用其他模式，并从此

00:34:33.700 --> 00:34:39.609
使用当前的良好模式以及将来更好的高度

00:34:39.609 --> 00:34:43.480
还会有另一种方案，我会告诉plz您实际上没有

00:34:43.480 --> 00:34:51.940
能够说出只有我们才能做到的事情的能力，这是一件好事

00:34:51.940 --> 00:34:56.290
它不会解析，那么声明是不同的，是的，是的，并且

00:34:56.290 --> 00:35:00.060
高度信息没有备份到块中，因此我们不能使用它

00:35:00.060 --> 00:35:05.650
当我们将这些块彼此独立放置时，会有一段时间

00:35:05.650 --> 00:35:08.790
您可以将其用作信号，但我认为这不是可靠的机制

00:35:08.790 --> 00:35:13.510
虽然没有真的没有关于时间的严格规则，但是

00:35:13.510 --> 00:35:16.240
这是我尚未深入研究的内容，但您实际上可以使用

00:35:16.240 --> 00:35:22.119
如果更严格地应用时间，那么您可以将时间用作信号

00:35:22.119 --> 00:35:27.400
是的，我认为时间特异性只有90分钟左右，

00:35:27.400 --> 00:35:30.620
所以我可以，你可以让她有个不错的命令

00:35:30.620 --> 00:35:33.380
是的，实际上实际上有无序的块实际上是很多

00:35:33.380 --> 00:35:38.030
块实际上是乱序的时间序列，为什么，因为实际上你

00:35:38.030 --> 00:35:42.800
最多需要90分钟进行和解，所以我认为一种方法

00:35:42.800 --> 00:35:46.100
我第一次遇到这个的时候，我以为我还可以，这是真的

00:35:46.100 --> 00:35:48.920
是一个独角兽，它将像一两个被两个块

00:35:48.920 --> 00:35:52.880
因为我不知道我在走下三关之前就走了300,000个街区

00:35:52.880 --> 00:35:56.540
帐户并遇到此问题的见证人承诺

00:35:56.540 --> 00:36:02.420
看起来像它存在，但不存在，所以我主要是想自己想得很好

00:36:02.420 --> 00:36:06.110
请指定此名称，因为我将在文档中写下这些内容，然后

00:36:06.110 --> 00:36:10.970
说这是IP LD比特币格式，这就是我们的方式以及顺便说一下

00:36:10.970 --> 00:36:16.250
有一个coinbase标识符的白名单，如果您遇到这些，

00:36:16.250 --> 00:36:20.510
那么他们有一个特殊的情况，你可以像使用散列一样使用散列

00:36:20.510 --> 00:36:26.360
列出您知道的四到五个哈希，并说这些是特殊的独角兽

00:36:26.360 --> 00:36:31.070
存在于历史中，我们现在将它们放在一旁，因为我们发布了一个网格，

00:36:31.070 --> 00:36:35.770
这些是特殊的，如果您遇到它们，并且您有特殊的处理方法，我

00:36:35.770 --> 00:36:40.070
仍然对研究这种方法感兴趣，但这是

00:36:40.070 --> 00:36:43.880
结果出了比我想像的更多的东西，是的，所以在

00:36:43.880 --> 00:36:47.720
json-ld世界实际上存在诸如jason framing之类的东西，我认为

00:36:47.720 --> 00:36:50.810
基本上就是您在其中实际放置文档的脚手架的地方

00:36:50.810 --> 00:36:53.750
必须存在的东西，但是我认为这里有一个分支逻辑

00:36:53.750 --> 00:37:00.890
说如果这些东西在这里，你知道那你就走这条路吧

00:37:00.890 --> 00:37:08.020
在IP中，所有这些游戏玩家都拥有工会，可以帮助我们做到这一点，

00:37:08.200 --> 00:37:12.080
然后，然后他们也将这个概念发扬光大，因为您应该能够

00:37:12.080 --> 00:37:15.260
应用不同的架构IP方案，因为这样做的目的是

00:37:15.260 --> 00:37:21.080
可快速验证，因为它们阻止了本地运行，您也不需要

00:37:21.080 --> 00:37:26.390
大量的处理，因此您应该能够快速尝试使用不同的架构

00:37:26.390 --> 00:37:32.720
找出来，但这不是这不是dag海滨甲板jason dag任何我们

00:37:32.720 --> 00:37:38.900
我在这里没有那么有趣，因为我正确地理解了这一点

00:37:38.900 --> 00:37:44.900
问题的一部分也是该信息一定已经被使用过

00:37:44.900 --> 00:37:50.150
比特币历史中此信息块的某些部分不一致

00:37:50.150 --> 00:37:55.550
就像人类实际上正确地使用它一样，所以您得到的是

00:37:55.550 --> 00:38:01.670
保留在较早的块中，并且使用时必须包含废话

00:38:01.670 --> 00:38:05.750
数据还是我们喜欢遇到人们喜欢尝试放置低位的块

00:38:05.750 --> 00:38:09.109
将自拍评级为比特币或我记得听到的故事

00:38:09.109 --> 00:38:16.510
关于这个是的，所以这个小小的见证人的承诺进入了一个领域

00:38:16.510 --> 00:38:25.280
在他们的脚本中，然后跟随着OP返回，这意味着

00:38:25.280 --> 00:38:33.920
这样的结束就是脚本ASM的结束，但是可以放一些东西

00:38:33.920 --> 00:38:39.410
歌剧转完之后，这是胡说八道，这就是人们嵌入的地方

00:38:39.410 --> 00:38:44.000
他们里面的东西可以说歌剧转好了，但是那之后我要放一些字节

00:38:44.000 --> 00:38:51.440
当他们说的是细分市场时，其中包含了我有趣的东西。

00:38:51.440 --> 00:38:55.550
您发现一个歌剧回合加上32个字节，其中32个字节是见证人的承诺

00:38:55.550 --> 00:39:00.700
但事实证明，我返回后人们正在插入32个字节

00:39:03.580 --> 00:39:08.630
您并没有试图在架构中为某事指定解码

00:39:08.630 --> 00:39:16.820
设计它更像是我们想要的网站证书

00:39:16.820 --> 00:39:21.440
在有人发现您的编码错误的情况下

00:39:21.440 --> 00:39:24.920
可以将信息放在空终止符之后，并且一些实现是

00:39:24.920 --> 00:39:30.770
如此艰苦的美好事物和花生正是这样，然后其他人回信

00:39:30.770 --> 00:39:35.450
它比以往任何时候都以更多不同的语义使用它，而他们只是

00:39:35.450 --> 00:39:42.770
推动它，是的，我们所看到的是我一直在想的含义是

00:39:42.770 --> 00:39:47.420
不想硬分叉的含义，这就是如果您

00:39:47.420 --> 00:39:51.170
想要做一个软叉，这是所有向后兼容的

00:39:51.170 --> 00:39:56.030
即使现在每个未成年人都神圣地对待了，赛格威也是什么样的人

00:39:56.030 --> 00:40:03.350
叉子，这就是这，这就是发生的事情，我认为彼得斯

00:40:03.350 --> 00:40:09.200
还可以识别出比特币实际上是使用区块高度作为

00:40:09.200 --> 00:40:15.560
我认为这里的版本是超真实的，所以我不知道它有多低

00:40:15.560 --> 00:40:19.520
从字面上看这是真的，它们位于代码层中，它们阻止了代码中的高度

00:40:19.520 --> 00:40:24.440
这是错误的，如果在这个高度之后，是这样，从字面上看，这是怎么回事

00:40:24.440 --> 00:40:30.640
他们的行为就像他们确实拥有基于您的区块权限的架构一样

00:40:32.260 --> 00:40:37.850
那不是回到块中的权利，这就是为什么在其中的原因之一

00:40:37.850 --> 00:40:42.230
现实中，您仍然必须克隆整个比特币链才能进行推理

00:40:42.230 --> 00:40:50.320
关于这就是为什么，是这样，否则否则，您必须信任实际的

00:40:50.320 --> 00:40:57.650
已下载的实际软件已在多个检查点中发布

00:40:57.650 --> 00:41:02.090
像实际ID一样来自区块链

00:41:02.090 --> 00:41:07.460
就像早于此ID一样，我们很好，但是如果您确实要验证

00:41:07.460 --> 00:41:12.800
您的软件不是吗，您必须从头开始

00:41:12.800 --> 00:41:18.020
创世纪一路阻塞，还有很多其他信息

00:41:18.020 --> 00:41:22.760
很有用，您只能从了解整个链条中获得

00:41:22.760 --> 00:41:27.710
您只有通过拥有所有这些才能获得的有关单个块的信息

00:41:27.710 --> 00:41:33.590
幸运的是，这不是很多数据，但我拥有

00:41:33.590 --> 00:41:39.170
我所有的单元测试中，我都必须删除一个固定的字段列表，

00:41:39.170 --> 00:41:55.670
难道你不能自己从积木中衍生出来，对吧，这就是我

00:41:55.670 --> 00:41:59.210
发现这是这个地址，这是这个练习，真的很有帮助

00:41:59.210 --> 00:42:05.170
在找出一些不该做的事情时，我真的发现了这一点很有价值，

00:42:05.170 --> 00:42:09.130
这也是，但也确实挑战了一些核心假设

00:42:09.130 --> 00:42:13.210
像这样的事情还可以，为什么我们不只是将块算法称为哈希

00:42:13.210 --> 00:42:21.460
功能，所以我不知道我们之前提到的时间和粒度

00:42:21.460 --> 00:42:30.640
也许是一种安静的确定，但在实践中和知道这是否合理

00:42:30.640 --> 00:42:34.570
比特币正式对区块高度所做的事情也是

00:42:34.570 --> 00:42:42.120
太不纯净了，这有点愚蠢了，所以这里的理智标准确实是

00:42:42.120 --> 00:42:47.230
低粒度时间足够好，我们可以实际将其用作启发式

00:42:47.230 --> 00:42:53.500
这个东西和文档，这就是我们正在做的事情，因为

00:42:53.500 --> 00:42:59.010
除非有时间戳记，否则其他方法可以检查是的

00:42:59.010 --> 00:43:03.190
完全不稳定的随机数，没有人以任何方式验证

00:43:03.190 --> 00:43:09.880
如果他们对他们有任何Stricker可能，那么我认为这是可能的

00:43:09.880 --> 00:43:16.150
也实际上与块高度相同，为此，

00:43:16.150 --> 00:43:20.650
超过挂钟的某个日期，即使我们已经大致同意，

00:43:20.650 --> 00:43:24.160
即使它像一天一样摆动也要摆动90分钟

00:43:24.160 --> 00:43:28.240
我们可以画线的地方，您可以知道很多客户

00:43:28.240 --> 00:43:32.860
区块链开始考虑这个32字节的结构是神奇的，

00:43:32.860 --> 00:43:36.610
那天之后，我们应该再也看不到路易斯安那州的拐角了

00:43:36.610 --> 00:43:41.410
是的，我肯定应该检查一下这些东西，因为我有

00:43:41.410 --> 00:43:46.750
它确实假设它的村庄不会有将来的街区

00:43:46.750 --> 00:43:53.230
没有能力度过疯狂的时光，因为也许未来的化身

00:43:53.230 --> 00:43:57.460
该算法的一部分会说是的，我们已经决定这次时间字段不

00:43:57.460 --> 00:44:03.040
真的很重要，因此您可以像他们喜欢的那样将其用于采矿业的变化

00:44:03.040 --> 00:44:07.360
他们已经使用了version字符串来完成了此操作，因此矿工们

00:44:07.360 --> 00:44:10.900
开始滥用版本字符串，因为比特币仅占用了最后五个

00:44:10.900 --> 00:44:14.410
这么说吧，好吧，我们已经将这三位

00:44:14.410 --> 00:44:17.590
前面我们非常非常，所以比特币中的版本号

00:44:17.590 --> 00:44:27.040
除非您仅考虑最后五位，否则块是很疯狂的

00:44:27.040 --> 00:44:29.830
人们给予他们自由时滥用的东西，如果他们得到了，那是真的

00:44:29.830 --> 00:44:36.310
严格的算法，并且因为有经济诱因而被发现，是的

00:44:36.310 --> 00:44:42.700
我只想把它带回埃里克所说的那一点

00:44:42.700 --> 00:44:47.340
有点像打破默克尔树的精神，这不是真的

00:44:47.340 --> 00:44:55.000
因为模式是在从根开始的整个dag上定义的

00:44:55.000 --> 00:45:00.760
实际上，这完全是确定性的，这是因为他们如何将其推出

00:45:00.760 --> 00:45:07.780
就像他们最出色的软件一样，最后在每个比特币节点中都有一个

00:45:07.780 --> 00:45:12.490
将来在当时不知道的某个日期切换，但基本上

00:45:12.490 --> 00:45:20.050
在这个高度，您开始将段与其他段一样对待，

00:45:20.050 --> 00:45:24.130
是的，我们不是在这里假装这些东西在

00:45:24.130 --> 00:45:29.260
隔离，但标头指向上一个块，因此dag是整个

00:45:29.260 --> 00:45:34.600
是的，这是我要尝试的基本要点

00:45:34.600 --> 00:45:44.140
使用区块链是正确的，他们基本上还有一个开关

00:45:44.140 --> 00:45:49.750
我们目前没有的架构类型，但比特币不仅会

00:45:49.750 --> 00:45:54.730
之所以要继续前进，是因为事物的能力不是，不是，不是

00:45:54.730 --> 00:46:00.070
那样的话他们走错路了，就像有补丁一样

00:46:00.070 --> 00:46:04.600
开始时会有一个很大的dag，就像您已经在

00:46:04.600 --> 00:46:09.070
当前的技巧，它涵盖了一切，然后推理就成立了

00:46:09.070 --> 00:46:13.210
很好，但是如果您付小费，那不是什么问题

00:46:13.210 --> 00:46:19.050
已经很老了，但您不知道对，您对此没有任何魔法知识

00:46:19.050 --> 00:46:23.560
你不能获得那种你不知道是否一路走遍的知识

00:46:23.560 --> 00:46:27.640
时光倒流，然后您可以评估所有的炒作权，但是如果您只有

00:46:27.640 --> 00:46:32.319
时光倒流的信息，那么你仍然有

00:46:32.319 --> 00:46:41.170
您仍然可以从该点生成高度

00:46:41.170 --> 00:46:45.520
如果你有一个完整的袋子，基本上可以发现它是你的一部分

00:46:45.520 --> 00:46:54.789
从某个角度，您可以弄清楚这一点到底有多高

00:46:54.789 --> 00:47:10.440
我继续，因为我还有更多的独角兽，是的，所以

00:47:10.440 --> 00:47:14.140
某种东西，所以这种方法不是我没有想出他的方法

00:47:14.140 --> 00:47:22.059
说让我们将这些隐式二进制Merkle分解为这些

00:47:22.059 --> 00:47:26.950
实际的块，以便我们可以将其作为单独的块进行导航，这是

00:47:26.950 --> 00:47:36.369
这是Jeremy和其他一些人使用的原始IP LD编解码器中的内容

00:47:36.369 --> 00:47:43.240
曾经使用过书面内容，因此其想法是，您可以导航到

00:47:43.240 --> 00:47:46.750
这个二进制Merkle有所有这些块都被标记为

00:47:46.750 --> 00:47:53.170
比特币TX，因为您不知道，也不知道这件事是否会

00:47:53.170 --> 00:47:57.640
是真正的交易或这个二进制默克尔中的另一个节点，您只知道一次

00:47:57.640 --> 00:48:05.529
您到达那里，因此将它们标记为所有比特币TX Mata编解码器确实有意义，因此

00:48:05.529 --> 00:48:08.980
您要做的是浏览并解决一个障碍，然后将障碍移出

00:48:08.980 --> 00:48:17.440
然后使用大小告诉您它是否是此树中的内部节点或

00:48:17.440 --> 00:48:22.359
它是否是真正的交易，如果恰好是64个字节啊，那么它是两个

00:48:22.359 --> 00:48:25.720
散列卡住了，然后就可以了，这就是您的架构

00:48:25.720 --> 00:48:30.520
然后您会说好吧，我返回一个数组，以查看ID为

00:48:30.520 --> 00:48:36.609
那就是你如何反序列化64字节的东西，如果你得到任何东西

00:48:36.609 --> 00:48:41.319
除了64个字节以外，您确实将其序列化为事务格式

00:48:41.319 --> 00:48:46.779
因此，您可以很好地做到这一点，您可以加载这些块，并在

00:48:46.779 --> 00:48:51.819
他们的长度事实证明，尽管正如我昨天发现

00:48:51.819 --> 00:48:59.430
解码后将其编码为64字节二进制形式的事务

00:48:59.430 --> 00:49:05.229
非常小的交易，但它们的长度与

00:49:05.229 --> 00:49:11.579
这些内部的默克尔节点，那么我们就有了这个方案，好吧，这是

00:49:11.579 --> 00:49:15.640
做到这一点我不能只是打开我必须的长度

00:49:15.640 --> 00:49:19.449
实际开始解码这些东西，看看它们是否解码正确，所以告诉

00:49:19.449 --> 00:49:25.029
不管是不是有可能，但是还有另一笔交易

00:49:25.029 --> 00:49:29.529
问题是这些块中有很多以足够的开头

00:49:29.529 --> 00:49:34.630
他们将成功解码的零和这些默克尔内部默克尔之一

00:49:34.630 --> 00:49:42.059
节点作为事务，并且常见的是此序列号17

00:49:42.059 --> 00:49:50.799
他们以32个零开头，这将为您解码成功的交易，

00:49:50.799 --> 00:50:00.279
基本上是空的，这很烂，所以分支逻辑就可以了

00:50:00.279 --> 00:50:03.549
它可以解码吗，好吧，让我们看看里面，

00:50:03.549 --> 00:50:08.349
进行完整性检查，因为它可能包含版本零和所有

00:50:08.349 --> 00:50:13.539
结构是零长度，如果这样，那几乎可以肯定不是

00:50:13.539 --> 00:50:18.670
交易，也许是一个内部默克尔节点，这是现在的分支，现在我还没有

00:50:18.670 --> 00:50:22.539
处理了所有区块链，以了解是否成功，因为也许

00:50:22.539 --> 00:50:26.410
那里还有另一个独角兽，它的交易版本为零

00:50:26.410 --> 00:50:32.019
而且没有任何我认为不可能的数组，因为硬币的底部有

00:50:32.019 --> 00:50:36.369
存在我们讨论过交易的宇宙，但我认为在交易中

00:50:36.369 --> 00:50:39.640
你必须有一个硬币流，你必须有一个进出

00:50:39.640 --> 00:50:43.890
这些都是数组，所以您必须至少有一个元素数组

00:50:43.890 --> 00:50:51.650
除了在创世纪块中，另一个甚至创世纪福克斯也有进出

00:50:51.650 --> 00:50:58.580
我认为这已经足够成功，但是这里的独角兽是64字节

00:50:58.580 --> 00:51:04.340
完全喜欢前面有足够租金的交易

00:51:04.340 --> 00:51:08.240
它可以解码成交易，但我没有遇到任何咬伤，我认为

00:51:08.240 --> 00:51:12.680
到目前为止，我遇到了一个块，该块长64个字节，并且有乱码

00:51:12.680 --> 00:51:17.720
在前端，也将其解码为一个块，这将是

00:51:17.720 --> 00:51:24.020
令人惊讶，但鉴于数字的随机性，这完全有可能，因此

00:51:24.020 --> 00:51:37.730
烦人，然后还有什么哦，是的，没有其他我的独角兽

00:51:37.730 --> 00:51:41.210
更像是格式化的东西，我发现了只有硬币的块

00:51:41.210 --> 00:51:48.230
我认为不可能的基础，但即使在树的后面也存在

00:51:48.230 --> 00:51:54.140
在硬币诱饵的链条中，硬币的基础是

00:51:54.140 --> 00:51:59.630
较小的奖项会进来并散发，以便未成年人获得他们的

00:51:59.630 --> 00:52:03.140
在硬币底部切入，然后从硬币链中接收

00:52:03.140 --> 00:52:07.580
基地，所以有些街区只获得了次要奖项，而没有其他真正的奖项

00:52:07.580 --> 00:52:13.040
但这不是一个真正不是首次公开募股（IPO）的问题，

00:52:13.040 --> 00:52:19.160
更多的解码器使用者，无论如何，这就是这些

00:52:19.160 --> 00:52:24.290
我正在经历的冒险，并不断地经历，我已经完成了大约一半的

00:52:24.290 --> 00:52:29.180
区块链中的块，但主要在前半部分，因为所有这些

00:52:29.180 --> 00:52:35.300
随着时间的推移，随着数以百万计的随机性增加，新颖性也随之引入

00:52:35.300 --> 00:52:42.770
猴子在这个东西上打字和键盘，所以在那里有很多课程

00:52:42.770 --> 00:52:48.410
但也只想回想一下我不是

00:52:48.410 --> 00:52:58.420
甚至通过尝试任何问题或评论完全疯了

00:53:01.369 --> 00:53:09.780
是的，所以我们还有四分钟还有其他人想要的吗

00:53:09.780 --> 00:53:16.829
分享说问我，我是说你需要遍历整个

00:53:16.829 --> 00:53:22.230
历史，您实际上可以回溯吗，您知道300个方块或十万个方块

00:53:22.230 --> 00:53:28.619
就像我们让所有人都同意那样

00:53:28.619 --> 00:53:33.270
他们的早期架构很难解析，所以实际上您拥有它，就像您知道的一样

00:53:33.270 --> 00:53:42.119
大多数方式都完成了，所以我真的不想明确地谈论

00:53:42.119 --> 00:53:47.910
这样做的目的，但我们只能说这是出于存档原因，因此

00:53:47.910 --> 00:53:52.200
终极游戏这里的终极目的是实际分解这些东西

00:53:52.200 --> 00:54:00.270
到IP LD块中，我们可以在比特币网络之外进行归档，而我

00:54:00.270 --> 00:54:05.520
是的，我们未宣布的原因是，这是另一项努力的一部分，

00:54:05.520 --> 00:54:09.480
将有自己的公告，但事实是部分已经很好

00:54:09.480 --> 00:54:15.230
宣布，所以不是那么多，但是是的，这个想法很好，并且

00:54:15.230 --> 00:54:19.650
比特币是其中可能会存在很长一段时间的事物之一

00:54:19.650 --> 00:54:25.109
时间，因为除非有重大缺陷，否则就像数字黄金一样

00:54:25.109 --> 00:54:29.579
发现无法撤消的小巧解决方法可能会

00:54:29.579 --> 00:54:33.990
周围很长一段时间，但更容易想象这些较小的块之一

00:54:33.990 --> 00:54:39.690
链条消失了，比如说Z缓存，这真的很不错

00:54:39.690 --> 00:54:43.619
它的属性非常有用，但是它没有

00:54:43.619 --> 00:54:48.329
很多用户，并且在不久的将来，每个人都可能会

00:54:48.329 --> 00:54:55.140
关闭他们的节点，然后所有数据都消失了，我们希望能够

00:54:55.140 --> 00:55:01.349
可以说这些东西在历史上存在过吗，我们可以将它们存储起来，以便它们

00:55:01.349 --> 00:55:06.300
可以是历史记录，这就是这里思想的一部分

00:55:06.300 --> 00:55:11.450
我们如何以对遍历和遍历有用的方式存储它们

00:55:11.450 --> 00:55:18.220
也许说我们可以将它们存储在我们的文件中过于雄心勃勃

00:55:18.220 --> 00:55:23.660
内容解决块的概念应该就是我们

00:55:23.660 --> 00:55:30.710
尝试，结果证明这是一个有趣的练习，因为另一个

00:55:30.710 --> 00:55:33.950
另一个选择是说好吧，让我们来

00:55:33.950 --> 00:55:37.790
阻止并将其二进制形式存储在dag PB中，您知道您可以做

00:55:37.790 --> 00:55:43.780
那只是说我收到任何文件，是的，那么PA的意义是什么

00:55:43.780 --> 00:55:48.050
是的，除非您拥有

00:55:48.050 --> 00:55:55.310
文件名，可能是哈希，然后就是你所拥有的，但是是的

00:55:55.310 --> 00:56:02.210
这主要是我发现这对挑战和投入很有用

00:56:02.210 --> 00:56:07.340
IP LD的问题还可以吗？我们如何解决？

00:56:07.340 --> 00:56:12.440
这些问题以及我们在做什么，这是上面的重大发展

00:56:12.440 --> 00:56:18.140
内容修饰，区块链和所有其他内容的概念

00:56:18.140 --> 00:56:25.940
是比特币带来并试图使用的，这是一个很好的练习

00:56:25.940 --> 00:56:32.510
所以我们时间不多了，谢谢大家的参与，并与大家见面

00:56:32.510 --> 00:56:41.489
希望下周再见大家[音乐]

00:56:42.380 --> 00:56:44.440
你

00:56:49.490 --> 00:56:51.550
你

00:56:56.270 --> 00:57:05.770
我们很低，您没有更多的东西，我想谈谈嗯

00:57:07.160 --> 00:57:14.890
对我来说，出于某种原因，我要显示静止的录音和生活，哦，是真的

