WEBVTT
Kind: captions
Language: zh-Hans

00:00:15.599 --> 00:00:20.480
欢迎大家参加本周的ipld同步会议

00:00:20.480 --> 00:00:28.320
2月的第一个2021年第一个月，每周我们都会浏览这些东西

00:00:28.320 --> 00:00:31.439
我们在上周所做的，然后我们谈到了

00:00:31.439 --> 00:00:39.120
我们下一步打算做什么？我从我自己开始

00:00:39.120 --> 00:00:44.320
我上周没做那么多，我想也有一些文件转换，但是我

00:00:44.320 --> 00:00:46.960
认为这组人最有趣的是

00:00:46.960 --> 00:00:50.719
我写了一篇有关Web汇编的小博客文章可能会返回

00:00:50.719 --> 00:00:57.440
当今锈蚀中的价值没有约束力，并且

00:00:57.440 --> 00:01:05.040
背景是在wasm中，您可以拥有多个返回值um

00:01:05.040 --> 00:01:07.680
新版本，我以为会

00:01:07.680 --> 00:01:13.760
可以很容易地做到这一点，但是博客文章中却没有

00:01:13.760 --> 00:01:17.759
而您希望获得多重回报的原因是

00:01:17.759 --> 00:01:21.119
由于Web程序集仅限于返回类型

00:01:21.119 --> 00:01:24.720
例如，如果您想返回一个字符串

00:01:24.720 --> 00:01:28.320
您将其放回内存中的位置以及需要返回的内容

00:01:28.320 --> 00:01:31.360
是内存中的实际位置以及

00:01:31.360 --> 00:01:35.920
长度，所以它是两个值，所以它的长度更多

00:01:35.920 --> 00:01:38.320
比返回一个值更方便

00:01:38.320 --> 00:01:42.240
然后，您可以读出其中的大小和位置

00:01:42.240 --> 00:01:49.920
嗯，这很有用嗯下周是

00:01:49.920 --> 00:01:52.960
对于所有将获得协议实验室的人

00:01:52.960 --> 00:01:56.159
这就是所谓的“黑客周”，我们花时间在

00:01:56.159 --> 00:02:00.479
使用我们通常不在工作范围内的堆栈进行项目

00:02:00.479 --> 00:02:06.960
我会和我一起努力工作

00:02:06.960 --> 00:02:13.920
通过lib p2p，它的想法是您不需要ttc服务器，但是可以

00:02:13.920 --> 00:02:21.040
以某种方式以分布式方式与远程其他人交谈

00:02:21.040 --> 00:02:24.879
我们可能会在下周看到嗯，我有一个

00:02:24.879 --> 00:02:29.760
即使不是与ip相关的um，也要对此进行更新

00:02:29.760 --> 00:02:34.239
好吧，我名单上的下一个是丹妮尔

00:02:34.959 --> 00:02:38.080
很酷，所以上周我大部分时间都在整理

00:02:38.080 --> 00:02:43.920
嗯，我主要是得到我的hamd adl来同意文件硬币

00:02:43.920 --> 00:02:46.640
紧紧围绕斑马字节寻找什么

00:02:46.640 --> 00:02:49.760
非常简单的地图，我上周大部分时间都在那儿，我只是

00:02:49.760 --> 00:02:52.160
长时间卡在参数上

00:02:52.160 --> 00:02:58.159
um本质上是b的默认参数，用于位宽和哈希

00:02:58.159 --> 00:03:02.159
库为您提供的算法

00:03:02.159 --> 00:03:05.440
没有什么像猎鹰明显使用，我是

00:03:05.440 --> 00:03:10.080
查看rod的规格以获得真实的filecon数据

00:03:10.080 --> 00:03:13.599
但是我错误地使用了默认值，所以一旦我修复它实际上看起来就

00:03:13.599 --> 00:03:19.360
一样，这很好，本质上我需要完成

00:03:19.360 --> 00:03:22.720
假设我没有做出任何选择，以使其喜欢读取猎鹰数据

00:03:22.720 --> 00:03:27.120
其他错误是呃具体化，所以像采取一些

00:03:27.120 --> 00:03:31.200
um块层节点，然后将它们解释为我的adl，然后

00:03:31.200 --> 00:03:37.040
据说应该可以神奇地从现有地图中读取键值

00:03:37.040 --> 00:03:40.239
嗯，但这差不多就是我要整理的代码并推送它

00:03:40.239 --> 00:03:44.159
大量的其他支持Filecoin的代码

00:03:44.159 --> 00:03:47.920
下周就像沃尔克提到的那样，我们有黑客周

00:03:47.920 --> 00:03:53.519
我到目前为止的项目至少基本上是ipfs的每个实现

00:03:53.519 --> 00:03:58.879
桌面，但是带有电子和所有ipfs桌面，实际上是

00:03:58.879 --> 00:04:02.400
使用演讲来展示精美的网络用户界面，但这是独立的

00:04:02.400 --> 00:04:06.560
你可以用浏览器打开它，然后我将要打开的东西

00:04:06.560 --> 00:04:10.879
工具是状态托盘图标和系统集成的种类

00:04:10.879 --> 00:04:13.599
很容易去做，很酷

00:04:13.599 --> 00:04:16.560
事情是，最终它可能会成为go ipfs的一部分

00:04:16.560 --> 00:04:22.160
本身，仍然不是一个很好的标准，因为它很多

00:04:22.160 --> 00:04:25.600
sigo之类的东西，例如，构建所需的Windows

00:04:25.600 --> 00:04:29.280
 Windows机器，因为所有系统标头，但是

00:04:29.280 --> 00:04:34.479
应该还是可以的，我想我们会看到适合我的

00:04:35.199 --> 00:04:38.960
感谢名单上的下一个是迈克尔

00:04:40.960 --> 00:04:44.000
嘿，对不起，我想让我的耳机真正快速地工作，以便

00:04:44.000 --> 00:04:47.840
你可以听到我一点点，看看是否行得通

00:04:47.840 --> 00:04:52.880
好的，很好，嗯，我仍在尝试写我的更新，但嗯

00:04:52.880 --> 00:04:56.000
我可以从第二个开始谈论这个，第一个和这个

00:04:56.000 --> 00:05:02.000
就像我们所有使用的烦人的um ipjs一样

00:05:02.000 --> 00:05:06.960
javascript会以一种类似的方式构建它的工作方式

00:05:06.960 --> 00:05:12.880
产生一个json包，然后将其转储出去，

00:05:13.360 --> 00:05:16.720
最终浮出水面，这真令人讨厌

00:05:16.720 --> 00:05:20.560
错误和汇总，然后就像关于node.js的烦人的部分一样

00:05:20.560 --> 00:05:25.759
指定了解析算法，结果发现排序像

00:05:25.759 --> 00:05:29.600
对于按键来说真的很重要，因为规格

00:05:29.600 --> 00:05:32.639
假设package.json是一种配置语言，与

00:05:32.639 --> 00:05:37.280
um的构建工具的输出，所以他们真的很在乎

00:05:37.280 --> 00:05:40.080
订购，如果您有一个浏览器字段并且想要实际

00:05:40.080 --> 00:05:44.320
首先必须使用它，但没有办法解决

00:05:44.320 --> 00:05:47.600
所以我解决了这个问题，所以当人们这样做时，它将立即生效

00:05:47.600 --> 00:05:50.639
但是还有一个非常糟糕的错误汇总

00:05:50.639 --> 00:05:57.120
基本上汇总起来的um具有这些逻辑

00:05:57.120 --> 00:06:00.240
为解决主要领域而分开

00:06:00.240 --> 00:06:07.360
与子树导入（即使它们实际上在做相同的事情）

00:06:07.360 --> 00:06:11.440
这意味着它实际上不是

00:06:11.440 --> 00:06:17.680
在子导入的默认导入中包括浏览器

00:06:17.680 --> 00:06:21.919
即使您曾经说过浏览器为真，也确实是在告诉您

00:06:21.919 --> 00:06:25.600
卷起来，嘿，得到兄弟的东西，然后你有一个东西说，嘿，我是

00:06:25.600 --> 00:06:28.639
子导入的浏览器内容，就像没有捡起来一样

00:06:28.639 --> 00:06:33.120
嗯，即使它是第一次，所以您可以通过添加它来解决它

00:06:33.120 --> 00:06:36.319
要配置的东西，但这是一个错误，所以就像现在登录并汇总一样，我

00:06:36.319 --> 00:06:40.720
认为那里会有链接，我们就像在排队一样

00:06:40.720 --> 00:06:43.280
是否将其固定在这里，但这意味着现在

00:06:43.280 --> 00:06:48.800
像是多种格式，嗯，是的，多种格式

00:06:48.800 --> 00:06:54.240
汇总所有子包装零件的esm进口为

00:06:54.240 --> 00:06:57.440
损坏，因此您可以导入主包并导入所有属性

00:06:57.440 --> 00:06:59.440
不能，但您不能喜欢多种格式

00:06:59.440 --> 00:07:06.560
现在封锁，所以那不是我写的那个愚蠢的呃

00:07:06.560 --> 00:07:10.639
呃我一直在研究ib续集

00:07:10.639 --> 00:07:16.000
解释如何分开看东西，现在我像一个

00:07:16.000 --> 00:07:19.919
一种我称之为sql证明的相当精心设计的系统

00:07:19.919 --> 00:07:24.319
嗯，我实际上可以通过一些幻灯片来对此进行一些讨论

00:07:24.319 --> 00:07:28.400
如果我们有时间的话，就结束了，但是本质上不像

00:07:28.400 --> 00:07:31.840
工作证明并不能为您提供可以提供的服务

00:07:31.840 --> 00:07:33.919
用一小部分计算进行验证

00:07:33.919 --> 00:07:37.199
计算是相同的以验证证明um

00:07:37.199 --> 00:07:41.120
但这会减少您需要的所有数据

00:07:41.120 --> 00:07:44.319
所以发生的事情是，就像您在sql中执行任何操作一样

00:07:44.319 --> 00:07:47.680
然后您得到的是已读取和写入的块的集合

00:07:47.680 --> 00:07:51.199
那个um以及数据库的新状态

00:07:51.199 --> 00:07:55.199
最终成为了构建所有

00:07:55.199 --> 00:07:57.520
您想要的传统数据库工作流程

00:07:57.520 --> 00:08:02.240
因此，实际上可以通过将这些状态进行比较来完成任何状态之间的复制

00:08:02.240 --> 00:08:06.000
现在设置，因此我们不必进行疯狂的图形遍历

00:08:06.000 --> 00:08:09.120
喜欢弄清楚你真正喜欢做的所有逻辑

00:08:09.120 --> 00:08:12.000
您想在sql中执行的操作我们在该sql引擎上运行了

00:08:12.000 --> 00:08:15.039
真正拥有所有数据的人的完整遍历

00:08:15.039 --> 00:08:18.000
然后他们产生的东西是哦，是的，您现在可以使用

00:08:18.000 --> 00:08:21.440
数据um的一部分，您可以将其视为

00:08:21.440 --> 00:08:25.520
因为它们现在是单向功能转换

00:08:25.520 --> 00:08:29.199
你可以做加密的版本

00:08:29.199 --> 00:08:34.080
不能让接收者实际看到任何数据，而只是结果

00:08:34.080 --> 00:08:38.479
您甚至可以将其换回原来的钥匙扣

00:08:38.479 --> 00:08:42.240
他们可以用它来计算所有相同的增量

00:08:42.240 --> 00:08:45.600
就像他们使用的未加密版本一样

00:08:45.600 --> 00:08:48.320
与您共享的人实际上看不到任何一个

00:08:48.320 --> 00:08:50.959
数据嗯，有很酷的东西

00:08:50.959 --> 00:08:54.320
你现在可以用这个来做，我正在这些幻灯片中进行计算

00:08:54.320 --> 00:09:00.160
我可以显示一下，但是嗯，这是我更新的要旨

00:09:01.200 --> 00:09:05.440
你下周要做什么

00:09:06.000 --> 00:09:10.800
是的，是的，不，我的意思是本周的黑客攻击

00:09:10.800 --> 00:09:14.480
一个星期，我想得到一个像在浏览器中为ipsequel工作的操场的um，所以您

00:09:14.480 --> 00:09:16.640
应该能够喜欢创建数据库和

00:09:16.640 --> 00:09:19.920
并执行sql查询之类的内容，嗯，

00:09:19.920 --> 00:09:22.560
希望实际上可以变成一个我在讲的教程

00:09:22.560 --> 00:09:25.040
关于这些东西如何像在浏览器中一样工作

00:09:25.040 --> 00:09:31.279
嵌入，如果我喜欢那个酷的乌姆，那么下一个是pedo

00:09:31.279 --> 00:09:37.600
是的，所以iplt前端仍然在大的旧卡中卡住了

00:09:37.600 --> 00:09:42.880
学校数据放置呃，但是你几乎知道

00:09:42.880 --> 00:09:47.760
除了这个，我花了很多时间

00:09:47.760 --> 00:09:53.680
嗯，上周，今天，还有院长

00:09:53.680 --> 00:09:59.120
计划好，帮助他计划呃

00:09:59.279 --> 00:10:05.920
通过位交换获得大块的能力，这是从我们的

00:10:05.920 --> 00:10:08.240
角度，您基本上可以将其视为

00:10:08.240 --> 00:10:15.040
嗯，如何在不观看视频的情况下在巨大的溪流中四处移动

00:10:15.040 --> 00:10:21.120
嗯，是的，我们将在整个hack中尝试将它们放在一起

00:10:21.120 --> 00:10:23.360
一周，至少您知道一个概念，因为

00:10:23.360 --> 00:10:28.720
有很多很多特殊情况，我们必须有点像

00:10:28.720 --> 00:10:32.480
意识到不是被完全弃用，而是

00:10:32.480 --> 00:10:36.079
基本思想是呃，基本上是

00:10:36.079 --> 00:10:40.320
像史蒂文一样勾勒出来的东西

00:10:40.320 --> 00:10:44.160
像2017年之类的东西

00:10:44.160 --> 00:10:52.000
我们基本上说您作为客户有某种方式

00:10:52.000 --> 00:10:59.120
向其他同伴查询我们所谓的sid

00:10:59.120 --> 00:11:04.399
这本质上只是一个不同的呃流哈希函数

00:11:04.399 --> 00:11:07.760
你知道sha 1班车56 75没关系吗

00:11:07.760 --> 00:11:11.760
基本上可以以最小状态重新启动的任何事物

00:11:11.760 --> 00:11:18.000
你会得到一组积木

00:11:18.000 --> 00:11:21.440
您的清单文件描述了一组块，

00:11:21.440 --> 00:11:27.519
如果您退出，则应该能够将其组合成一个流，您可以

00:11:27.519 --> 00:11:29.760
然后使用此附加信息进行验证

00:11:29.760 --> 00:11:34.880
基本上每一个告诉你的清单

00:11:34.880 --> 00:11:38.880
兆字节左右与特定

00:11:38.880 --> 00:11:45.519
如果您为此s ID使用的哈希值的初始化向量，

00:11:45.519 --> 00:11:48.640
根据您已经获得的数据运行它

00:11:48.640 --> 00:11:55.120
您应该以与整个事物的缓存完全相同的sid作为结尾，并且

00:11:55.120 --> 00:11:59.279
是的，我们基本上映射了更高的水平

00:11:59.279 --> 00:12:03.440
那部分，嗯，我不知道嗯，与呃核对

00:12:03.440 --> 00:12:06.399
与其他人最喜欢我们的选择之一

00:12:06.399 --> 00:12:11.839
恩，是的，我们将在半个星期内看到情况如何，所以我有

00:12:12.079 --> 00:12:15.760
我认为下一个是真实的

00:12:16.720 --> 00:12:25.360
确保上周与ipld相关的事情我采取状态差异和graphql的东西

00:12:25.360 --> 00:12:31.600
并将其拉到actor v3 um上，因此它现在具有已实现的文件硬币

00:12:31.600 --> 00:12:36.320
带有新架构的架构，事实证明这是很多

00:12:36.320 --> 00:12:41.200
代码重复，但没有实际变化

00:12:41.200 --> 00:12:45.360
嗯，这很令人兴奋，这是因为我实际上没有计划

00:12:45.360 --> 00:12:51.200
我只是假装自己就像是他们的adl，所以我假装自己

00:12:51.200 --> 00:12:56.160
就像它是一张地图，之前和之后都是地图

00:12:56.160 --> 00:13:00.079
所以我在模式表示中的所有类型都没有改变

00:13:00.079 --> 00:13:03.120
但是我必须重复所有类型

00:13:03.120 --> 00:13:08.160
这样我就知道我在v3节点中，因此当我看到障碍物时

00:13:08.160 --> 00:13:13.760
在那个v3节点中，我应该使用较新的露营装载机来装载那些手

00:13:13.760 --> 00:13:17.440
所以我现在基本上有多个版本

00:13:17.440 --> 00:13:21.360
只是在其结构名称um和旧版本上被标记

00:13:21.360 --> 00:13:24.959
在整个filecoin中设置节点样式，以便我的加载程序

00:13:24.959 --> 00:13:28.000
可以基于它在哪个子树中

00:13:28.000 --> 00:13:31.760
如果它处于av3与v2 um状态路由中

00:13:31.760 --> 00:13:35.440
知道在这些放大器之一中运行时，应该使用哪个营地装载机

00:13:35.440 --> 00:13:40.079
类型，但这似乎在很大程度上起作用

00:13:40.079 --> 00:13:43.680
压力有

00:13:44.560 --> 00:13:48.480
由于v3 actor升级仍在进行中，因此有所减少

00:13:48.480 --> 00:13:52.880
嗯，我会在这两件事上大声呼u

00:13:52.880 --> 00:13:59.040
一个um硬币硬币的人没有将他们的所有弹弓都更改为v3弹弓

00:13:59.040 --> 00:14:02.160
在生物飞机上仍然潜伏着一些v2障碍

00:14:02.160 --> 00:14:06.560
因此即使升级后我们仍然不会拥有完整的数据模型

00:14:06.560 --> 00:14:12.720
嗯，尤其是从每个块标题链接的消息仍然是

00:14:12.720 --> 00:14:17.519
使用上一个阵营进行链接，并且没有版本控制指针

00:14:17.519 --> 00:14:20.240
块头或要在其中发信号的消息结构

00:14:20.240 --> 00:14:23.600
现在应该使用不同的放大器实现

00:14:23.600 --> 00:14:27.519
不像国家路线，所以他们正在考虑该怎么做

00:14:27.519 --> 00:14:30.320
并希望在将来的某个时候他们会

00:14:30.320 --> 00:14:34.720
并可能期望仅在街区高度上执行此操作，因此一旦您遇到了

00:14:34.720 --> 00:14:38.480
块头的高度超过某个数字

00:14:38.480 --> 00:14:41.360
现在知道消息将以不同的方式进行编码，因此

00:14:41.360 --> 00:14:45.199
成为一个新的隐性事物，学习另一个隐性事物

00:14:45.199 --> 00:14:47.920
以前我们只是用的宽度

00:14:47.920 --> 00:14:51.680
我们在您的尺寸和思考方式方面知道的这五个常数

00:14:51.680 --> 00:14:55.360
现在，已对参数组进行参数设置，并且在不同的参数组中有所不同

00:14:55.360 --> 00:14:59.680
嗯，这是另一种存在于模式中的数据

00:14:59.680 --> 00:15:02.240
因为有时候你会碰到这些邮票，就像哦

00:15:02.240 --> 00:15:06.079
这是一个只有六人的汉普顿，而与之相对的是这些人的营地

00:15:06.079 --> 00:15:09.360
有五个嗯，我不知道我们是否有个好地方

00:15:09.360 --> 00:15:13.680
在评论之外的任何地方对um进行编码

00:15:13.680 --> 00:15:16.800
但是当我们进行变异时，这当然很重要

00:15:16.800 --> 00:15:21.120
嗯，我觉得少了点，所以尽管你去读书是很有帮助的

00:15:21.120 --> 00:15:24.560
我想你可以从呃推断出它有多宽

00:15:24.560 --> 00:15:28.399
位宽度可能是该位字段的

00:15:28.399 --> 00:15:32.320
但是已经添加了这个额外的隐式参数

00:15:32.320 --> 00:15:36.079
你知道他们只是让杆的生活变得轻松

00:15:36.079 --> 00:15:42.160
嗯，我想这就是关于呃放大器的全部内容，

00:15:42.160 --> 00:15:45.759
那个数据结构，嗯，实际上是这个星期

00:15:45.759 --> 00:15:52.880
开始在我所拥有的javascript uH方面工作

00:15:52.880 --> 00:15:57.920
jsipfs构建并在浏览器中，它似乎获得了节点ID并连接到

00:15:57.920 --> 00:16:03.279
使用新的Web Pack的东西，哦，男孩

00:16:03.279 --> 00:16:06.560
现在它不再为您提供v5中的所有polyfill，因此您必须

00:16:06.560 --> 00:16:10.000
注意到所有不存在的所有事物，并慢慢修复它们，直到

00:16:10.000 --> 00:16:12.320
东西加载，但最终不会加载，所以很好

00:16:12.320 --> 00:16:17.279
所以现在我认为第一步是我能

00:16:17.279 --> 00:16:20.240
使用像dht提供程序一样查找也感兴趣的所有节点

00:16:20.240 --> 00:16:22.560
相同的sid，然后从那里创建一个pub sub

00:16:22.560 --> 00:16:27.199
围绕该节点集合进行分组，以便能够将消息发送给其他人

00:16:27.199 --> 00:16:29.759
在一个房间里做一些消息后端

00:16:29.759 --> 00:16:36.000
在浏览器中传输，所以这是一个很酷的时间

00:16:36.000 --> 00:16:39.519
谢谢，接下来是杆

00:16:41.360 --> 00:16:44.480
嗯，这是我不得不回过头来尝试对什么进行分类的那几周之一

00:16:44.480 --> 00:16:46.560
我已经做完了，因为感觉不像我已经取得了很大的成就

00:16:46.560 --> 00:16:52.399
嗯，但是那是因为我一直在照顾

00:16:52.399 --> 00:16:55.279
孩子多半是上周，所以我实际上没有做很多事情

00:16:55.279 --> 00:16:59.040
嗯，所以杰森（Jackson）父亲一直在努力，我一直在认真地研究这个问题

00:16:59.040 --> 00:17:03.440
因为我真的可以品尝到完成的味道

00:17:03.440 --> 00:17:06.880
感觉就像我捆绑了dag pb和dag seabor

00:17:06.880 --> 00:17:10.559
我真的想要达克·杰森（Dak Jason）做，因为我我只是

00:17:10.559 --> 00:17:14.160
我一直想用它来测试夹具

00:17:14.160 --> 00:17:18.959
只是为了能够表达您想要对block做的任何事情

00:17:18.959 --> 00:17:23.679
可读性测试中的变异和创造

00:17:23.679 --> 00:17:26.480
复制并粘贴，这就是我的主要目的

00:17:26.480 --> 00:17:29.440
尿布袋杰森的动机，但得到它

00:17:29.440 --> 00:17:33.440
只需保持一致并进行整理就可以了

00:17:33.440 --> 00:17:37.200
嗯，我真的很努力地得到一个新的

00:17:37.200 --> 00:17:40.559
嗯，我不知道我想我上周在开会，所以其中一些是

00:17:40.559 --> 00:17:44.559
从前一周开始，但我有一个新的javascript实现

00:17:44.559 --> 00:17:47.520
那个使用很多相同的后端代码

00:17:47.520 --> 00:17:52.400
就像我做过的dagsebor工作一样，进行解析和编码

00:17:52.400 --> 00:17:56.080
以确定性的方式处理我们关心的所有规则

00:17:56.080 --> 00:18:01.200
嗯，我这样做的原因不是我怀疑我是否真的可以

00:18:01.200 --> 00:18:04.160
由于速度原因替换了当前的，但是

00:18:04.160 --> 00:18:07.360
事实证明我可以喜欢速度是

00:18:07.360 --> 00:18:10.720
在某些地方相当甚至更好

00:18:10.720 --> 00:18:15.840
太好了，但是我想去的是

00:18:15.840 --> 00:18:21.440
eric在um中拥有um令牌的问题

00:18:21.440 --> 00:18:26.880
cid和字节数您实际如何流式传输

00:18:26.880 --> 00:18:30.799
阅读它，您希望能够提早保释，

00:18:30.799 --> 00:18:34.000
要么说这不是我想的那样，那是

00:18:34.000 --> 00:18:39.200
只是一些标准地图，或者是格式错误的字节或cid，或者是

00:18:39.200 --> 00:18:43.600
是一个cid或um字节，因此处理步骤

00:18:43.600 --> 00:18:46.640
我们传统上不必用javascript来处理，因为您只是

00:18:46.640 --> 00:18:48.720
没有证实整个事情，然后你

00:18:48.720 --> 00:18:53.280
检查它，但是如果您以流方式进行操作，则它会变成

00:18:53.280 --> 00:18:56.080
不同的野兽，所以我想做到这一点，所以我可以玩

00:18:56.080 --> 00:19:01.600
围绕它来描述那些规则，所以在拉

00:19:01.600 --> 00:19:05.280
要求我已链接到dag jason的规格仓库

00:19:05.280 --> 00:19:08.720
我已经描述了这些规则，我知道有人对此发表评论

00:19:08.720 --> 00:19:13.840
对于um修复我很感激的语言，因为它是

00:19:13.840 --> 00:19:18.880
很难清楚地描述它们，所以我会尽力而为

00:19:18.880 --> 00:19:22.960
专注于做到这一点另一件事是我

00:19:22.960 --> 00:19:26.880
我是不是一直想问eric在哪里

00:19:26.880 --> 00:19:30.320
iple的主要版本是因为他开始了

00:19:30.320 --> 00:19:36.640
拉请求以正确添加字节，我认为cid的东西

00:19:36.640 --> 00:19:41.120
ipld prime，那只是坐在他有点像的一个分支上

00:19:41.120 --> 00:19:44.640
放弃了，但现在分支似乎已经消失了，所以我想知道是否

00:19:44.640 --> 00:19:49.280
这项工作刚刚被完全抛弃，我们需要重新开始

00:19:49.280 --> 00:19:54.720
嗯或其他的东西，所以最好将iple灌注到这个水平

00:19:54.720 --> 00:19:58.080
真正的最终目标是拥有两个实现

00:19:58.080 --> 00:20:02.640
完全一样的工作方式我一直玩的另一件事是

00:20:02.640 --> 00:20:06.080
迈克尔开始使用的加密内容

00:20:06.080 --> 00:20:09.919
规格库中的拉取请求和多种格式的请求（一种）

00:20:09.919 --> 00:20:14.559
试图解决它，因为我们确实

00:20:14.559 --> 00:20:19.840
就像是，让我们使用es，我们仍在发明新的加密货币

00:20:19.840 --> 00:20:23.120
而且，所有这些都让您知道了警告

00:20:23.120 --> 00:20:26.400
你不应该发明自己的加密系统

00:20:26.400 --> 00:20:30.480
伴随着它，所以一直在尝试

00:20:30.480 --> 00:20:35.280
嗯，找出这个东西的所有边界，以便

00:20:35.280 --> 00:20:39.039
当我们推出它时，我们可以说这样的事情对

00:20:39.039 --> 00:20:42.400
这些情况下，它具有合理的默认值，它不会让您

00:20:42.400 --> 00:20:46.320
在大多数情况下，请使用脚踏枪，但请勿在这些情况下使用

00:20:46.320 --> 00:20:50.720
的地方，因为它不会获得您期望的保证

00:20:50.720 --> 00:20:57.120
嗯，是的，那个地方有很多空间

00:20:57.120 --> 00:20:59.600
如果人们只是选择现成的说这是一个通用的

00:20:59.600 --> 00:21:04.240
我可以用于我的应用程序的加密东西

00:21:04.240 --> 00:21:07.520
它具有在周围移动数据的特殊模型

00:21:07.520 --> 00:21:11.200
嗯，事情有可能变坏，所以

00:21:11.200 --> 00:21:16.240
是的，无论如何，有些想法已经落入该规范中

00:21:16.240 --> 00:21:20.400
是的，我们会看到我们很快会继续前进

00:21:20.400 --> 00:21:24.159
是的，我需要回复我对乌姆的意思，但是

00:21:24.159 --> 00:21:27.280
我们应该把推荐的这些算法放到那里

00:21:27.280 --> 00:21:30.720
喜欢其中的哪一个是最好的，因为不这样做只是愚蠢的

00:21:30.720 --> 00:21:34.320
一系列的算法，嗯，然后再说

00:21:34.320 --> 00:21:37.600
我们想要添加的其他算法，例如我，我不在乎它们是什么

00:21:37.600 --> 00:21:41.440
只是它们只是多格式表中的密码条目，就像我们不是

00:21:41.440 --> 00:21:45.840
确保周围有一个实施

00:21:46.640 --> 00:21:58.080
嗯，我想我想是我，是的，谢谢，接下来是卡尔森

00:21:58.080 --> 00:22:02.000
嗨，我是呃，我是这里的局外人，实际上我在

00:22:02.000 --> 00:22:05.760
公共空间，所以我必须保持面具在嗯

00:22:05.760 --> 00:22:08.960
我在酒店大堂，所以我要让它超短

00:22:08.960 --> 00:22:13.919
列出了我本周正在做的一些事情，包括修补

00:22:13.919 --> 00:22:20.320
某些ipsql sql证明作为crdt的东西

00:22:20.320 --> 00:22:25.360
希望有几张幻灯片可以让您稍后浏览

00:22:25.360 --> 00:22:29.280
这与我一直在做的一些工作有关

00:22:29.280 --> 00:22:36.559
默克尔标记为通用通用标准，因此

00:22:36.559 --> 00:22:42.080
令我兴奋不已，直到今天，我仍在阅读一些

00:22:42.080 --> 00:22:45.360
迈克尔的东西，就像哦，该死的，我们可以解决

00:22:45.360 --> 00:22:51.840
很多类似的问题，例如cid set原语，所以这真的很酷

00:22:51.840 --> 00:22:56.720
嗯，我也开始在um上做一些类似的文档

00:22:56.720 --> 00:23:01.600
纺织方面，因此开始释放一堆

00:23:01.600 --> 00:23:06.240
javascript库，用于测试非常简单的原语

00:23:06.240 --> 00:23:10.880
点对点的系统，所以我刚刚发布了一个库

00:23:10.880 --> 00:23:14.640
称为lib p2p捆绑包，基本上只是

00:23:14.640 --> 00:23:19.200
lib p2p捆绑包，在ipfs中用作默认捆绑包

00:23:19.200 --> 00:23:22.320
这样，如果您只想调整lib p2p捆绑包

00:23:22.320 --> 00:23:27.760
正是ipfs使用的功能，但您只需要p2p捆绑包即可

00:23:27.760 --> 00:23:30.240
只需使用所有默认值都相同

00:23:30.240 --> 00:23:34.640
事实证明，它非常方便，因为我可以把它放进去

00:23:34.640 --> 00:23:38.640
无需像limp p2p repo这样的整体安装程序

00:23:38.640 --> 00:23:42.640
这是零配置，它只是一种工作，所以很好，我将把

00:23:42.640 --> 00:23:47.120
稍微多花些力气就可以打包，就像

00:23:47.120 --> 00:23:50.240
嗯，是一个完整的yes版本，所以您可以

00:23:50.240 --> 00:23:54.000
有点在浏览器中拉es模块以及类似的东西，但目前

00:23:54.000 --> 00:23:58.080
它非常方便，而且它已经帮助我测试了一堆

00:23:58.080 --> 00:24:04.720
就像点对点一样，就像区块交换算法一样

00:24:04.720 --> 00:24:08.799
因此，与此同时，我发布了一个名为lib p2p rpc的东西

00:24:08.799 --> 00:24:16.000
然后，您可以使用um uh michael真正简单的rpc库

00:24:16.000 --> 00:24:20.799
这样您就可以像测试不同的rpc配置一样测试，并且您

00:24:20.799 --> 00:24:24.159
只需使用此lib p2p捆绑包，您就可以轻松测试所有内容，这真的很容易

00:24:24.159 --> 00:24:28.000
诸如图同步算法之类的非常酷的东西，并且事情真的很快，所以

00:24:28.000 --> 00:24:30.960
那很有趣，我对此有些偏颇

00:24:30.960 --> 00:24:34.720
因为我一直在和你一起玩，所以知道不同的区块交换

00:24:34.720 --> 00:24:39.279
算法嗯，所以事实证明，你可以采取那些

00:24:39.279 --> 00:24:42.799
相同的工具，并且喜欢获取fetch api

00:24:42.799 --> 00:24:48.400
覆盖p2p以及各种其他整洁的东西，然后您意识到，如果

00:24:48.400 --> 00:24:53.360
你可以像webrtc一样让两个对等体连接两个浏览器对等体

00:24:53.360 --> 00:24:56.240
就像他们两个之间的http查询

00:24:56.240 --> 00:24:59.760
还有一些有趣的事情，这样您就可以像服务器一样纯粹地工作，

00:24:59.760 --> 00:25:03.200
一个像对等服务器一样有趣的服务器

00:25:03.200 --> 00:25:06.640
嗯，然后在纺织方面，我们只是

00:25:06.640 --> 00:25:10.799
举行了一次大型团队会议，我们试图统一我们的工作方式

00:25:10.799 --> 00:25:15.120
令牌和整个堆栈中的访问权限，我们开始

00:25:15.120 --> 00:25:18.799
倾向于裂变小组一直在研究的东西

00:25:18.799 --> 00:25:22.960
ucans用户访问令牌基本上是一种方法

00:25:22.960 --> 00:25:28.799
使用类似嵌套的许可对jwt进行编码

00:25:28.799 --> 00:25:32.320
如果你接受了，再加上一些度数的工作，

00:25:32.320 --> 00:25:40.640
嗯，那是我和Oed的资助，那么你会得到像

00:25:40.640 --> 00:25:44.400
基本上是嵌套权限的ipld结构

00:25:44.400 --> 00:25:48.960
因此，您可以像传递您所知的那样，将其作为标题发送给您，例如您可以说出外观

00:25:48.960 --> 00:25:52.640
这是我的我可以的，无论谁操作

00:25:52.640 --> 00:25:56.640
您可以追踪类似许可的历史记录

00:25:56.640 --> 00:26:01.760
一直分配回根目录以及那些带有ipld链接的目录

00:26:01.760 --> 00:26:05.760
所以你可以做一些事情，比如说看起来我拥有这个数据，但是我在告诉

00:26:05.760 --> 00:26:08.960
我告诉这个同龄人，他们也可以

00:26:08.960 --> 00:26:13.200
做某种操作，我签署

00:26:13.200 --> 00:26:16.320
然后我将我的初始签名链接到

00:26:16.320 --> 00:26:20.080
乌肯（Ucan），然后那个齿轮可以通过，你可以沿着它说，看起来如此某某

00:26:20.080 --> 00:26:23.600
说我可以做到这一点，你可以一直追溯到

00:26:23.600 --> 00:26:28.799
根权限和um，这样您就可以开始和该规则

00:26:28.799 --> 00:26:33.039
就像这些权限必须小于或等于

00:26:33.039 --> 00:26:37.840
像根一样，所以您可以越来越喜欢

00:26:37.840 --> 00:26:41.440
一种不信任的权限分配

00:26:41.440 --> 00:26:45.120
或者很好，您可以相信允许该路由授予这些权限

00:26:45.120 --> 00:26:47.840
然后您就可以开始做一些很棒的事情

00:26:47.840 --> 00:26:52.000
例如基于功能的访问控制，这就是我们

00:26:52.000 --> 00:26:54.320
探索，看起来很有前途

00:26:54.320 --> 00:27:00.159
嗯，超级酷的声音听起来像对象功能嗯，就是这样

00:27:00.159 --> 00:27:04.880
根据是的，是的，对英国来说，是巨大的道具

00:27:04.880 --> 00:27:09.120
裂变团队喜欢嫁给jwts和一些

00:27:09.120 --> 00:27:16.159
谷歌，嗯，那法国甜点叫什么

00:27:16.159 --> 00:27:22.320
蛋白杏仁饼干Google的蛋白杏仁饼干有点是uh设置，jwts和ipld之类的

00:27:22.320 --> 00:27:26.880
这样放置在一起相当简单但功能强大

00:27:26.880 --> 00:27:32.159
如访问控制原语（如果您有指向其中一些的链接）

00:27:32.159 --> 00:27:34.399
在文档中确实很棒的事情

00:27:34.399 --> 00:27:38.320
以便我们可以查找它们，因为这听起来真的很有趣

00:27:38.320 --> 00:27:44.399
你刚才提到的是的，是的，很酷，是的，我会提供一些链接

00:27:46.480 --> 00:27:51.760
谢谢卡尔森·埃里克，你有更新吗

00:27:52.080 --> 00:27:56.640
嗯，这周没来一吨，没有做好充分的准备，对不起

00:27:56.880 --> 00:28:02.080
嗯，也许在袖口上方了，我做了一些代码审查，

00:28:02.080 --> 00:28:04.399
丹尼尔和其他几个人本周和

00:28:04.399 --> 00:28:08.080
意识到像我可能实际上需要退缩其中一种方法

00:28:08.080 --> 00:28:12.240
我正在将模式dmt统一化为样板

00:28:12.240 --> 00:28:16.000
它实际上失控了，所以我们正在考虑

00:28:16.000 --> 00:28:19.120
实际上以不同的方式打破了这一点

00:28:19.120 --> 00:28:25.840
问题源于我们生成的代码

00:28:25.840 --> 00:28:30.000
上面有一些方法可以暴露自己的类型信息

00:28:30.000 --> 00:28:35.919
自我描述，这意味着它以一个周期结束，所以我们

00:28:35.919 --> 00:28:41.039
实际上认为我们可能会停止这样做，因为到目前为止该功能

00:28:41.039 --> 00:28:44.399
实际上在其效用上是一种假设

00:28:44.399 --> 00:28:49.760
所以就像也许我们不会，那会让我们打破一些

00:28:49.760 --> 00:28:53.279
以前是有问题的周期，也许让我们通过

00:28:53.279 --> 00:28:59.840
减少了更多的混浊，所以可能在将来

00:29:02.320 --> 00:29:09.360
好的，谢谢你，查理，你有更新吗

00:29:09.360 --> 00:29:13.279
是的，所以我正在处理的东西，是否符合规范，并且

00:29:13.279 --> 00:29:16.640
幕后的戏剧让迈克尔和罗德（Michael and Rod）感谢您

00:29:16.640 --> 00:29:21.360
评论和帮助我，胡安被塞进去，我想呃

00:29:21.360 --> 00:29:24.559
只是试图弄清楚，他们就可以从政治上导航前进的道路

00:29:24.559 --> 00:29:28.799
这与技术无关，或者与缺乏ipl交易无关

00:29:28.799 --> 00:29:31.440
dag cbo的尊重与规范不符

00:29:31.440 --> 00:29:35.440
引用，然后实际上是从做的引导

00:29:35.440 --> 00:29:38.720
规格或我借了一些

00:29:38.720 --> 00:29:43.600
规范中的规范算法文本，但我将其放在

00:29:43.600 --> 00:29:46.720
sebor节希望这dagsebor节

00:29:46.720 --> 00:29:49.679
将继承它，因此它打开了整个

00:29:49.679 --> 00:29:54.399
潘多拉（Pandora）的贡献和ipr和

00:29:54.399 --> 00:29:57.520
嗯，然后是mime类型，仅此而已

00:29:57.520 --> 00:30:03.600
哦，那是戏剧，所以我不确定前进的方向

00:30:03.600 --> 00:30:07.200
实际上有一些关于在创造中进行创作的话题吗？

00:30:07.200 --> 00:30:11.279
规格注册表um，但这就是放置的地方

00:30:11.279 --> 00:30:15.840
属性不是um核心表示，所以

00:30:15.840 --> 00:30:19.919
如果我们将其超出规范，这将在加拿大发布

00:30:19.919 --> 00:30:23.600
接下来大概一两个星期，然后它就会掉下来，

00:30:23.600 --> 00:30:25.919
这令人沮丧，因为我一直喜欢

00:30:25.919 --> 00:30:29.520
参与了大约两年，现在我想看看

00:30:29.520 --> 00:30:36.640
像文件一样，是dag seaborn呃，主要是

00:30:36.640 --> 00:30:40.720
无论如何还是令人沮丧

00:30:44.080 --> 00:30:48.640
谢谢，无论如何，对您的病人来说做得很好，因为

00:30:48.640 --> 00:30:53.039
就连那个线程中只有短短的几周就一直在延伸我的生命

00:30:53.039 --> 00:30:55.200
所以

00:30:57.360 --> 00:31:03.760
是的，所以这是

00:31:03.760 --> 00:31:10.480
最新消息um上还有其他事项，我们要让michael参加

00:31:10.480 --> 00:31:14.960
展示他的一些东西

00:31:15.519 --> 00:31:19.679
是的，迈克尔，你想我什么都没看到吗，是的，让我们做吧

00:31:19.679 --> 00:31:25.039
好吧，开始播放

00:31:25.360 --> 00:31:32.640
我现在正在共享我的屏幕，我们去这里，我们去吧，也许好吧，我们只是

00:31:32.640 --> 00:31:35.679
做我们可以通过的事情，这很好，因为到最后

00:31:35.679 --> 00:31:41.760
我用完了一点点嗯嗯，所以sql证明

00:31:41.760 --> 00:31:48.399
好吧，这是将数据库分为三个不同部分的一种

00:31:48.399 --> 00:31:52.000
变得更加清晰，您如何处理去中心化数据库，

00:31:52.000 --> 00:31:55.840
本质上是这种模型中的sql，尤其是um

00:31:55.840 --> 00:32:00.399
所以我们实际上是在分离状态转换

00:32:00.399 --> 00:32:04.720
从像是通过一致的状态表示

00:32:04.720 --> 00:32:07.760
所以您需要这些过渡，然后您需要引用这些状态

00:32:07.760 --> 00:32:12.159
转换um，您需要在互斥锁上执行此操作

00:32:12.159 --> 00:32:14.799
是的，所以数据库通常会为您提供某种帮助

00:32:14.799 --> 00:32:18.080
人们已经同意你在做这个

00:32:18.080 --> 00:32:21.600
这样您就可以在互斥体上拥有某种状态

00:32:21.600 --> 00:32:25.279
嗯，然后存储与此分开，我认为我们都

00:32:25.279 --> 00:32:28.399
真的用来分离存储层和那种排序

00:32:28.399 --> 00:32:30.960
您可以将这些块放入其中的任何键值存储中

00:32:30.960 --> 00:32:34.000
嗯，我想对您来说，认识其他人

00:32:34.000 --> 00:32:37.760
一个非常新的数字，通常是数据库写到一个非常特定的

00:32:37.760 --> 00:32:42.399
继续运行um的文件格式，因此，如果您看起来像原始数据库

00:32:42.399 --> 00:32:46.320
架构，我们只需要一种状态，就需要将其移至

00:32:46.320 --> 00:32:48.880
第二种状态，我们要进行大量操作

00:32:48.880 --> 00:32:52.000
并做一些我们可以回滚的中间交易

00:32:52.000 --> 00:32:56.080
嗯，因为我们这样做了，然后我们最终将它提交给这个互斥体

00:32:56.080 --> 00:32:59.360
um在典型的数据库中完成，例如fsync调用

00:32:59.360 --> 00:33:03.039
实际上就像写所有有关磁盘的信息

00:33:03.039 --> 00:33:06.640
分批处理整个交易，您知道是否要

00:33:06.640 --> 00:33:09.360
确保它在多个位置，然后实际上是一个同步

00:33:09.360 --> 00:33:12.000
在多台计算机和不同的地方，然后

00:33:12.000 --> 00:33:15.760
这一切意味着，当您获得权利的答复时，您将拥有一个

00:33:15.760 --> 00:33:18.000
确保将其实际写入磁盘

00:33:18.000 --> 00:33:22.000
那实际上是每个人现在都同意的状态

00:33:22.000 --> 00:33:27.360
好吧，所以f-sync确实不适用于分布式系统，就像我们不能

00:33:27.360 --> 00:33:29.679
我们不能把所有的保证都放在此之上

00:33:29.679 --> 00:33:32.320
嗯，如果我们想要像这样的分散系统，我们可能会这样做

00:33:32.320 --> 00:33:37.440
像我们想要的那样使用加密技术，我们想复制一些这样的内容

00:33:37.440 --> 00:33:41.840
保证我们进入一个去中心化的系统um和

00:33:41.840 --> 00:33:44.960
如此多的数据库，例如nosql世界和

00:33:44.960 --> 00:33:48.320
最终是一致且高度可扩展的

00:33:48.320 --> 00:33:52.320
因为事实证明，如果您想执行sql，则很难做到这一点

00:33:52.320 --> 00:33:55.600
完全一致且分散的，因为您无法真正对其建模

00:33:55.600 --> 00:33:59.120
没有像这些epson之一保证um那么

00:33:59.120 --> 00:34:04.880
多数大型数据库最终都像sql一样是较低级别的原语

00:34:04.880 --> 00:34:08.800
它并没有像sql那样做那么多的sql

00:34:08.800 --> 00:34:12.399
嗯，但您可以在此行为之上进行建模，然后使用

00:34:12.399 --> 00:34:15.919
可以做所有事情的原始，但是我们在这里想要做的是

00:34:15.919 --> 00:34:20.079
实际使用所有sql并实际为您提供sql作为一种语言

00:34:20.079 --> 00:34:23.119
进行操作um并允许其在

00:34:23.119 --> 00:34:28.000
分布式系统很好，这就是我们要做的

00:34:28.000 --> 00:34:32.879
使用sql证明作为一个证明只是功能

00:34:32.879 --> 00:34:36.000
转换它实际上需要输入哈希

00:34:36.000 --> 00:34:40.399
并生成输出哈希um，并针对该实现和版本

00:34:40.399 --> 00:34:44.000
ip sql它将始终产生该哈希值，就像那样，这完全是

00:34:44.000 --> 00:34:46.560
确定性一旦稳定并转变为

00:34:46.560 --> 00:34:49.359
规格，那么它将像真正一致的权利

00:34:49.359 --> 00:34:53.280
嗯，但我们实质上是在谈论这种确定性状态转移

00:34:53.280 --> 00:34:56.800
从一个状态到另一个um和输入

00:34:56.800 --> 00:35:00.400
是数据库和sql语句的当前哈希

00:35:00.400 --> 00:35:04.079
我们将这些东西放在一起并对其进行散列，这就是输入的散列权

00:35:04.079 --> 00:35:09.200
嗯，输出呃有点复杂，不只是那种

00:35:09.200 --> 00:35:11.200
之后的数据库，就像我们正在谈论的

00:35:11.200 --> 00:35:14.240
在这里读和写，我们不仅在谈论权利

00:35:14.240 --> 00:35:20.000
嗯，您得到的是结果，所以当您执行sql查询时

00:35:20.000 --> 00:35:23.200
行会工具就像一堆列数据一样

00:35:23.200 --> 00:35:25.280
如果您做对了，您将不会获得结果

00:35:25.280 --> 00:35:30.160
然后得到两组，本质上一组是读取的块，另一组是读取的块

00:35:30.160 --> 00:35:32.960
是权利um的块，如果您只是在阅读，

00:35:32.960 --> 00:35:37.680
显然您没有任何权利，而这些CID集只是我们的树而已

00:35:37.680 --> 00:35:40.240
就像我一直在谈论的那种矮矮胖胖的树木

00:35:40.240 --> 00:35:43.520
um上的数据库，但我们可以继续改进

00:35:43.520 --> 00:35:46.240
并进一步完善它们，但它们已经像

00:35:46.240 --> 00:35:49.680
真正有能力进行比较的数据结构

00:35:49.680 --> 00:35:53.760
um，最后在执行该语句的末尾得到哈希，所以如果

00:35:53.760 --> 00:35:56.800
这是一个查询，然后它将与输入哈希相同

00:35:56.800 --> 00:36:00.160
但是，如果更改了数据库，那么现在您有了新的数据库头。

00:36:00.160 --> 00:36:04.720
数据库末尾的声明还可以

00:36:04.720 --> 00:36:08.079
非常重要，我们必须锁定在这里

00:36:08.079 --> 00:36:12.800
没有在讨论遍历，我们也没有将遍历描述为

00:36:12.800 --> 00:36:15.599
这些数据结构，显然有遍历

00:36:15.599 --> 00:36:18.320
在执行sql语句时发生的情况将遍历

00:36:18.320 --> 00:36:21.359
树，但我们您会从中得到什么

00:36:21.359 --> 00:36:24.560
证明并不能告诉您有关遍历的任何信息

00:36:24.560 --> 00:36:27.119
而且我们从不附带有关遍历的任何内容

00:36:27.119 --> 00:36:32.560
在同伴之间，我们所运送的是这些证明，其中包含

00:36:32.560 --> 00:36:36.160
所有您访问过的区块地址，而您不必

00:36:36.160 --> 00:36:39.680
遍历其他内容以了解工作数据集

00:36:39.680 --> 00:36:43.200
这真的很重要，因为我们可以一直将它们进行比较

00:36:43.200 --> 00:36:47.200
产生增量，不仅是写入会产生

00:36:47.200 --> 00:36:50.079
一个cid集，它是先前状态的增量

00:36:50.079 --> 00:36:54.880
读操作还给我带来了它要读取的所有数据的集合

00:36:54.880 --> 00:36:58.320
读取它，如果我在新的位置上再次运行该查询

00:36:58.320 --> 00:37:01.040
数据库状态我可以接受新设置并进行比较

00:37:01.040 --> 00:37:03.760
反对旧设置并获得三角洲

00:37:03.760 --> 00:37:07.520
嗯，所以，如果我们在谈论您，就知道我们对图形同步的处理方式

00:37:07.520 --> 00:37:11.280
今天我们实际上从来没有做过一件以上的事情

00:37:11.280 --> 00:37:14.720
请求和响应了吧，如果我需要您执行sql查询，我就

00:37:14.720 --> 00:37:18.079
会说嘿，运行此查询，而不是像

00:37:18.079 --> 00:37:22.000
完整的证明或该系列中的所有读物都给了我

00:37:22.000 --> 00:37:26.880
在那和我之前拥有的先前状态之间的增量，您可以得到

00:37:26.880 --> 00:37:29.680
退去那个三角洲，这样你就可以像每个

00:37:29.680 --> 00:37:32.800
同步操作在每个应用程序操作中变成一个

00:37:32.800 --> 00:37:39.359
就像一个快速的请求响应周期

00:37:39.359 --> 00:37:43.839
是的，所以生产者都是国家链，它们都是交易性的

00:37:43.839 --> 00:37:46.000
状态更改，它们也是读取接口

00:37:46.000 --> 00:37:49.200
嗯，记住这一点很重要

00:37:49.200 --> 00:37:53.359
而且我什至还没有研究互斥的工作原理，但是

00:37:53.359 --> 00:37:56.880
您可以想象这些权利的链条，就像更新数据库一样

00:37:56.880 --> 00:37:59.280
在您可能知道的某个地方的存储中发布新的

00:37:59.280 --> 00:38:03.040
在ipns中指出，您可以将其粘贴到其他地方

00:38:03.040 --> 00:38:06.000
那是永久的，权威的，但是你想说

00:38:06.000 --> 00:38:10.160
这是数据库的当前状态，就像您可以说的那样

00:38:10.160 --> 00:38:13.359
证明正确之后您得到的是正确的

00:38:13.359 --> 00:38:16.800
嗯，我从一开始就谈到了这一点，但这对我来说真的很重要

00:38:16.800 --> 00:38:19.520
请注意，像这些证明一样，不能减少

00:38:19.520 --> 00:38:22.240
某人需要进行验证的计算

00:38:22.240 --> 00:38:26.640
他们只会减少数据量，但是却做得非常好

00:38:26.640 --> 00:38:31.520
因此，您知道您可以拥有一个数据提供程序，或者说它实际上是不受信任的

00:38:31.520 --> 00:38:34.560
他们可以访问所有可能是

00:38:34.560 --> 00:38:40.720
PB正确，您得到的回报是，您只知道其中的一小部分

00:38:40.720 --> 00:38:44.720
验证证明所必需的数据

00:38:44.720 --> 00:38:47.520
您只是为了查询或突变而得到的

00:38:47.520 --> 00:38:52.400
嗯，好的，直到我们继续前进之前，我应该

00:38:52.400 --> 00:38:55.680
大概想停一下

00:38:57.200 --> 00:39:02.240
嗯，我有一个，如果你这样的话，那套就回来了

00:39:02.240 --> 00:39:09.280
他们是否只返回查询的休假或您拥有的每个ca

00:39:09.280 --> 00:39:12.960
每次CID都遇到了每个CID，实际上是um

00:39:12.960 --> 00:39:16.079
像是从字面上传递过来的一组

00:39:16.079 --> 00:39:19.839
在javascript中，它实际上是一个通过整个读取传递的集合

00:39:19.839 --> 00:39:23.359
介面，因此每当它读取一个

00:39:23.359 --> 00:39:26.480
数据um或将um从缓存中拉出一个节点

00:39:26.480 --> 00:39:31.200
具有与之关联的块地址，该地址被添加到集合和um中

00:39:31.200 --> 00:39:34.400
是的，所以这就像整个树一样，所以

00:39:34.400 --> 00:39:37.359
您永远不需要进行遍历，这就是为什么

00:39:37.359 --> 00:39:40.079
它也是整个merkle的证明，虽然不对，所以它不只是叶子的叶子

00:39:40.079 --> 00:39:42.000
那棵树是它带到的所有树枝

00:39:42.000 --> 00:39:45.119
到达那里是的，因为您可以从根源追溯到

00:39:45.119 --> 00:39:48.720
验证证明是的，所以这些集合实际上可以是

00:39:48.720 --> 00:39:52.800
根深蒂固地绕过去，因为他们就像呃

00:39:52.800 --> 00:39:55.599
是的，是的，而且很棒

00:39:55.599 --> 00:39:58.560
关于它们的事情是，例如，如果您加密数据

00:39:58.560 --> 00:40:01.680
嗯，那么你可以嗯，你不必加密

00:40:01.680 --> 00:40:06.800
这些地址顶部的树就可以了，例如，您可以有一堆加密的文件

00:40:06.800 --> 00:40:10.319
集合中的地址，集合本身实际上就像

00:40:10.319 --> 00:40:14.480
可读性强，因此您可以像清晰地将其传递给您，并将其用于

00:40:14.480 --> 00:40:18.560
复制状态是的，是的，是的，您可以，而且您可以

00:40:18.560 --> 00:40:23.680
指的是显然是的，是的，我的意思是这些

00:40:23.680 --> 00:40:26.560
就像是设计用于

00:40:26.560 --> 00:40:29.359
像这样彼此正确，这就是我们获取设置数据结构的地方

00:40:29.359 --> 00:40:33.680
从嗯，这些没有什么不同

00:40:35.680 --> 00:40:38.720
嗯，我认为我们实际上已经涵盖了此幻灯片中的所有内容

00:40:38.720 --> 00:40:42.800
已经很酷了

00:40:42.800 --> 00:40:47.680
是的，好吧，让我们来看看它是真实的快速嗯，是的，所以我们采取这个呃

00:40:47.680 --> 00:40:51.200
db为null，因为我们正在创建一个新数据库，我们说create table with

00:40:51.200 --> 00:40:55.040
架构um，我们得到的是一组

00:40:55.040 --> 00:41:00.240
为此和新数据库所必需的写操作正确，因此，如果我们

00:41:00.240 --> 00:41:03.280
你知道实现这个数据库，我们只是将所有这些都写到存储中

00:41:03.280 --> 00:41:06.319
每当互斥量插入时更新，因此我们将

00:41:06.319 --> 00:41:10.000
现在将一些值插入此处，我们得到的结果就像新的写法一样

00:41:10.000 --> 00:41:13.119
在新的状态下，我们现在再次做同样的事情

00:41:13.119 --> 00:41:17.680
更新我们的数据库非常酷，有些事情

00:41:17.680 --> 00:41:20.960
这真的很有趣，我会讲一点

00:41:20.960 --> 00:41:24.480
因为我还没有时间围绕它创建幻灯片

00:41:24.480 --> 00:41:28.000
表的模式就像合同

00:41:28.000 --> 00:41:31.680
它可以确保由谁来运行这些证明

00:41:31.680 --> 00:41:35.680
将来当他们做新的插入物时会做产生的工作

00:41:35.680 --> 00:41:38.880
您需要针对何处进行查询的索引结构

00:41:38.880 --> 00:41:41.680
这些列，所以这真的是一个很酷的功能

00:41:41.680 --> 00:41:45.200
就像我们一样，您可以设计自己的桌子，

00:41:45.200 --> 00:41:49.359
设计您正在做的事情，您还需要烘烤这些操作

00:41:49.359 --> 00:41:53.280
嗯，要求进入要在其上运行的操作中。

00:41:53.280 --> 00:41:56.720
 dag表又发生了一件非常有趣的事情，所以

00:41:56.720 --> 00:42:00.079
我尚未对此进行记录，但是我有一个dag表实现，其中

00:42:00.079 --> 00:42:04.960
嗯，就像典型的sql数据库一样，它的行就像钻机一样

00:42:04.960 --> 00:42:08.160
但是您插入的是整个图形的Cid

00:42:08.160 --> 00:42:13.280
然后您为架构添加的列名称就是其中的路径

00:42:13.280 --> 00:42:17.280
结构等等在这个时候会发生什么

00:42:17.280 --> 00:42:19.359
像这个合同一样执行

00:42:19.359 --> 00:42:22.720
正确的是，您正在有效地提取数据

00:42:22.720 --> 00:42:26.240
在图中需要这些索引结构

00:42:26.240 --> 00:42:30.640
并且您实际上并没有存储其余的内容，因此，如果您知道所有的索引编制

00:42:30.640 --> 00:42:33.680
您需要一个庞大的连锁店，而您不想存储

00:42:33.680 --> 00:42:37.440
整个图，因为它很大，例如它是文件硬币链

00:42:37.440 --> 00:42:40.960
嗯，您可以烘焙合同哦，遍历这些属性以创建

00:42:40.960 --> 00:42:44.319
这些索引，然后每次有人写新状态时

00:42:44.319 --> 00:42:48.480
我们知道，为了获得这些索引，将发生这些遍历

00:42:48.480 --> 00:42:52.560
这些读取将显示在读取集中，但读取集中将不包含其余内容

00:42:52.560 --> 00:42:55.119
图中我们没有说需要索引

00:42:55.119 --> 00:42:58.800
对，所以这就像您使用时的一种有效的拔除结构

00:42:58.800 --> 00:43:03.119
随着时间的流逝，嗯，让我们看一下真正的阅读速度

00:43:03.119 --> 00:43:08.960
是的，嗯，我们确实看到我们选择了返回结果um该结果也

00:43:08.960 --> 00:43:11.359
上面有一个哈希，所以如果我在

00:43:11.359 --> 00:43:14.319
将来我可以检查um是否仅更改结果

00:43:14.319 --> 00:43:18.240
看着真的很好的哈希，只要我相信我

00:43:18.240 --> 00:43:22.240
另一方，然后我取回所有读物

00:43:22.240 --> 00:43:25.520
完成后，数据库um位于末尾

00:43:25.520 --> 00:43:30.160
交易嗯，这两个都有哈希地址

00:43:30.160 --> 00:43:33.359
就像我们可以哈希该块一样

00:43:33.359 --> 00:43:37.760
输入输出也被哈希处理，现在我们实际上知道该哈希处理

00:43:37.760 --> 00:43:40.240
产生此哈希，因此可以将其缓存

00:43:40.240 --> 00:43:45.359
永远正确，嗯，我不，哦，我没有在这里写下来，我不认为

00:43:45.359 --> 00:43:48.720
嗯，该死，虽然很好，但如果

00:43:48.720 --> 00:43:55.680
如果您想将这种操作作为一种HTTP请求来进行结构化

00:43:55.680 --> 00:43:58.960
所以您像在不同状态下一样输入http请求

00:43:58.960 --> 00:44:02.640
您正在更改的HTTP请求可以永远被缓存

00:44:02.640 --> 00:44:06.800
就在任何缓存层中，因为它只是该哈希的哈希

00:44:06.800 --> 00:44:09.920
如果您说执行此操作，则在进行增量计算时也会发生相同的情况

00:44:09.920 --> 00:44:13.440
查询此哈希，但随后只返回给我一个汽车文件

00:44:13.440 --> 00:44:16.640
此先前读取集之间的差值是

00:44:16.640 --> 00:44:19.119
将在htm请求中向您返回汽车文件，并且

00:44:19.119 --> 00:44:22.880
整个内容也可以像永远被缓存在hp缓存中一样

00:44:22.880 --> 00:44:30.160
嗯，我们谈到了这个问题，所以现在我们将新数据插入

00:44:30.160 --> 00:44:32.800
数据库，我们使用新的数据库再次运行查询

00:44:32.800 --> 00:44:36.960
数据库状态，哦，是的，我们得到了这个新的，阅读了这个新的

00:44:36.960 --> 00:44:40.640
一套嗯，读的是西数，那么我们就可以了哦

00:44:40.640 --> 00:44:45.200
是的，我确实在这里有对不起，但是，嗯，嗯，如果我们像我们一样

00:44:45.200 --> 00:44:48.000
谈到这个我不需要再谈了，但是是的，如果你喜欢

00:44:48.000 --> 00:44:52.800
字面上就像给我读交易，然后响应可以被永久缓存

00:44:52.800 --> 00:44:58.160
我真的在想，就像汽车档案一样，实际上是交换

00:44:58.160 --> 00:45:00.960
我认为您在此基础上建立的任何协议中的机制

00:45:00.960 --> 00:45:05.839
嗯，因为与cadb和我一直在工作的东西不同

00:45:05.839 --> 00:45:09.520
在它上面有索引结构的工作，您总是需要所有

00:45:09.520 --> 00:45:12.000
这些块，您总是只加载所有这些块

00:45:12.000 --> 00:45:15.760
线性地，当您得到他们时，您实际上不寻找他们，因为

00:45:15.760 --> 00:45:19.119
因为您已经在所有想要的地方进行了增量计算

00:45:19.119 --> 00:45:23.119
所有的块，所以您总是会像浸泡所有

00:45:23.119 --> 00:45:25.920
他们反复迭代，所以是的，我认为汽车文件确实

00:45:25.920 --> 00:45:28.640
就像正确的方式来移动这些数据

00:45:28.640 --> 00:45:33.200
嗯，是这样，为什么实际上我为什么不再次在这里暂停呢？

00:45:33.200 --> 00:45:37.760
嗯，在这一点上，问题

00:45:42.560 --> 00:45:47.839
罗德怎么想

00:45:49.280 --> 00:45:55.520
嗯，因为我最近一直在玩

00:45:55.520 --> 00:45:58.800
有了文件硬币数据，我的脑海立即跳了起来

00:45:58.800 --> 00:46:02.400
像这样的东西是完美的

00:46:02.400 --> 00:46:06.240
这非常适合您要查询和变异的大型数据结构

00:46:06.240 --> 00:46:07.920
因为我的意思是这就是sql的优点

00:46:07.920 --> 00:46:10.720
拿一些很大的东西，然后缩小到你所要的东西

00:46:10.720 --> 00:46:15.440
想要，这些鳕鱼套让我想

00:46:15.440 --> 00:46:19.040
这里有很多孩子[音乐]

00:46:19.040 --> 00:46:26.560
内存中保存并处理了大量数据

00:46:26.560 --> 00:46:31.920
这些集不一定存储在内存中，而是可以存储在内存中

00:46:31.920 --> 00:46:35.599
是的，而且我知道，这些都是实际问题，

00:46:35.599 --> 00:46:42.400
可以稍后再来，我的担心主要是因为我不认为我们

00:46:42.400 --> 00:46:46.000
嗯有

00:46:46.560 --> 00:46:52.880
呃，我不认为我们实际上非常擅长确保

00:46:52.880 --> 00:46:56.400
那些实际的问题实际上已经解决了

00:46:56.400 --> 00:46:58.800
我们对此没有良好的记录，因此

00:46:58.800 --> 00:47:02.240
我越来越担心那个了，我们做了很多理论上的工作

00:47:02.240 --> 00:47:05.760
但是，当橡胶撞上道路时，

00:47:05.760 --> 00:47:09.520
事情停止了，我的意思是从某种意义上说，我感觉很多

00:47:09.520 --> 00:47:12.400
这些都是垃圾收集问题

00:47:12.400 --> 00:47:16.960
我们现在拥有um在修剪数据集um

00:47:16.960 --> 00:47:19.680
真正来自于一种信念，即我们真的要

00:47:19.680 --> 00:47:22.720
能够对很多我们可以描述的东西使用遍历

00:47:22.720 --> 00:47:25.280
某些遍历将仅提供我们需要或同步的数据

00:47:25.280 --> 00:47:26.960
我们需要的数据之类的东西

00:47:26.960 --> 00:47:30.800
我认为那实际上并没有像很多

00:47:30.800 --> 00:47:34.720
这些想法来自一个地方，就像每次

00:47:34.720 --> 00:47:38.319
我需要你的帮助，我需要能够像我们一样谈论三角洲

00:47:38.319 --> 00:47:41.119
能够仅移动一部分数据

00:47:41.119 --> 00:47:44.480
嗯，我需要能够仅向您描述您需要的数据

00:47:44.480 --> 00:47:48.640
就像是某种类似的东西

00:47:48.640 --> 00:47:51.440
在某种程度上比数据库的结构更重要

00:47:51.440 --> 00:47:55.040
是我们可以比较这些集合

00:47:55.040 --> 00:47:58.160
是的，是的，因为我什至你知道

00:47:58.160 --> 00:48:01.200
现在垃圾收集的东西，这周我正在玩的东西，嗯，我是

00:48:01.200 --> 00:48:04.400
只是弄乱浏览器视频内容，但

00:48:04.400 --> 00:48:07.520
我仍然不得不违反数据

00:48:07.520 --> 00:48:10.800
像我想要的垃圾收集东西一样，我想做ipl数据结构

00:48:10.800 --> 00:48:13.040
但我需要能够有效地丢弃

00:48:13.040 --> 00:48:16.640
当我进行更改时我不再使用的东西

00:48:16.640 --> 00:48:22.480
就是这么痛苦呀，是啊，随便一起工作

00:48:22.480 --> 00:48:26.559
大而长的图是您知道的难事吗？

00:48:26.559 --> 00:48:31.920
是的，嗯，我要说的另一件事是

00:48:31.920 --> 00:48:36.960
嗯，是的，还有一件非常有趣的事情

00:48:36.960 --> 00:48:39.760
关于这个，我会讲这个，因为就像

00:48:39.760 --> 00:48:42.640
这些幻灯片的结尾，我还没来得及真正解决它

00:48:42.640 --> 00:48:45.440
还是没来得及记录下来

00:48:45.440 --> 00:48:47.839
但是，当我说像你可以使用这些像

00:48:47.839 --> 00:48:51.359
我的意思是，因为它们是单向功能

00:48:51.359 --> 00:48:54.640
正确的转换权，您始终可以测试两个更改是否可以计算

00:48:54.640 --> 00:48:58.240
他们很抱歉通勤，因为您可以互相套用，

00:48:58.240 --> 00:49:00.000
如果你有一样的哈希值就好

00:49:00.000 --> 00:49:02.800
嗯，还有一些您想做的额外的事情

00:49:02.800 --> 00:49:04.880
获得纯附加插入方式

00:49:04.880 --> 00:49:08.480
您可以通过检查sql ast来完成，但在大多数情况下都可以

00:49:08.480 --> 00:49:12.960
实际上，您知道在与您相同的状态下进行一千笔交易

00:49:12.960 --> 00:49:15.359
弄清楚了您想并行执行的操作

00:49:15.359 --> 00:49:21.119
然后您可以um再次并行测试所有成对的两个

00:49:21.119 --> 00:49:24.240
对它们进行通勤，这样您就可以真正运行所有它们

00:49:24.240 --> 00:49:27.200
同时成对um，然后成对，然后成对

00:49:27.200 --> 00:49:30.160
分成两半，然后从那里配对成两半

00:49:30.160 --> 00:49:33.200
这可能是一个非常昂贵的操作

00:49:33.200 --> 00:49:37.040
但是，对于阅读集和一个阅读集来说，这确实是一件很不错的事情。

00:49:37.040 --> 00:49:39.599
每一项交易的权利

00:49:39.599 --> 00:49:43.680
通勤是当您启动另一个进程或将其交给您时

00:49:43.680 --> 00:49:46.800
转到您所使用的任何并发向量

00:49:46.800 --> 00:49:50.400
使用您所需要的所有块一样的知识

00:49:50.400 --> 00:49:55.680
以便以99.9的概率进行访问

00:49:55.680 --> 00:49:58.640
这些换向操作中的大多数将在这些线程中发生，而没有

00:49:58.640 --> 00:50:01.680
需要其他任何读物，而不是交给他们的东西

00:50:01.680 --> 00:50:05.680
因为你只是把布景把它们放在一起

00:50:05.680 --> 00:50:09.359
在某些极端情况下，您最终会导致

00:50:09.359 --> 00:50:12.800
当您更改它时，它会合并在树中，就像

00:50:12.800 --> 00:50:19.280
每万次更改为例如整数索引将

00:50:19.280 --> 00:50:24.400
最终可能会更改um之一，就像引起这三个之一

00:50:24.400 --> 00:50:27.839
合并，然后该树可能需要将数据读取到

00:50:27.839 --> 00:50:31.119
对，实际上并没有将它传递给通勤者

00:50:31.119 --> 00:50:33.359
所以我们只需要访问相同的数据

00:50:33.359 --> 00:50:38.079
谁启动了该过程，那么它可能需要做一遍读

00:50:38.079 --> 00:50:41.119
马上，但这就是我们要做的所有事情

00:50:41.119 --> 00:50:44.400
您，您实际上可以像crdt一样完成所有这些操作

00:50:44.400 --> 00:50:49.520
并行处理通勤的事情，而没有大量的io

00:50:49.520 --> 00:50:57.040
很好，是的，还有其他问题或评论

00:50:57.200 --> 00:51:04.960
在crdt方面很好，因此对于几乎所有要添加的操作

00:51:04.960 --> 00:51:09.760
或仅查询附加内容的喜欢的美丽

00:51:09.760 --> 00:51:15.920
集的可合并性就像您在通勤时没问题，然后有一个

00:51:15.920 --> 00:51:21.359
然后只有在您改变状态并移除状态的情况下

00:51:21.359 --> 00:51:25.839
某件事，实际上是想真正清理

00:51:25.839 --> 00:51:32.160
您所担心的障碍，例如

00:51:32.400 --> 00:51:37.920
知道是否有些过去，例如呃突变删除了某些东西，

00:51:37.920 --> 00:51:41.599
然后再将其添加回去，反之亦然，让我们来看一下

00:51:41.599 --> 00:51:44.079
没事的地方是正确的

00:51:44.079 --> 00:51:47.200
这样做有意义吗，不，实际上比这要简单一点

00:51:47.200 --> 00:51:50.000
对，所以这是它的工作方式之一是

00:51:50.000 --> 00:51:55.119
您需要查看一次sql ast，以查看um是否为纯插入

00:51:55.119 --> 00:52:00.079
没有与之关联的读取，如果它是纯插入，那么你

00:52:00.079 --> 00:52:03.200
其实你可以知道那将与

00:52:03.200 --> 00:52:05.440
所有其他插入物，但是如果您尝试将它们应用到

00:52:05.440 --> 00:52:07.920
您实际上是不同的订单，您将获得不同的哈希，因此您

00:52:07.920 --> 00:52:12.319
需要喜欢将那些放在一边，然后喜欢其余的查询

00:52:12.319 --> 00:52:16.720
您将在um上进行某种形式的读写语义

00:52:16.720 --> 00:52:22.880
等等，因此您无法在sql中预测看起来像什么的

00:52:22.880 --> 00:52:25.280
事情变得疯狂，例如，如果您看着那种

00:52:25.280 --> 00:52:30.160
postgres必须做的后空翻才能像um

00:52:30.160 --> 00:52:33.440
需要访问的中间状态更改，并且变得很漂亮

00:52:33.440 --> 00:52:38.480
复杂的um，但是像sql这样强大的语言，您可以像

00:52:38.480 --> 00:52:43.440
就像多项选择一样，将数学和通勤运算结合在一起，然后产生

00:52:43.440 --> 00:52:46.319
你做对的权利，所以如果你有一千个

00:52:46.319 --> 00:52:50.240
您想要一次完成的所有权利都无法通过查看

00:52:50.240 --> 00:52:54.240
树真的知道像哦，这个最终像

00:52:54.240 --> 00:52:56.319
读取其他人写的一些数据

00:52:56.319 --> 00:53:00.319
其实是对的还是被改写或更改的，所以e

00:53:00.319 --> 00:53:03.680
因此，最简单的操作实际上就是像针对

00:53:03.680 --> 00:53:06.640
对方的状态，然后查看哈希是否匹配

00:53:06.640 --> 00:53:10.480
还是不正确，那样做是简单的方法

00:53:10.480 --> 00:53:13.359
那里有一个AI正在与mikola谈论这件事，他

00:53:13.359 --> 00:53:16.400
好像没有，我们可以做很多事情来真正喜欢

00:53:16.400 --> 00:53:19.119
缩小范围，所以有一种方法可以使您摆脱困境

00:53:19.119 --> 00:53:22.800
像很多计算一样的开销，但我认为

00:53:22.800 --> 00:53:26.720
总会有一些非常复杂的sql案例

00:53:26.720 --> 00:53:29.599
您将需要不这样做，并且始终运行该语句

00:53:29.599 --> 00:53:32.640
再次检查，但是当您正确切出它们时，您只是

00:53:32.640 --> 00:53:34.880
实际上将陈述混为一谈

00:53:34.880 --> 00:53:37.760
就像你一样，就像在上下班时将一个语句添加到另一个语句中一样

00:53:37.760 --> 00:53:39.920
他们，你要添加读和写集

00:53:39.920 --> 00:53:43.599
然后在所有通勤的最后，您只想

00:53:43.599 --> 00:53:47.040
重新运行整个组合查询集，以便

00:53:47.040 --> 00:53:51.200
您最终得到的证明是um并不包括所有

00:53:51.200 --> 00:53:54.839
您知道通勤操作后可能已更改的孤立数据

00:53:54.839 --> 00:53:58.960
是的，这实际上是最简单的通勤方式

00:53:58.960 --> 00:54:02.800
这可能比尝试穿过树更容易，

00:54:02.800 --> 00:54:05.359
找出场景中的孤儿

00:54:05.359 --> 00:54:08.640
正确，所以您只需收集它们，然后重新运行查询，

00:54:08.640 --> 00:54:12.400
以这种方式修剪是的，是的，我的意思是

00:54:12.400 --> 00:54:15.839
关于sql查询的事情是，像数据结构一样，

00:54:15.839 --> 00:54:20.000
减少计算量，这样您就可以进入

00:54:20.000 --> 00:54:21.920
尤其是当您使用区块链时，就像我如何

00:54:21.920 --> 00:54:24.240
像处理一样减少，我不增加处理

00:54:24.240 --> 00:54:29.200
我如何才能像sql这样的所有问题都得到解决

00:54:29.200 --> 00:54:33.119
建立快速查询和易于查询的数据结构等

00:54:33.119 --> 00:54:37.359
只是让sql做那个um，你就知道了

00:54:37.359 --> 00:54:40.319
方式和真正的合作方式，例如我们如何定义

00:54:40.319 --> 00:54:45.760
所需的数据子集，并减少了所需的数据量

00:54:50.839 --> 00:54:54.960
是的，嗯，我想我现在没时间了，所以

00:54:54.960 --> 00:54:58.319
这可能是一个停止的好地方

00:54:58.720 --> 00:55:05.359
是的，我只是要说，所以嗯，谢谢大家的参加

00:55:05.359 --> 00:55:11.920
下周再见

