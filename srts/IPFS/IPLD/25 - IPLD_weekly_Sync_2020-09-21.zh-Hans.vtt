WEBVTT
Kind: captions
Language: zh-Hans

00:00:11.519 --> 00:00:17.760
欢迎大家参加本周的ipld devsync会议，

00:00:17.760 --> 00:00:23.439
 2020年9月21日，每周我们都会讨论这些内容

00:00:23.439 --> 00:00:27.199
在过去的一周中我们一直在努力，然后

00:00:27.199 --> 00:00:32.000
讨论了我们可能遇到的任何未解决的问题

00:00:32.000 --> 00:00:35.920
嗯，请把你的名字放在黑客的参加者名单上

00:00:35.920 --> 00:00:39.920
垫顺便说一句，垫板再次在线，因为有一些

00:00:39.920 --> 00:00:44.879
互联网的工作，但它应该可以再次工作

00:00:44.879 --> 00:00:50.399
是的，所以我从我自己开始，没有太多报道，我仍然在

00:00:50.399 --> 00:00:55.440
生锈的多播东西，有趣的是，

00:00:55.440 --> 00:00:59.120
当我改进api时，因为当我集成它时

00:00:59.120 --> 00:01:05.040
进入锈病cid上使用api太可怕了，因为您

00:01:05.040 --> 00:01:11.439
经常需要打开包装，因为可能会有错误，但是在许多情况下

00:01:11.439 --> 00:01:15.040
你是100肯定不会有错误

00:01:15.040 --> 00:01:18.320
但您仍然需要解开包装，因为理论上可能会有一个

00:01:18.320 --> 00:01:21.759
但在那种情况下不是这样，这导致了一些

00:01:21.759 --> 00:01:25.040
api的更改使事情变得更好，然后

00:01:25.040 --> 00:01:31.360
有点像我改变了几乎所有东西，我有点重写了整个东西

00:01:31.360 --> 00:01:35.759
但是现在又回到了以前的样子

00:01:35.759 --> 00:01:38.799
或多或少这是很好的，所以没有太多的变化

00:01:38.799 --> 00:01:44.000
当我做公关，但现在我觉得我对结果感到满意

00:01:44.000 --> 00:01:47.360
而且我仍在确保一切正常

00:01:47.360 --> 00:01:50.399
但随后又尝试与

00:01:50.399 --> 00:01:57.600
锈cid和lib t2p，因为像这样我

00:01:57.600 --> 00:02:02.000
我用来确保api至少相同的库

00:02:02.000 --> 00:02:08.239
嗯，很酷，嗯，我没有太多其他的了

00:02:08.239 --> 00:02:15.840
在我的清单上，iPod的另一面是丹妮尔（danielle）

00:02:15.840 --> 00:02:22.319
很酷，所以我继续与ipld adl一起使用hampt um

00:02:22.319 --> 00:02:26.319
我与Rod和Peter进行了有益的通话，基本上讨论了任何

00:02:26.319 --> 00:02:29.920
关于您的问题我一般都知道火腿

00:02:29.920 --> 00:02:33.760
我们要在此处构建的模式的架构

00:02:33.760 --> 00:02:37.040
嗯，所以我现在仍在进步，我已经达到了

00:02:37.040 --> 00:02:38.800
真正理解我需要写的所有东西

00:02:38.800 --> 00:02:43.920
嗯，因为在我不熟悉ipld prime的工作方式或我如何使用adls之前，

00:02:43.920 --> 00:02:47.599
实际上已经实现了，我还写了

00:02:47.599 --> 00:02:51.840
ipld go的介绍，这是本次演讲周的一部分，

00:02:51.840 --> 00:02:56.080
仅剩一小段时间了，所以我本周要完成这一点，我也

00:02:56.080 --> 00:02:59.840
将自己挖入multicodec的兔子洞中，因为我发现

00:02:59.840 --> 00:03:04.000
ipld prime的示例，例如在使用stack c war时

00:03:04.000 --> 00:03:09.400
他们只会使用uh 0x71而不是做类似的事情

00:03:09.400 --> 00:03:13.680
multicodec.cbor或apld.taxi或类似的东西

00:03:13.680 --> 00:03:17.120
所以我想我将与所有辅音一起生成lightgo包

00:03:17.120 --> 00:03:21.360
这些ID中的至少一个，最后

00:03:21.360 --> 00:03:24.959
通过eric，我们开始写下如何改变的想法

00:03:24.959 --> 00:03:31.360
一旦有Filecoin的事情平静下来，就可以在不久的将来去ipld primes api

00:03:31.360 --> 00:03:35.280
有点像导入路径

00:03:35.280 --> 00:03:38.879
不依赖github的东西，还有其他一些东西，例如删除一些

00:03:38.879 --> 00:03:43.040
不必要的错误返回之类的东西，以及

00:03:43.040 --> 00:03:51.519
对我来说就是这样，谢谢，接下来是迈克尔

00:03:51.519 --> 00:03:54.879
嘿，嗯，嗯，所以我做了很多文档工作

00:03:54.879 --> 00:03:58.239
嗯主要是清理打乱它的东西

00:03:58.239 --> 00:04:02.799
呃写更多的文档，然后对规范站点进行实质性的更改

00:04:02.799 --> 00:04:08.159
因此，有一个新的规格网站，它具有所有规格和所有内容，

00:04:08.159 --> 00:04:12.159
现在只是架构，实际上只是针对架构um

00:04:12.159 --> 00:04:14.000
那真的是必要的，因为我需要

00:04:14.000 --> 00:04:17.040
记录文档站点以经常链接到规范

00:04:17.040 --> 00:04:20.239
所以这两个地方都在进行改进

00:04:20.239 --> 00:04:25.120
嗯，结果是规格库中有一些新文件

00:04:25.120 --> 00:04:28.880
没有公关，因为他们只是喜欢不得不去一个非常快的地方，我不得不

00:04:28.880 --> 00:04:30.880
建立网站，但嗯，所以有一些

00:04:30.880 --> 00:04:33.520
清理工作仍然要做，还有一些工作要做

00:04:33.520 --> 00:04:37.759
docs网站，我们正在等待红外线，以单击uh网站

00:04:37.759 --> 00:04:41.600
但总的来说docs网站看起来不错，就像

00:04:41.600 --> 00:04:45.280
展示给人们，嗯，我们知道你需要去做一些事情

00:04:45.280 --> 00:04:48.560
合并进来，我们需要将其余的东西合并进来，但嗯

00:04:48.560 --> 00:04:52.080
总的来说，看起来您比我们拥有的任何东西都要了解得多

00:04:52.080 --> 00:04:56.560
之前，那很好，我也参加了

00:04:56.560 --> 00:04:59.280
填充规范，所以我把它从彼得的盘子上拿下来，

00:04:59.280 --> 00:05:03.039
如果您有任何相关文档要发送，我现在要写出来，嗯，正在努力中

00:05:03.039 --> 00:05:07.199
以我的方式，我有一个降价文件，他和

00:05:07.199 --> 00:05:11.440
呃er​​ic eric在码头仓库中的帕丁顿（Paddington）上写了一个快速码头

00:05:11.440 --> 00:05:17.120
我搬走了，所以在那个嗯和最后一个呃上工作

00:05:17.120 --> 00:05:20.160
上周，我在dagdb上的这个播客客户端上戳

00:05:20.160 --> 00:05:25.680
嗯，在某个时候建立了股票网站，我意识到

00:05:25.680 --> 00:05:30.240
我不知道为什么要花这么长时间，有太多的代码和查看媒体

00:05:30.240 --> 00:05:33.360
从markdown文件制作一个网站，好像

00:05:33.360 --> 00:05:37.360
好像很多，从中建立一个网站似乎真的很容易

00:05:37.360 --> 00:05:40.320
降价文件，所以我开始有点问题

00:05:40.320 --> 00:05:43.199
并意识到，就像哦，实际上您可以做一些很酷的事情

00:05:43.199 --> 00:05:46.880
在这里，如果您使用降价文件，而您

00:05:46.880 --> 00:05:51.280
使用您最终会遇到的Yaml前端问题

00:05:51.280 --> 00:05:54.240
显示数据和元数据，例如实际结构化的

00:05:54.240 --> 00:05:58.720
数据类型在这种统一的树结构中结合在一起，然后

00:05:58.720 --> 00:06:03.360
我可以接受它并将其实际上像数据结构一样粘贴在dag db中

00:06:03.360 --> 00:06:06.639
然后当我开始玩这个游戏时会发生什么，所以我意识到

00:06:06.639 --> 00:06:11.440
哦，您可以使用它来像帖子列表一样进行扩展，然后您

00:06:11.440 --> 00:06:14.240
知道站点地图和所有类似的东西都可以像

00:06:14.240 --> 00:06:17.280
从匕首视图表示形式开始，因为它可以完成所有

00:06:17.280 --> 00:06:20.400
链接和所有索引的所有内容等等

00:06:20.400 --> 00:06:24.319
基本上就像我写了这么一点我就开始从事这个小项目

00:06:24.319 --> 00:06:27.520
它基本上需要您知道Markdown的回购

00:06:27.520 --> 00:06:32.720
然而，弹药前沿的问题是可选的，并将其转化为数据

00:06:32.720 --> 00:06:35.440
结构，然后另一件事采取这些数据结构并转向

00:06:35.440 --> 00:06:39.280
他们进入这个网站，然后我也很喜欢哦，但是你

00:06:39.280 --> 00:06:42.560
可以关注其他网站，然后它们可能就像您的

00:06:42.560 --> 00:06:45.840
按照提要，您可以开始做一些类似社交数据的数据

00:06:45.840 --> 00:06:48.000
网络是一种相互联系的东西，所以我一直在戳

00:06:48.000 --> 00:06:52.240
在这里，我们称其为ipmd，因为它就像是

00:06:52.240 --> 00:06:55.759
记下加上yammer前端问题，就像是一个数据结构

00:06:55.759 --> 00:06:58.960
就像一个您随处逛逛的网站，但它很酷

00:06:58.960 --> 00:07:02.000
嗯，就像使用很多github动作一样

00:07:02.000 --> 00:07:08.319
像这个um的后端，所以像所有dagnyb的东西一样

00:07:08.319 --> 00:07:11.120
存储在其中，这就像复制其他人的

00:07:11.120 --> 00:07:14.240
数据库像所有托管一样出现，并且所有内容都已经存在

00:07:14.240 --> 00:07:18.800
它像动作一样自动安装以进行发布和其他操作

00:07:18.800 --> 00:07:21.520
这样，就像在做一件有趣的小事，

00:07:21.520 --> 00:07:26.400
肯定会让很多um东西陷入我们的原始知识中

00:07:26.400 --> 00:07:29.599
就像我意识到有些事情可能会更容易一些

00:07:29.599 --> 00:07:32.240
我想修复的所有这些图层

00:07:32.240 --> 00:07:35.919
嗯，是的，这就像我一直在戳一个有趣的小项目

00:07:35.919 --> 00:07:38.960
你可以随意看

00:07:41.759 --> 00:07:45.759
我认为到了新的一年，团队中的每个人都会拥有自己的小东西

00:07:45.759 --> 00:07:48.479
他们正在发布的个人网站，因为它确实使

00:07:48.479 --> 00:07:50.400
发布一个非常有趣的小网站

00:07:50.400 --> 00:07:53.840
其实就像他妈的hack pad，就像我要开始推送markdown文件一样

00:07:53.840 --> 00:07:56.560
到我的个人网站，您会看到它们，因为

00:07:56.560 --> 00:08:00.560
像这样实际上更容易，并且像某些工作流程一样更容易

00:08:00.560 --> 00:08:03.280
比我们用于此类网站的某些网站

00:08:03.280 --> 00:08:06.319
就像我可能不再使用拳头一样，就像在我的页面上制作这些页面一样

00:08:06.319 --> 00:08:13.199
个人网站还是很有趣的，我不知道下一个是谁

00:08:13.199 --> 00:08:18.160
eric me yeah顺便说一句

00:08:18.160 --> 00:08:21.360
因为我花了一些时间四处逛逛，尝试翻新我的

00:08:21.360 --> 00:08:26.479
这个星期的个人网站嗯，我目前的网站是我不知道在哪里

00:08:26.479 --> 00:08:32.880
我实际上不知道数十年后会消失

00:08:32.880 --> 00:08:36.640
和所有现代工具一样

00:08:38.839 --> 00:08:44.800
无论如何，在ipld golang新闻中

00:08:44.800 --> 00:08:48.640
丹尼尔（Daniel）一直在写一些文档资料，这让我大吃一惊。

00:08:48.640 --> 00:08:51.680
努力使一些更漂亮的东西

00:08:51.680 --> 00:08:56.560
一直很好，所以本周我要做的一件事就是做出一些

00:08:56.560 --> 00:09:00.000
瓷类型函数可帮助您构建数据

00:09:00.000 --> 00:09:07.040
这将需要像地图和结构以及填充和排序之类的普通golang类型

00:09:07.040 --> 00:09:12.320
用反射扫描它们并将其转换为数据模型等等

00:09:12.320 --> 00:09:15.760
可以说这是一个很长的逾期，但是有一个

00:09:15.760 --> 00:09:20.080
某些原型的初稿

00:09:20.720 --> 00:09:24.560
这将是非常非常低效的事情

00:09:24.560 --> 00:09:28.240
它不会是cpu快，也不会是廉价的内存分配

00:09:28.240 --> 00:09:31.519
实际上对他们两个人来说都是可怕的可怕

00:09:31.519 --> 00:09:34.959
但它可以让您像单线一样完成工作

00:09:34.959 --> 00:09:40.320
所以也许它将有一些实用程序，所以有一个公关，我不太

00:09:40.320 --> 00:09:44.000
完成后，您必须处理所有需要解决的问题和思考

00:09:44.000 --> 00:09:47.440
勤奋一点，这周我做的另一件事

00:09:47.440 --> 00:09:53.760
是我在整个链接加载程序故事中又经历了一次裂缝吗？

00:09:53.760 --> 00:09:57.680
 go ipld prime repo上也有一段时间未解决的问题

00:09:57.680 --> 00:10:01.839
它是55号，这是关于罐头的大问题

00:10:01.839 --> 00:10:06.560
请简化一点，这是一个棘手的话题

00:10:06.560 --> 00:10:09.279
因为它把所有这些不同的东西拖在一起

00:10:09.279 --> 00:10:13.360
像我们希望将编解码器分开的接口，但是

00:10:13.360 --> 00:10:16.079
全部插入在一起，并且多哈希都被

00:10:16.079 --> 00:10:20.160
分开，但插在一起，然后所有这些都在

00:10:20.160 --> 00:10:23.600
与其他链接内容相同的交界点，是的，这只是很多

00:10:23.600 --> 00:10:26.640
接触的事物

00:10:27.519 --> 00:10:32.320
所以我想我还有一些可能是解决方案的草案

00:10:32.320 --> 00:10:36.480
这将所有这些东西分解为

00:10:36.480 --> 00:10:39.200
较小的函数类型声明，所以有一个函数

00:10:39.200 --> 00:10:45.360
类型，例如选择多哈希器实现，例如选择编解码器

00:10:45.360 --> 00:10:49.200
实现，所以有该层功能

00:10:49.200 --> 00:10:52.160
界面，然后这些就给您一些符合该功能的东西

00:10:52.160 --> 00:10:55.680
编解码器的接口，所以它也不是直接绑定在那里

00:10:55.680 --> 00:11:00.160
当时的想法是，我们可以使整个注册系统甚至是

00:11:00.160 --> 00:11:03.279
那些只是选择器的函数类型

00:11:03.279 --> 00:11:07.519
样机，这应该给我们所有

00:11:07.519 --> 00:11:09.920
建立注册中心所需的灵活性

00:11:09.920 --> 00:11:15.440
很简单，面向用户，默认情况下喜欢做正确的事，

00:11:15.440 --> 00:11:18.880
也让我们有能力让其他人自己做

00:11:18.880 --> 00:11:21.760
这些版本的版本基本上就像您不想拥有全球

00:11:21.760 --> 00:11:23.920
注册表，那么您可以使用一堆自己的

00:11:23.920 --> 00:11:27.360
功能，然后将它们全部拉到一起

00:11:27.360 --> 00:11:30.240
变成一个大的旧结构，称为链接系统

00:11:30.240 --> 00:11:34.240
然后我们可以将所有其他辅助方法放到这里

00:11:34.240 --> 00:11:37.760
用户在一天结束时实际上在乎的

00:11:37.760 --> 00:11:42.399
因此，我们有一个地方可以重复所有这些事情，而不会推动所有这些事情

00:11:42.399 --> 00:11:46.000
所有的实施工作和大量其他辅助功能

00:11:46.000 --> 00:11:50.959
链接或法典或哈希或其他任何形式的实现

00:11:50.959 --> 00:11:55.600
所以这仍然只是草稿，但感觉要简单得多

00:11:55.600 --> 00:11:59.440
我想我们将来可能想尝试一下

00:11:59.440 --> 00:12:05.120
所以这周能穿上这袖子很酷

00:12:05.839 --> 00:12:14.639
谢谢，接下来是Rod好的，我在yeah um上吗

00:12:14.639 --> 00:12:17.680
我这一周一直在做原始的爱好者，而我的头是

00:12:17.680 --> 00:12:22.000
充满了原始的迷们充满了原始的迷们

00:12:22.000 --> 00:12:28.399
嗯，所以我认为我已经完成了，尽管嗯，我看到了山谷已经张贴了

00:12:28.399 --> 00:12:33.600
有趣的问题，呃，他在哪里张贴了这个

00:12:33.600 --> 00:12:40.560
船厂，嗯，有一个他刚刚张贴了一个

00:12:40.560 --> 00:12:44.320
ipfs资源管理器组件上的有趣问题

00:12:44.320 --> 00:12:51.680
网页浏览器以及um所在的位置

00:12:51.680 --> 00:12:54.959
网络用户界面以及资源管理器在浏览时都遇到了麻烦

00:12:54.959 --> 00:12:59.760
某些s路径的unix

00:12:59.760 --> 00:13:04.839
并且他是错误类型，因为它是不确定的，所以看起来好像是从

00:13:04.839 --> 00:13:12.160
ipld tag pb是较早的um protobuf库，因此

00:13:12.160 --> 00:13:17.600
调查一下，我会看一下那个嗯，所以我做了什么

00:13:17.600 --> 00:13:23.440
所以我很确定新的dag pb库已经可以发布了

00:13:23.440 --> 00:13:26.560
虽然我想看看规格链接

00:13:26.560 --> 00:13:29.839
首先对规格的拉取请求现在得到了

00:13:29.839 --> 00:13:35.360
最后简化了，我的出价比起初要高出很多

00:13:35.360 --> 00:13:38.480
绕回去，所以真的是唯一的重大变化

00:13:38.480 --> 00:13:44.079
模式使散列是可选的，它在其中

00:13:44.079 --> 00:13:48.880
格式，以um为单位

00:13:48.880 --> 00:13:55.279
去吧，嗯，等等，所以我决定只是为了

00:13:55.279 --> 00:13:59.279
使这是没有像它会很好

00:13:59.279 --> 00:14:03.440
如果所有内容（如果每个链接实际上都有一个哈希），但有可能

00:14:03.440 --> 00:14:08.000
构造块，因为我没有哈希，他们只是

00:14:08.000 --> 00:14:12.880
空链接，因此虽然不理想

00:14:12.880 --> 00:14:16.080
嗯，我们应该考虑现有的那些块嗯

00:14:16.080 --> 00:14:20.480
[音乐]但无论如何，关于此的讨论可能

00:14:20.480 --> 00:14:23.600
如果您认为那是个坏主意，那是值得的

00:14:23.600 --> 00:14:26.800
我们应该开始阻止它，并做出任何让步

00:14:26.800 --> 00:14:33.600
停止将这些块作为有效um加载，因此在297中的请求不佳

00:14:33.600 --> 00:14:36.880
那里的规格回购以及我已经添加了一堆

00:14:36.880 --> 00:14:42.160
模式下的其他小注释说明了如何

00:14:42.160 --> 00:14:46.959
um无法在模式中表达的其他约束

00:14:46.959 --> 00:14:53.440
像um这样的事情，你不能有一个空的links数组，因为那是

00:14:53.440 --> 00:14:58.800
在字节级别在块级别在编码级别上是无法区分的

00:14:58.800 --> 00:15:06.079
它必须是未定义的，可选的或丢失的，因此您的links数组必须是

00:15:06.079 --> 00:15:08.880
一个或多个，还有其他一些小东西

00:15:08.880 --> 00:15:14.720
像那样，现在我在其中添加了一些测试

00:15:14.720 --> 00:15:21.440
进入merkle dag实施go所在的地方um

00:15:21.440 --> 00:15:25.600
那是在笔记um中有一个拉取请求

00:15:25.600 --> 00:15:28.800
我会尝试将其合并，但是嗯

00:15:28.800 --> 00:15:33.759
添加一些测试以推动格式的边缘以查看

00:15:33.759 --> 00:15:37.279
这些在不同情况下会发生什么，最终会导致什么

00:15:37.279 --> 00:15:43.440
作为二进制及其解码的内容，只是为了了解这些往返行程的本质，

00:15:43.440 --> 00:15:46.079
各种形状意味着什么

00:15:46.079 --> 00:15:49.440
存在于数据模型中，然后会发生什么

00:15:49.440 --> 00:15:52.560
他们来回旅行时给他们看，以便我们确定

00:15:52.560 --> 00:15:57.519
这些东西的确切形式um，然后我将这些测试镜像到

00:15:57.519 --> 00:16:01.680
javascript有几种情况，我排除了

00:16:01.680 --> 00:16:07.040
选项，所以一种情况是，我说的是

00:16:07.040 --> 00:16:12.800
哈希必须是cid哈希，然后是不能

00:16:12.800 --> 00:16:17.199
解释为cid应该无效，您可以使用相同的参数

00:16:17.199 --> 00:16:21.759
为了说得好，哈希也不应是未定义的，也许是这样

00:16:21.759 --> 00:16:25.920
我们应该做一些其他事情

00:16:25.920 --> 00:16:29.759
是空链接数组，所以您不能这样做

00:16:29.759 --> 00:16:33.920
你只是做不了一件事情，以至于新事物

00:16:33.920 --> 00:16:41.040
js的实现是它只允许您编码

00:16:41.040 --> 00:16:45.680
形状精确的物体

00:16:45.680 --> 00:16:49.360
如果它继续经历往返

00:16:49.360 --> 00:16:52.800
编码，因此您无法制作内存版本

00:16:52.800 --> 00:16:56.800
这些东西是无效的，那将是

00:16:56.800 --> 00:16:59.199
如果要往返旅行就改变了

00:16:59.199 --> 00:17:02.880
因此，对这些对象的检查非常严格，但它也会导出

00:17:02.880 --> 00:17:08.799
一种准备方法，让您可以在安全性较高的情况下运行它

00:17:08.799 --> 00:17:12.000
衡量或为方便起见，如果您对自己的方式有点草率

00:17:12.000 --> 00:17:14.959
想创建对象，它会做类似的事情，以确保

00:17:14.959 --> 00:17:18.000
你没有任何多余的财产

00:17:18.000 --> 00:17:23.039
对象um它将把字符串变成字节之类的东西

00:17:23.039 --> 00:17:28.400
它将按照正确的方式对您的链接列表进行排序，

00:17:28.400 --> 00:17:31.679
如果你不照顾的话会有点乏味

00:17:31.679 --> 00:17:36.720
如果您要创建复杂的内容um，或者只是将数据推入

00:17:36.720 --> 00:17:38.640
你不想建立只想显示的链接

00:17:38.640 --> 00:17:42.000
个字节，并且您不想形成这些东西，因此有一个prepare方法

00:17:42.000 --> 00:17:46.559
那里使它变得更容易处理非常严格的格式，而我认为

00:17:46.559 --> 00:17:51.679
很好，嗯，那是我想我是我想

00:17:51.679 --> 00:17:54.480
我总结了有关搭扣的问题，可能是需要

00:17:54.480 --> 00:17:58.320
需要解决，我仍然不确定

00:17:58.320 --> 00:18:03.919
嗯，但除了那个，那是我，我想我想

00:18:03.919 --> 00:18:07.840
现在从pb继续前进

00:18:07.840 --> 00:18:11.039
嗯，有点流泪哦，另一件事是在javascript中

00:18:11.039 --> 00:18:16.080
实施，我写了一个手卷

00:18:16.080 --> 00:18:20.880
um for protobus的编码器和解码器，因为我们的格式不是

00:18:20.880 --> 00:18:24.960
复杂的嗯，这非常简单，所以我

00:18:24.960 --> 00:18:29.520
实际上所做的是从重写的代码生成版本中拉出

00:18:29.520 --> 00:18:32.720
javascript，然后对其进行重构和简化

00:18:32.720 --> 00:18:37.120
更加愉快，所以现在没有了

00:18:37.120 --> 00:18:41.200
该库中的依赖项，因此它将能够完成整个操作

00:18:41.200 --> 00:18:44.960
本身就是我们可以将其包括在内的东西

00:18:44.960 --> 00:18:49.840
现在它在uh块接口中的默认值（如果太小）

00:18:49.840 --> 00:18:52.880
是的，是的，这就是为什么我们不包括它的原因是

00:18:52.880 --> 00:18:59.200
因为深度树，所以是的，所以这是你做了一个

00:18:59.200 --> 00:19:02.960
使用protobuf编译器生成javascript，然后您就可以

00:19:02.960 --> 00:19:07.280
就像用一只手将其削减到所需的最低限度

00:19:07.280 --> 00:19:11.520
我把它拿走了，所以go版本有一个代码gen

00:19:11.520 --> 00:19:18.080
 um中的probbuff编码器解码器版本，因为这就是您的操作方式

00:19:18.080 --> 00:19:21.280
它就像您实际制作代码一样，所以我

00:19:21.280 --> 00:19:24.960
拉过该代码，然后将其转换为javascript

00:19:24.960 --> 00:19:27.760
手动，然后因为不是那样

00:19:27.760 --> 00:19:30.799
复杂，然后我就简化了，因为像我一样

00:19:30.799 --> 00:19:34.240
您知道变体编码的所有重复

00:19:34.240 --> 00:19:39.039
我只是我有一个编码和解码方差的函数，那个

00:19:39.039 --> 00:19:41.520
他们只是不复杂，所以全部内联

00:19:41.520 --> 00:19:45.520
一切都与病毒或其他任何东西无关

00:19:45.520 --> 00:19:52.480
和UM进行重复数据删除，我又添加了UM我应该怎么做

00:19:52.480 --> 00:19:56.960
因此在protobuf中有一个非常有趣的案例

00:19:56.960 --> 00:20:04.480
你将允许你解码草率的对象，所以它dag pb

00:20:04.480 --> 00:20:11.200
将接受具有与格式无关的无关数据的对象

00:20:11.200 --> 00:20:15.360
在go版本中，它只是将其挂在隐藏的位置上

00:20:15.360 --> 00:20:22.000
dag pv struct和um中的属性，它从未被um感动过

00:20:22.000 --> 00:20:25.200
我已经把它留在那儿了，此刻它刚掉在地上，但是

00:20:25.200 --> 00:20:27.440
这是我们格式中的一种

00:20:27.440 --> 00:20:32.159
具有所有可以嵌入的方式，可以创建

00:20:32.159 --> 00:20:36.720
具有相同数据但具有不同哈希值的块，或者您可以在其中隐藏数据

00:20:36.720 --> 00:20:42.559
那不会被使用的，嗯，我不认为分贝有那个，但是是的

00:20:42.559 --> 00:20:46.799
它确实在所有格式中都有这个um

00:20:46.799 --> 00:20:49.600
这样，在那里，我不会拒绝

00:20:49.600 --> 00:20:52.960
我不是，我很想在那扔一个东西，所以

00:20:52.960 --> 00:20:56.559
它甚至不解码具有这些的块，但是谁知道

00:20:56.559 --> 00:21:00.880
这些东西在野外，所以如果那在

00:21:00.880 --> 00:21:05.360
野外非常令人惊讶，所以我会

00:21:05.360 --> 00:21:11.120
但是你永远不知道你就是不知道是的，我有点像我看着代码

00:21:11.120 --> 00:21:13.280
它很小，但是我第一次像

00:21:13.280 --> 00:21:17.280
为什么从头开始为什么会生成导入的代码

00:21:17.280 --> 00:21:21.840
javascript javascript的构建来自肥沃但

00:21:21.840 --> 00:21:24.559
它是如此之小

00:21:25.039 --> 00:21:28.400
我们并没有像所有protobuf一样使用，就像我们非常喜欢

00:21:28.400 --> 00:21:31.520
是的，像所有东西一样狭窄，是的，但是那有点奇怪，我也很好

00:21:31.520 --> 00:21:36.480
像花花公子一样，看起来像是在这里，你想说老实话

00:21:36.480 --> 00:21:38.559
说实话，这是那些事故之一

00:21:38.559 --> 00:21:42.320
那是剃毛剃须的事故，那就像我在旅途中

00:21:42.320 --> 00:21:45.600
代码，我搞砸了，我正在测试一些优势，

00:21:45.600 --> 00:21:47.760
所以我对这段代码很感兴趣，就像

00:21:47.760 --> 00:21:50.559
我想看看这在javascript中有什么用，它正在移植一点点

00:21:50.559 --> 00:21:53.919
它，为什么你不只是做它，这真的

00:21:53.919 --> 00:21:57.840
转换基本的go确实不难，尤其是代码没有

00:21:57.840 --> 00:22:01.600
不会在javascript中做太多花哨的东西

00:22:01.600 --> 00:22:05.039
你知道这真的只是在改变一点语法，

00:22:05.039 --> 00:22:09.039
就是这样，然后您将其重构为更好的东西

00:22:09.039 --> 00:22:13.280
和嗯，你最终得到的是，嗯

00:22:13.280 --> 00:22:16.880
这是非常有效的布局方式

00:22:16.880 --> 00:22:20.320
字节，我设法找到一些

00:22:20.320 --> 00:22:24.640
我认为在字节处理方面有一些相当不错的效率提升

00:22:24.640 --> 00:22:30.880
将其布置在um块中的方式，然后甚至以um读取它的方式

00:22:30.880 --> 00:22:36.159
它会做一些um会在相当长的时间内重用字节

00:22:36.159 --> 00:22:39.600
高效的方式，所以如果我们取得了显著成就，我也不会感到惊讶

00:22:39.600 --> 00:22:45.200
嗯，性能提升了，但是我真的不想花钱

00:22:45.200 --> 00:22:49.280
我花了更多的时间测试这种东西，而我

00:22:54.240 --> 00:22:57.120
很酷的

00:22:57.600 --> 00:23:04.080
好的，还有其他人有任何更新或想要分享吗？我有两件真实的东西

00:23:04.080 --> 00:23:08.240
快速，所以有人在ipfs上发布了一些问题

00:23:08.240 --> 00:23:11.679
今天关于ipld的比特币reddit，我提供了一个

00:23:11.679 --> 00:23:15.919
回复，所以随时查看它，让我知道我是否

00:23:15.919 --> 00:23:18.240
错过了一种更好的方法来完成它，我只是将其链接

00:23:18.240 --> 00:23:22.880
在聊天室里，然后还有另一件事

00:23:22.880 --> 00:23:27.520
是你们正在用js craftsync项目看那个呃

00:23:27.520 --> 00:23:32.159
我想做什么我需要做的就像

00:23:32.159 --> 00:23:36.000
graphsync对响应者和请求者的引用

00:23:36.000 --> 00:23:39.280
而且我正计划将它们写在旅途中，因为已经有一个图书馆

00:23:39.280 --> 00:23:43.520
显然ipfs有响应者

00:23:43.520 --> 00:23:48.720
功能，所以我可以使用它，但这只是一个很大的依赖

00:23:48.720 --> 00:23:50.880
所以我只是想做一些快速而简单的事情

00:23:50.880 --> 00:23:54.240
去图同步，所以鉴于我正在建立一个事实，这是我的问题

00:23:54.240 --> 00:23:59.200
javascript库，我需要使用go基本代码

00:23:59.200 --> 00:24:06.000
作为呃，要反对以验证操作你们对我如何思考

00:24:06.000 --> 00:24:10.000
应该结构这应该把go基本代码作为单独的repo

00:24:10.000 --> 00:24:14.400
并像一个extern git子模块一样拉进去

00:24:14.400 --> 00:24:18.400
那些去我的JavaScript的其他目录中的东西

00:24:18.400 --> 00:24:22.720
包或我的仓库，如果是的话，目录结构是什么

00:24:22.720 --> 00:24:25.039
我不知道你们是否不是在谈论我的主要目标是写

00:24:25.039 --> 00:24:27.919
javascript，但我需要一些go代码才能使用此

00:24:27.919 --> 00:24:31.200
验证我想要放的JavaScript的验证

00:24:31.200 --> 00:24:32.640
把它放在某个地方，你们呢

00:24:32.640 --> 00:24:38.400
认为仅仅是测试装置就是您在做什么

00:24:38.400 --> 00:24:41.919
是的，我的意思可能是，那是我所有的迫切需求

00:24:41.919 --> 00:24:47.840
嗯，我需要像cli一样基本上充当javascript的请求者

00:24:47.840 --> 00:24:50.640
响应者，反之亦然，一个JavaScript请求

00:24:50.640 --> 00:24:54.559
得到一个响应者，所以周围非常简单的包装

00:24:54.559 --> 00:24:57.679
去图同步，你会知道发出请求

00:24:57.679 --> 00:25:01.760
我什至可以硬编码cid和所有我想要的东西

00:25:01.760 --> 00:25:04.880
是的，我有几次不得不做这样的事情，嗯

00:25:04.880 --> 00:25:10.559
我有一个嵌入式的变体，因为我有一个回购

00:25:10.559 --> 00:25:15.200
我实际上有javascript并排镜像

00:25:15.200 --> 00:25:19.120
用于发布，但这只是暂时的事情，不是一种理想的消费方式

00:25:19.120 --> 00:25:22.159
在其他情况下，你只是

00:25:22.159 --> 00:25:25.200
将其作为单独的子目录粘贴到您的测试目录中

00:25:25.200 --> 00:25:29.840
然后您可以npm从发布中忽略它

00:25:29.840 --> 00:25:33.200
嗯，因为这样做的好处是，您最终不会

00:25:33.200 --> 00:25:37.360
你不会肿你的回购编译你

00:25:37.360 --> 00:25:42.880
所有这些都发生在别处，因此您的代码只是一个人坐着，而编译却没有

00:25:42.880 --> 00:25:46.559
并非如此，您最终并没有获得大量目标文件，以后需要清理

00:25:46.559 --> 00:25:51.679
嗯，所以这只是但也许是理想的选择

00:25:51.679 --> 00:25:55.360
实际上要做的只是建立一个单独的项目

00:25:55.360 --> 00:25:59.200
并将其放在您的转到源目录中，因为其中之一

00:25:59.200 --> 00:26:03.760
go的问题是，如果您没有，那会很不开心

00:26:03.760 --> 00:26:07.360
在正确的目录中的正确目录中设置

00:26:07.360 --> 00:26:14.240
如果不这样做，就去找源头，那你就陷入了一段糟糕的时光

00:26:14.559 --> 00:26:18.240
您可以要求为单独的项目编译一个参数

00:26:18.240 --> 00:26:23.360
到wasm，然后从javascript调用它，所以您只需完成所有操作即可

00:26:23.360 --> 00:26:28.480
使用已编译为wasm的go代码在javascript中进行测试

00:26:29.200 --> 00:26:32.480
然后你真的膨胀你的回购哦，是的，是的

00:26:32.480 --> 00:26:38.960
是的，唯一的问题是我需要网络连接，但不确定谁

00:26:38.960 --> 00:26:42.880
请问go asm支持

00:26:42.880 --> 00:26:49.120
还是我想这应该是PDP支持的功能

00:26:49.120 --> 00:26:50.960
不，不，我不认为，所以你不

00:26:50.960 --> 00:26:53.760
您认为编译时没有完整的联网功能

00:26:53.760 --> 00:26:58.559
wasm，但是你可以做包装器

00:26:58.559 --> 00:27:03.679
算法是的，是的，好吧，所以我不知道这是否行得通，但是

00:27:03.679 --> 00:27:06.960
所以听起来听起来像是罗杰说，要么只是把它放进去

00:27:06.960 --> 00:27:11.120
进入测试目录，就像测试夹具或测试一样

00:27:11.120 --> 00:27:16.559
我想地图或单独的存储库取决于它是否复杂

00:27:16.559 --> 00:27:20.000
这很简单，只需在测试目录中创建一个go目录

00:27:20.000 --> 00:27:24.159
贴在里面，但这就是区别

00:27:24.159 --> 00:27:27.360
如果有任何复杂性，请制作一个单独的项目并发布

00:27:27.360 --> 00:27:29.919
分别放入您的go源码中

00:27:29.919 --> 00:27:34.320
目录否则是的，实际上我应该怎么做

00:27:34.320 --> 00:27:37.760
像测试一样将其添加到go graph同步库中

00:27:37.760 --> 00:27:41.279
示例应用程序，因为它们非常基础，我可以看到有人使用此应用程序

00:27:41.279 --> 00:27:46.000
是的，绝对是个好主意，我也有一些这样的案例

00:27:46.000 --> 00:27:48.480
就像我的父亲pp那样，这就是我刚刚所做的

00:27:48.480 --> 00:27:53.279
确实是我要在旧仓库中添加测试，而且我没有触及他们的代码

00:27:53.279 --> 00:27:57.760
我只是添加测试以向我展示一些东西

00:27:57.760 --> 00:28:01.360
好的，那是我要去给汉娜打个电话，看看是否

00:28:01.360 --> 00:28:04.399
我确定她会很好的，但是我会和她核对一下，但实际上我现在

00:28:04.399 --> 00:28:07.679
想着更有意义，谢谢

00:28:10.559 --> 00:28:16.640
好的，还有其他更新问题或要讨论的事情

00:28:16.640 --> 00:28:23.679
所以我只是有一个关于Uh cbor到json的um编码格式的问题

00:28:23.679 --> 00:28:30.559
而且我很好奇ipld规范的一致性如何，呃，有一个新的

00:28:30.559 --> 00:28:35.440
在IETF或RFC 7049中进行草稿

00:28:35.440 --> 00:28:40.880
而且我认为很多对冲案例与我的无关

00:28:40.880 --> 00:28:45.200
用例，但我很好奇你们是否在跟进最新的草案

00:28:45.200 --> 00:28:52.399
Ietf RFF的想法，以确保它实际上是um

00:28:52.399 --> 00:28:55.840
遵循json序列化建议

00:28:55.840 --> 00:28:59.840
我应该提到的是非规范性的

00:29:02.720 --> 00:29:06.880
这是您在结尾处切出一点的链接

00:29:06.880 --> 00:29:13.840
嗯，好吧，这是新的cbor规范

00:29:14.240 --> 00:29:18.159
这是用于更新海带的新草案

00:29:18.159 --> 00:29:21.440
我认为如我上周提到的那样，我遇到了一些挑战

00:29:21.440 --> 00:29:27.840
将seaboard转换为json

00:29:36.240 --> 00:29:41.840
所以我们不遵守这个法律

00:29:46.799 --> 00:29:50.960
好吧，我们不喜欢，但至少像我有时把它当作

00:29:50.960 --> 00:29:58.240
基本上从um json的外观中获得灵感

00:29:58.240 --> 00:30:02.480
我们基本上如何构造他们或喜欢的东西，所以看不到

00:30:02.480 --> 00:30:09.679
至少当我们定义甲板如何

00:30:09.679 --> 00:30:13.360
c板工作以确保在我们这样做时

00:30:13.360 --> 00:30:16.720
在xc板上有一些特定的东西

00:30:16.720 --> 00:30:20.559
当您将其转换为json或返回时，适用于

00:30:20.559 --> 00:30:24.960
像这样基本上的建议

00:30:24.960 --> 00:30:29.120
在本节中，很高兴看到

00:30:29.120 --> 00:30:33.520
修剪下来的C板看起来像这样，所以我拿了这个

00:30:33.520 --> 00:30:36.399
当我想到数据模型等时的灵感

00:30:36.399 --> 00:30:40.159
嗯，但是我不认为我们会紧跟其后，但是如果有的话

00:30:40.159 --> 00:30:42.480
我认为我们应该检查的任何更新

00:30:42.480 --> 00:30:47.600
嗯，以确保是的，所以我正在将更新写入

00:30:47.600 --> 00:30:50.720
我上周提到的cbor部分有文档吗

00:30:50.720 --> 00:30:56.000
他们在那里希望我提出非常具体的准则

00:30:56.000 --> 00:30:58.960
用于sibor和sibor之间的无损转换

00:30:58.960 --> 00:31:02.399
json，尤其是当它必须处理二进制表示形式时

00:31:02.399 --> 00:31:08.159
在seabor中并将其转换为以16为基数的转换

00:31:08.159 --> 00:31:11.519
在cbor中该二进制blob的64位编码

00:31:11.519 --> 00:31:14.000
因为显然不支持json

00:31:14.000 --> 00:31:18.000
在cbor中，有像标签21 22和23这样的标签，但是没有

00:31:18.000 --> 00:31:23.360
像是基于uh 58的标签，所以除了我实际使用的所有标签之外

00:31:23.360 --> 00:31:29.200
还建议使用公钥多编解码器属性

00:31:29.200 --> 00:31:33.360
基本上那是他们不喜欢链接，所以它不会成为一个斜线

00:31:33.360 --> 00:31:38.080
在cid中只是一个cid，而该cid是自我描述的

00:31:38.080 --> 00:31:44.799
一个多编解码器，说这是基于base 58编码的，它在版本1中

00:31:44.799 --> 00:31:51.120
它是一个公钥，它是dd25519，然后是字节

00:31:51.120 --> 00:31:54.399
用那种编码

00:31:56.240 --> 00:32:01.120
并且在这种情况下使用base 58编码是否有意义

00:32:01.120 --> 00:32:06.640
像这样的情况，如果不这样做，您使用基地的原因是什么

00:32:06.640 --> 00:32:11.440
像abc这样，我的意思是json像base 64一样

00:32:11.440 --> 00:32:14.799
或某些我认为会有意义的事情，是的，我认为他们只是做到了

00:32:14.799 --> 00:32:18.480
故意困难并且自己过度设计

00:32:18.480 --> 00:32:21.919
我认为这主要只是公司争吵而已

00:32:21.919 --> 00:32:25.679
让人们基本上彼此合一

00:32:25.679 --> 00:32:29.039
我正在尝试确保它基本上是

00:32:29.039 --> 00:32:32.159
容易，我上次提到的是，他们不

00:32:32.159 --> 00:32:37.840
像基本的字符串表示形式，所以它们的整个过程都令人费解

00:32:37.840 --> 00:32:42.320
假设公钥十六进制的命名结构是

00:32:42.320 --> 00:32:45.200
应该像随后的事情一样代表它，应该是

00:32:45.200 --> 00:32:48.799
具有的公共密钥的公共密钥的十六进制表示形式

00:32:48.799 --> 00:32:53.039
特定类型等，所以它是呃

00:32:53.440 --> 00:32:56.960
呃工程，如果你问我，但我正在努力做到

00:32:56.960 --> 00:33:01.919
并提出一些建议，以实现cbor与cbor之间的无损转换

00:33:01.919 --> 00:33:04.320
json

00:33:04.559 --> 00:33:08.880
是的，是的，所以我想像我猜的那样，因为基数

00:33:08.880 --> 00:33:12.240
至少从我的经验来看58是一种痛苦

00:33:12.240 --> 00:33:15.600
忙，所以没有多少人喜欢基地

00:33:15.600 --> 00:33:19.200
64那里有很多编码器，所以非常简单

00:33:19.200 --> 00:33:25.919
但是，是的，我可能会使用base64或32，但是，是的，

00:33:25.919 --> 00:33:30.159
但他们基本上希望，如果您确实在seabor中以二进制形式表示它

00:33:30.159 --> 00:33:36.320
这些呃标签，所以它会给你一些提示

00:33:36.320 --> 00:33:38.880
当转换为json时，应该将其转换为

00:33:38.880 --> 00:33:42.960
假设base64和我需要做同样的事情

00:33:42.960 --> 00:33:48.159
适用于所有不同的编码，包括基数58。

00:33:48.159 --> 00:33:52.480
所以我的意思是因为导致标签标签的一致性

00:33:52.480 --> 00:33:56.000
尽管因为现在您有了二进制文件，所以基本上在两句话中意味着同一件事

00:33:56.000 --> 00:34:00.559
不同的块，但它有这样的提示，说你知道

00:34:01.440 --> 00:34:05.440
是的，这主要是针对ipld以外的seabor

00:34:05.440 --> 00:34:11.119
嗯，使文件适合丢失了这种无损的转换，但我认为

00:34:11.119 --> 00:34:15.200
我当然在ipld上进行所有工作，但我需要使其与之互操作

00:34:15.200 --> 00:34:19.359
每个人的方法都令我头疼

00:34:19.359 --> 00:34:25.119
是的，嗯，我想像这样的json规范，我认为我们也使用

00:34:25.119 --> 00:34:28.960
以64为基数。如果我没记错的话，我就记不起

00:34:28.960 --> 00:34:31.520
认为我们使用32作为CID，然后使用64

00:34:31.520 --> 00:34:36.320
对于二进制哦，是的，是的

00:34:40.399 --> 00:34:45.599
好吧，别的

00:34:46.839 --> 00:34:51.839
嗯，好的，然后谢谢大家

00:34:51.839 --> 00:34:55.359
参加，下周再见

00:34:55.359 --> 00:34:57.679
每个人

00:34:59.119 --> 00:35:03.520
我在这里最后有一些东西

