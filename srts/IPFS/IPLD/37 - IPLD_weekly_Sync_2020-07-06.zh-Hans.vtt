WEBVTT
Kind: captions
Language: zh-Hans

00:00:16.940 --> 00:00:23.520
欢迎大家参加本周的IPL这些每周同步会议，这的确像

00:00:23.520 --> 00:00:30.480
SiC 2020，每周我们都会研究我们所做的工作，

00:00:30.480 --> 00:00:38.940
将在下周开始工作，然后讨论未解决的问题或回答问题，让您感到

00:00:38.940 --> 00:00:45.690
自由参加，是的，我开始自己了，所以我在放假两个

00:00:45.690 --> 00:00:53.339
几周的时间，所以我没有任何工作可以在休假前进行良好的报告

00:00:53.339 --> 00:01:00.359
在生锈的情况下-请把所有东西塞进生锈的图案中，接下来就是抓

00:01:00.359 --> 00:01:06.510
我错过了一些东西，可能还有很多ficon工作，所以我没有

00:01:06.510 --> 00:01:12.060
确保我本周不会做很多知识产权工作，但我一定会赶上

00:01:12.060 --> 00:01:19.560
希望我能对Kerr进行评论，是的，我们会问一些问题，但是发展-我

00:01:19.560 --> 00:01:33.290
如果可以的话，大概可以做的大部分是我自己做的，接下来是彼得

00:01:39.899 --> 00:01:46.979
是的，就我所做的事情而言，我所做的一切基本上都是

00:01:46.979 --> 00:01:57.929
试图找出如何测试我们的Dumbo在9000下降

00:01:57.929 --> 00:02:07.619
最后，我想他最终以未成年人告终，显然他更难

00:02:07.619 --> 00:02:12.239
跟着我原本想的那样成为恶魔，所以第三次是

00:02:12.239 --> 00:02:20.970
希望现在可以进行另一项设置，以使充满土地交易的魅力趋向于

00:02:20.970 --> 00:02:25.410
以多个节点结尾，我们将可以发出此合唱

00:02:25.410 --> 00:02:29.250
鲁ck之类的东西来实际检查一切是否正常

00:02:29.250 --> 00:02:37.590
在我见过迈克尔的匕首上做广告，并试图

00:02:37.590 --> 00:02:43.980
重新介绍他们，我们正在做的是什么，您知道这套

00:02:43.980 --> 00:02:49.590
那里发生了很多类似对齐的工具，因为迈克尔实际上并没有

00:02:49.590 --> 00:02:56.790
知道曾经去过哪个方向，我们将在某个时候找出答案

00:02:56.790 --> 00:03:05.130
一周接下来的步骤是什么，但是像步骤0.5一样，我们将会看到

00:03:05.130 --> 00:03:15.780
可以在奥斯曼的包裹中交叉编译它，看看它如何工作

00:03:15.780 --> 00:03:25.859
因为迈克尔认识的每个人都会对此非常感兴趣

00:03:25.859 --> 00:03:35.250
那不是领域，所以就这样，并且还与

00:03:35.250 --> 00:03:42.079
我不记得他的名字的人，对不起其余UNIX FS上的人

00:03:42.079 --> 00:03:50.669
添加命令并逐步介绍添加的实际组成部分

00:03:50.669 --> 00:03:56.880
ipfs的东西以及哪些部分-基本上是牛排

00:03:56.880 --> 00:04:00.390
他们可以做到的事，他们不会那样，因为我应该离开

00:04:00.390 --> 00:04:03.030
讨论时间比我原先预计的要长

00:04:03.030 --> 00:04:08.600
这几乎是我的一周

00:04:10.650 --> 00:04:22.140
很酷，我也看到了克里斯（Chris yeah）的最新消息，所以上周家人在一起

00:04:22.140 --> 00:04:27.460
深入研究Dumbo投递代码并进行大量重构，因此关键

00:04:27.460 --> 00:04:35.410
重点是创建Visual Studio代码容器配置，如果

00:04:35.410 --> 00:04:37.960
您还没玩过就觉得很酷，因为您可以

00:04:37.960 --> 00:04:42.610
将整个工具链和依赖项封装在docker容器中，

00:04:42.610 --> 00:04:48.340
然后基本上将其旋转起来，这样可以帮助人们快速入门

00:04:48.340 --> 00:04:53.890
反对找出版本冲突或其他依赖测试

00:04:53.890 --> 00:04:59.290
基本上跑得很快，以确保我没有摔坏任何东西和68个单元

00:04:59.290 --> 00:05:03.310
测试运行时间不到20毫秒，因此确保我不会

00:05:03.310 --> 00:05:08.410
破坏任何东西和大量的源代码文档文档，因此

00:05:08.410 --> 00:05:14.230
主要围绕着，大概我主要分为三个阶段

00:05:14.230 --> 00:05:18.940
从项目的角度来看，它涉及的最主要是解析文件和

00:05:18.940 --> 00:05:23.200
将它们转换为IP LD盒，形状相当不错，我

00:05:23.200 --> 00:05:28.240
现在在第二部分上工作，它正在创建汽车零件，这是

00:05:28.240 --> 00:05:32.820
简单得多，但是由于

00:05:32.820 --> 00:05:39.520
正确地注入东西是很难的，对于杆的一个问题是

00:05:39.520 --> 00:05:49.600
对Jas数据存储汽车的依赖，它在一个名为complete graph的分支上

00:05:49.600 --> 00:05:56.350
它已经不存在了，但是出现了一个AR包，它合并了什么

00:05:56.350 --> 00:06:00.850
在NPM中，它只是数据存储车，因此只需安装最新的数据存储

00:06:00.850 --> 00:06:05.830
汽车，该分支被合并一点应该工作吗

00:06:05.830 --> 00:06:15.280
改变了，但是应该可以，因为没关系，这是我的更新内容

00:06:15.280 --> 00:06:18.370
[音乐]

00:06:28.190 --> 00:06:37.940
几乎有一个小消息是，现在在V零点处有五个

00:06:37.940 --> 00:06:44.820
滑行药T Prime的标签，它只是做了一些API更改就使它们脱离了

00:06:44.820 --> 00:06:46.800
我上周和现在关于这个的方式

00:06:46.800 --> 00:06:51.660
它已经完成了推送标签，但对于任何需要

00:06:51.660 --> 00:07:00.090
这样做，这是我本周得到的一个重大新闻，那就是我们有Cochin供工会使用，

00:07:00.090 --> 00:07:07.830
这让我感到非常兴奋，这是实施的一部分

00:07:07.830 --> 00:07:14.220
进度表中有很多众所周知的知识，现在至少有一个

00:07:14.220 --> 00:07:19.790
几个漂亮的屏幕复选标记，所以这很重要，因为

00:07:19.790 --> 00:07:24.930
工会尽管听起来很简单，但通常被认为是其中之一

00:07:24.930 --> 00:07:29.850
科钦最棘手的部分和架构系统，然后特别是

00:07:29.850 --> 00:07:36.720
之所以要实施，是因为它们涉及到根据什么做出很多选择

00:07:36.720 --> 00:07:39.900
他们期望包含在其中的数据实际上很难处理

00:07:39.900 --> 00:07:43.290
与诸如structs之类的其他任何东西相比，您知道您将拥有

00:07:43.290 --> 00:07:47.610
所有这些事情，就工会而言，这很简单

00:07:47.610 --> 00:07:50.340
将拥有这些不同的事物之一，而您将需要

00:07:50.340 --> 00:07:55.020
根据它是哪个而疯狂地分支，所以他们只是发现它们有一个

00:07:55.020 --> 00:08:02.280
比您可能天真地期望的代码要多得多，因此到目前为止

00:08:02.280 --> 00:08:05.970
仅实现了一种表示模式，这很关键，因为

00:08:05.970 --> 00:08:11.070
到目前为止，它也是最容易做到的，并且将是性能最高的，但是我们已经

00:08:11.070 --> 00:08:14.820
得到了键表示和语义类型，现在都实现了

00:08:14.820 --> 00:08:21.660
这样可以使我们走得更远，您就像在证明核心设计一样

00:08:21.660 --> 00:08:27.900
他们周围的工作连贯一致，这是一个很大的缓解，所以这使我们

00:08:27.900 --> 00:08:34.080
真的很接近后期可以做的事情

00:08:34.080 --> 00:08:37.980
很酷的实际事情，我今天基本上还没有写过架构，

00:08:37.980 --> 00:08:43.980
至少有UT分钟，这样我们终于得到了，就像是的，我们要

00:08:43.980 --> 00:08:53.160
几乎甚至可以自行托管模式架构，其中一个重要的警告是

00:08:53.160 --> 00:09:00.060
我在架构模式中使用了内联Union表示形式，所以我实际上

00:09:00.060 --> 00:09:04.380
考虑更改架构方案以将其退回并将其切换到

00:09:04.380 --> 00:09:09.690
保持工会，因为无论如何kikyo的情况会更好，这会发生

00:09:09.690 --> 00:09:14.040
使这种自托管的事情变得容易得多，所以也许他们没有采取

00:09:14.040 --> 00:09:20.760
对此采取行动，但可能是这样，这很令人兴奋

00:09:20.760 --> 00:09:26.550
我已经和Rod谈过一些关于Doc的话题，我想我们只需要

00:09:26.550 --> 00:09:32.580
越努力越好，越快越强大，未来，我只是

00:09:32.580 --> 00:09:38.370
要做更多的事情，我非常接近获得架构架构自托管代码gem

00:09:38.370 --> 00:09:43.380
我有点想在下一个很长的时间内越过终点线

00:09:43.380 --> 00:09:49.350
它需要我拥有的下一个有趣的东西，事实是所有的

00:09:49.350 --> 00:09:53.190
我编写的占位符类型信息结构，就像引导程序一样

00:09:53.190 --> 00:09:57.020
我有自我托管循环之前的事情

00:09:57.020 --> 00:10:04.530
目前无法使用循环类型引用创建它们，因此我必须

00:10:04.530 --> 00:10:10.320
处理这个问题并修复占位符至少要花很长时间，然后我才能得到

00:10:10.320 --> 00:10:14.450
占位符完全取代了哦

00:10:14.960 --> 00:10:19.080
其他一些有趣的细节，例如我的未来，但我不会与之见面

00:10:19.080 --> 00:10:24.450
它们是您与内联工会的经验，以及您与

00:10:24.450 --> 00:10:30.510
模式模式建议我们应该考虑重新访问一些有关

00:10:30.510 --> 00:10:34.470
内联，我想我认为我们可能对他们轻描淡写，只是说他们会

00:10:34.470 --> 00:10:41.490
难以区分，但也许我们需要在其中进一步说明

00:10:41.490 --> 00:10:47.170
这不是最不理想的情况，还是不那么理想的联盟类型之一

00:10:47.170 --> 00:10:52.299
是的，我真的很想在文档中尽可能地阐明这一点

00:10:52.299 --> 00:10:58.149
这是我们需要的功能，因为人们可以像这样制作数据，并且

00:10:58.149 --> 00:11:03.549
数字，但在野外，我们关心准确地描述它，但是

00:11:03.549 --> 00:11:08.949
我越喜欢它，就越知道我有多大

00:11:08.949 --> 00:11:13.329
性能的决定取决于这些决定，就像种子工会一样

00:11:13.329 --> 00:11:17.049
认为我在足够多的地方用文字说过了，但对于那些正在观看的人来说

00:11:17.049 --> 00:11:22.179
尚未听到带有键控工会的union声，表示您有

00:11:22.179 --> 00:11:25.629
映射键，那就是您要区分的值，然后是

00:11:25.629 --> 00:11:30.910
关于这个X然后是Y的可爱之处是在第一部分中做出了选择

00:11:30.910 --> 00:11:36.850
然后您就可以掌握第二部分的操作信息

00:11:36.850 --> 00:11:40.869
足够，这意味着您可以像知道自己的选择一样高效地进行操作

00:11:40.869 --> 00:11:47.529
而且其中的一些其他表示特别讨厌

00:11:47.529 --> 00:11:51.279
不一定知道您正在区分信息提示

00:11:51.279 --> 00:11:56.199
放在这个数据范围的最前面，所以如果它出现在

00:11:56.199 --> 00:12:01.839
回到这里，您必须缓冲这些您无权决定的数据

00:12:01.839 --> 00:12:07.569
该怎么办，所以您可以选择执行任何有效率的工作

00:12:07.569 --> 00:12:15.009
就像在那儿一样，所以我希望我们能够支持对此的推理

00:12:15.009 --> 00:12:21.399
那种数据，鼓励人们不要这样做是很好的

00:12:21.399 --> 00:12:27.579
模式中有很多东西可以用来描述我们知道的数据

00:12:27.579 --> 00:12:33.399
存在于野外，但是有理想的数据可以很好地工作

00:12:33.399 --> 00:12:39.459
只是模式而已，该方案描述的是更理想的东西

00:12:39.459 --> 00:12:44.019
而不是野外有很多东西，所以使

00:12:44.019 --> 00:12:48.100
Docs中明确指出，这些模式应该能够

00:12:48.100 --> 00:12:56.470
描述现有的90％通用数据格式或布局欠缺的格式，但是您

00:12:56.470 --> 00:12:59.439
应该限制​​自己甚至更远的视野，并像从头开始设计一个那样

00:12:59.439 --> 00:13:04.070
使用这些东西，是的，我们应该使我们像高级

00:13:04.070 --> 00:13:06.890
应该在我与之链接的某个地方进行有关该元素的元讨论

00:13:06.890 --> 00:13:11.690
对于架构文档的详细信息的位置，这是个好主意，本次讨论是

00:13:11.690 --> 00:13:16.250
实际上在您上周打开的有关新提案的问题中继续

00:13:16.250 --> 00:13:21.890
称为您的联合格式称为密钥嗅探，它可能是合理的，也可能不是合理的

00:13:21.890 --> 00:13:25.910
名称，但现在它是一个不错的占位符，但是有一个很酷的问题

00:13:25.910 --> 00:13:31.910
关键嗅探联合类型，可以将90％扩展到95，以描述

00:13:31.910 --> 00:13:36.920
世界上有更多类型的数据，但确实存在所有这些问题

00:13:36.920 --> 00:13:42.530
使它不理想的工会，但我在他们所在的地区做工会

00:13:42.530 --> 00:13:48.620
试图在草率所在的数据中捕获该区域

00:13:48.620 --> 00:13:53.270
大量存在的数据格式，我们可以在其中捕获更多数据格式

00:13:53.270 --> 00:13:57.740
该方案的安全范围是我认为更好的方案，但确实为我们打开了大门

00:13:57.740 --> 00:14:03.430
这么多的草率，所以我们必须非常小心地踩踏

00:14:06.310 --> 00:14:13.310
从头顶上可以举一个例子，那里的数据

00:14:13.310 --> 00:14:25.130
获得内联联盟的东西，这取决于他的能力，这取决于

00:14:25.130 --> 00:14:31.550
关于谁开始设计数据的，所以如果您的意思是我的意思是确切的例子，

00:14:31.550 --> 00:14:37.280
已经是设计了，我的意思是我想不起，但是但是我会

00:14:37.280 --> 00:14:40.730
说出您是否四处查看了所抛出的数据中的

00:14:40.730 --> 00:14:44.240
编写JavaScript的人，您会发现更多此类示例

00:14:44.240 --> 00:14:50.330
松散的和你一起知道这个领域可能有这个东西或它可能有

00:14:50.330 --> 00:14:55.130
这个东西，取决于我的感受，取决于我在尝试什么

00:14:55.130 --> 00:14:58.790
沟通，我可以应对这种灵活性，因为当我

00:14:58.790 --> 00:15:02.140
DC意识到我有一个可以在内存中操作的对象

00:15:02.140 --> 00:15:07.339
而打字语言的人在哪里需要提前准备

00:15:07.339 --> 00:15:12.800
并说好，我确实将其序列化了，我需要真正知道其中的内容，是的，我

00:15:12.800 --> 00:15:15.590
想不到一个，但您必须更有可能找到

00:15:15.590 --> 00:15:19.340
在无类型的生态系统中，我们可以扔掉的那些例子

00:15:19.340 --> 00:15:22.070
围绕这些对象，然后将它们反序列化为这些格式，

00:15:22.070 --> 00:15:30.940
然后更容易地在代码中做出决策，我想我问这个是因为

00:15:30.940 --> 00:15:37.090
就像我们在专门讨论持久性或存储格式一样

00:15:37.090 --> 00:15:44.390
通常人们不会以存储格式了解SQL知识，这就是为什么

00:15:44.390 --> 00:15:49.190
我实际上想举一个例子，但是是的，因为可以互换

00:15:49.190 --> 00:15:58.970
无论如何，我明白了，是我从我的集体中做出了这些选择

00:15:58.970 --> 00:16:03.280
我在任何API中都见过的每个JSON结构的模糊回忆

00:16:03.280 --> 00:16:08.360
完全没有区别的李，那些是API抱歉，这些是运输

00:16:08.360 --> 00:16:13.780
通常没有人在此存储一些JSON，我的意思是，你知道没有人

00:16:13.780 --> 00:16:18.020
这些工具也可以用于这些东西，就像我想要一些开发

00:16:18.020 --> 00:16:24.110
拥有这种Web API的东西，没有理由我应该

00:16:24.110 --> 00:16:27.910
必须绝对令人敬畏

00:16:33.730 --> 00:16:42.200
我会在你后面排好队，工会也有这种潜力，我认为

00:16:42.200 --> 00:16:48.920
在一个可能有很多复杂结构的空间中行动

00:16:48.920 --> 00:16:53.390
可选的东西，或者您可以区分两种类型的脚本

00:16:53.390 --> 00:17:02.930
结构，因此它确实存在于您可以选择的空间中

00:17:02.930 --> 00:17:08.390
您如何编写模式，因为那是因为那是

00:17:08.390 --> 00:17:12.140
我能想到的例子就像您知道我接触了NPM数据之类的东西

00:17:12.140 --> 00:17:18.080
其中有很多可选项，所以当您描述一个软件包时，

00:17:18.080 --> 00:17:21.560
字段可能在那里，有些可能不取决于作者的工作方式

00:17:21.560 --> 00:17:25.490
这些软件包，在这些示例中，您可以说您知道

00:17:25.490 --> 00:17:27.860
我有一个可选的可选字段

00:17:27.860 --> 00:17:32.299
也许有一种模式，我只收到我收到的数据

00:17:32.299 --> 00:17:36.410
有三个字段，所有这些可选选项都消失了，所以也许我会区别对待

00:17:36.410 --> 00:17:40.250
跟联盟说好吧，如果我只有这三个领域，那么你

00:17:40.250 --> 00:17:45.230
知道这是一件事情，然后，如果我有其他领域，那么这是一件

00:17:45.230 --> 00:17:50.510
东西，那就是那行和那个关键的草率空间

00:17:50.510 --> 00:18:00.559
嗅觉会存在，是的，谢谢，如果有人在听，

00:18:00.559 --> 00:18:05.330
对这些东西更感兴趣的是在架构中有架构规范

00:18:05.330 --> 00:18:11.000
在规格点IPL经销商IO网站上，我们确实有在线工会的示例

00:18:11.000 --> 00:18:21.830
以及其他工会类型，如果您想了解更多关于下一个权利的信息，

00:18:21.830 --> 00:18:27.620
我的清单很糟糕，所以我的又一个礼拜

00:18:27.620 --> 00:18:35.020
在一周结束时我去做的事情我做了我改变的事情

00:18:35.020 --> 00:18:40.340
但是我确实设法对这些小事情做了很多的核算

00:18:40.340 --> 00:18:43.850
似乎并不像我刚开始思考时那样糟

00:18:43.850 --> 00:18:47.630
关于上周初我所做的最后一件事，

00:18:47.630 --> 00:18:55.820
完成Z现金美元的IPL神化并打包

00:18:55.820 --> 00:19:04.669
进入汽车文件以进行文件文件硬币发现，因此它不会像

00:19:04.669 --> 00:19:10.010
今天的Z缓存块必须倒退一点，因为我现在所做的

00:19:10.010 --> 00:19:15.200
说用比特币做同样的事情，我把它们打包成一个演出文件

00:19:15.200 --> 00:19:20.630
我没有剩余的汽车档案，所以最后一个演出带我去的地方是

00:19:20.630 --> 00:19:26.240
我停下来的地方，但以后可能还会添加这些东西，所以

00:19:26.240 --> 00:19:34.520
它可以再次运行，所以我花了大约810,000块，它位于

00:19:34.520 --> 00:19:37.480
我认为最近两个月

00:19:38.130 --> 00:19:45.850
是的，所有这些都已经上传完毕，代码是完整的，有效的，而且非常有用

00:19:45.850 --> 00:19:50.890
比比特币更顺畅，因为Z Cash有了更好的选择

00:19:50.890 --> 00:19:57.040
关于比特币的数据格式版本控制，比比特币有

00:19:57.040 --> 00:20:04.960
撰写新颖数据的人数似乎大大少于

00:20:04.960 --> 00:20:09.820
比特币也许是可以理解的，所以这种情况很少

00:20:09.820 --> 00:20:16.120
不得不被抓住，所以一旦我掌握了基础知识，它就可以很好地运行了，

00:20:16.120 --> 00:20:19.540
那就是那本身就真的很有趣，

00:20:19.540 --> 00:20:23.890
人们真的一直在戳戳比特币，以拉长比特币的价格。

00:20:23.890 --> 00:20:31.720
格式以启用不同的挖掘类型并将奇怪的内容打包到

00:20:31.720 --> 00:20:37.510
交易和人们只是不使用Z现金，因为它不是

00:20:37.510 --> 00:20:44.200
因为它不是很有趣，也不是那么不赚钱，所以代码可以正常工作

00:20:44.200 --> 00:20:47.290
很好，这一切都很好，我有很多代码

00:20:47.290 --> 00:20:53.670
和比特币在没有合并在那里的拉取请求中工作，那是

00:20:53.670 --> 00:20:59.080
很大程度上是因为文档文档不完整

00:20:59.080 --> 00:21:03.870
完整的是比特币的文档完整的代码文档

00:21:03.870 --> 00:21:09.580
C现金的东西不是很完整，然后下一项是相关的

00:21:09.580 --> 00:21:16.810
这是LD回购的比特币规格，我填写了这些规格回购

00:21:16.810 --> 00:21:20.560
仍然在努力消除它的乏味，而我继续前进

00:21:20.560 --> 00:21:24.420
回到它，我告诉你完成它，然后也进行Z缓存

00:21:24.420 --> 00:21:31.860
这基本上就是我所有关于这些格式的大脑都转储的地方

00:21:31.860 --> 00:21:37.030
内容寻址格式如此，所有极端情况下如何考虑其

00:21:37.030 --> 00:21:42.820
内容介绍了如何弥合区块链世界，以及

00:21:42.820 --> 00:21:48.070
内容地址数据结构需要更多的加密货币

00:21:48.070 --> 00:21:55.240
桥接比您想像中的要多，您会粗略地看一下

00:21:55.240 --> 00:22:05.110
两件事正在发生，如果我能参加lambda比赛，我就要参加一些比赛

00:22:05.110 --> 00:22:11.610
在克里斯工作的那一周里，他现在要去找点乐子了

00:22:11.610 --> 00:22:19.830
弄清楚如何使这些东西适合展示给全世界

00:22:20.470 --> 00:22:26.110
无论如何，这都是开源的，它不是很漂亮，而且代码

00:22:26.110 --> 00:22:29.980
过度，因为它试图弄清楚如何做以及如何做

00:22:29.980 --> 00:22:33.910
足够有效地在lambda中运行，因此可以进行很多调整

00:22:33.910 --> 00:22:39.310
在那之后，还有一些Doc和五个硬币校对编码员

00:22:39.310 --> 00:22:47.790
那么就需要更新Falcone证明代码，这样Chris他就知道了

00:22:48.330 --> 00:22:57.730
帮助彼得获得文件硬币CID的东西，我合并了吗？

00:22:57.730 --> 00:23:06.370
承认合并并没有消失，但这只是他们的职责所在

00:23:06.370 --> 00:23:13.180
下一次测试网重置大约需要两个星期，但这是一个巨大的

00:23:13.180 --> 00:23:20.470
为他们改变只是表演他们需要触摸的一块，所以我基本添加了

00:23:20.470 --> 00:23:27.030
在他们的董事会上，所以再次好

00:23:27.990 --> 00:23:42.610
好吧，我们昨天没有做一个相当的事情，这是

00:23:42.610 --> 00:23:47.380
在可能具有某种概念对接方面的区域中

00:23:47.380 --> 00:23:56.200
关于这样的定价，我们继续面临着我认为他们的哲学差异

00:23:56.200 --> 00:24:01.300
与区块链世界有关的归档，这是相同的东西，但是

00:24:01.300 --> 00:24:05.899
我特别遇到过比特币，但是​​有

00:24:05.899 --> 00:24:11.659
有一个上下文地址与用于加密货币的区块链

00:24:11.659 --> 00:24:15.860
当您在构建区块链并且正在考虑时的事情

00:24:15.860 --> 00:24:21.379
从矿工的角度来看，您有很多东西可供选择

00:24:21.379 --> 00:24:26.120
做出有关格式的决定，格式在不断变化，格式在不断变化，其功能也不断变化

00:24:26.120 --> 00:24:33.980
随时间变化最明显的是您具有链条高度，因此您可以

00:24:33.980 --> 00:24:38.299
根据您的应用在任何时间的高度做出决定，所以说您

00:24:38.299 --> 00:24:42.320
在一些高处，你知道十万，你说，好吧，我想

00:24:42.320 --> 00:24:47.059
切换我存储这些数字的方式，您知道我想停止我想要

00:24:47.059 --> 00:24:51.830
开始以十万个高度将我的花车存储为字符串，你可以

00:24:51.830 --> 00:24:55.639
做到这一点，所有矿工所有这些完整的节点都具有该高度信息

00:24:55.639 --> 00:25:02.269
但是高度不是存储在块中的东西，因此如果您的文件

00:25:02.269 --> 00:25:07.070
格式是分支并且基于高度，那么您需要能够

00:25:07.070 --> 00:25:10.879
一直导航到Genesis块，以便在您做出决定时

00:25:10.879 --> 00:25:16.070
在查看内容时阅读格式并从我们的角度来看

00:25:16.070 --> 00:25:21.850
地址数据的位置越多越好，所以当我遇到一个

00:25:21.850 --> 00:25:28.309
内容地址块我有一个哈希，我想到的是数据，你有

00:25:28.309 --> 00:25:31.700
表示这是数据类型的多编解码器，很高兴能够

00:25:31.700 --> 00:25:36.769
说这是数据的类型，我知道如何读取，但是如果您必须

00:25:36.769 --> 00:25:40.610
说好吧，我有这个街区，但我需要十万个需求

00:25:40.610 --> 00:25:48.320
在我不知道如何阅读它之前，在它之前先阻塞

00:25:48.320 --> 00:25:52.149
区块链世界是合理的，有两个原因，一个是

00:25:52.149 --> 00:25:59.029
解码这些块的大多数软件都具有该信息，因此

00:25:59.029 --> 00:26:03.649
他们将高度存储在他们拥有的二进制数据附近，因此它不是

00:26:03.649 --> 00:26:09.799
这么大的事情，还有这个哲学思想，

00:26:09.799 --> 00:26:14.869
如果您可以验证区块链，则区块链可以为您提供安全性

00:26:14.869 --> 00:26:20.320
创世记块，所以也有发展的趋势

00:26:20.320 --> 00:26:25.700
只是具有说这个东西的能力与创世纪块有关

00:26:25.700 --> 00:26:30.799
是区块链背后思想的一部分，因此高度是其中的一部分

00:26:30.799 --> 00:26:36.409
只是地方性使得其他一切都变得如此容易，所以试图

00:26:36.409 --> 00:26:45.049
将这些数据版本化的东西放到更本地化的工具中讨论会更好，并且

00:26:45.049 --> 00:26:49.490
因此，正如e-cash特别为您使用他们的版本一样，他们拥有版本

00:26:49.490 --> 00:26:55.249
块标题中的字段，以及交易事务中的字段，因此

00:26:55.249 --> 00:27:00.080
被寻址的单元中有一个version字段，它们是

00:27:00.080 --> 00:27:03.679
实际上使用该版本字段，他们有数据，他们有一个版本和一个

00:27:03.679 --> 00:27:08.720
原始组ID uh-huh，当您将这两件事结合在一起时，您会得到两个

00:27:08.720 --> 00:27:12.259
他们写二进制格式的开始，所以你要使那些

00:27:12.259 --> 00:27:17.179
本地决策，好吧，这是版本，这是版本，版本组

00:27:17.179 --> 00:27:20.980
ID我知道如何解码其余部分，我不知道这意味着什么

00:27:20.980 --> 00:27:26.659
比特币有一个版本，其中的版本字段位也不常用

00:27:26.659 --> 00:27:32.749
据我所知，coin确实没有版本字段，所以我确实有

00:27:32.749 --> 00:27:35.629
我们只是为了传递给文件硬币团队而撰写了有关这些内容的文章

00:27:35.629 --> 00:27:41.929
之前谈论过几次，但实际上从未粘过，所以他们

00:27:41.929 --> 00:27:46.369
应该在这里选择我们的硬币，但那里是比特币

00:27:46.369 --> 00:27:50.779
现在基本上未定义以备将来使用，您知道并且您

00:27:50.779 --> 00:27:54.289
不要定义是否当您不定义某些内容时就知道您在其中找到了什么

00:27:54.289 --> 00:28:00.679
过一会儿，是的，是的，是的--我们会用的是，我实际上把

00:28:00.679 --> 00:28:08.539
在您将参考文献放在一起给出9的文档中

00:28:08.539 --> 00:28:14.899
一种如何使单个版本字段与业务协调的方法

00:28:14.899 --> 00:28:18.669
链，以及如何基本将所有这些放在一起

00:28:18.669 --> 00:28:26.539
所以基本上是哪种软件会在特定的高度胜出，这就是

00:28:26.539 --> 00:28:30.860
我不确定为什么会喜欢找到它，我不确定他们为什么没有找到它

00:28:30.860 --> 00:28:36.440
他们正在向他们使用它，所以要么它们有缺陷，要么就永远无法得到

00:28:36.440 --> 00:28:41.000
共识，我们需要从类似的内容开始，但是TL DR是

00:28:41.000 --> 00:28:45.590
对于文件硬币，这实际上可能是要考虑的事情，因为它不是

00:28:45.590 --> 00:28:54.770
专辑中的想法非常好，是的，你有一场比赛

00:28:54.770 --> 00:29:01.220
我认为我觉得真的很有趣，并且使用了一些版本

00:29:01.220 --> 00:29:07.160
字段已比其他字段使用得更好，并且像这样隐式地拥有一个

00:29:07.160 --> 00:29:10.910
版本字段并不意味着您已经神奇地修复了它，这就是您的方式

00:29:10.910 --> 00:29:17.210
计划使用它也很重要，但是特别是如果您在这些

00:29:17.210 --> 00:29:21.380
您作为作者无法控制事物随着时间演变的情况

00:29:21.380 --> 00:29:26.809
所以你不能用区块链加密货币你不能你不能说

00:29:26.809 --> 00:29:30.500
我知道随着时间的流逝它将如何发展，因为您必须达成共识

00:29:30.500 --> 00:29:33.350
在你的矿工和你之间，这很有可能你不会成为那个

00:29:33.350 --> 00:29:39.110
有足够的力量来做出这些决定，所以您知道这件事

00:29:39.110 --> 00:29:43.429
会从您手中演变而来，我认为这就是为什么这就是故事的原因

00:29:43.429 --> 00:29:46.700
比特币的意思是，我们可以提前计划好了，但是这件事

00:29:46.700 --> 00:29:54.340
只是拥有自己的生活而已

00:29:55.090 --> 00:29:59.179
值得怀疑的是在网络上，傻瓜谁知道如何使更多

00:29:59.179 --> 00:30:04.910
后来怎么样，是的，那将是一个

00:30:04.910 --> 00:30:14.150
观看节目的好过程好吧，好吧，您知道那是正在进行的

00:30:14.150 --> 00:30:18.380
Google文档，但我不知道是否会在某个时候出现

00:30:18.380 --> 00:30:25.630
规格重放中的内容有人想看它让我知道，但是否则

00:30:25.660 --> 00:30:29.840
因为地方越多越好，因此将其表述为

00:30:29.840 --> 00:30:37.730
你想爬的连续体，是的，我认为这就是我们的想法，但是我

00:30:37.730 --> 00:30:40.520
不知道如何将其桥接到区块链世界，因为我知道

00:30:40.520 --> 00:30:44.340
不是他们的想法，我知道，我认为那不是

00:30:44.340 --> 00:30:49.620
他们的h4，所以面临的挑战是，我们如何以思维为出发点的人

00:30:49.620 --> 00:30:55.230
传达这种东西是对那些不适合自己的人的理想选择

00:30:55.230 --> 00:31:02.160
在区块级别思考，更像是我们的本地化成本

00:31:02.160 --> 00:31:06.890
那里的某个地方已经被抽象掉了，但是就像现在每次我需要

00:31:06.890 --> 00:31:16.350
认为什么是测试笔记，这是四个小时的测试网，就像我们可以

00:31:16.350 --> 00:31:23.370
我已经老了，这是我认为的另一种观点，所以我的理解是

00:31:23.370 --> 00:31:28.890
文件硬币的区块链会非常厚，因此会生成一个

00:31:28.890 --> 00:31:33.270
随着时间的流逝，大量的数据，因此，随着比特币的出现，它已经持续了11年，

00:31:33.270 --> 00:31:38.070
您有大约300个演出的数据定理，大约300个演出，

00:31:38.070 --> 00:31:45.630
如果成功，年轻的文件硬币可能会越来越大，因此

00:31:45.630 --> 00:31:50.940
可以说我加十万的成本，这增加了

00:31:50.940 --> 00:31:54.750
随着高度的增加，然后您必须拥有所有已知的数据

00:31:54.750 --> 00:32:00.930
一天，比特币将拥有数TB的数据，而且您知道磁盘很便宜

00:32:00.930 --> 00:32:04.200
网络也将变得越来越便宜，这不像是

00:32:04.200 --> 00:32:10.260
无法克服，但是必须说出高度是有代价的，于是你就结束了

00:32:10.260 --> 00:32:15.930
最大限度地减少了区块链附带的信任，因为如您现在所见

00:32:15.930 --> 00:32:19.440
比特币没有那么多的完整节点，完整节点的数量

00:32:19.440 --> 00:32:22.890
随着时间的流逝而减少，因此我们不必使用这些第三方，因此

00:32:22.890 --> 00:32:26.070
你去了一个比特币，一个区块链浏览器，你说我想

00:32:26.070 --> 00:32:29.790
了解此区块中的内容，然后您必须相信他们，

00:32:29.790 --> 00:32:35.220
给您正确的信息高达10万，这是我所信任的

00:32:35.220 --> 00:32:40.410
你知道你的身高，我也相信你

00:32:40.410 --> 00:32:44.340
原因是因为我不想运行一个完整的节点来理解该数据，所以

00:32:44.340 --> 00:32:47.940
这种信任关系破裂了，因为它变得不切实际

00:32:47.940 --> 00:32:55.170
拥有全部内容，因此您可以更确切地说这可能是来自

00:32:55.170 --> 00:33:00.240
区块链，这不仅可能，而且肯定是

00:33:00.240 --> 00:33:05.399
数据说明了什么，无论如何，我的意思是，这真的很有趣

00:33:05.399 --> 00:33:10.169
如果我们有这样的论点，那是我不喜欢的哲学方面的东西

00:33:10.169 --> 00:33:15.299
去年提交了Coyne的文件，但我还没有真正深入区块链

00:33:15.299 --> 00:33:20.159
这些加密货币直到今年，所以确实有一些

00:33:20.159 --> 00:33:23.820
我们正在做的所有工作的有趣焦点

00:33:23.820 --> 00:33:34.350
无论如何，我在称为pr's的规范存储库中做了一些小小的整理

00:33:34.350 --> 00:33:43.350
就像eric提到的那样，刚刚结束并关闭的问题合并了，我做到了

00:33:43.350 --> 00:33:47.220
我们在规格回购中讨论了码头工作的一些近期优先事项

00:33:47.220 --> 00:33:51.779
拿一些他是这些要点的，他把这些都很好扔掉了

00:33:51.779 --> 00:33:57.120
想法，并将其转化为更正式的规范文档（如果其概念或

00:33:57.120 --> 00:34:03.090
规范，目前我正在研究他提出的规范

00:34:03.090 --> 00:34:07.049
上周是编解码器的完整性，它是基于已经完成的一些工作

00:34:07.049 --> 00:34:13.679
关于任何IP的完整性范围考虑一会儿

00:34:13.679 --> 00:34:23.510
LD编解码器在考虑使用IP LD时，其目的是能够描述

00:34:23.510 --> 00:34:32.520
大量的内容兴趣格式，从开始到比特币，再到

00:34:32.520 --> 00:34:36.450
然后沿着诸如dag之类的完整性的连续性

00:34:36.450 --> 00:34:41.369
Seabourn Dec Jason几乎可以完全描述我们的理想

00:34:41.369 --> 00:34:47.310
任意形状的数据的状态，不只是这些形状

00:34:47.310 --> 00:34:52.829
特定格式，那么频谱看起来像什么，这意味着什么

00:34:52.829 --> 00:34:57.390
走向理想，什么是理想，还有埃里克标题，

00:34:57.390 --> 00:35:00.690
真的很好，他只是我想将其转换为文档，但是将会有

00:35:00.690 --> 00:35:05.099
一些关键的事情，我们围绕着这个理想是什么进行了讨论

00:35:05.099 --> 00:35:11.670
特别是关于排序的意思

00:35:11.670 --> 00:35:16.050
我们一起偶然发现了几次

00:35:16.050 --> 00:35:21.060
正确地并真正获得对这意味着什么的共同理解

00:35:21.060 --> 00:35:27.870
所有要排序的东西，级别和默认值

00:35:27.870 --> 00:35:33.810
确实很棘手的东西，但这是很好的解决办法

00:35:33.810 --> 00:35:38.460
之所以这样，是因为此时此刻的黑暗基本上表明存在理想的终结

00:35:38.460 --> 00:35:44.610
我们尚不存在的频谱，因此我们可以进一步发展，但是它将

00:35:44.610 --> 00:35:50.790
意味着定义我们自己的格式或改变我们使用海滨的方式

00:35:50.790 --> 00:35:57.240
我们可以做到这一点，并进一步向理想迈进，但这可能是因为

00:35:57.240 --> 00:36:01.350
在理想的情况下，您只是处于妥协的境界，而您只是在做出

00:36:01.350 --> 00:36:08.970
为您的用例做出正确的妥协，最后我将在全家度假

00:36:08.970 --> 00:36:15.690
从本周末到下周，但我将与

00:36:15.690 --> 00:36:20.220
减少的输出我不打算消失，但我可能不会显示

00:36:20.220 --> 00:36:27.900
直到下周的会议，因为我想睡，所以

00:36:27.900 --> 00:36:30.320
不可接受的

00:36:30.590 --> 00:36:44.220
好吧，其他任何人都想讨论的事情，我想知道什么时候萝卜

00:36:44.220 --> 00:36:52.500
解释要在泥土上工作的工厂，这极受诱惑，因为这会

00:36:52.500 --> 00:36:57.660
也许真的很容易，我只是这要多少钱的问题

00:36:57.660 --> 00:37:01.590
就是这么多钱，所以有这么多的硬币真的很有趣

00:37:01.590 --> 00:37:08.370
在那里，但是可能不会，但是可能不会很难，因为

00:37:08.370 --> 00:37:14.550
就像可以使用比特币一样容易哦，我只是不知道人们是否

00:37:14.550 --> 00:37:20.370
如果我们有一个狗狗币抄本来回购我们，我们将认真对待

00:37:20.370 --> 00:37:23.100
教育我的意思是所有的加密猫

00:37:23.100 --> 00:37:29.120
是的，是的，就像TCPA的信鸽一样

00:37:29.120 --> 00:37:39.930
无论如何，RFC，如果您使用梳状PDF和I，则为Chris提供一个信息。

00:37:39.930 --> 00:37:46.560
还要查看实际的防锈填充证明代码，您想知道为什么不这样做

00:37:46.560 --> 00:37:51.600
这个东西只是一个尖叫的操作，可能是因为我双重操作

00:37:51.600 --> 00:37:55.860
但是我还没深入，只是为了以防万一你想为什么这样做

00:37:55.860 --> 00:38:00.000
内存中或磁盘上的东西或其他任何东西，您可以将其流式传输

00:38:00.000 --> 00:38:04.470
是的，就像是的，我希望这只不倒翁在那上面，然后

00:38:04.470 --> 00:38:11.010
是的，如果没有原因，该便笺上的便笺没有理由伏特加酒

00:38:11.010 --> 00:38:16.160
因为我确实向克里斯描述了所有这些，但是所有这些都可能会在哪里

00:38:16.160 --> 00:38:22.710
比较计算器必须重新实现整个竞争生成

00:38:22.710 --> 00:38:31.380
之所以起作用，是因为除锈打样只允许使用默克尔本机

00:38:31.380 --> 00:38:39.090
具有特定存储支持的树算法存储支持缓存存储，我们可以

00:38:39.090 --> 00:38:43.620
我们需要内存存储，而锈场证明API则无法实现

00:38:43.620 --> 00:38:48.930
切换它们的存储，所以您必须重新实现各种各样的功能

00:38:48.930 --> 00:38:56.100
我认为我固定了我那天正在看的东西，但仍然

00:38:56.100 --> 00:39:01.590
就像所有的错字都在这里，所以一切都很好，但是

00:39:01.590 --> 00:39:05.640
只是这意味着我们要实现10行代码，是的，但是

00:39:05.640 --> 00:39:11.420
理想的情况是不必重新实现，但是像没有那样的变化

00:39:11.420 --> 00:39:15.690
我不确定这几天是否可以，但是如果忙碌的话应该很容易进入

00:39:15.690 --> 00:39:20.160
一种简单的方法，可以直接用防锈的螺丝直接完成，因为我和我一样

00:39:20.160 --> 00:39:23.299
说我实际上以为我已经做到了，但是如果我还没有这样做的话

00:39:23.299 --> 00:39:28.669
是的，我们可以跟克里斯·蒙塔古（Chris Montagu）谈一谈，所以克里斯在那里

00:39:28.669 --> 00:39:32.529
一个ping所有这些东西好吗

00:39:32.649 --> 00:39:39.919
不错，然后我觉得很好

00:39:39.919 --> 00:39:47.070
然后，是的，我结束会议，一周之内见到大家，再见

00:39:47.070 --> 00:39:50.209
[音乐]

