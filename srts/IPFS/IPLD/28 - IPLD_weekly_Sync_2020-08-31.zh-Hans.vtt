WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.920 --> 00:00:20.400
欢迎大家参加本周的ipld同步会议

00:00:20.400 --> 00:00:27.359
2020年8月31日，每周我们都会浏览

00:00:27.359 --> 00:00:30.720
我们在过去一周中完成的工作，并计划在下一个工作中进行

00:00:30.720 --> 00:00:36.719
一周，然后讨论我们的开放式议程项目

00:00:36.719 --> 00:00:42.719
可能有，所以让我假设这让我发疯了，抱歉，嗯

00:00:42.719 --> 00:00:46.960
它总是对不起我需要得到的一切

00:00:46.960 --> 00:00:52.719
茄子，嗯，还好

00:00:53.280 --> 00:00:59.760
所以嗯，是的，我开始了自己，所以在过去的一周中，我终于，是的，我

00:00:59.760 --> 00:01:03.920
也喜欢有时间花在ipod上，所以

00:01:03.920 --> 00:01:08.880
嗯，我做了些小杂烩，有点像铁锈

00:01:08.880 --> 00:01:12.159
多哈希，但计划上游

00:01:12.159 --> 00:01:19.680
嗯，我计划希望合并

00:01:19.680 --> 00:01:24.799
这个星期，并使其上游，另一件事是

00:01:24.799 --> 00:01:29.520
当然，您还需要上游除锈等，但是

00:01:29.520 --> 00:01:32.720
嗯，所以本周基本上，我尝试着重于获得所有这些

00:01:32.720 --> 00:01:36.159
在上游，您可以从那里移走，因为我们也有

00:01:36.159 --> 00:01:42.560
讨论是否要使用像js这样的mono repo之类的方法

00:01:42.560 --> 00:01:45.600
所以不喜欢不喜欢一个图书馆的所有东西

00:01:45.600 --> 00:01:48.479
创建但就像为所有多种格式只有一个存储库一样

00:01:48.479 --> 00:01:52.479
因为像multi hash和cid等通常

00:01:52.479 --> 00:01:55.360
喜欢彼此之间非常依赖，或者想要拥有

00:01:55.360 --> 00:01:59.200
他们之间的变化，所以有一个单一的存储库与

00:01:59.200 --> 00:02:03.040
所有板条箱，但这是呃，我也想与

00:02:03.040 --> 00:02:10.160
整个社区都可以

00:02:10.160 --> 00:02:15.680
然后我也开始讨论诸如

00:02:15.680 --> 00:02:22.480
多编解码器实际上是什么意思，所以这是通过

00:02:22.480 --> 00:02:29.599
也会引起人们对它的讨论，就像基本上

00:02:29.599 --> 00:02:32.800
多重散列是关于散列的，所以我们创建多个散列，然后

00:02:32.800 --> 00:02:37.040
多阴影线，请问我关于法典的问题

00:02:37.040 --> 00:02:40.560
所以应该将您从事的工作称为

00:02:40.560 --> 00:02:44.720
多编解码器，因为它有点像编解码器

00:02:44.720 --> 00:02:49.920
在类固醇上，因为变异剂是散列的，这很有趣，因为我已经

00:02:49.920 --> 00:02:53.680
从来没有见过这样的事情，因为我知道multicodex的悠久历史，

00:02:53.680 --> 00:02:57.120
的东西，但它可能是有趣的是的

00:02:57.120 --> 00:03:01.280
讨论命名或查看是否因为

00:03:01.280 --> 00:03:05.440
我个人认为例如多编码实际上应该是我们

00:03:05.440 --> 00:03:09.040
当前调用多重编码应仅称为我的解码

00:03:09.040 --> 00:03:12.400
但我认为我们仍然应该称呼另一件事

00:03:12.400 --> 00:03:17.599
超级编码，但仍然是名称，我们应该澄清一下

00:03:17.599 --> 00:03:22.239
还有一个未解决的问题，我也被链接到笔记中

00:03:23.200 --> 00:03:28.640
是的，很酷，嗯，我所拥有的不多，因此新闻不多

00:03:28.640 --> 00:03:33.040
哦，我还有更多的消息要告终

00:03:33.040 --> 00:03:37.599
在过去的几周中，我做了很多消防工作，

00:03:37.599 --> 00:03:43.120
今天我也宣布了我们在猎鹰中所讨论的

00:03:43.120 --> 00:03:46.799
从我们所在的团队开会，我终于回到了

00:03:46.799 --> 00:03:51.840
只有兼职的硬币，所以我玩计划花大约一天的时间

00:03:51.840 --> 00:03:54.720
值得的工作和文件硬币，其余的我的

00:03:54.720 --> 00:03:59.280
质量，所以我有点像恢复正常

00:03:59.599 --> 00:04:03.680
是的，对于团队来说可能很有趣，所以希望会有更多

00:04:03.680 --> 00:04:06.720
我在接下来的几周内会收到有关hyperld的消息

00:04:06.720 --> 00:04:10.799
好吧，我名单上的下一个是彼得

00:04:11.120 --> 00:04:15.840
是的，我这边没有更新，我想念你们

00:04:17.759 --> 00:04:26.720
好吧，那么我名单上的下一个是丹妮尔

00:04:26.720 --> 00:04:30.560
很酷，所以这是我的第一个礼拜

00:04:30.560 --> 00:04:33.759
上手并阅读文档和规格

00:04:33.759 --> 00:04:37.120
而且我也开始捕捉我的经验

00:04:37.120 --> 00:04:41.919
随着我的前进，并希望如果有什么我可以整理的有用的东西

00:04:41.919 --> 00:04:45.680
知道经历过之后的反馈

00:04:45.680 --> 00:04:50.320
可能对我有用，因为我正在阅读有关规格

00:04:50.320 --> 00:04:54.479
我注意到的博客格式有一种编码方式

00:04:54.479 --> 00:04:57.919
当前规范以多种方式使用json字符串，因此我发现

00:04:57.919 --> 00:05:00.639
一个问题可能不是高纯度的，但仍然可能是

00:05:00.639 --> 00:05:05.759
有趣，仅此而已，嗯，我会继续，嗯，我会说我

00:05:05.759 --> 00:05:09.919
大约三分之二的人至少在某种程度上了解了规格

00:05:09.919 --> 00:05:13.919
基本级别，我可能需要阅读架构内容

00:05:13.919 --> 00:05:16.080
再过几次才能完全理解它

00:05:16.080 --> 00:05:25.720
就是这样，很酷，谢谢，下一个是eric

00:05:25.720 --> 00:05:30.479
嗯，我这个星期花了一点时间看

00:05:30.479 --> 00:05:35.280
一些库的下游用户关于内存配置的报告

00:05:35.280 --> 00:05:38.639
东西硬币看着他们的表现

00:05:38.639 --> 00:05:41.440
我猜想在这个项目中这个阶段是可以预期的

00:05:41.440 --> 00:05:47.039
嗯，所以有几位公关人员参加了关于降低

00:05:47.039 --> 00:05:50.880
分配，我们已经合并了一些

00:05:50.880 --> 00:05:53.280
主要涉及钻探

00:05:53.280 --> 00:05:57.680
抽象有点像拥有读者和

00:05:57.680 --> 00:06:02.000
编写器接口，以便您拥有一堆接口

00:06:02.000 --> 00:06:06.000
原因，但事实证明，如果您知道

00:06:06.000 --> 00:06:08.639
您将整个字节数组作为一个连续的东西

00:06:08.639 --> 00:06:11.520
如果您直接进行钻探，则需要它运行得更快，这是适合您的

00:06:11.520 --> 00:06:14.960
分配，所以我们开始介绍一些

00:06:14.960 --> 00:06:18.160
像在表现似的地方进行抽象钻取

00:06:18.160 --> 00:06:23.199
有道理，所以这很有趣，我也一直在做一堆

00:06:23.199 --> 00:06:26.880
上周我们需要在此库中完成的其他任务的枚举

00:06:26.880 --> 00:06:31.120
一堆东​​西已经在我脑海中浮现，不再可扩展

00:06:31.120 --> 00:06:37.280
丹尼尔（u Daniel）已针对go ipld prime中的各种问题编写了六份修复程序

00:06:37.280 --> 00:06:39.680
顺便说一句，他没有给自己以荣誉

00:06:39.680 --> 00:06:44.080
嗯，所以他应该这样做，并且正在更新ci，这是非常重要的

00:06:44.080 --> 00:06:47.840
欢迎和其他有趣的消息

00:06:47.840 --> 00:06:52.639
我这周要和纺织品开会，

00:06:52.639 --> 00:06:56.000
三个有框框的人和其他与他们合作的人

00:06:56.000 --> 00:07:00.840
开发出jose以及jose和jose以及所有这些

00:07:00.840 --> 00:07:03.680
实施，现在有人在看

00:07:03.680 --> 00:07:09.199
如何去做这些事情，这真的很令人兴奋，所以我花了一个

00:07:09.199 --> 00:07:14.840
很少的时间和他们一起在图书馆走走

00:07:14.840 --> 00:07:18.800
嗯，我认为很多实施选择都会像

00:07:18.800 --> 00:07:22.560
完全取决于那些做这些事情的开发人员

00:07:22.560 --> 00:07:26.000
我们真的不喜欢对这些东西的任何方式做出严格的承诺

00:07:26.000 --> 00:07:29.599
预计会继续进行，但只是一些类似的信息

00:07:29.599 --> 00:07:32.000
交流更多类似的事实调查

00:07:32.000 --> 00:07:35.039
代码库的详细信息以及类似的内容

00:07:35.039 --> 00:07:38.720
这是编解码器代码所在的地方，这是其他您知道的地方

00:07:38.720 --> 00:07:41.840
但是现在他们已经掌握了很多信息，所以我真的

00:07:41.840 --> 00:07:44.400
期待看到随之而来的东西，我们谈到了一堆

00:07:44.400 --> 00:07:48.960
可以采用不同的方式来实现这些东西以最大化编码

00:07:48.960 --> 00:07:54.080
从我们的早期讨论中，我们将看到听起来很可能的结果

00:07:54.080 --> 00:07:59.680
实际上是我们的目标，我们希望这将是可能的

00:07:59.680 --> 00:08:05.360
针对大多数实现，使其行为有点像adl之类的

00:08:05.360 --> 00:08:09.199
一般而言，高级布局代码在某种意义上是

00:08:09.199 --> 00:08:12.400
一堆具有以下特征的函数

00:08:12.400 --> 00:08:16.400
给我一个节点，我会给你另一个已经改写的节点

00:08:16.400 --> 00:08:22.000
信息，然后当我们希望它仍然是

00:08:22.000 --> 00:08:25.120
直接与某种多编解码器号码相关联

00:08:25.120 --> 00:08:29.039
将其与多编解码器代码捆绑在一起真的很容易

00:08:29.039 --> 00:08:34.479
在最后一刻，但是如果您想将此代码准备好用作adl

00:08:34.479 --> 00:08:37.760
将来我们可能会提出接口

00:08:37.760 --> 00:08:42.479
同时让我们获得99点（如果不是100点的话）

00:08:42.479 --> 00:08:47.839
希望那只是赢了，我们会看到

00:08:47.839 --> 00:08:50.800
所以这就是我的意思

00:08:51.360 --> 00:08:58.640
谢谢，接下来是迈克尔，嘿，你呢，又是一个礼拜

00:08:58.640 --> 00:09:03.519
被z bag um捕获了，这是呃

00:09:03.519 --> 00:09:09.279
有一些很酷的东西，所以有一个非常详细的规范

00:09:09.279 --> 00:09:13.279
它包含了我几乎所有的想法和推理以及

00:09:13.279 --> 00:09:18.160
从上个星期开始一直实施到大约星期四

00:09:18.160 --> 00:09:21.760
从那以后，我有了更多的主意，包括一些最大的主意

00:09:21.760 --> 00:09:25.760
压缩胜出，我认为我已经看过呃，但真正重要的是

00:09:25.760 --> 00:09:29.839
嗯，我在解释它方面做得更好，我在研究方面打得非常好

00:09:29.839 --> 00:09:33.920
嗯，史蒂文（Steven）收到了一些非常好的意见

00:09:33.920 --> 00:09:36.000
得到这个，这就是我需要的

00:09:36.000 --> 00:09:38.959
了解你在说什么，所以我写了

00:09:38.959 --> 00:09:42.560
呃在规范中写了很多东西

00:09:42.560 --> 00:09:46.320
我敢打赌，上周我听起来像个疯子

00:09:46.320 --> 00:09:50.959
谁没睡过，因为那就是我

00:09:50.959 --> 00:09:54.240
现在就像真的一样

00:09:54.240 --> 00:10:01.279
男人，我发现了一些巨大的巨大胜利，就像当你解析时一样。

00:10:01.279 --> 00:10:03.760
您知道的csv，就像您得到一堆

00:10:03.760 --> 00:10:07.519
只是列表的列表，就像它只是一堆数组中的一个数组一样

00:10:07.519 --> 00:10:11.040
或者就像一堆uh对象的数组，但是一样

00:10:11.040 --> 00:10:14.240
一遍又一遍都相同大小的键

00:10:14.240 --> 00:10:17.680
ii有技巧可以抛弃所有这些代币

00:10:17.680 --> 00:10:21.360
就像没有令牌了，就像从字面上就可以编码

00:10:21.360 --> 00:10:25.200
形状的尺寸，如果列有

00:10:25.200 --> 00:10:29.519
您可以只对列进行一次编码，就可以使用相同的类型

00:10:29.519 --> 00:10:33.200
那么如果它们具有相同的密钥，则只需编码一次密钥增量

00:10:33.200 --> 00:10:37.120
所以从字面上看，就像那种结构变得像

00:10:37.120 --> 00:10:42.079
一系列没有结束语的暴力行为，因为您知道尺寸

00:10:42.079 --> 00:10:46.079
您甚至不需要关闭令牌，这真的很棒，如果您继续

00:10:46.079 --> 00:10:49.920
255以下的压缩表实际上是固定大小的

00:10:49.920 --> 00:10:53.440
表格，所以您可以跳进去，因为您知道他们在

00:10:53.440 --> 00:10:58.320
嗯，只有一个咬住指针，所以，如果我们为此设计

00:10:58.320 --> 00:11:02.079
我们最终只会缩小50％到70％

00:11:02.079 --> 00:11:06.160
比我喜欢的像我这样的cbor

00:11:06.160 --> 00:11:08.640
像是如果你只是从seabourn拿东西放进去的话

00:11:08.640 --> 00:11:13.200
大概增加12倍，但如果您设计得像

00:11:13.200 --> 00:11:17.040
嗯，这是胡说八道，是的，我的意思是

00:11:17.040 --> 00:11:19.920
打电话给我，我想我可以谈谈更多有关我的方式

00:11:19.920 --> 00:11:23.120
描述它和一些类似的研究

00:11:23.120 --> 00:11:26.240
在提出正确的建议方面，乡亲们真的很有帮助

00:11:26.240 --> 00:11:29.040
使用的术语之类的东西，以便我可以在结尾处讨论

00:11:29.040 --> 00:11:33.440
打电话，但这基本上是我的一周，嗯，嗯，也像一堆

00:11:33.440 --> 00:11:37.680
我必须做的管理工作，嗯，是的

00:11:37.680 --> 00:11:43.839
就是这样，虽然我不知道谁是下一个乡亲

00:11:45.120 --> 00:11:52.639
下一个是正确的，所以在javascript中有一个星期的杂项

00:11:52.639 --> 00:12:01.040
我再次接触了某些esm内容，然后测试了浏览器内容

00:12:01.040 --> 00:12:06.959
嗯，八个数组与缓冲区um比较，所以主要集中在汽车周围

00:12:06.959 --> 00:12:13.040
回购，因为那有点呃我很好

00:12:13.040 --> 00:12:17.279
我本周并不是打算这样做，我本来打算做比特币规格

00:12:17.279 --> 00:12:20.880
我们陷入了这个JavaScript的东西嗯

00:12:20.880 --> 00:12:25.839
但是我有点想买车

00:12:25.839 --> 00:12:32.880
易于使用的东西，以便我们可以处理其中一些

00:12:32.880 --> 00:12:36.320
eric和我映射出的测试治具

00:12:36.320 --> 00:12:40.399
那是一个艰巨的目标，即使是

00:12:40.399 --> 00:12:44.560
如果我们一切都好，我的意思是我们可能想回去

00:12:44.560 --> 00:12:48.720
帮助法尔科内拿东西，但这是最初的目标，但是

00:12:48.720 --> 00:12:53.120
无论如何，这只是一个长期目标，所以我们一直致力于

00:12:53.120 --> 00:12:57.920
嗯，使其在浏览器中正常工作的东西，使用了michael的新工具链

00:12:57.920 --> 00:13:02.000
javascript一切正常，我得到了很大的公关

00:13:02.000 --> 00:13:06.399
合并了我在笔记中链接的内容

00:13:06.480 --> 00:13:10.399
我已经开始重构整个界面

00:13:10.399 --> 00:13:18.320
从旧版本继承的数据存储接口

00:13:18.320 --> 00:13:22.160
出现的事情是为ipfs提出的，这只是

00:13:22.160 --> 00:13:29.519
在ipld um上太令人沮丧了，所以

00:13:29.519 --> 00:13:35.600
嗯，我们决定咬一口子，为此做一个新的界面

00:13:35.600 --> 00:13:39.839
嗯，这符合我们对

00:13:39.839 --> 00:13:44.399
块抽象嗯，所以我有一个问题，我正在链接

00:13:44.399 --> 00:13:49.360
我在那里写了我要去的提案的笔记

00:13:49.360 --> 00:13:54.720
在那里做，所以我想尝试并完成它

00:13:54.720 --> 00:13:57.680
出来，但是当我这样做的时候，我也

00:13:57.680 --> 00:14:02.639
发现我可能会

00:14:02.639 --> 00:14:07.440
我不确定我是否会在汽车库中内部执行此操作，还是

00:14:07.440 --> 00:14:13.360
嗯，实际上它的重构量更大，但是我

00:14:13.360 --> 00:14:16.079
拉出算法的核心

00:14:16.079 --> 00:14:19.360
就像它已经被拉入核心一样

00:14:19.360 --> 00:14:24.000
像编码器解码器一样，但我在想，也许这需要走

00:14:24.000 --> 00:14:27.839
其他地方，所以你有这个块存储

00:14:27.839 --> 00:14:33.120
并非真正属于汽车文件的汽车文件的抽象

00:14:33.120 --> 00:14:38.000
真的不是他们不是您真正的大商店

00:14:38.000 --> 00:14:40.160
通常使用可以存放get的块存储

00:14:40.160 --> 00:14:44.560
迭代所有这些事情，比如说，汽车是平面文件

00:14:44.560 --> 00:14:48.000
有多种模式可以在其顶部进行操作，因此它不是

00:14:48.000 --> 00:14:51.360
它不完全适合抽象，足够好了

00:14:51.360 --> 00:14:56.800
嗯，但是汽车文件呃，它有相关的基本算法

00:14:56.800 --> 00:14:59.920
因此，考虑将其拉出

00:14:59.920 --> 00:15:03.040
一个单独的库，以便您可以在需要时使用它，并且

00:15:03.040 --> 00:15:05.920
您可以在其顶部编写自己的抽象

00:15:05.920 --> 00:15:10.240
但是您想与它进行交互，或者也许我只是将其保留在其中

00:15:10.240 --> 00:15:13.279
该库，并使其从外部更易于访问

00:15:13.279 --> 00:15:18.000
尚不确定，但嗯，这一直在进行，所以我正在将其提取到

00:15:18.000 --> 00:15:21.040
好东西

00:15:21.760 --> 00:15:27.120
棒，我只是，我刚刚在聊天室中发布了一个链接，嗯，这不是真的

00:15:27.120 --> 00:15:31.839
现在困扰很多，但是我要记住它是

00:15:31.839 --> 00:15:34.880
这是对javascript的第三阶段语言增强

00:15:34.880 --> 00:15:39.440
嗯，所以它可能在未来三年左右可用

00:15:39.440 --> 00:15:42.959
嗯，就像我们也许可以在几年内转向它一样

00:15:42.959 --> 00:15:48.880
嗯，但这是不可变的类型，呃，他们是上帝，我们会得到很多

00:15:48.880 --> 00:15:53.519
用掉它们，嗯，它们很棒，但是嗯

00:15:53.519 --> 00:15:57.120
最重要的是，当您使用块接口时

00:15:57.120 --> 00:16:00.639
当我们在设计其他一些东西时，我们应该牢记

00:16:00.639 --> 00:16:03.839
在几年内，我们可能会做出重大改变以采用其中一些

00:16:03.839 --> 00:16:08.000
工具特别是块api

00:16:08.000 --> 00:16:13.600
缓存um和um的编码和解码状态

00:16:13.600 --> 00:16:16.240
块，然后基本上返回您的副本

00:16:16.240 --> 00:16:20.240
这就是为什么存在这些不安全的方法的原因，所以如果您知道的话，您总是可以

00:16:20.240 --> 00:16:22.560
你不会突变它，你可以得到

00:16:22.560 --> 00:16:26.000
原始的，但是如果突变它，那么最终它们会像可怕的一样

00:16:26.000 --> 00:16:31.040
像我在dagdb中做过一次这样的可怕错误，我花了两天的时间来跟踪它

00:16:31.040 --> 00:16:35.519
嗯，所以这些也将更快

00:16:35.519 --> 00:16:39.600
因此，在某些时候，例如，而不是um周围有二进制文件，

00:16:39.600 --> 00:16:45.440
基本上可能是uinta状态的不变元组

00:16:45.440 --> 00:16:49.519
而且您知道任何经过编码的地图都可能最终也成为记录

00:16:49.519 --> 00:16:52.720
我们也会从那些数字中复制出来

00:16:52.720 --> 00:16:56.240
所以是的，我喜欢我只把它放在我们的

00:16:56.240 --> 00:16:59.120
现在就像设计新事物一样

00:16:59.120 --> 00:17:01.920
介意我们可能会在某个时候将其插入

00:17:01.920 --> 00:17:04.640
然后这些原语将真正帮助我们

00:17:04.640 --> 00:17:09.280
事情要快得多，我想我想搬到一个

00:17:09.280 --> 00:17:13.039
处理一件事情的界面是关键

00:17:13.039 --> 00:17:16.559
在这里，现在是块接口

00:17:16.559 --> 00:17:19.199
然后在未来可以发展，但是

00:17:19.199 --> 00:17:22.720
是的，我们现在面临的挑战是该数据存储

00:17:22.720 --> 00:17:27.199
接口是它的字符串键二进制值

00:17:27.199 --> 00:17:34.080
是的，我们有cids和blocks，就像ah，所以这是

00:17:34.080 --> 00:17:37.039
cid的持续转换，简直是一团糟

00:17:37.039 --> 00:17:40.240
是的，但是要考虑的一件事就是那个

00:17:40.240 --> 00:17:45.200
您可以进行这些深层比较，这样它们是不可变的，因此您可以进行深层比较

00:17:45.200 --> 00:17:48.240
比较它们，以便您实际上可以创建一个集合

00:17:48.240 --> 00:17:51.840
并检查它是否在集合中

00:17:51.919 --> 00:17:55.039
这就像一个完整的深度比较，所以我们甚至可以

00:17:55.039 --> 00:17:58.480
如果我们正在编码大量数据，并且我们知道我们现在有一个类似的东西

00:17:58.480 --> 00:18:02.640
我有一堆街区商店的卢鲁斯，但我只是用那些来检查

00:18:02.640 --> 00:18:06.559
如果cid在里面，我们实际上可以跳过

00:18:06.559 --> 00:18:09.840
通过检查通用数据是否已编码或解码来对通用数据进行编码和解码

00:18:09.840 --> 00:18:12.320
通过使用

00:18:12.320 --> 00:18:16.080
不可变的类型，因此一旦存在就将变得非常酷

00:18:16.080 --> 00:18:20.640
我一直要求这个问题已经十年了，是的，我很漂亮

00:18:20.640 --> 00:18:22.559
兴奋的是它正在漂亮地进行着

00:18:22.559 --> 00:18:28.559
很快，供应商对实施它感到非常兴奋

00:18:28.559 --> 00:18:33.120
更重大的变化，就像三年了，就像三年

00:18:33.120 --> 00:18:40.240
没关系，没关系，也可以知道

00:18:41.039 --> 00:18:47.360
嗯，还有其他人有任何更新或想要分享吗

00:18:47.360 --> 00:18:49.760
某物

00:18:49.840 --> 00:18:54.960
还是上周我忘记了，因为做一个好的开始

00:18:54.960 --> 00:19:00.160
询问是否需要介绍自己的新面孔

00:19:00.160 --> 00:19:07.710
嗯，您当然不必，但是[音乐]

00:19:08.640 --> 00:19:17.120
 ii对不起ricardo对不起，继续吧，嗨，我叫ricardo malabon，我来自

00:19:17.120 --> 00:19:23.360
墨西哥和我对IPSF作为一种技术非常感兴趣

00:19:23.360 --> 00:19:30.720
因为我们在墨西哥的某些声音中拥有非常具有挑战性的互联网访问

00:19:30.720 --> 00:19:37.440
可以实现集中化的技术非常

00:19:37.440 --> 00:19:42.160
对我们发展嗯很重要

00:19:42.160 --> 00:19:49.039
我不是开发人员，我是集成商或我们所说的集成商

00:19:49.039 --> 00:19:56.080
我对这类技术非常感兴趣，我只是

00:19:56.080 --> 00:19:58.559
客人

00:19:59.360 --> 00:20:05.760
我不能给你太多我不，我没有这种

00:20:05.760 --> 00:20:10.799
知识，但如果你允许我我可以学习

00:20:10.799 --> 00:20:17.520
关于这个特定项目的更多信息ipld

00:20:17.520 --> 00:20:21.280
您如何处理数据非常有趣

00:20:21.280 --> 00:20:26.400
多谢允许我在这里

00:20:27.600 --> 00:20:32.320
谢谢，太酷了

00:20:32.840 --> 00:20:38.640
嗯，是的，嗯，是的，所以我们有

00:20:38.640 --> 00:20:45.039
议程项目，嗯讨论或我们应该给像

00:20:45.039 --> 00:20:53.600
35分钟给迈克尔读了他的新东西，所以我

00:20:53.600 --> 00:20:56.799
只是关于上一个主题ii呃

00:20:56.799 --> 00:21:00.080
现在我们想结束了，我想听听

00:21:00.080 --> 00:21:03.200
呃，我不是，你是一个新角色，我认为

00:21:03.200 --> 00:21:06.559
你似乎正在做很多ipfs的事情，你可以吗

00:21:06.559 --> 00:21:10.240
告诉我们您现在的位置以及我们应该如何考虑您

00:21:10.240 --> 00:21:17.840
在ipfs小组中，斯蒂芬被绑架了，所以我很害怕

00:21:18.080 --> 00:21:26.720
嗯，这是最接近的近似值um，但说实话，我认为

00:21:26.720 --> 00:21:31.440
他可能就像斯蒂芬仍在帮助别人，特别是一些

00:21:31.440 --> 00:21:35.360
过渡材料，我怀疑他会使用

00:21:35.360 --> 00:21:40.159
机会um发布一些文件硬币的东西到

00:21:40.159 --> 00:21:42.320
想出自己喜欢做的​​一些事情

00:21:42.320 --> 00:21:46.240
最初想做的事是在他让ipfs维护人员被切断之前

00:21:46.240 --> 00:21:51.679
嗯，实际上就是您得到它的方式

00:21:51.679 --> 00:21:54.960
就像因为杰里米（Jeremy）被拉进Filecoin

00:21:54.960 --> 00:22:00.880
是的，对，对，对，所以这样的东西

00:22:00.880 --> 00:22:06.480
嗯，在待办事项清单上的东西，就像

00:22:06.480 --> 00:22:09.760
你知道所以一些目前正在发生的事情，例如

00:22:09.760 --> 00:22:16.720
我的待办事项清单正在弄清楚，就像我们有一些东西一样

00:22:16.720 --> 00:22:20.880
像我们这样交换事实的东西

00:22:20.880 --> 00:22:24.080
难道我们似乎没有这个计划，我们只是在广告中

00:22:24.080 --> 00:22:27.840
宇宙，那太荒谬了

00:22:27.840 --> 00:22:33.440
嗯，就像我有一个1 TB的zip文件一样，没人需要第五个

00:22:33.440 --> 00:22:38.880
要发布的zip文件中的块，他们需要的第一个块是

00:22:38.880 --> 00:22:43.360
它，但是需要对UM进行一些更改

00:22:43.360 --> 00:22:46.400
进行位交换，然后再进行DHT

00:22:46.400 --> 00:22:50.159
我想使DHT更具可升级性

00:22:50.159 --> 00:22:54.240
基本上使旋转和做版本颠簸变得更容易

00:22:54.240 --> 00:23:01.360
嗯，我们有了这个，几乎你知道几乎完成了转换转换，然后执行ipfs

00:23:01.360 --> 00:23:05.760
在块存储中使用多个哈希

00:23:05.760 --> 00:23:09.039
使用cidv1可以使事情变得容易得多

00:23:09.039 --> 00:23:14.559
还有什么，嗯，然后我不知道我想

00:23:14.559 --> 00:23:18.159
开始使用可变命名的东西，因为在

00:23:18.159 --> 00:23:23.039
去年，但仍然有很多不足之处

00:23:23.039 --> 00:23:29.200
实际上我想可能不像某些人那么遥远

00:23:29.200 --> 00:23:34.840
怀疑，尽管它可能我想为ips使用ipld格式

00:23:34.840 --> 00:23:40.240
记录um，因为我认为这会

00:23:40.240 --> 00:23:46.080
我认为这将是有用的，我们需要使其更具可扩展性

00:23:46.080 --> 00:23:50.640
和bi怀疑在新的UNIX中，fs可能很快就会出现

00:23:50.640 --> 00:23:55.679
他们

00:23:55.679 --> 00:23:59.520
嗯，我们也将拥有可变的子目录

00:23:59.520 --> 00:24:02.799
因此，与其像一个可变的指针，然后是其他所有东西，

00:24:02.799 --> 00:24:06.559
在它下面是不可变的，我认为这是完全合理的

00:24:06.559 --> 00:24:10.880
人们想要其他可变目录的可变目录

00:24:10.880 --> 00:24:16.840
嗯，因为那样就习惯了

00:24:16.840 --> 00:24:21.039
有时候是的，嗯，我是说我们绝对应该

00:24:21.039 --> 00:24:24.720
为ipns做一个架构，就像我们回到那个um

00:24:24.720 --> 00:24:26.720
绝对应该只写我的意思

00:24:26.720 --> 00:24:30.400
我们可以在任何时候写到我们拥有模式语言

00:24:30.400 --> 00:24:33.679
这不是一种很难使用的格式

00:24:33.679 --> 00:24:38.480
嗯，可变子目录的事情很有趣

00:24:38.480 --> 00:24:43.200
嗯，因为我不确定您要如何对其进行编码

00:24:43.200 --> 00:24:48.000
嗯，你想不想放在哪里

00:24:48.000 --> 00:24:53.760
可变性，例如您想将其放在不可变图形中还是

00:24:53.760 --> 00:24:57.600
将其放在名称或命名点中

00:24:57.600 --> 00:25:01.200
我的猜测就像是，而这即将到来

00:25:01.200 --> 00:25:04.880
严格来说，这是文件系统将如何做到的

00:25:04.880 --> 00:25:08.480
您的目录是指向事物的指针列表，而不是

00:25:08.480 --> 00:25:11.279
指针，你知道不可变的东西

00:25:11.279 --> 00:25:15.919
指针不是一成不变的东西，好吧，这绝对是

00:25:15.919 --> 00:25:18.799
尚未探索的Unix 52尺寸

00:25:18.799 --> 00:25:22.320
嗯，所以只是对unix m62进行快速更新，因为您

00:25:22.320 --> 00:25:26.840
可能就像不喜欢盯着我们的规格仓库

00:25:26.840 --> 00:25:31.520
我们有一个很好的数据结构

00:25:31.520 --> 00:25:35.679
对于所有字节，就像线性字节流一样，

00:25:35.679 --> 00:25:37.760
不仅如此的数据结构

00:25:37.760 --> 00:25:41.840
非常高效，很好，而且喜欢递归和

00:25:41.840 --> 00:25:45.679
真的很棒，但是它不会锁定

00:25:45.679 --> 00:25:48.960
嗯，任何这些东西的布局

00:25:48.960 --> 00:25:53.039
完全一样，它支持像您知道的滴答滴答一样的各种方式

00:25:53.039 --> 00:25:56.480
像所有东西一样平淡无奇，嗯，它支持所有这些

00:25:56.480 --> 00:25:59.520
但是您不需要任何新代码就能读取它或类似的东西

00:25:59.520 --> 00:26:02.080
那个，所以我们永远不必像

00:26:02.080 --> 00:26:04.320
新的阅读器代码，我们只需将其插入

00:26:04.320 --> 00:26:08.080
因此，就像具有通用数据结构的灵活字节一样

00:26:08.080 --> 00:26:12.159
列出fbl，因为在其他情况下，我们需要一个字节流

00:26:12.159 --> 00:26:15.840
并不是我们唯一的，然后在e62中，我们很友善

00:26:15.840 --> 00:26:18.640
指出我们有一份草稿的公关

00:26:18.640 --> 00:26:22.480
unixico c2的规范，这在一定程度上是合理的，但事实并非如此

00:26:22.480 --> 00:26:24.960
包括你刚才所说的

00:26:24.960 --> 00:26:28.720
嗯，我想我们越看越喜欢

00:26:28.720 --> 00:26:32.400
规范的一部分，就像描述的文件和目录一样

00:26:32.400 --> 00:26:35.679
一旦您进入ipld模式，就很容易做到这一点，我们将

00:26:35.679 --> 00:26:38.000
有点像最有效的争论

00:26:38.000 --> 00:26:41.760
表示形式，那就是我们最终要争论的是

00:26:41.760 --> 00:26:44.960
关于元数据的他妈的几个月，就像你知道的

00:26:44.960 --> 00:26:48.320
就像我们如何编码日期和类似的东西一样，

00:26:48.320 --> 00:26:52.080
这些就像小巧的东西，就像一连串的自行车拉扯一样

00:26:52.080 --> 00:26:55.360
但基础知识全都存在，我也认为

00:26:55.360 --> 00:26:59.600
嗯，像文件元数据这样的东西，它必须全部是可选的

00:26:59.600 --> 00:27:01.360
无论如何，因为您想拥有

00:27:01.360 --> 00:27:03.200
像您所知道的文件并没有全部

00:27:03.200 --> 00:27:06.880
Unix成功或类似传统文件系统的开销

00:27:06.880 --> 00:27:10.480
嗯，但是我认为我们应该登录有关

00:27:10.480 --> 00:27:15.919
IPNS的事情，因为我会以为我们

00:27:15.919 --> 00:27:19.679
结构化目录指针，您想要这个

00:27:19.679 --> 00:27:24.799
仅适用于目录，不适用于文件，对不起，我的意思是我的文件也将是合理的

00:27:24.799 --> 00:27:29.279
我的想法更像是如果有人让ips指针

00:27:29.279 --> 00:27:31.840
可以使用和渲染的东西，然后

00:27:31.840 --> 00:27:34.640
他们想将其收藏在某个地方

00:27:34.640 --> 00:27:37.600
他们将把这些东西放到哪里哦，他们可能会

00:27:37.600 --> 00:27:39.520
只是去，他们会把它扔进去就像

00:27:39.520 --> 00:27:45.360
mfs或任何um或一些，或者他们或他们正在寻找

00:27:45.360 --> 00:27:48.480
东西，我们现在什么都没有，所以现在我们可以从头开始设计它

00:27:48.480 --> 00:27:54.000
没有任何遗留问题，如果我们要纠正的话，这肯定会改变

00:27:54.000 --> 00:27:59.200
这肯定改变了我们对指针的思考方式，因为我

00:27:59.200 --> 00:28:02.720
认为我们这样做的方式是工会

00:28:02.720 --> 00:28:06.000
所以已经可以有很多东西，但是就像内联

00:28:06.000 --> 00:28:09.440
版本或它的链接，我认为这是一种结合

00:28:09.440 --> 00:28:12.720
嗯，也许在我真正拥有良好的工会之前就已经存在了，所以

00:28:12.720 --> 00:28:16.799
可能不是um，但应该是um，但如果我们是

00:28:16.799 --> 00:28:20.559
说不，它需要包含这个额外的内容

00:28:20.559 --> 00:28:26.240
只是指向该指针或实际上位于此处的文件指针部分中的元数据

00:28:26.240 --> 00:28:29.440
好吧，我的意思是，问题是链接，我的意思是，我想也许这就像高

00:28:29.440 --> 00:28:35.279
级别是呃，我们有一个链接接口

00:28:35.279 --> 00:28:38.720
我们有一个实现的东西是cid

00:28:38.720 --> 00:28:43.360
问题是它是否可以支持某些非CID的东西

00:28:43.360 --> 00:28:47.200
所以这就是我们一直在研究的方式

00:28:47.200 --> 00:28:51.440
是像cid一样是低级原始标准

00:28:51.440 --> 00:28:56.720
就像是多种格式，就像不可变的指针部分一样

00:28:56.720 --> 00:29:00.240
就像我们的数据结构一样

00:29:00.240 --> 00:29:03.760
我们采取像这些原语一样CID或字节

00:29:03.760 --> 00:29:07.120
然后我们创建一个更大的布局，就像这就是你的样子

00:29:07.120 --> 00:29:10.799
像无处不在一样对待字节，但实际上就像一系列

00:29:10.799 --> 00:29:13.039
斗争以及我们正在思考的方式

00:29:13.039 --> 00:29:16.960
就像好吧，我们有链接，我们如何创建更多

00:29:16.960 --> 00:29:20.159
复杂的链接具有其他功能，就像在其中具有路径一样

00:29:20.159 --> 00:29:23.600
它是否像您知道的那样具有与之关联的ips记录

00:29:23.600 --> 00:29:27.840
嗯，是的，我想我们甚至对可变链接进行了一次小讨论，

00:29:27.840 --> 00:29:30.159
以及那种数据结构可能是什么样的

00:29:30.159 --> 00:29:33.120
但是，嗯，我认为那是我认为你是对的，这可能是

00:29:33.120 --> 00:29:36.880
正确的攻击方式就像我们如何谈论那些

00:29:36.880 --> 00:29:38.960
有与他们相关联的ips记录，例如

00:29:38.960 --> 00:29:43.279
它指向那里的不可变状态，但是它也有一个

00:29:43.279 --> 00:29:45.919
表示您可能会如何更新

00:29:45.919 --> 00:29:50.559
嗯，好吧，好吧，有趣的是，让我们开始这个讨论

00:29:50.559 --> 00:29:54.080
工厂谈话是的，那里有一堆奇怪的问题，对不起

00:29:54.080 --> 00:29:56.880
提前eric呃，我有两个大小组

00:29:56.880 --> 00:30:00.559
观察结果是一堆变成了应用

00:30:00.559 --> 00:30:03.360
随时了解可变性时的层级语义

00:30:03.360 --> 00:30:06.720
所以我想要做的是制作一个架构

00:30:06.720 --> 00:30:11.120
用于描述所有不可变部分的sp2的unix

00:30:11.120 --> 00:30:14.399
然后停下来，然后希望我们能够将其重用为一些

00:30:14.399 --> 00:30:18.960
像我们这样组合使用的库

00:30:18.960 --> 00:30:24.960
产生可变文件系统，空间可变文件系统的方法和

00:30:24.960 --> 00:30:29.840
嗯，更详细一点，正如迈克尔已经提到的，

00:30:29.840 --> 00:30:32.640
在很多地方都有一个指向事物的指针

00:30:32.640 --> 00:30:37.679
这样就拥有了sv2 Unix的架构

00:30:37.679 --> 00:30:41.679
不变，然后编写第二个模式

00:30:41.679 --> 00:30:44.960
这几乎完全是相同的东西，将另一个成员添加到

00:30:44.960 --> 00:30:48.799
联合是一个非常容易描述的操作，

00:30:48.799 --> 00:30:51.039
我们可以把它们都放在一条数据上

00:30:51.039 --> 00:30:54.640
并确定是哪一个，然后用户还可以决定是否要

00:30:54.640 --> 00:30:58.000
是否允许在当前上下文中使用可变的东西

00:30:58.000 --> 00:31:04.399
嗯，我有很多数字，也不知道那是什么大脑，很难

00:31:04.399 --> 00:31:07.600
就像我不知道，我不知道，虽然喜欢

00:31:07.600 --> 00:31:13.120
关于这一点的事情是，即使您拥有可变的指针

00:31:13.120 --> 00:31:17.200
你也有一个不变的，所以它可能是

00:31:17.200 --> 00:31:20.640
使其成为一种规格可能是值得的，因为您始终

00:31:20.640 --> 00:31:23.679
不变的，应用层总是可以这样说

00:31:23.679 --> 00:31:28.799
我将忽略可变性权利，我的意思是，如果您愿意

00:31:28.799 --> 00:31:32.159
像我不认为该声明会脱机

00:31:32.159 --> 00:31:35.440
真正在应用程序开发中幸存下来并拥有意见

00:31:35.440 --> 00:31:40.080
虽然并非始终如此，但它必须脱机工作

00:31:44.880 --> 00:31:46.960
一世

00:31:51.519 --> 00:31:55.360
我应该在这里放松一下我的想法，我看不出有什么不同

00:31:55.360 --> 00:32:01.600
在可变和不变的um标准之间，因为您总是

00:32:01.600 --> 00:32:06.480
观察不可变状态，如果它是一个可变的指针，那么

00:32:06.480 --> 00:32:11.760
更新操作是先使图形变异，然后读取新的不变状态

00:32:11.760 --> 00:32:15.120
所以这好像不是实际上是两个不同的东西，如果你

00:32:15.120 --> 00:32:19.200
没有可用来更新可变状态的机制

00:32:19.200 --> 00:32:22.559
无论如何，您总是在阅读不变的一面，就像

00:32:22.559 --> 00:32:24.799
同样的东西就像不可变版本不一样

00:32:24.799 --> 00:32:28.399
需要任何代码来实现可变性，并且不会出现类似的冲突

00:32:28.399 --> 00:32:32.159
我可以给一个地方命名吗

00:32:32.240 --> 00:32:35.600
你实际上喜欢它会禁止在哪里

00:32:35.600 --> 00:32:38.480
有人把可变性放在一个问题上

00:32:38.480 --> 00:32:44.880
有周期，你想成为什么周期

00:32:44.880 --> 00:32:48.399
对，您可以使用可变的东西来创建创造周期的东西

00:32:48.399 --> 00:32:52.480
无限目录，这是我想快速提及的内容之一

00:32:52.480 --> 00:32:55.519
关于链接界面以及您所问的具体问题

00:32:55.519 --> 00:32:58.880
我们可以更早地使ipns适应链接吗

00:32:58.880 --> 00:33:02.240
界面，尤其是当您在谈论它的ipod质数定义时

00:33:02.240 --> 00:33:06.480
答案很难，因为是的，是的，是的，是的，是的

00:33:06.480 --> 00:33:08.559
我喜欢那样，这就是我的意思是

00:33:08.559 --> 00:33:11.919
像um，如果您像可变指针一样看它

00:33:11.919 --> 00:33:15.840
只是一个不可变的指针，它告诉您如何对图形进行变异以获取

00:33:15.840 --> 00:33:18.640
新状态，它实际上不是像这样的可变指针

00:33:18.640 --> 00:33:22.240
一种应用程序，即使是在线的应用程序，我也会用这种方式

00:33:22.240 --> 00:33:24.960
并具有更新可变状态的能力

00:33:24.960 --> 00:33:28.640
它永远不要像可变的那样读取图形

00:33:28.640 --> 00:33:32.000
它永远不应该像去积极地看着那样

00:33:32.000 --> 00:33:37.279
它应该总是走哦，有机会在此之前进行更新

00:33:37.279 --> 00:33:41.279
我读了它，我应该更新此图，然后现在我要阅读

00:33:41.279 --> 00:33:44.720
像这样的更新图实际上不是操作

00:33:44.720 --> 00:33:46.799
它

00:33:47.440 --> 00:33:52.320
这就像嗯，这是像adls这样的断点

00:33:52.320 --> 00:33:55.519
被概念化为您可以去做某事的地方，

00:33:55.519 --> 00:34:00.240
您会跳出其他空间，而不是像一个集成的链接

00:34:00.240 --> 00:34:04.480
图的一部分是AI到达这里，我可以做出选择

00:34:04.480 --> 00:34:08.159
那是在Codeland以外的其他地方

00:34:08.159 --> 00:34:12.320
数据的状态和不可变图可以

00:34:12.320 --> 00:34:15.760
只能按照定义正确读取，没有写操作

00:34:15.760 --> 00:34:20.720
所以嗯，就像这个youtube的unix的不可变版本一样

00:34:20.720 --> 00:34:23.280
您只是在阅读它不变的一面而已

00:34:23.280 --> 00:34:26.000
从不考虑突变操作

00:34:26.000 --> 00:34:30.879
是的，但是为什么我们要讨论的是unif fs的上下文

00:34:30.879 --> 00:34:35.440
关于变异的一切，因为我们不会

00:34:35.440 --> 00:34:37.919
将接口编码为模式，甚至

00:34:37.919 --> 00:34:42.399
进入adl，以获取像unix之类的基本知识

00:34:42.399 --> 00:34:47.280
所以可变性到底会在哪里

00:34:49.760 --> 00:34:53.919
在某种程度上是adl，就像它为您提供的是文件类型一样

00:34:53.919 --> 00:34:57.920
就它不是高阶种类而言，它不是adl

00:34:57.920 --> 00:35:02.240
就像我们在数据模型中拥有的一样，但这就像一个新类型，就像您获取文件一样

00:35:02.240 --> 00:35:05.599
就像在dagdb中，如果我想取一个文件并将其存储

00:35:05.599 --> 00:35:08.400
我将使用unix效果，就像我将使用该adl，然后

00:35:08.400 --> 00:35:11.359
实际上会向您提供一个类，该类说它是一个包含元数据的文件

00:35:11.359 --> 00:35:14.079
与之相关联，就像我不只是要给你

00:35:14.079 --> 00:35:19.040
就像json正确地查看数据一样，但是所有这些都是实现细节

00:35:19.040 --> 00:35:25.680
具体取决于您的应用如何处理此静态内容

00:35:25.680 --> 00:35:31.280
不可变dag会读取或写入的其他内容，例如不会

00:35:31.280 --> 00:35:35.440
服从任何此接口或实施它们将以不同的方式进行操作

00:35:35.440 --> 00:35:39.119
但这对现在所有的adl都是正确的

00:35:39.119 --> 00:35:44.079
像数据层中的所有adl一样，看起来像一堆数据模型，

00:35:44.079 --> 00:35:46.480
然后就像你必须有代码和不同

00:35:46.480 --> 00:35:48.960
人们在阅读该代码时会做出不同的解释

00:35:48.960 --> 00:35:54.640
就像我的意思，直到我们有一种方法可以将计算编码到图中

00:35:54.640 --> 00:35:58.880
完全一样，通过编码计算，我们基本上

00:35:58.880 --> 00:36:01.920
对读取操作进行编码，因为您无法进行编码

00:36:01.920 --> 00:36:04.960
某物的权利

00:36:05.200 --> 00:36:08.800
对，它不会以这种方式工作，所以基本上，基本上

00:36:08.800 --> 00:36:15.119
我想了解的是，很多人把可变性作为

00:36:15.119 --> 00:36:18.480
概念随处可见，它不会像我在哪里点击

00:36:18.480 --> 00:36:21.680
它实际上是否适合我们在内容和可追溯性方面所做的工作

00:36:21.680 --> 00:36:27.119
因为他们只是不点击

00:36:27.119 --> 00:36:30.320
是的，我的意思是在这种情况下是可变的指针

00:36:30.320 --> 00:36:34.400
是不可变的指针，提示您如何更新到新状态

00:36:34.400 --> 00:36:37.520
该图的内容，但该突变操作完全是

00:36:37.520 --> 00:36:41.839
在这里的应用程序中

00:36:43.200 --> 00:36:48.079
但这是某种方式，但是我某种程度上是标准化的

00:36:48.960 --> 00:36:52.320
我会给你一个更好的例子，就像你参与其中一样

00:36:52.320 --> 00:36:59.680
所以嗯嗯，这个文件的权限嗯嗯像这些不是一个真正的他妈的

00:36:59.680 --> 00:37:03.040
ipfs中的问题就像我们没有的一样

00:37:03.040 --> 00:37:06.880
这些用户记录和用户ID，我们不知道这意味着什么

00:37:06.880 --> 00:37:09.839
就像字面上没有任何意义，我们也不保证任何安全性

00:37:09.839 --> 00:37:14.000
围绕它，因为它只是我们想要喜欢um hold的元数据

00:37:14.000 --> 00:37:16.400
从我们采用的文件系统

00:37:16.400 --> 00:37:20.320
来自我们的数据，就像我们在大学里进行的对话一样

00:37:20.320 --> 00:37:24.880
关于如何维护数据并四处移动的两个问题

00:37:24.880 --> 00:37:27.760
对ipfs完全没有用，对ipfs完全没有用

00:37:27.760 --> 00:37:30.720
喜欢我们对数据的整个想法

00:37:30.720 --> 00:37:33.839
不变的状态，仅是应用层

00:37:33.839 --> 00:37:35.599
能够保留它，如果它要序列化

00:37:35.599 --> 00:37:40.560
正确的其他方法是的，但是此元数据也是数据的一部分

00:37:40.560 --> 00:37:45.440
在某种程度上是因为posix文件系统不只是一堆字节

00:37:45.440 --> 00:37:48.880
这个按钮周围有很多语义

00:37:48.880 --> 00:37:52.000
但是，是的，但是您正在描述每个数据结构，就像每个数据一样

00:37:52.000 --> 00:37:54.320
结构中有一堆没人知道的数据，除了

00:37:54.320 --> 00:37:57.760
应用我认为我认为是一个更好的类比

00:37:57.760 --> 00:38:05.200
这可能是如果您要使用一组文件和目录

00:38:05.200 --> 00:38:10.720
从mac os到Linux um上，会有很多剩菜剩饭

00:38:10.720 --> 00:38:15.599
那将是您在um之类的Mac OS上看不到的

00:38:15.599 --> 00:38:21.280
诸如此类的事情，您知道缓存的图标um和其他一些元数据

00:38:21.280 --> 00:38:24.560
不会出现，因为是因为mac os

00:38:24.560 --> 00:38:29.839
用一种特殊的方式解释它们um而在linux上则不是这样

00:38:29.839 --> 00:38:32.160
如果可以的话，如果我们有一些特别的地方

00:38:32.160 --> 00:38:36.079
指针类型，可能只是一些实现而已

00:38:36.079 --> 00:38:40.640
显示为一些奇怪的小文件或标记，

00:38:40.640 --> 00:38:44.720
只是一个死胡同，而如果您通过镜头来解释它

00:38:44.720 --> 00:38:48.320
这个指针adl也许吧

00:38:48.320 --> 00:38:53.359
成为通往神秘土地的神奇门户

00:38:53.359 --> 00:38:57.440
但是是的，否则只是一点点，是的，所以实际上被称为

00:38:57.440 --> 00:39:01.599
实际上，这实际上是Mac OS中的魔术点文件，它确定了

00:39:01.599 --> 00:39:07.119
哑剧类型ds商店的人是正确的，但又是

00:39:07.119 --> 00:39:09.200
就像我们盘旋回所有这一切是

00:39:09.200 --> 00:39:14.880
基本上是关于解释的，所以在里面读是的，是的，但是在

00:39:14.880 --> 00:39:18.240
为了解释它，我们必须具有标准规格，您

00:39:18.240 --> 00:39:22.400
知道如何写，以便不同的人以相同的方式解释它

00:39:22.400 --> 00:39:25.680
我的意思是，这就是全部，这就是为什么我认为

00:39:25.680 --> 00:39:28.079
这不是两个规格它只是一个

00:39:28.079 --> 00:39:31.280
堆栈数量

00:39:31.520 --> 00:39:36.160
好的，那是很多事情

00:39:36.480 --> 00:39:41.359
当我们开始谈论可变性时，我们可以像往常一样返回吗？

00:39:41.359 --> 00:39:45.119
呃，迈克尔，你说的是

00:39:45.119 --> 00:39:48.800
我不认为这种定义方式的一种理论

00:39:48.800 --> 00:39:53.200
实际上已经清楚地确定了，我想简短地暂停一下并确定它

00:39:53.200 --> 00:39:56.800
您似乎暗示了可变链接

00:39:56.800 --> 00:40:01.040
在任何情况下都将永远永远以

00:40:01.040 --> 00:40:04.319
指定某种可变性的部分

00:40:04.319 --> 00:40:08.079
我们根本没有讨论过的东西加上当前

00:40:08.079 --> 00:40:13.359
不变的链接，而这可能是应用程序选择结构的一种方式

00:40:13.359 --> 00:40:16.800
有些事情我不认为那实际上是嗯

00:40:16.800 --> 00:40:20.560
是的，是的，是的，是的，不是，呃

00:40:20.560 --> 00:40:23.760
我应该把那是我们应该做的

00:40:23.760 --> 00:40:26.800
我认为那是一个好习惯，我们应该拥有这样的习惯

00:40:26.800 --> 00:40:30.000
应该始终对不可变状态和要突变的提示进行编码

00:40:30.000 --> 00:40:35.040
再次回来，但是是的，我认为人们已经通过ips做到了这一点

00:40:35.040 --> 00:40:38.240
就像他们只是在某处放置ips记录，他们不会说

00:40:38.240 --> 00:40:41.359
就像他们喜欢去看这个吧

00:40:41.359 --> 00:40:44.000
就像那是他们在说的那样，他们不喜欢也链接到

00:40:44.000 --> 00:40:49.760
永恒不变的状态，但就像我认为变得过分

00:40:49.760 --> 00:40:53.200
关于这个的规定性也有点危险，我也不想

00:40:53.200 --> 00:40:56.079
把它放在任何地方都太基本了，因为

00:40:56.079 --> 00:40:59.200
有时人们会想出一些想法，例如，是的，我想要

00:40:59.200 --> 00:41:03.760
我的，如果我有这样的对，我希望不变的一面指向某事

00:41:03.760 --> 00:41:09.040
那本身就像是事物历史上的哈希树，好吧，

00:41:09.040 --> 00:41:13.440
等价于语义，就像提起git commit tree的想法一样

00:41:13.440 --> 00:41:15.839
而不是直接链接到个人

00:41:15.839 --> 00:41:20.560
数据内容树，就像我不想在其中过度指定

00:41:20.560 --> 00:41:24.800
这样可以防止人们发明类似的东西

00:41:24.800 --> 00:41:28.720
是的，我的意思是我们应该将其记录为最佳

00:41:28.720 --> 00:41:32.880
练习并写出我们的推理，因为我最主要的是

00:41:32.880 --> 00:41:39.119
尝试解决该问题只是您应该

00:41:39.119 --> 00:41:42.960
永远不会，如果你能避免它只指向喜欢

00:41:42.960 --> 00:41:47.040
一些可变的指针um，因为那样您会损失所有现金

00:41:47.040 --> 00:41:50.160
能力是对的，所以如果可以的话，您总是可以同时做，但是

00:41:50.160 --> 00:41:54.319
例如，如果您来自非ipld和内容残障人士

00:41:54.319 --> 00:41:58.079
那么您的直觉是将链接视为人们经常去做的可变的事情

00:41:58.079 --> 00:42:00.880
然后抬头看，就像是要成为人们的

00:42:00.880 --> 00:42:04.720
在大多数情况下实际上做我们认为错误的本能

00:42:04.720 --> 00:42:06.960
的东西，我们应该让他们远离它

00:42:06.960 --> 00:42:11.680
但是是的，你是对的，就像有很多解释可以进入

00:42:11.680 --> 00:42:18.000
这些事情是在确定要做什么时的一个adl问题

00:42:18.000 --> 00:42:21.839
以您喜欢的方式跳到宇宙的其余部分，您是否可以访问

00:42:21.839 --> 00:42:27.359
到导致您执行此操作的链接

00:42:28.480 --> 00:42:34.880
这是一个非常好的问题，嗯，我认为我编写的接口和ipld

00:42:34.880 --> 00:42:37.520
黄金地段，但如​​果您想走得更远，那一定是区域性的

00:42:37.520 --> 00:42:40.960
使用闭包，但无论如何这似乎是可能的

00:42:40.960 --> 00:42:44.880
所以我问的原因是，如果您要对ipns进行任何操作

00:42:44.880 --> 00:42:53.440
您可能想知道cid不仅是数据，还不仅仅是记录

00:42:54.000 --> 00:42:58.079
对，因为那里有cid和记录

00:42:58.079 --> 00:43:01.599
但是如果关键信息仅存在于cid中而不是记录中，因为

00:43:01.599 --> 00:43:06.160
您正在尝试保存字节，是，是，是，不是，那是

00:43:06.160 --> 00:43:09.760
可能很好，特别是当它那么浅时

00:43:09.760 --> 00:43:12.640
好吧，那是浅浅的，是的，就像一个

00:43:12.640 --> 00:43:17.520
非常简单，好吧，这实际上就像是

00:43:17.520 --> 00:43:19.599
我们一直在争夺一点

00:43:19.599 --> 00:43:26.640
嗯，我们的某些接口对状态如何获取的思考不够

00:43:26.640 --> 00:43:30.000
遍历时携带的数据以及大量数据结构

00:43:30.000 --> 00:43:34.640
实际上就像没有你继承的状态是无法解释的

00:43:34.640 --> 00:43:38.240
使用某些界面会有些棘手，但就像此时

00:43:38.240 --> 00:43:41.839
我很舒服地说，就像大多数数据结构一样

00:43:41.839 --> 00:43:46.880
足够复杂，必须这样做，我可以在dagdb中做到这一点，我认为unix

00:43:46.880 --> 00:43:50.319
巨星也许不会，尽管我认为像你这样设计

00:43:50.319 --> 00:43:53.520
您可以使用其中的任何部分，将其附加到上面就可以了

00:43:53.520 --> 00:43:57.680
另一个图，所以我们在这种情况下正在设计，因此它应该是

00:43:57.680 --> 00:44:01.520
很好，但是我想说的是

00:44:01.520 --> 00:44:04.319
您知道的文件硬币链就像您查看的任何数据库一样

00:44:04.319 --> 00:44:09.599
知道你就是你，不用看猎鹰链

00:44:09.599 --> 00:44:16.160
好吧，别看这个国家了，嗯，是的，我是说你

00:44:16.160 --> 00:44:19.200
您不能指望实际上能够解释一条数据

00:44:19.200 --> 00:44:23.119
通常没有至少部分遍历路径

00:44:23.119 --> 00:44:27.359
是的，我也会这样，这就像

00:44:27.359 --> 00:44:31.280
谢谢大家让我一窥

00:44:31.280 --> 00:44:37.119
嗯，我也想根据你的时代安排，我理想地知道

00:44:37.119 --> 00:44:40.720
嗯，今年年底或明年

00:44:40.720 --> 00:44:46.240
实际获得eric一直在努力的所有很酷的东西

00:44:46.240 --> 00:44:50.400
而喜欢直播和直播ipfs不仅可以

00:44:50.400 --> 00:44:55.839
就像这里，也可能是图同步的事情

00:44:55.839 --> 00:45:00.560
特别是最近像我一样添加了ipfs dag stat

00:45:00.560 --> 00:45:06.000
命令真的很简单，因为就像人们一样

00:45:06.000 --> 00:45:08.240
我如何让您知道笔服务就像

00:45:08.240 --> 00:45:12.160
哦，我需要获取一个对象的大小，然后他们才像使用

00:45:12.160 --> 00:45:19.760
对象状态，就像没有权利，嗯，没权利

00:45:19.760 --> 00:45:24.160
由于各种原因，就像没有，这也阻止了其中的一些

00:45:24.160 --> 00:45:27.839
一些固定服务来自存储任意ipld数据，因为它们

00:45:27.839 --> 00:45:30.800
无法弄清楚向人收取多少费用

00:45:30.800 --> 00:45:34.400
因为他们不知道要占用多少数据

00:45:34.400 --> 00:45:37.920
对，所以他们就像哦，你不是，你不是在标记pb bye

00:45:37.920 --> 00:45:43.599
嗯，好吧，你会这样，是的，是的，这是完全一样的

00:45:43.599 --> 00:45:46.000
就像两个月前我们开始的对话

00:45:46.000 --> 00:45:49.359
我相信与亚光，基本上是的，是的，是的

00:45:49.359 --> 00:45:53.359
是的，我们也很想通知他，你完全可以撒谎

00:45:53.359 --> 00:45:57.440
对对对所以有各种各样的原因，但是

00:45:57.440 --> 00:46:00.800
但是，但是总的来说，

00:46:00.800 --> 00:46:04.400
将它们铺在更高的水平上，我认为这也会有所帮助

00:46:04.400 --> 00:46:08.960
我认为um ipfs有点太二进制了，现在有点

00:46:08.960 --> 00:46:12.319
少一点图书馆，尤其是在旅途中

00:46:12.319 --> 00:46:15.359
javascript在图书馆方面做得更好

00:46:15.359 --> 00:46:20.720
嗯，我们去旁边的叶子是理想的，但我怀疑，特别是如果你

00:46:20.720 --> 00:46:23.520
人们开始想要获取ipfs的库文件

00:46:23.520 --> 00:46:28.960
与所有ipld事物进行交互，因为我认为并且我正在讲话

00:46:28.960 --> 00:46:31.839
和我们在一起时与Dietrich在一起

00:46:31.839 --> 00:46:35.040
嗯，像Microsoft这样的人正在研究

00:46:35.040 --> 00:46:38.160
正在研究离子，不可避免地要进行所有这些对话

00:46:38.160 --> 00:46:41.440
最终就像哦，你们可能想考虑像ipld结构那样

00:46:41.440 --> 00:46:45.040
是不是文件，就像那样，不可避免地如何

00:46:45.040 --> 00:46:48.480
就像所有这些对话一样，这就像您要达到目的

00:46:48.480 --> 00:46:53.040
定制，现在就可以了，如果您将其简化为

00:46:53.040 --> 00:46:56.400
也许文件是不正确的权利，所以像

00:46:56.400 --> 00:46:59.680
是的，只是拿工具接管了

00:46:59.680 --> 00:47:02.960
然后通过fpfs将其推给用户，以便他们可以与之交互

00:47:02.960 --> 00:47:05.920
这样，是的，我认为早期的反馈意见

00:47:05.920 --> 00:47:09.839
我们得到的就像您要建立新的数据结构

00:47:09.839 --> 00:47:13.280
确实是某种代码生成中的一种，就像我们一直在花钱的地方一样

00:47:13.280 --> 00:47:17.520
的时间，但就像dag api和ipfs中的所有东西一样

00:47:17.520 --> 00:47:21.839
应该能够像想要的那样尽快移动，然后

00:47:21.839 --> 00:47:25.040
unix只是v2，您知道那可能会降落

00:47:25.040 --> 00:47:28.160
之所以喜欢cogen的东西，是因为我们将为其提供模式，

00:47:28.160 --> 00:47:30.960
一切热能就像沿着多远

00:47:30.960 --> 00:47:34.640
此时完成的eric百分比

00:47:34.640 --> 00:47:39.920
实际上，我查看了清单，我认为那是70或80或

00:47:39.920 --> 00:47:42.000
是的，功能清单

00:47:42.000 --> 00:47:45.359
内部大概是70或80，剩下的东西是

00:47:45.359 --> 00:47:51.760
少用的东西，但把它变成一个cli

00:47:51.760 --> 00:47:54.240
面对工具，并做一些抛光使其像

00:47:54.240 --> 00:47:57.760
除了不幸的是我以外的任何人都可以使用

00:47:57.760 --> 00:48:01.200
一个很大的事情要做，所以我也没有那个广告，但它正在

00:48:01.200 --> 00:48:05.280
很快就可以了，是的，不要怀疑任何

00:48:05.280 --> 00:48:07.839
这些事情就像没有一件事情像明天发生的那样

00:48:07.839 --> 00:48:11.520
但他们就像哦，他们在雷达上

00:48:11.520 --> 00:48:14.720
您知道我们被忽略了一段时间的事情，因为它就像

00:48:14.720 --> 00:48:17.280
哦，我点燃了彼得p，是所有的大火，所以我们走吧

00:48:17.280 --> 00:48:19.680
做所有脂质的几件事，然后就像

00:48:19.680 --> 00:48:23.520
好吧，酷吧，我们去做ipld的事情

00:48:26.319 --> 00:48:31.040
哦，谢谢你放纵我没问题

00:48:33.119 --> 00:48:39.520
好的，好的，迈克尔，你想谈谈最后吗

00:48:39.520 --> 00:48:46.079
关于他的东西五分钟，我有点累，但嗯

00:48:46.559 --> 00:48:51.520
我是说，是的，所以我们也可以结束会议，对我来说很好

00:48:51.520 --> 00:48:54.640
是的，我正在整理一些幻灯片

00:48:54.640 --> 00:49:00.640
嗯，所有的手和东西，所以嗯，我应该所有这些都应该是

00:49:00.640 --> 00:49:04.079
好多了，很快我的自述文件就很多了

00:49:04.079 --> 00:49:06.640
比以前更好的规格比以前好很多

00:49:06.640 --> 00:49:10.400
您对z感兴趣，我会

00:49:11.119 --> 00:49:16.400
嗯，很抱歉，我接到了电话，ios认为不管是什么

00:49:16.400 --> 00:49:20.720
碰巧你必须接电话

00:49:22.960 --> 00:49:26.640
所以是的，看起来一切都变得更干净了，所以实际上在这一点上

00:49:26.640 --> 00:49:29.280
人们应该只阅读它，然后告诉我它是否有意义

00:49:29.280 --> 00:49:35.440
嗯，是的，基本上就像

00:49:35.440 --> 00:49:38.240
这就是我要说的，今天我已经告诉了几个人

00:49:38.240 --> 00:49:41.119
已经，但是嗯

00:49:41.599 --> 00:49:46.160
难道我们不能像传统压缩那样看待它

00:49:46.160 --> 00:49:50.240
因为压缩器与生成数据的人的关系

00:49:50.240 --> 00:49:55.359
是如此不同，以至于字符串压缩器可以获取任何人的字符串数据

00:49:55.359 --> 00:49:59.040
正确的视频压缩器会获取任何人的视频数据，当您制作一个

00:49:59.040 --> 00:50:02.559
像摄影师这样的视频不喜欢

00:50:02.559 --> 00:50:06.400
像h.264压缩率一样写出来，然后进行调整

00:50:06.400 --> 00:50:09.599
这样的镜头不是视频的制作方法

00:50:09.599 --> 00:50:12.400
这太像一个压缩逻辑太复杂而无法获得

00:50:12.400 --> 00:50:15.119
绕着呃和两个这样的不是

00:50:15.119 --> 00:50:18.400
关系，但数据结构非常不同，例如我们要

00:50:18.400 --> 00:50:22.880
压缩数据结构，而不是产生数据的人

00:50:22.880 --> 00:50:26.720
成为一个积极的参与者，所以这不只是哦，这是一堆

00:50:26.720 --> 00:50:28.960
真正减小尺寸的技巧

00:50:28.960 --> 00:50:33.680
以及表示形式，这就像我们如何将这些功能描述为

00:50:33.680 --> 00:50:38.000
人员，以便他们可以调整其数据结构以匹配

00:50:38.000 --> 00:50:40.400
因为我们现在在海边手工做

00:50:40.400 --> 00:50:44.960
就像我们坐在那儿一样，谈论塞博尔（heborrhe）使用的每一口食物

00:50:44.960 --> 00:50:47.839
表示一个结构，以便我们可以将其降至最小数量

00:50:47.839 --> 00:50:51.359
如果我们真的进行了简单的压缩

00:50:51.359 --> 00:50:54.160
可以剃光更远的技术

00:50:54.160 --> 00:50:57.200
那么我们肯定会把事情砍得更多

00:50:57.200 --> 00:51:01.200
并不是说它不适用于通用数据，就像我说的，你知道我们

00:51:01.200 --> 00:51:04.240
将文件硬币链砍掉了大约8％，那是在我之前

00:51:04.240 --> 00:51:08.720
发现了很多这些新技术，所以我想我会把它弄下来的

00:51:08.720 --> 00:51:12.800
更进一步，我认为什么是呃，需要什么

00:51:12.800 --> 00:51:18.319
被叫出来的是您正在从事的工作是我们的

00:51:18.319 --> 00:51:23.920
数据模型的容器格式，您知道and等

00:51:23.920 --> 00:51:28.240
通常本身相对较胖，所以您专注于

00:51:28.240 --> 00:51:32.000
压缩容器格式和原始原始

00:51:32.000 --> 00:51:35.839
有效负载仍然按原样保留

00:51:35.839 --> 00:51:39.760
如果它是二进制文件，那么大多数情况下已经像您一样

00:51:39.760 --> 00:51:42.640
知道通用的压缩技术，甚至

00:51:42.640 --> 00:51:46.319
写了关于尝试做泄气之类的东西

00:51:46.319 --> 00:51:50.880
是您严格专注于容器

00:51:50.880 --> 00:51:54.240
由于我们的工作方式而产生的元数据

00:51:54.240 --> 00:51:57.520
知道我们如何做才能有收获

00:51:57.520 --> 00:52:01.280
是的，我加入研究团队的语言是结构性的

00:52:01.280 --> 00:52:03.680
压缩，所以我们要压缩结构

00:52:03.680 --> 00:52:06.720
数据表示方式，我们实际上并没有触及价值

00:52:06.720 --> 00:52:10.480
数据um这也使它与其他压缩有很大不同

00:52:10.480 --> 00:52:13.920
方案，因为您可以像这样对它进行双重压缩

00:52:13.920 --> 00:52:18.319
这通常是一个很大的禁忌，但是就像我们将所有可能

00:52:18.319 --> 00:52:20.800
像这里一样压缩到字符串压缩器中

00:52:20.800 --> 00:52:23.839
而且您仍然可以在其上使用字符串压缩器，我们只是在

00:52:23.839 --> 00:52:26.000
下来用于的所有令牌

00:52:26.000 --> 00:52:30.480
结构表示法，嗯，是的，我在那里

00:52:30.480 --> 00:52:32.640
就像规范中几乎没有记载的那样，因为我

00:52:32.640 --> 00:52:36.240
还没有实现它，但是那个桌子

00:52:36.240 --> 00:52:41.119
压缩真是不可思议，就像那样，它将摆脱所有标记

00:52:41.119 --> 00:52:47.839
嗯，但是很酷

00:52:52.400 --> 00:52:57.119
没有别的了，所以我关闭了会议，再次见到大家

00:52:57.119 --> 00:53:08.640
下周九月再见大家

