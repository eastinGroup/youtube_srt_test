WEBVTT
Kind: captions
Language: zh-Hans

00:00:14.920 --> 00:00:18.480
也是想念克里斯，但我想他可能有一个

00:00:18.480 --> 00:00:22.480
要做的事欢迎大家参加本周的ipld

00:00:22.480 --> 00:00:29.840
同步会议时间为2020年10月3日，每周我们都会讨论

00:00:29.840 --> 00:00:35.360
过去一周我们一直在研究的东西，然后是um

00:00:35.360 --> 00:00:38.960
可能，然后我们再看一下那个东西

00:00:38.960 --> 00:00:42.399
是的，如果有任何行动项目，就在议程上

00:00:42.399 --> 00:00:49.760
嗯，很酷，嗯，是的，我本周开始我自己

00:00:49.760 --> 00:00:53.760
我实际上所以我必须带走，但是

00:00:53.760 --> 00:00:57.600
当我真的是伊波利时，我实际上有足够的时间来工作这部影片

00:00:57.600 --> 00:01:02.480
最值得注意的东西

00:01:02.480 --> 00:01:09.280
当前在库中的最后一个Marty哈希值

00:01:09.280 --> 00:01:14.400
称为微小的多哈希，但计划肯定是将其上游

00:01:14.400 --> 00:01:17.119
有点像商定的，所以它将上游

00:01:17.119 --> 00:01:20.479
他们还在，只是时间问题，我想继续改善

00:01:20.479 --> 00:01:27.200
他们的文档有点嗯，是的，修复了一些小问题，但是嗯

00:01:27.200 --> 00:01:32.320
应该真的很快，并在多格式的东西

00:01:32.320 --> 00:01:36.000
javascript还有很多事情在进行，因为嗯

00:01:36.000 --> 00:01:40.479
疼痛的大脑目前正在努力移动代码

00:01:40.479 --> 00:01:46.880
从使用节点缓冲区到在您中使用um

00:01:46.880 --> 00:01:50.240
八个数组代替，这当然被称为

00:01:50.240 --> 00:01:56.000
对于整个api和所有库来说，这是一个重大变化，因为我们

00:01:56.000 --> 00:02:01.759
真的，是的，然后有8个阵列移动并移出

00:02:01.759 --> 00:02:06.079
对于node.js用户而言，这并不坏，因为

00:02:06.079 --> 00:02:11.680
node.js缓冲区也是un8数组，因此您至少可以传递一个缓冲区，但是

00:02:11.680 --> 00:02:15.920
您将得到一个新的8阵列，因此如果您想再次使用它作为一个

00:02:15.920 --> 00:02:20.560
缓冲，您必须自己进行转换，但这仍在进行中，我主要回顾

00:02:20.560 --> 00:02:25.360
这个东西嗯，但我实际上有一个要求

00:02:25.360 --> 00:02:30.800
认为这是因为在jscid上有一个开放的pr，具有重大更改

00:02:30.800 --> 00:02:34.319
对此表示赞赏是一件好事

00:02:34.319 --> 00:02:39.840
是的，我稍后会在笔记中发布它，因为我基本上认为

00:02:39.840 --> 00:02:41.920
至少我想让ipald竖起大拇指

00:02:41.920 --> 00:02:46.319
团队，您想像是阻止他进行其他更改，所以它

00:02:46.319 --> 00:02:51.200
如果您当天也可以这样做，那会很棒，因为嗯

00:02:51.200 --> 00:02:55.040
我告诉他明天是他的日子，所以他在英国

00:02:55.040 --> 00:02:58.640
嗯，他可能将不得不获得批准

00:02:58.640 --> 00:03:04.800
因为我不希望有任何主要的阻碍因素，嗯，很酷，嗯，仅此而已

00:03:04.800 --> 00:03:11.680
我有它正在将cid点缓冲区重命名为cid点字节

00:03:11.680 --> 00:03:17.599
是的，那会很受伤吗？

00:03:17.599 --> 00:03:20.319
因为我们认为无论如何我们都会做出重大改变，

00:03:20.319 --> 00:03:27.440
这样真的真的很快就炸毁了，嗯，因为如果你只是打

00:03:27.440 --> 00:03:31.840
缓冲的东西，所以基本上就可以了

00:03:31.840 --> 00:03:35.680
否则就改变了，这是一个巨大的改变，因为它

00:03:35.680 --> 00:03:39.680
不再返回缓冲区，所以基本上问题是

00:03:39.680 --> 00:03:43.760
缓冲区，缓冲区属性将不再返回缓冲区，而是

00:03:43.760 --> 00:03:47.120
你是一个数组了吗

00:03:48.400 --> 00:03:51.680
我会买的，我会买的，就像处理了这个

00:03:51.680 --> 00:03:55.920
过去像这样的值类型更改，最好是

00:03:55.920 --> 00:03:59.360
能够给人们带来错误而不是最有效

00:03:59.360 --> 00:04:03.599
在他们尝试访问不存在的方法之前

00:04:03.599 --> 00:04:06.640
最好是不，不，我是说我们应该

00:04:06.640 --> 00:04:10.879
移动js多种格式的ID以使用字节，然后像

00:04:10.879 --> 00:04:13.200
并在所有方面应对这种变化

00:04:13.200 --> 00:04:15.519
难度格式的东西，因为我们使用点缓冲区，即使它是

00:04:15.519 --> 00:04:19.759
统一数组好吧

00:04:19.840 --> 00:04:24.720
好吧，如果您确定要担心的话，请放

00:04:24.720 --> 00:04:29.360
在公关上发布，然后我们也可以

00:04:30.400 --> 00:04:33.440
播放它，所以它不像呃，就像您必须同意

00:04:33.440 --> 00:04:36.560
你别无选择，就像我要你进来

00:04:36.560 --> 00:04:41.919
对此的投入，是的，要使之成为现实，是的，我评论了，我认为我们应该

00:04:41.919 --> 00:04:44.880
添加一些其他属性，这些属性将使将来的迁移变得更加容易

00:04:44.880 --> 00:04:47.680
嗯，但是总的来说这是一个很好的

00:04:47.680 --> 00:04:53.280
改变，我们应该这样做吧，好吧，嗯

00:04:53.280 --> 00:04:57.600
哦，所以我们也可以添加整数代码属性

00:04:57.600 --> 00:05:03.520
是的，嗯，他们可以接受并在构造函数中接受它们

00:05:03.520 --> 00:05:08.639
是的，如果我们在中断内容时得到一首歌曲，现在就这样做是个好主意

00:05:08.639 --> 00:05:12.479
是的，而且两者都可以工作一段时间，因此人们可以迁移一点

00:05:12.479 --> 00:05:16.240
更像是渐渐的，是的，我认为

00:05:16.240 --> 00:05:20.400
我认为um alex将希望使此更改尽可能小，但我

00:05:20.400 --> 00:05:23.199
同意我们，我同意我们应该介绍那些

00:05:23.199 --> 00:05:25.600
以及，所以我想权衡将是这样

00:05:25.600 --> 00:05:32.960
你看是否对字节变化不满意，而他对字节数不满意

00:05:32.960 --> 00:05:36.400
其他的改变我们都是妥协的

00:05:36.400 --> 00:05:39.280
那就是那

00:05:44.400 --> 00:05:48.530
[笑声]

00:05:50.639 --> 00:05:57.520
我会确定的告诉你，但是，嗯，很酷

00:05:57.520 --> 00:05:59.759
嗯

00:06:03.199 --> 00:06:07.520
很酷，我名单上的下一个是正确的

00:06:07.600 --> 00:06:11.120
好的，嗯

00:06:11.759 --> 00:06:16.720
对，所以我这周的大部分时间都花在了AMT上

00:06:16.720 --> 00:06:21.280
嗯，这是在做什么

00:06:21.280 --> 00:06:25.360
以及为它编写文档的含义是什么

00:06:25.360 --> 00:06:31.199
进行讨论，提交一些错误报告和一些拉取请求

00:06:31.199 --> 00:06:37.039
只是为了解决一些非常小的事情，嗯，还没有完全完成

00:06:37.039 --> 00:06:39.199
我是因为我们没有为此的规格

00:06:39.199 --> 00:06:45.759
这是我最终要在事物本身中编写规范样式文档

00:06:45.759 --> 00:06:49.680
但我也说过，我可能会为此写一个规范文档，所以

00:06:49.680 --> 00:06:53.759
嗯，我还是在不断努力

00:06:53.759 --> 00:06:58.720
文档嗯，我一直在对人们说

00:06:58.720 --> 00:07:03.120
这一问题的权衡远比一而就有趣

00:07:03.120 --> 00:07:06.960
你和你会产生更大的影响

00:07:06.960 --> 00:07:13.039
通过调整这个um的参数来实现um，这样您就可以将其真正推入

00:07:13.039 --> 00:07:16.400
反方向取决于参数和

00:07:16.400 --> 00:07:20.160
输入类型和用法样式，而大麻要宽容得多

00:07:20.160 --> 00:07:24.240
因为你有哈希来随机化事物，而这个你

00:07:24.240 --> 00:07:26.480
知道您可以滥用它，并且

00:07:26.480 --> 00:07:30.240
[音乐]做成一些形状奇特的树，

00:07:30.240 --> 00:07:33.919
还有很多很多小块，如果你

00:07:33.919 --> 00:07:38.880
确实确实有稀疏的数据um非常稀疏，那么您可以有很多

00:07:38.880 --> 00:07:42.880
小块和嗯，我认为这值得记录

00:07:42.880 --> 00:07:45.199
我正在尝试以一种非常清晰的方式做到这一点，以便

00:07:45.199 --> 00:07:48.240
忙文件硬币的人可以阅读和理解

00:07:48.240 --> 00:07:51.599
考虑一下他们正在做的取舍，因为我知道他们在做

00:07:51.599 --> 00:07:58.560
现在担心链的大小，所以要完成它

00:07:58.560 --> 00:08:01.919
嗯，现在埃里克，我一直在谈论

00:08:01.919 --> 00:08:08.960
一个用于交叉实施的um测试夹具系统um

00:08:08.960 --> 00:08:13.199
去年我在议程上进行的工作是

00:08:13.199 --> 00:08:16.400
它首先进入了汽车和拉链车

00:08:16.400 --> 00:08:19.840
嗯，从来没有回到它，但现在有了这个

00:08:19.840 --> 00:08:25.440
汉普顿amt工作嗯，firecoin需要这个，因为

00:08:25.440 --> 00:08:31.599
他们有这些实施者在做事情，还有一些信心问题

00:08:31.599 --> 00:08:35.200
与代码及其可移植性和

00:08:35.200 --> 00:08:40.479
安全实施事物的能力，所以我们

00:08:40.479 --> 00:08:46.240
我们为这个东西规划了基本框架

00:08:46.240 --> 00:08:48.560
像我们如何把这东西放在一起

00:08:48.560 --> 00:08:54.640
嗯，想出了一个非常有趣的事情，可以相当公平地拍摄

00:08:54.640 --> 00:08:58.640
基本的嗯，但是应该相当有用

00:08:58.640 --> 00:09:03.279
也许在某个时候与volca同步是值得的

00:09:03.279 --> 00:09:08.080
嗯，考虑是否还可以很快完成防锈工作

00:09:08.080 --> 00:09:11.600
嗯，所以想法是我们有这些简单的装置

00:09:11.600 --> 00:09:15.600
嗯，每个案例每个夹具都有一个文件

00:09:15.600 --> 00:09:20.640
并且您可以知道将其选中并针对您的实现运行它，但是

00:09:20.640 --> 00:09:27.600
您也可以使用它来了解调试事物中断的过程

00:09:27.600 --> 00:09:31.279
是的，关于这件事，有很多有趣的功能

00:09:31.279 --> 00:09:36.800
因为这是最小的，所以我一直在想

00:09:36.800 --> 00:09:40.480
我们谈论了这一点，并试图清理甲板以到达

00:09:40.480 --> 00:09:45.839
这是我当时遇到的问题之一，是在重访时

00:09:45.839 --> 00:09:48.880
我正在做汽车的工作

00:09:48.880 --> 00:09:52.480
javascript汽车库迁移到js

00:09:52.480 --> 00:09:56.640
 ii目前暂时放下的多种格式

00:09:56.640 --> 00:10:02.720
我需要完成它，所以我回去开始看它是什么

00:10:02.720 --> 00:10:08.160
想要更多地利用迈克尔的esm

00:10:08.160 --> 00:10:14.880
迁移到那个嗯做的堆栈

00:10:14.880 --> 00:10:19.200
但这就是我一直在回避的整个兔子洞

00:10:19.200 --> 00:10:25.920
所以现在我无法避免它，是的，然后只是一堆

00:10:25.920 --> 00:10:30.160
一路上的小冒险，以及其他不断出现的事物，

00:10:30.160 --> 00:10:33.839
需要处理的是不值得逐项列出的

00:10:33.839 --> 00:10:36.560
那是我

00:10:37.680 --> 00:10:43.279
关于该测试框架的快速问题是你们

00:10:43.279 --> 00:10:48.880
考虑所有不愉快的路径测试或繁重的通过

00:10:48.880 --> 00:10:55.920
大部分如此，所以现在我们专注于um

00:10:55.920 --> 00:10:59.040
最低生存

00:10:59.279 --> 00:11:05.519
事情，所以我们没有太多的消极想法

00:11:05.519 --> 00:11:11.440
更专注于积极的um，而我们最初正在致力于

00:11:11.440 --> 00:11:15.440
假设你不是，那不会取代

00:11:15.440 --> 00:11:19.920
您对所有事物的所有测试，都集中在一个狭窄的用例上

00:11:19.920 --> 00:11:24.560
你的东西有一些基本的测试，涵盖了它的

00:11:24.560 --> 00:11:29.360
它的共同点是您在实施过程中关心的事情

00:11:29.360 --> 00:11:31.680
可能还会进行一些负面测试

00:11:31.680 --> 00:11:38.079
嗯，这是这个主要用例

00:11:38.079 --> 00:11:40.160
是我没有提到这个而是多块

00:11:40.160 --> 00:11:42.640
数据结构是我们正在考虑的

00:11:42.640 --> 00:11:46.720
我可以看到它在其他类型的ipld应用程序中的效用

00:11:46.720 --> 00:11:52.800
但实际上，您有一件事情需要在非常

00:11:52.800 --> 00:11:57.519
特定的方式并具有非常稳定的结果，因此您可以执行此操作

00:11:57.519 --> 00:12:01.600
反对它并执行这些步骤，您将获得

00:12:01.600 --> 00:12:07.600
这些结果以及您可以测试的结果

00:12:07.600 --> 00:12:12.079
错误的用例，以便您可以找到优势并发挥到极致

00:12:12.079 --> 00:12:18.240
并查看在作为测试人员的情况下您发现该问题的情况

00:12:18.240 --> 00:12:23.760
这个东西需要测试它的边缘是什么，所以例如我们

00:12:23.760 --> 00:12:26.880
有了这个汉普特姆，我们将有一些

00:12:26.880 --> 00:12:29.680
无论如何，对于我的javascript实现，我们都可以

00:12:29.680 --> 00:12:36.079
拉入并说出使用这些参数以及这些操作

00:12:36.079 --> 00:12:39.360
你应该得到它的这个反常的版本

00:12:39.360 --> 00:12:44.320
它应该可以处理它，嗯，那里有做事的空间

00:12:44.320 --> 00:12:48.320
像我们一样，我们希望您能够产生

00:12:48.320 --> 00:12:52.480
如果您将其推到目前位置会出错，但是我们还没有考虑足够多

00:12:52.480 --> 00:12:56.560
关于错误的情况，但是最重要的是要得到这个东西

00:12:56.560 --> 00:12:59.200
工作，然后也许回来再开始

00:12:59.200 --> 00:13:02.160
考虑我们如何添加一些负面因素

00:13:02.160 --> 00:13:06.160
是的，我喜欢很难测试一些压力情况

00:13:06.160 --> 00:13:10.720
以及一些更具体的细节，而没有真正具体实现的细节

00:13:10.720 --> 00:13:14.160
而且很难喜欢使用跨语言无法测试错误条件

00:13:14.160 --> 00:13:16.000
就像跨语言一样

00:13:16.000 --> 00:13:20.800
真的很困难，不是没有可能，你甚至不能测试这种突变

00:13:20.800 --> 00:13:22.880
操作应在此产生这些块

00:13:22.880 --> 00:13:26.399
顺序，因为您假设该实现会在它们得到时生成块

00:13:26.399 --> 00:13:29.920
创建的并不是所有实现都必须工作的方式

00:13:29.920 --> 00:13:33.440
嗯，这主要是像我给你这些操作来做

00:13:33.440 --> 00:13:36.639
这是树的新根散列吗

00:13:36.639 --> 00:13:40.720
对，就是那台机器，或者如果我给你这棵数据树

00:13:40.720 --> 00:13:44.160
并告诉您对什么是

00:13:44.160 --> 00:13:47.120
像那些树是那些真的很好，值得测试

00:13:47.120 --> 00:13:50.160
并获得大多数东西，但一些疯狂的东西

00:13:50.160 --> 00:13:53.680
是必须要更多的实现特定的，是的，像我这样

00:13:53.680 --> 00:13:56.720
JavaScript的东西，我测试加载和保存的数量

00:13:56.720 --> 00:13:59.760
从数据存储中来，那不是您想做的事情

00:13:59.760 --> 00:14:03.279
在整个实施过程中，因为每个人都会做不同的事情

00:14:03.279 --> 00:14:06.560
所以您只想测试产生的结果是

00:14:06.560 --> 00:14:10.160
就是这样

00:14:13.120 --> 00:14:19.760
好吧，我名单上的下一个是彼得，是的，所以再等一周

00:14:19.760 --> 00:14:23.920
大部分是燃烧猎鹰的东西，只有ipod相关

00:14:23.920 --> 00:14:27.120
部分是，我开始用一点帮助蜡烛

00:14:27.120 --> 00:14:32.560
各种数据如何融合的猎鹰规格

00:14:32.560 --> 00:14:35.839
存储方面，实际上我们有更多的会议

00:14:35.839 --> 00:14:39.600
他，因为我原来有很多话要说

00:14:39.600 --> 00:14:44.399
嗯，在我有机会的同时，把这些东西挑出来

00:14:44.399 --> 00:14:51.600
我开始研究呃，什么是模块

00:14:51.600 --> 00:14:54.959
匕首的chanker部分看起来像呃

00:14:54.959 --> 00:15:00.800
并在周末花费了一些时间来尝试编译不同的东西，

00:15:00.800 --> 00:15:03.600
嗯，结合黄金不是

00:15:03.600 --> 00:15:06.560
有点胖，但实际上比我小得多

00:15:06.560 --> 00:15:11.600
预期是诚实的

00:15:11.600 --> 00:15:15.680
嗯，我想尝试的另一件事是

00:15:15.680 --> 00:15:21.480
与贾妮丝交谈我们的合作方式是怎样的

00:15:21.480 --> 00:15:26.320
[音乐]计算产生的时间和时间

00:15:26.320 --> 00:15:30.240
努力将呃哑滴添加到实际

00:15:30.240 --> 00:15:35.360
验证文件，嗯，从为什么这是一部分开始

00:15:35.360 --> 00:15:39.360
我们现在使用的速度太慢了，想看看它到底在做什么

00:15:39.360 --> 00:15:43.440
要实施它，要知道它并没有像正确的那样慢

00:15:43.440 --> 00:15:50.240
现在，实际上很有可能像

00:15:50.240 --> 00:15:56.240
比rustville的运行速度快10倍我还没有

00:15:56.240 --> 00:16:00.560
嗯，看起来像是在做这个

00:16:00.560 --> 00:16:04.160
以任何方式逮捕友善，这只是一次探索

00:16:04.160 --> 00:16:12.720
是的，然后要针对一些目标特定的问题，与流式传输有关

00:16:12.720 --> 00:16:19.519
也很奇怪，我需要忍受一个例子，也许埃里克看一下

00:16:19.519 --> 00:16:26.079
呃，但是当我有时间重新思考的时候，这也是呃

00:16:26.079 --> 00:16:29.920
猎鹰链和测试交易和东西

00:16:29.920 --> 00:16:32.639
这就是我的全部

00:16:34.000 --> 00:16:40.880
谢谢你，托尼·霍迪，你好吗？

00:16:40.880 --> 00:16:44.000
东西uh去中心化标识符文档um

00:16:44.000 --> 00:16:49.120
我设法得到一个关于seabor（特别是dagsebor）的小节

00:16:49.120 --> 00:16:52.800
ipld中有一些关于um的工作

00:16:52.800 --> 00:16:57.120
这些反馈是如何写的呢？

00:16:57.120 --> 00:17:00.399
反映了很多笨拙的钻孔约束，包括um

00:17:00.399 --> 00:17:03.759
确定规范的seabor和

00:17:03.759 --> 00:17:07.600
键作为文本，所以现在有很多关于如何优化的讨论

00:17:07.600 --> 00:17:11.120
以及更多使键更简洁的int

00:17:11.120 --> 00:17:16.079
 cbor的功能，而不必一定要红色单独的注册表

00:17:16.079 --> 00:17:19.439
所以有很多关于um sebor ld um的话题

00:17:19.439 --> 00:17:25.839
带有外部uh词典，用于将键映射到

00:17:25.839 --> 00:17:28.880
特质那里有一个巨大的漏洞

00:17:28.880 --> 00:17:32.880
就像描述贾森ld的可变上下文一样

00:17:32.880 --> 00:17:36.880
我对此有重大保留，这是本周在ietf上谈到的

00:17:36.880 --> 00:17:41.840
sibor会话，我正在尝试实际做一些

00:17:41.840 --> 00:17:46.320
使用将at触点扩展到

00:17:46.320 --> 00:17:51.039
包括一个dag seabor那里的dagsy蛀虫实际上

00:17:51.039 --> 00:17:58.160
是简明扼要的成文本字段之间的映射，但是

00:17:58.160 --> 00:18:01.679
再次，我欢迎任何反馈，嗯，他们给了我很多建议

00:18:01.679 --> 00:18:05.440
据我的那部分说的是呃

00:18:05.440 --> 00:18:09.760
嗯，这不在左字段，它没有足够的实现

00:18:09.760 --> 00:18:13.360
就像只是海带，像标签一样

00:18:13.360 --> 00:18:16.799
嗯，您实际上可以使用标签很好地表示出来

00:18:16.799 --> 00:18:20.880
这是我没有发明任何新的加密技术

00:18:20.880 --> 00:18:27.760
呃dagsebor的呃seaboard标签42是向戴安娜（diana）注册的

00:18:27.760 --> 00:18:29.840
它在那里，实际上包括电池

00:18:29.840 --> 00:18:33.360
嗯，主要是我觉得好像很多

00:18:33.360 --> 00:18:36.960
公司关于正在进行的实施的争执以及

00:18:36.960 --> 00:18:43.120
呃，特别感兴趣，所以我想我确实需要更新我给的例子

00:18:43.120 --> 00:18:46.000
在文档中要在seabor部分中有一个

00:18:46.000 --> 00:18:49.360
非常清晰的cose密钥格式，但确实可以解决

00:18:49.360 --> 00:18:52.880
dag sebor与特定dag cos a之间的映射

00:18:52.880 --> 00:18:57.280
用适当的格式将其格式化为纯cos

00:18:57.280 --> 00:19:02.240
标签，所以我现在就在锈中编写样式库来做到这一点

00:19:04.799 --> 00:19:08.080
酷约翰尼，你在乡亲们中循环吗

00:19:08.080 --> 00:19:14.320
呃，阅读《 dag cose jose Codex》，不，我想，呃，有几个

00:19:14.320 --> 00:19:17.280
不同的人，我想，我当然是纺织集团

00:19:17.280 --> 00:19:20.400
正在使用这个，然后我认为是三个盒子的人

00:19:20.400 --> 00:19:23.120
但这就像基督教徒拳头一样，我实际上已经在谈论这个

00:19:23.120 --> 00:19:26.480
几年前在重新启动的信任网络上一起写了一篇论文

00:19:26.480 --> 00:19:29.760
所以我认为与我们有很多相似之处

00:19:29.760 --> 00:19:34.799
嗯，嗯，我想主要是它进入了嗯

00:19:34.799 --> 00:19:38.640
互操作性的标准和语义，我认为

00:19:38.640 --> 00:19:42.559
确保我们在解决问题的方式上都在同一个页面上

00:19:42.559 --> 00:19:46.080
好的，嗯，我实际上是要求有一个

00:19:46.080 --> 00:19:49.600
在我现在找不到的线程um中与他们通话

00:19:49.600 --> 00:19:53.440
我想将您添加到youtuber um中，但是

00:19:53.440 --> 00:19:57.520
是的，嗯，我想澄清我

00:19:57.520 --> 00:20:01.120
开始，我开始质疑我们过去的方式

00:20:01.120 --> 00:20:04.240
考虑表示形式，数据模型实际上是正确的事情

00:20:04.240 --> 00:20:07.360
在这里可能还有其他我们想做的事情

00:20:07.360 --> 00:20:10.640
所以我真的很想听听他们如何使用格式的更多信息

00:20:10.640 --> 00:20:14.720
以及我们在挖掘之前如何在野外使用

00:20:14.720 --> 00:20:18.320
是的，我想我只是以为基本上是dag coz

00:20:18.320 --> 00:20:21.600
困难的事情就像是它会导致

00:20:21.600 --> 00:20:25.360
一个无环图，我认为这很棘手

00:20:25.360 --> 00:20:29.120
你如何证明它是一部非文图

00:20:30.559 --> 00:20:38.640
是的，那将是更多的阴谋，是的，我的意思是

00:20:40.000 --> 00:20:42.400
是的，我不知道您将如何表示它，但是如果您可以签署

00:20:42.400 --> 00:20:44.799
cid然后您知道它正在签名

00:20:44.799 --> 00:20:48.400
是的，是我获取论文的方式，我之前向你们展示过

00:20:48.400 --> 00:20:52.320
从被取消的布宜诺斯艾利斯的重新启动橡胶信托基金中

00:20:52.320 --> 00:20:59.840
是我基本上在标签98 cos中使用了签名，而您基本上使用了标签

00:20:59.840 --> 00:21:03.760
42 as ab

00:21:03.760 --> 00:21:07.760
字符串，它是ac id，但是有点多余

00:21:07.760 --> 00:21:12.720
因为您在“算法”部分中，所以要说的是在sha-2256上说

00:21:12.720 --> 00:21:18.320
使用ed edsa签名，但随后的cid实际上具有冗余

00:21:18.320 --> 00:21:24.000
信息，它是一个基本的前缀，加上一个sha-2256，因此

00:21:24.000 --> 00:21:28.559
这是双重编码，我想我也不确定

00:21:28.559 --> 00:21:33.840
有效负载现在该有效负载可以持续多长时间，例如55

00:21:33.840 --> 00:21:37.200
字节之类的东西，所以您要进行256加震撼

00:21:37.200 --> 00:21:41.120
你知道前面所有那些不同的单独字节，所以我觉得嗯

00:21:41.120 --> 00:21:44.320
一致性就是人们会喜欢的适当的东西吗？

00:21:44.320 --> 00:21:50.559
了解该cid签名了cos一个uh签名，标签98指向一个

00:21:50.559 --> 00:21:54.240
有效载荷和标签42就是人们很酷

00:21:54.240 --> 00:21:58.159
明白，是的，我明白你在说什么

00:21:58.159 --> 00:22:02.559
您使用标记对二进制文件进行签名，还是在发送二进制文件之前

00:22:02.559 --> 00:22:07.919
标记为是，是的，就像现在的CID，我正在寻找

00:22:07.919 --> 00:22:13.200
完整的CID，其中包括所有的多基础信息，我的意思是您应该以为您

00:22:13.200 --> 00:22:16.159
是的，应该像你签的那样吗？

00:22:16.159 --> 00:22:19.120
签名dag，除非您发送cid（如果您正在签名多哈希）

00:22:19.120 --> 00:22:23.280
只是签名一些数据，直到它没有任何意义

00:22:23.280 --> 00:22:27.520
你把cid放在我们实际拥有的价值上

00:22:27.520 --> 00:22:31.840
我认为我们已经在多编解码器表中添加了条目，或者也许它们是

00:22:31.840 --> 00:22:36.080
只是公关公司，但我认为他们在那里合并

00:22:36.080 --> 00:22:40.400
是不是cid基本上会支付呃

00:22:40.400 --> 00:22:43.679
有效负载的哈希值加上其签名作为单个

00:22:43.679 --> 00:22:49.039
就像27个字节或类似的东西

00:22:49.039 --> 00:22:53.679
正确的编解码器，所以有几个公关，但那个和

00:22:53.679 --> 00:22:55.840
合并了多种格式，只是添加了

00:22:55.840 --> 00:22:58.880
整数，但是还有开放的公关，我们仍然

00:22:58.880 --> 00:23:02.960
在ipld中谈论规格说明

00:23:02.960 --> 00:23:08.159
实际的代码实际上是um和类似的代码

00:23:08.159 --> 00:23:11.280
未解决的问题

00:23:12.240 --> 00:23:15.679
我只是提起它，因为有人已经这样做了

00:23:15.679 --> 00:23:18.159
哦，好吧，另外一个系统，它是

00:23:18.159 --> 00:23:22.640
该表中已存在多编解码器表

00:23:22.640 --> 00:23:26.080
我相信，所以我将不得不在我们交谈时

00:23:26.080 --> 00:23:30.159
我很想看看我实际上不知道那件事

00:23:33.280 --> 00:23:38.320
好的，好的，谢谢[音乐]

00:23:38.320 --> 00:23:41.760
接下来是埃里克

00:23:43.200 --> 00:23:47.279
所以我得到了更多的代码生成新闻，我们现在可以生成

00:23:47.279 --> 00:23:51.120
具有元组表示的结构

00:23:51.120 --> 00:23:54.320
有点令人兴奋，因为那是真正的代表之一

00:23:54.320 --> 00:23:58.240
通常由对串行数据大小敏感的人使用

00:23:58.240 --> 00:24:02.159
看着你的Filecoin和Lotus人，他们几乎都在用它们

00:24:02.159 --> 00:24:06.559
到处都是99的代码，所以这是一个很重要的代码

00:24:06.559 --> 00:24:10.400
它们的使用量um，特别是出现在我们已经使用的一些大麻材料中

00:24:10.400 --> 00:24:13.279
一直在看我们上周提到的内容，所以我们

00:24:13.279 --> 00:24:17.679
在这个世界上偷看那里的工会

00:24:17.679 --> 00:24:21.840
代表性也大约是85，我希望很快就会出来，但需要

00:24:21.840 --> 00:24:25.600
像往常一样多一点的错误处理实际上是

00:24:25.600 --> 00:24:31.120
最棘手的部分，任何类型的惊喜

00:24:31.120 --> 00:24:34.159
我们已经知道了一段时间了，但是我们

00:24:34.159 --> 00:24:37.200
像我们想要的那样彻底详细地指定它

00:24:37.200 --> 00:24:41.360
几个月前，事实证明，这比我们容易

00:24:41.360 --> 00:24:44.640
认为这只是一种联合，仅此而已

00:24:44.640 --> 00:24:47.760
事实证明，鞭打一个拥有

00:24:47.760 --> 00:24:50.799
所有基本类型，然后添加地图类型

00:24:50.799 --> 00:24:56.960
那只是任何人到任何作曲家的地图，就像

00:24:56.960 --> 00:25:00.080
当然，您在该定义中有一个循环

00:25:00.080 --> 00:25:06.000
但是事实证明还不错，所以我做了一些代码原型

00:25:06.000 --> 00:25:09.279
喷射它，它只是有点工作，所以这是一个非常

00:25:09.279 --> 00:25:11.919
美好的惊喜

00:25:12.480 --> 00:25:16.159
将来可能还有更多工作要做

00:25:16.159 --> 00:25:21.760
嗯，某种形式出现的东西是

00:25:22.400 --> 00:25:25.840
我们可能需要常规配置来确定何时使用指针

00:25:25.840 --> 00:25:30.480
汇编程序嵌入在其他汇编程序类型中

00:25:30.480 --> 00:25:35.120
概括节点汇编器是gli pld prime中的接口

00:25:35.120 --> 00:25:38.559
一个节点的汇编器通常会为所有子代嵌入汇编器

00:25:38.559 --> 00:25:42.960
类型，以便您可以预分配一个大的内存，其中包含所有

00:25:42.960 --> 00:25:46.080
您将需要进行的所有房间的数据组装匹配

00:25:46.080 --> 00:25:48.400
以及在您处于中间状态时所需的所有状态跟踪

00:25:48.400 --> 00:25:51.200
咀嚼有效性检查等

00:25:51.200 --> 00:25:54.400
因此，通过嵌入所有这些东西，我们得到了一个巨大的分配

00:25:54.400 --> 00:25:59.520
它运行很快，但这意味着如果您具有循环类型

00:25:59.520 --> 00:26:02.559
任何定义都可以是包含以下内容的联合

00:26:02.559 --> 00:26:06.000
称为map的值具有称为unit或

00:26:06.000 --> 00:26:10.960
如果您嵌入汇编器，则任何周期

00:26:10.960 --> 00:26:13.840
装配图中的任何装配图中的任何装配

00:26:13.840 --> 00:26:16.159
从地图上，这表明您要

00:26:16.159 --> 00:26:21.360
必须保留一个无限大的实验室内存，这当然不会编译

00:26:21.360 --> 00:26:25.919
所以有时候我们需要说我不想嵌入这个汇编器

00:26:25.919 --> 00:26:28.960
确实希望它成为指针电话

00:26:28.960 --> 00:26:32.960
现在有一些情况无论如何都会发生

00:26:32.960 --> 00:26:37.039
特别是它恰好在联合中以及在配置它们时发生

00:26:37.039 --> 00:26:42.000
在内部使用此内存布局，但这有点巧合

00:26:42.000 --> 00:26:45.279
解决方案，它不应该是唯一的解决方案，所以

00:26:45.279 --> 00:26:48.159
一些功能可能在那里工作，但没有任何阻碍

00:26:48.159 --> 00:26:50.320
它

00:26:50.840 --> 00:26:53.360
很快就看了一下测试夹具的东西

00:26:53.360 --> 00:26:59.360
有点像罗德已经在谈论呃迈克尔·拜姆

00:26:59.360 --> 00:27:02.559
我们一直在悄悄地想着会是什么样子

00:27:02.559 --> 00:27:07.760
实施一个新的汉普顿，并去使用其中一些

00:27:07.760 --> 00:27:11.039
但这还为时过早，所以我们要看看情况如何

00:27:11.039 --> 00:27:15.200
也许我稍后再讨论，但今天可能不多

00:27:15.200 --> 00:27:17.919
就是这样

00:27:18.880 --> 00:27:25.279
很酷，我接下来要起来了，是的，所以最重要的是

00:27:25.279 --> 00:27:28.399
文档的进度，因此还有更多的东西

00:27:28.399 --> 00:27:32.640
javascript堆栈教程在um中变得越来越锁定

00:27:32.640 --> 00:27:35.440
现在其他人需要做的事情

00:27:35.440 --> 00:27:37.840
我将其移至标杆所写的所有架构文档上

00:27:37.840 --> 00:27:42.080
以及所有的配置资料和面试，我花了一段时间才弄清楚了那些

00:27:42.080 --> 00:27:46.159
侧边栏ron是一种怪异的格式，可以查看这些

00:27:46.159 --> 00:27:50.640
嗯，但现在一切都很好嗯，是的

00:27:50.640 --> 00:27:55.279
码头真的很近，我现在真的需要其他人的捐助

00:27:55.279 --> 00:27:59.919
人们在我可以继续前进之前，然后我花了星期四和星期五

00:27:59.919 --> 00:28:06.399
嗯，我花了很多时间清理dagdb，然后展示给了

00:28:06.399 --> 00:28:10.399
嗯，还有很多人

00:28:10.399 --> 00:28:13.679
我忘记了多少代码完整性和

00:28:13.679 --> 00:28:16.640
它很多都起作用，所以人们开始在其中使用它

00:28:16.640 --> 00:28:19.039
戳一下我现在确定有错误，但是它们是

00:28:19.039 --> 00:28:20.960
现在我们找不到的那种错误

00:28:20.960 --> 00:28:24.799
除非使用它，我的意思是说覆盖了100个代码，没有了

00:28:24.799 --> 00:28:30.720
找出这种方式的错误，是的，看起来还不错

00:28:30.720 --> 00:28:33.760
到目前为止，反馈一直非常积极

00:28:33.760 --> 00:28:37.760
ii确实向卡森展示了一些东西，他说

00:28:37.760 --> 00:28:41.440
他们在线程v2中所做的很多事情实际上已经存在

00:28:41.440 --> 00:28:43.360
所以我们一直在谈论它会做些什么

00:28:43.360 --> 00:28:48.720
在dagdb上运行线程v2，这是一个有趣的对话，正在向前发展

00:28:48.720 --> 00:28:51.840
那就是我们在的地方

00:28:53.039 --> 00:29:01.039
嗯，有没有人有任何议程项目

00:29:01.440 --> 00:29:05.760
因为我可能有一个，因为我想得到一点

00:29:05.760 --> 00:29:09.520
嗯，除了彼得是一个更重要的人物，就像

00:29:09.520 --> 00:29:12.559
我想从迈克尔那里知道并写关于

00:29:12.559 --> 00:29:17.120
cid会像um一样更改，因为我可能会与亚当的明天谈谈

00:29:17.120 --> 00:29:21.279
就像它只是属性，我们可以

00:29:21.279 --> 00:29:24.480
已经填充了，就像基本上

00:29:24.480 --> 00:29:28.240
或多或少在cid内部进行了更改，而您没有

00:29:28.240 --> 00:29:31.520
需要从外面关心很多事情，或者这意味着您也

00:29:31.520 --> 00:29:34.159
需要从外面照顾，基本上反映出

00:29:34.159 --> 00:29:38.640
像所有依赖的依赖

00:29:38.840 --> 00:29:44.159
cid rod的话语他被静音了

00:29:45.039 --> 00:29:48.320
它不会破坏更改，而只是功能版本

00:29:48.320 --> 00:29:52.159
好吧，是的，我要添加的内容仅是功能版本

00:29:52.159 --> 00:29:53.840
因为它们是您需要的功能

00:29:53.840 --> 00:29:56.480
迁移到将来，所以没有休息

00:29:56.480 --> 00:30:04.720
是的，当您迁移到下一个时，会有休息，但是是的，但是就像

00:30:04.720 --> 00:30:10.640
如果我记录重新计算，例如代码，我会这样做吗？

00:30:10.640 --> 00:30:14.480
代码的东西，所以它基本上是然后填充

00:30:14.480 --> 00:30:19.360
当您这样做时，我们显然使用了字符串，但是我们从某处获取了代码，因此我们

00:30:19.360 --> 00:30:23.679
就像您创建此ID时一样，我们只会填充yeah

00:30:23.679 --> 00:30:28.159
无论如何，同居是的，是的，我的意思是你可以通过从代码中查找字符串来

00:30:28.159 --> 00:30:30.240
五彩的桌子，因为你拥有整个东西

00:30:30.240 --> 00:30:33.039
拍摄图像时也可以在构造函数中使用，也可以将其转换

00:30:33.039 --> 00:30:35.200
到字符串并在那里保持字符串行为

00:30:35.200 --> 00:30:39.039
但至少您知道您可以迁移到新表格的外部用法

00:30:39.039 --> 00:30:43.679
所以构造函数的逻辑可能有点尴尬

00:30:43.679 --> 00:30:48.000
但这不是超级幻想，只是因为你有

00:30:48.000 --> 00:30:51.279
您将有多个号码，然后说您需要开启

00:30:51.279 --> 00:30:55.360
因此您需要打开版本编解码器

00:30:55.360 --> 00:30:59.360
数字和字符串，但您应该查看该代码

00:30:59.360 --> 00:31:04.159
在旧的CID中，有一点我不知道它是否会变得容易或

00:31:04.159 --> 00:31:06.799
很难，但比他们在那里要复杂一些

00:31:06.799 --> 00:31:10.080
这就是我说的要检查参数的数量，是的，是的，是的

00:31:10.080 --> 00:31:12.720
这就是为什么我说这很好，这将不仅仅是一个简单的问题

00:31:12.720 --> 00:31:17.360
公开一个属性，就像一点点算法黑客一样

00:31:17.360 --> 00:31:20.240
在暴露在道具好

00:31:20.240 --> 00:31:25.679
属性，您可以只使用吸气剂，并在需要时使用它。

00:31:25.679 --> 00:31:33.200
好吧，那将是一个休息吧，那将是一个补充

00:31:33.200 --> 00:31:36.799
在构造函数上，但仍然可以与旧版本一起使用

00:31:36.799 --> 00:31:40.159
所以基本上它不应该破坏任何东西是的，我是

00:31:40.159 --> 00:31:45.440
想知道我们是否可以做一个1.0版本

00:31:45.440 --> 00:31:50.320
没有这些东西，然后将它们添加到1.1版本中

00:31:50.320 --> 00:31:53.919
您可以，但是喜欢让他们加入的全部要点是，当您这样做时

00:31:53.919 --> 00:31:57.039
您可以通过您可能想要的方式传达的重大变化

00:31:57.039 --> 00:31:59.600
您正在遍历所有代码并将其转换为使用缓冲区，也可能

00:31:59.600 --> 00:32:01.600
只想改用这些代码属性

00:32:01.600 --> 00:32:04.880
并以这种方式实例化，因为这将非常好

00:32:04.880 --> 00:32:08.559
在两个库中都具有相同的功能真是太好了

00:32:08.559 --> 00:32:13.440
是的，是的，这不是它，不是像塞伯特的东西

00:32:13.440 --> 00:32:16.799
就像问题一样，就像您想要的时间问题一样

00:32:16.799 --> 00:32:19.279
立即发送所有消息，因为人们将进入其中

00:32:19.279 --> 00:32:23.360
代码迁移到您并反而讨厌

00:32:23.360 --> 00:32:26.159
然后，因为如果您推出，而您推出的版本

00:32:26.159 --> 00:32:29.120
亚历克斯的变化，那么你可以轻松地坐在那

00:32:29.120 --> 00:32:34.159
版本，您通常会很好，但随后您会拥有一个

00:32:34.159 --> 00:32:38.000
如果您想迁移到最新的平台，则额外的痛苦

00:32:38.000 --> 00:32:41.519
您尚未开始这项工作，但这使您可以选择启动该工作

00:32:41.519 --> 00:32:45.039
在任何时候都可以工作，所以您可以在任何时候都可以说哦

00:32:45.039 --> 00:32:49.600
也许我们应该切换到整数多编解码器，而你可以做到

00:32:49.600 --> 00:32:52.240
那个旧图书馆真的很好

00:32:52.240 --> 00:32:59.200
好吧，那么好吧，但是要点是，因为它有这么多

00:32:59.200 --> 00:33:03.200
依赖就像它是js中的一个巨大的依赖树

00:33:03.200 --> 00:33:06.000
知道，是的，所以需要很长时间

00:33:06.000 --> 00:33:12.240
直到人们可以实际使用cid的时间

00:33:12.240 --> 00:33:17.360
我的意思是，如果我们明天去发布的话，

00:33:17.360 --> 00:33:20.240
您不能真正使用代码库，因为您没有其他所有的库

00:33:20.240 --> 00:33:24.720
需要缓冲区等的依赖项基本上我在说的是我们有

00:33:24.720 --> 00:33:30.399
实施uh 1.1版本还有很多时间，因为您无法使用它

00:33:30.399 --> 00:33:34.640
无论如何，没有上游依赖可以使用

00:33:34.640 --> 00:33:38.480
明天会发行新的cd版本，这样我就更民俗了，这样回购

00:33:38.480 --> 00:33:43.200
每次签到时都没有自动发布信息，就像我们可以

00:33:43.200 --> 00:33:46.480
合并该公关并等待，但就像当您推出时

00:33:46.480 --> 00:33:50.080
主要的重大发行版本，我们可能希望在此之前获得此代码

00:33:50.080 --> 00:33:52.000
那是因为那是在收到消息时

00:33:52.000 --> 00:33:57.440
正确的问题是，它基本上可以阻止alex

00:33:57.440 --> 00:34:00.880
很难，就像他基本上已经完成了

00:34:00.880 --> 00:34:08.079
基本上是阻塞标签pb，因此是unix fs

00:34:08.079 --> 00:34:11.119
因此是ipfs

00:34:11.520 --> 00:34:14.480
好吧，随便

00:34:14.960 --> 00:34:20.720
所以让我怎么样，如果今天我失败了，我尝试在今天投入一些东西

00:34:20.720 --> 00:34:24.879
那么您可以继续发布，但今天我会尽力

00:34:24.879 --> 00:34:31.040
做到这一点，然后您就可以缩短时间了，即使

00:34:31.040 --> 00:34:36.000
即使我们基本上完成了一半，我也很喜欢

00:34:36.000 --> 00:34:39.440
我几乎可以在小事情上解决这些问题，我也可以解决这些问题

00:34:39.440 --> 00:34:43.119
因此，如果我们谈论的天数范围是完全可以的，

00:34:43.119 --> 00:34:46.960
听起来不错，我们最终会在某个时候做，那太久了

00:34:46.960 --> 00:34:50.560
因为我真的不想干嘛，这可不是什么大不了的事

00:34:50.560 --> 00:34:54.079
很大的变化，没关系，这是这样做的乏味，是的，

00:34:54.079 --> 00:34:58.240
问题是我不太喜欢细节部分

00:34:58.240 --> 00:35:01.920
新的东西，所以如果是的话，上帝，那完全没问题，

00:35:01.920 --> 00:35:07.520
然后，是的，我很高兴，是的，所以让我们尝试一下，然后进行测试

00:35:07.520 --> 00:35:12.480
打字稿的定义，是的，这很乏味

00:35:14.079 --> 00:35:18.160
好吧，现在很酷，是的，那是完美的，然后好吧

00:35:18.160 --> 00:35:25.440
嗯，彼得，你想说点我很快，哦，是的，是的，所以

00:35:25.440 --> 00:35:31.040
这是我大约一个星期前喜欢的一个想法，我只想了解一下

00:35:31.040 --> 00:35:35.839
像巩固一样，我们要继续前进

00:35:35.839 --> 00:35:41.040
嗯，我意识到约翰尼在这里，呃，不要被我提议的事情惊呆了

00:35:41.040 --> 00:35:46.320
实际上会直接影响您在做什么，所以我们似乎正在运行

00:35:46.320 --> 00:35:50.320
陷入整个生态系统的问题

00:35:50.320 --> 00:35:54.160
就像在生锈中，我不知道该怎么办

00:35:54.160 --> 00:35:56.640
JavaScript中的故事可能也相似

00:35:56.640 --> 00:36:00.880
我们拥有这些半机械人的编码器和解码器

00:36:00.880 --> 00:36:05.599
诅咒实际上为右旋糖酐做正确的事

00:36:05.599 --> 00:36:11.200
更严格，更有弹性，更多，更多。。。

00:36:11.200 --> 00:36:13.680
看来我们基本上

00:36:13.680 --> 00:36:18.800
说东西是基于sibor或

00:36:18.800 --> 00:36:22.640
大战将cybor作为名称的一部分

00:36:22.640 --> 00:36:26.960
浮动了几次，我们应该有一个不同的um

00:36:26.960 --> 00:36:34.240
就像对象的另一种更好的呃格式

00:36:34.240 --> 00:36:38.320
嗯，对不起，对于节点，不管您想称呼它是什么，

00:36:38.320 --> 00:36:41.839
对于块um

00:36:42.320 --> 00:36:46.079
我的事情是，我们应该称呼它没有任何东西

00:36:46.079 --> 00:36:49.920
既不包含json，也不包含内战，不包含xml

00:36:49.920 --> 00:36:52.800
昨天你想要什么什么完全不同的名字

00:36:52.800 --> 00:36:56.800
这样，没有人实现这个想法就好了，我将重用它

00:36:56.800 --> 00:37:00.400
我已经用我的语言在这里建立的图书馆，我只是

00:37:00.400 --> 00:37:07.200
得到它，您知道修复我认为很重要的事情，并且他们会做到的

00:37:07.520 --> 00:37:11.200
那就是我想浮出水面的地方，实际上不是一个好地方

00:37:11.200 --> 00:37:15.760
证明有思想的东西，是的

00:37:15.760 --> 00:37:18.480
我的意思是，当我们考虑采用新的块格式时，我们会想出一个名称

00:37:18.480 --> 00:37:22.320
这是非常独特的，这可能会很有趣

00:37:22.320 --> 00:37:25.440
从ip开始

00:37:30.000 --> 00:37:35.920
但是，是的，不，是的，这就像这是一般的我

00:37:35.920 --> 00:37:41.119
是的，对块格式进行了争论

00:37:41.119 --> 00:37:45.280
做正确的事是非常困难的，我认为

00:37:45.280 --> 00:37:48.560
西摩在制造时绝对是正确的选择，

00:37:48.560 --> 00:37:50.480
现在可能仍然是正确的选择

00:37:50.480 --> 00:37:55.040
嗯，但是我们知道我们现在已经足够了解这种格式的工作原理以及如何编写

00:37:55.040 --> 00:37:57.920
自己做块的格式

00:37:57.920 --> 00:38:01.119
未来的格式，就像不是，它变得越来越清晰

00:38:01.119 --> 00:38:05.920
sibor格式不好确实不好

00:38:05.920 --> 00:38:10.000
就是这个周围的术语是

00:38:10.000 --> 00:38:14.880
有时会造成严重的沟通不畅，因为它

00:38:14.880 --> 00:38:18.320
使人们随身携带各种行李

00:38:18.320 --> 00:38:21.440
是的，并且喜欢假设某些形式的扩展

00:38:21.440 --> 00:38:25.200
当他们绝对不是的时候会去工作那是真正的问题

00:38:25.200 --> 00:38:27.440
一

00:38:29.520 --> 00:38:32.560
随时格式化，但那不是全部问题

00:38:32.560 --> 00:38:36.480
要么我的意思是这么多，但是就像我们有一个现有的表格一样

00:38:36.480 --> 00:38:39.119
我们正在努力使其具有确定性，这确实是

00:38:39.119 --> 00:38:42.079
痛苦的事情，例如采用现有的格式和项目

00:38:42.079 --> 00:38:45.440
确定性就像不好玩一样，我们发现了所有的角落

00:38:45.440 --> 00:38:47.839
现在或者至少我希望我们找到了所有这些

00:38:47.839 --> 00:38:51.200
嗯，但是这会希望继续出现，尤其是随着人们

00:38:51.200 --> 00:38:54.160
区块链的工作，我认为当您这样做时，这种现象最为明显

00:38:54.160 --> 00:38:55.839
区块链工作是因为您始终必须

00:38:55.839 --> 00:39:00.000
就相同的序列化达成一致，就像我实际上并不担心

00:39:00.000 --> 00:39:03.359
反序列化和直流实现方面的松懈我只担心

00:39:03.359 --> 00:39:08.079
对序列化um和类似这些错误的错误严格

00:39:08.079 --> 00:39:10.560
现在的自己很难测试

00:39:10.560 --> 00:39:16.000
所以就像问题嗯是的，就像不好

00:39:16.000 --> 00:39:18.720
就像我认为

00:39:19.359 --> 00:39:23.119
是的，很明显，在某个时候，我们将需要编写一个

00:39:23.119 --> 00:39:25.280
块格式，我们需要真正考虑一下

00:39:25.280 --> 00:39:29.680
嗯，真的很辛苦，但是我们被困在了那里

00:39:29.680 --> 00:39:33.040
现在是的，但我认为尽管

00:39:33.040 --> 00:39:36.640
关于整件事的一件很酷的事情是，您可以拥有自己的块格式

00:39:36.640 --> 00:39:40.320
基本上，所以我认为这就像我们至少应该做两个

00:39:40.320 --> 00:39:44.800
同时喜欢不同的人

00:39:44.800 --> 00:39:48.480
之所以这样，是因为您基本上会以

00:39:48.480 --> 00:39:51.839
哦，您基本上可以优化它，无论是优化格式还是

00:39:51.839 --> 00:39:55.359
像ipld或它周围的东西优化为单一格式，这完全是

00:39:55.359 --> 00:39:59.680
不是四月的重点哦，所以你应该基本上有格式

00:39:59.680 --> 00:40:04.240
这是不同的，所以你基本上还是喜欢

00:40:04.240 --> 00:40:07.839
我的意思是，基本上这就是dag.json就像没人真正使用它们json我

00:40:07.839 --> 00:40:10.640
认为他们应该

00:40:19.760 --> 00:40:23.040
我们仍然可以使用sibo像

00:40:23.040 --> 00:40:27.440
将seaboard视为难以处理的另一种格式

00:40:27.440 --> 00:40:34.000
但是，是的，就像新的块格式一样，是的，是的，是的

00:40:34.000 --> 00:40:36.800
我们要做的事情不应该在数据之外做任何事情

00:40:36.800 --> 00:40:39.119
模拟它应该做的所有您不能做的工作-索引板

00:40:39.119 --> 00:40:43.040
只是有点像效率更高一点，更容易

00:40:43.040 --> 00:40:46.079
确保像所有这些东西一样的确定性

00:40:46.079 --> 00:40:48.880
它不应该是您绝对必须使用的东西，例如dixie vs

00:40:48.880 --> 00:40:53.040
不要在所有地方工作，堆栈应该假设

00:40:53.520 --> 00:41:00.160
是的，我完全同意，即使将呃作为正常网络的副产品

00:41:00.160 --> 00:41:04.960
库能够解码就可以了，只是我们真的不能

00:41:04.960 --> 00:41:07.680
做广告，因为它使我们知道了什么是什么老鼠

00:41:07.680 --> 00:41:11.920
说我认为这是星期二，像哦，我们将做超级严格或

00:41:11.920 --> 00:41:15.520
像这样的事情你不能做一个非常严格的

00:41:15.520 --> 00:41:20.000
现有的图书馆，你需要新的嘴唇，我的意思是

00:41:20.000 --> 00:41:24.640
不应小看，也许有一些很好的

00:41:24.640 --> 00:41:26.800
人们建议去研究的东西

00:41:26.800 --> 00:41:32.560
t json用于json类型，就像json加上一些注释，但它们

00:41:32.560 --> 00:41:37.040
提出了明确的论点，然后再说

00:41:37.040 --> 00:41:40.720
清楚描述您解析的方式

00:41:40.720 --> 00:41:45.280
作为常规的json，但像整个过程一样，我可以将其解析为这种旧格式

00:41:45.280 --> 00:41:49.599
熟悉的情况就像在其自己的h2下有一个单独的子句

00:41:49.599 --> 00:41:53.839
他们有这样的名字后就去

00:41:53.839 --> 00:41:58.000
是新的东西，不是像杰森·ld（Jason ld）那样

00:41:58.000 --> 00:42:01.599
算法工作，不是吗，因为我

00:42:01.599 --> 00:42:04.240
当您将块存储为

00:42:04.240 --> 00:42:07.760
seabor实际上是没有命令的，基本上只是字节而已

00:42:07.760 --> 00:42:10.480
方便的订购是，但实际上

00:42:10.480 --> 00:42:15.040
当您读取消引用并阅读，然后

00:42:15.040 --> 00:42:19.440
您正在将其转换回人类可读的格式，如json

00:42:19.440 --> 00:42:22.960
那就是您实际执行术语确定性映射的时间

00:42:22.960 --> 00:42:31.040
按最低字节顺序排序um否否否它必须

00:42:35.200 --> 00:42:39.200
好吧，因为我认为那可能是其中的一部分，实际上就像

00:42:39.200 --> 00:42:44.319
很好，当您反序列化它时，您正在应用特定的排序算法

00:42:44.319 --> 00:42:49.599
或者您符合特定的um算法的uh格式

00:42:49.599 --> 00:42:52.960
其实你是你正在申请的一部分

00:42:52.960 --> 00:42:58.880
是的，在转型过程中，我的意思是像我们所遇到的问题

00:42:58.880 --> 00:43:01.200
进入右边就像他们是什么，所以有一个是地图

00:43:01.200 --> 00:43:04.800
订购东西，就像不是每个人都实际实现地图订购

00:43:04.800 --> 00:43:08.480
正确的，我们现在到处都是，但是像很多

00:43:08.480 --> 00:43:11.599
我们发现很多人都不喜欢，因为这就像一个怪异的角落

00:43:11.599 --> 00:43:16.000
规格，然后另一个是um整数

00:43:16.000 --> 00:43:18.880
嗯，它说你应该总是在哪里输入东西

00:43:18.880 --> 00:43:25.280
使用最小的表示形式um，很多人不使用um，我认为

00:43:25.280 --> 00:43:28.880
这部分的一部分也就好像你在说彼得甚至什么都没有

00:43:28.880 --> 00:43:32.079
人们拉起他们的海滨图书馆，并用它来做字面上的一切

00:43:32.079 --> 00:43:34.079
人们甚至没有实现所有的seabor

00:43:34.079 --> 00:43:37.040
他们实现了像他们在此关注的海滨功能一样

00:43:37.040 --> 00:43:39.599
事情，然后就是这样，所以就像

00:43:39.599 --> 00:43:44.079
令人难以置信的天真和具体嗯，这就是他们的很多想法

00:43:44.079 --> 00:43:46.400
问题

00:43:47.040 --> 00:43:50.960
或者他们实施了更多实施方式，例如无限列表

00:43:50.960 --> 00:43:54.160
而且您知道诸如此类的事情，但是要加入约翰尼的观点，那不是

00:43:54.160 --> 00:43:58.079
关于可以反序列化的是

00:43:58.079 --> 00:44:02.240
总是关于磁盘上的内容，因为磁盘上的内容就是网络上的内容

00:44:02.240 --> 00:44:06.160
网络上的内容就是您可以验证自己是否

00:44:06.160 --> 00:44:09.680
立即遭到攻击，或者您实际上得到了正确的cie

00:44:09.680 --> 00:44:12.720
这一切都发生在您解码任何东西之前，所以这一切

00:44:12.720 --> 00:44:17.520
在正确的时间是非常重要的，我的意思是做新的事情很高兴

00:44:17.520 --> 00:44:22.160
块格式是，我们基本上可以预先加载所有链接，因此

00:44:22.160 --> 00:44:25.200
您可以在不解析整个块的情况下获取所有链接，所以这真的

00:44:25.200 --> 00:44:29.040
很酷，但也只是想不那么容易

00:44:29.040 --> 00:44:32.160
写这些天真的实现，因为你必须做一堆

00:44:32.160 --> 00:44:36.000
前期工作以了解该障碍

00:44:36.000 --> 00:44:38.800
所以喜欢的人不会为

00:44:38.800 --> 00:44:41.520
序列化序列化我认为那会很好

00:44:41.520 --> 00:44:44.480
像在其中添加一些特定于应用程序的压缩一样，也会

00:44:44.480 --> 00:44:47.200
真的很有帮助，应该有点困难

00:44:47.200 --> 00:44:52.319
不执行整个事情，我认为那会很棒

00:44:52.480 --> 00:44:56.079
是的，我在本周的ietf电话会议中看到，实际上有很多

00:44:56.079 --> 00:44:59.280
前缀压缩，实际上就像在朗读中

00:44:59.280 --> 00:45:04.800
数组中的第一个uh字节实际上就像一堆iuis或uris是

00:45:04.800 --> 00:45:08.079
实际上，所有内容都始于非常相似的内容，因此您可以将其压缩

00:45:08.079 --> 00:45:11.200
基本上就像是，是的，但是那是

00:45:11.200 --> 00:45:14.480
我不知道这将是确定性的

00:45:14.480 --> 00:45:19.280
这样做的方式，所以不，您绝对可以通过这种方式确保确定性

00:45:19.280 --> 00:45:23.119
是的，是的，您只需要确保当您订购时就可以订购

00:45:23.119 --> 00:45:26.880
提前加载它们，是的，我们完全可以做到

00:45:26.880 --> 00:45:31.920
一直以来，我们都应该真正地做他们想像的专家

00:45:31.920 --> 00:45:38.720
我们需要的东西我们应该像我认为的那样亲

00:45:38.720 --> 00:45:42.480
很可能在实施中，所以实施

00:45:42.480 --> 00:45:47.440
只有我们需要标签cbo的斑马才会有趣，就像没有

00:45:47.440 --> 00:45:49.359
实施，例如采取

00:45:49.359 --> 00:45:53.520
支持将只是它只支持一个标签，就像它不支持

00:45:53.520 --> 00:45:57.280
甚至需要正确的标签解析，但就像硬编码一样

00:45:57.280 --> 00:46:01.680
拿42，因为我认为那不是

00:46:01.680 --> 00:46:06.000
它应该已经漂亮了，它不再是一个甲板了，它是一个链接

00:46:06.000 --> 00:46:12.079
是的是的，但是它喜欢代码，因为如果您只

00:46:12.079 --> 00:46:17.200
失去那些功能cbor并不难读或

00:46:17.200 --> 00:46:20.400
如果您只做我们需要的工作，基本上就是写东西会很有趣

00:46:20.400 --> 00:46:23.680
像是花了多长时间才为我们实施javascript

00:46:23.680 --> 00:46:27.040
您知道Java python或不需要其他映射键的任何内容，

00:46:27.040 --> 00:46:33.200
东西，是的，是的，是的，这可能很简单

00:46:33.200 --> 00:46:37.599
我想我可能会尝试

00:46:37.599 --> 00:46:40.800
我们可以结束我最后想做的一件事吗？

00:46:40.800 --> 00:46:42.960
的

00:46:46.960 --> 00:46:51.440
是的，那我将结束会议

00:46:52.160 --> 00:47:00.000
再见了，大家都很棒

