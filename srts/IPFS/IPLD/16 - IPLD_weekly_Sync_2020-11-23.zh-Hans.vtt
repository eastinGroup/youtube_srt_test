WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.519 --> 00:00:18.480
欢迎大家，这是ipod同步会议

00:00:18.480 --> 00:00:25.519
2020年11月23日，每周我们都要经过员工

00:00:25.519 --> 00:00:28.720
在过去的一周中我们一直在努力，然后

00:00:28.720 --> 00:00:34.160
讨论我们可能拥有的所有未结项目，是的，我

00:00:34.160 --> 00:00:37.840
从我自己开始，我实际上不记得我曾经做过的事情

00:00:37.840 --> 00:00:40.079
在上周一定要更多，但我不能

00:00:40.079 --> 00:00:44.320
只能回想起我最大的成功是

00:00:44.320 --> 00:00:49.600
最终，prs出现了，所以lib p2p现在使用的是最轻的rust multi-hash

00:00:49.600 --> 00:00:55.600
和森林rust fico实施正在使用最新的rust martial和

00:00:55.600 --> 00:01:00.160
锈cid，所以好消息就这样

00:01:00.160 --> 00:01:02.960
如果我和森林里的人说话不是这样

00:01:02.960 --> 00:01:06.960
那个他们无法做到的表演

00:01:06.960 --> 00:01:11.360
真正衡量差异，但他们至少可以衡量

00:01:11.360 --> 00:01:15.280
所以报价严格来说是更好的性能，所以

00:01:15.280 --> 00:01:18.479
当然不会更糟，但肯定会更好，但是

00:01:18.479 --> 00:01:20.640
它可能无法测量，但仍然存在

00:01:20.640 --> 00:01:27.600
那里没有回归，所以非常高兴知道这个，也许也喜欢

00:01:27.600 --> 00:01:31.119
如果有回归的话，只有p2p的人会说些什么

00:01:31.119 --> 00:01:38.320
所以很好，嗯，差不多

00:01:38.320 --> 00:01:44.960
我名单上的下一个是丹妮尔（Danielle）酷，所以上周嗯

00:01:44.960 --> 00:01:48.399
我基本上在前一周完成了多编解码器库，但是

00:01:48.399 --> 00:01:51.920
这只是我计划在第一个标签上的一个fyi

00:01:51.920 --> 00:01:55.840
明天发布重写发布，所以如果有人有任何最后反馈，请

00:01:55.840 --> 00:02:00.159
现在说，我确实做了一点点修饰

00:02:00.159 --> 00:02:04.399
上个星期一，所以现在的名字有点惯用了

00:02:04.399 --> 00:02:08.560
而且代码生成器也较小，这不是很好

00:02:08.560 --> 00:02:13.360
我也跟罗德讲了好吧，这是迈克尔说的

00:02:13.360 --> 00:02:15.680
如果在哪一周之前

00:02:15.680 --> 00:02:19.840
hammed adl也支持文件投币手，因为我们有

00:02:19.840 --> 00:02:23.120
大量格式的数据，所以我讲了一下

00:02:23.120 --> 00:02:26.640
就像这两种模式之间的区别到底是什么

00:02:26.640 --> 00:02:30.319
以及支持旧版本和新版本的重要性

00:02:30.319 --> 00:02:33.680
因为支持旧版本在今天很有用，因为我们有很多数据

00:02:33.680 --> 00:02:36.879
那个，所以实际的差异只在于

00:02:36.879 --> 00:02:39.840
元素类型，因为新的是亲切的，而旧的是有键的

00:02:39.840 --> 00:02:43.920
我想我没错，所以迈克尔实际上想出了一个主意

00:02:43.920 --> 00:02:47.840
就像一个双重工会，他称呼它，所以有一个议程

00:02:47.840 --> 00:02:52.080
关于这个的项目，以便我们可以看一看，我也和遗嘱进行了交谈。

00:02:52.080 --> 00:02:54.480
关于可能使用它而不是

00:02:54.480 --> 00:02:59.280
在他的东西中归档硬币手um idl，因为现在我

00:02:59.280 --> 00:03:03.599
相信他将其与ipld主节点包装程序一起使用

00:03:03.599 --> 00:03:06.879
这就像只读，用于执行选择器之类的操作

00:03:06.879 --> 00:03:10.879
所以我想我很亲近，因为我已经读了很多东西

00:03:10.879 --> 00:03:14.239
现有的笔记，我只是想缺少，因为原型在那里，并且

00:03:14.239 --> 00:03:16.480
一堆东​​西在那里，我想我只是想念

00:03:16.480 --> 00:03:20.480
refi，也许还有其他一些功能，例如缓存链接加载

00:03:20.480 --> 00:03:25.920
但是大多数事情都应该在那里，我想我也讲过关于Ghost构建的话题

00:03:25.920 --> 00:03:29.120
缓存进行得很顺利，如果有人要观看，就会有一个视频

00:03:29.120 --> 00:03:35.840
明天我将在go 116中的时间跟踪中讨论初始化时间

00:03:35.840 --> 00:03:39.040
这是相当利基，但如果有人有超大

00:03:39.040 --> 00:03:42.640
去需要很长时间才能启动的二进制文件是所有单元功能

00:03:42.640 --> 00:03:46.000
在工作中，您实际上可以用116来衡量他们需要多长时间

00:03:46.000 --> 00:03:50.080
每个包装真的很好，最后一件事

00:03:50.080 --> 00:03:53.200
这已经持续了好几个月，我已经提出来了

00:03:53.200 --> 00:03:56.319
我想过一两次，但我们有点

00:03:56.319 --> 00:04:00.239
重新设计编码json包，使其成为第二个版本，但是

00:04:00.239 --> 00:04:03.439
嗯，它还没有公开，因为我们不知道它是否会成为第二版

00:04:03.439 --> 00:04:07.680
也许实验会惨败，也许会

00:04:07.680 --> 00:04:12.480
嗯，但如果有人感兴趣，我以后可以分享一些细节

00:04:12.480 --> 00:04:17.840
这就是我的感谢，这实际上让我想起了

00:04:17.840 --> 00:04:22.000
我上周的工作是在虚拟聚会上讲话，我准备了

00:04:22.000 --> 00:04:26.880
几乎是整个星期的谈话，并且会有录音，所以有

00:04:26.880 --> 00:04:29.680
现在没有录音，但将有录音发布

00:04:29.680 --> 00:04:36.080
是的，是的，所以我名单上的下一个是鱼竿

00:04:36.080 --> 00:04:41.199
相似的一周伏特加实际上已经有很多周了

00:04:41.199 --> 00:04:46.160
迈克尔幻灯片的um幻灯片

00:04:46.160 --> 00:04:51.120
嗯，我不认为，我想你们中的大多数人可能都没有看过，但是

00:04:51.120 --> 00:04:55.520
我想是因为我花了一些时间试图理解算法

00:04:55.520 --> 00:05:00.080
然后弄清楚如何用一种方式来解释它

00:05:00.080 --> 00:05:03.120
如果我只是看幻灯片以了解它将会对我有帮助

00:05:03.120 --> 00:05:10.000
所以我认为幻灯片非常擅长于达到算法的核心

00:05:10.000 --> 00:05:17.039
嗯，所以他们可能在某个时候值得分享

00:05:17.039 --> 00:05:21.280
嗯，我想那儿还有一小部分

00:05:21.280 --> 00:05:26.960
像um碰撞案这样的安全案需要

00:05:26.960 --> 00:05:29.840
整理出来，那真的是一个基本问题，需要解决

00:05:29.840 --> 00:05:33.600
需要一个坚实的解决方案，然后我们才能

00:05:33.600 --> 00:05:38.880
喇叭这个东西响亮而宽阔，嗯，这继续困扰着我，呃，我

00:05:38.880 --> 00:05:42.960
知道迈克尔认为他对此有解决方案，但是我们会

00:05:42.960 --> 00:05:46.160
我认为迈克尔一对一谈论

00:05:46.160 --> 00:05:50.400
嗯，你知道那实际上花了几天

00:05:50.400 --> 00:05:54.000
做那个，我一直在搞乱

00:05:54.000 --> 00:06:02.479
呃，与河流S3数据文件硬币数据，嗯，我做了一个本地块存储

00:06:02.479 --> 00:06:07.120
仅使用汽车文件和级别数据库就可以足够有效地存储它

00:06:07.120 --> 00:06:13.680
索引um我知道，而michael正在研究

00:06:13.680 --> 00:06:16.880
以及块存储，所以我们正在进行多个块存储

00:06:16.880 --> 00:06:20.720
并会有汽车索引的东西，所以有

00:06:20.720 --> 00:06:22.639
这里发生了很多大宗商店的东西

00:06:22.639 --> 00:06:25.199
目前有很多有趣的事情

00:06:25.199 --> 00:06:28.240
但我遇到了所有与之相关的问题

00:06:28.240 --> 00:06:35.600
um遍历非常大的图um，那是你知道的，所以我

00:06:35.600 --> 00:06:38.880
无论如何，我不想在这个东西上被卡住太多，但是我

00:06:38.880 --> 00:06:45.120
真的希望um可以更轻松地访问此数据，然后

00:06:45.120 --> 00:06:48.000
花一点时间来澄清术语

00:06:48.000 --> 00:06:51.280
Farcoid的创世块有点混乱

00:06:51.280 --> 00:06:54.880
但我想我今天将合并一份公关的最终表格

00:06:54.880 --> 00:07:00.000
在规格库中只是因为有一个创始，然后有一个

00:07:00.000 --> 00:07:05.520
Falcoin和um的起源，这两件事需要

00:07:05.520 --> 00:07:08.720
在我们的文档中进行了描述，因为与

00:07:08.720 --> 00:07:14.000
另一个，所以试图从中推断

00:07:14.000 --> 00:07:18.479
莲花码人们如何思考和谈论这件事

00:07:18.479 --> 00:07:22.080
并没有我所希望的那样好，它需要一些

00:07:22.080 --> 00:07:26.240
各种人的干预，以澄清周围的问题

00:07:26.240 --> 00:07:32.080
无论如何，我认为公关已经足够好了，因为这是为了澄清

00:07:32.080 --> 00:07:35.280
语言和情况，这就是我要说的

00:07:35.280 --> 00:07:38.080
关于那真的是所有值得注意的事情

00:07:38.080 --> 00:07:45.840
上个星期我也记得下一个

00:07:45.840 --> 00:07:50.879
嗯，所以[音乐]

00:07:50.879 --> 00:07:57.360
在Filecoin上的graphql东西在公共地址上并且正在运行

00:07:57.360 --> 00:08:02.560
人们正在使用它，这意味着存在错误和功能请求等

00:08:05.599 --> 00:08:09.919
有几个地方我会继续调整

00:08:09.919 --> 00:08:13.039
有趣的是自然的

00:08:13.039 --> 00:08:18.800
像graphql作为标量公开的基本类型一样，称为id

00:08:18.800 --> 00:08:22.319
很自然地，我们说自己的罪魁祸首是

00:08:22.319 --> 00:08:26.400
id类型，但是因为它是内置的graphql类型，这意味着您不会

00:08:26.400 --> 00:08:29.280
轻松覆盖有关该类型的任何内容，因为它是

00:08:29.280 --> 00:08:32.320
内置在graphql库中，例如，这意味着您不能

00:08:32.320 --> 00:08:35.919
然后定义如何在按住时以流形式漂亮地打印cid

00:08:35.919 --> 00:08:40.399
他们的字节格式正确，所以我们有我们的ID，实际上是

00:08:40.399 --> 00:08:43.360
某种非标准类型，因此我们想将其视为

00:08:43.360 --> 00:08:47.680
ID scalar的核心graphql类型在某种意义上也是

00:08:47.680 --> 00:08:51.519
有一些自定义规则，所以那是在那里

00:08:51.519 --> 00:08:55.839
我们将不得不找出一条道路

00:08:57.680 --> 00:09:01.680
它正在对裤子进行一些挑剔的装载

00:09:01.680 --> 00:09:05.519
这有助于加快速度

00:09:07.200 --> 00:09:11.600
Go ipld中有几个公关，一个很小，合并了另一个

00:09:11.600 --> 00:09:15.440
嗯，有一个代码生成看看

00:09:15.440 --> 00:09:19.760
生成代码并跳过的目标程序包

00:09:19.760 --> 00:09:23.440
类型的生成（如果已在目标软件包中定义它们的话）

00:09:23.440 --> 00:09:26.640
不在自动生成的代码中作为一种方式

00:09:26.640 --> 00:09:30.720
只是让您采用一种类型，并用一些怪异的自定义内容来定义它，

00:09:30.720 --> 00:09:34.000
没有，然后还有教练和其他不存在的东西

00:09:34.000 --> 00:09:39.839
嗯，大概有一种方法可以让cogen暴露一些可以

00:09:39.839 --> 00:09:43.279
您可以将其设置为更窄且更适合的替代项

00:09:43.279 --> 00:09:45.839
真正有意义的事情，我还没有弄清楚如何

00:09:45.839 --> 00:09:52.640
做到这一点，而另一个

00:09:53.440 --> 00:09:57.279
有趣的事情可能是我添加的另一个

00:09:57.279 --> 00:10:00.320
高速缓存似乎非常有效

00:10:00.320 --> 00:10:04.160
速度，这是一个实现的对象缓存

00:10:04.160 --> 00:10:11.440
因此，此graphql服务器在ipld.node中将cid保留在内存中

00:10:11.440 --> 00:10:15.760
解析的事物，因此与其返回到数据仓库以重用

00:10:15.760 --> 00:10:18.399
它已经解析并实现的那些节点

00:10:18.399 --> 00:10:23.120
这似乎很有用，我们应该为其缓存的一层

00:10:23.120 --> 00:10:28.240
嗯，这很简单，就像那样

00:10:28.240 --> 00:10:32.560
你做一个lru或emt，或者当你做的时候会赚一些钱

00:10:32.560 --> 00:10:37.519
唯一的地方

00:10:38.079 --> 00:10:45.360
烦人，因为我一直在做别的事情，因为莲花

00:10:45.360 --> 00:10:51.839
在其状态路由上，有时直到v2 actor的升级上

00:10:51.839 --> 00:10:55.040
它在桩根处没有间接层

00:10:55.040 --> 00:10:58.160
因此，国家团体只是直接指出了演员的阵营

00:10:58.160 --> 00:11:01.600
现在定义的状态路由对象的

00:11:01.600 --> 00:11:04.160
汉普顿因素的简报和一个版本

00:11:04.160 --> 00:11:11.920
id和我以前统一的方式是如果我失败了

00:11:11.920 --> 00:11:15.279
将其解析为具有汉普顿演员和

00:11:15.279 --> 00:11:19.279
我编造了一个版本ID，说它是零版本，然后放

00:11:19.279 --> 00:11:23.920
与演员汉普顿相同的sid，因为它是演员汉普顿

00:11:23.920 --> 00:11:27.920
但现在这意味着有两个具有相同cid的ipld节点

00:11:27.920 --> 00:11:34.160
在那种情况下，所以我要同时输入cid和ipld的类型

00:11:34.160 --> 00:11:36.800
节点，因为我确实知道该类型是什么

00:11:36.800 --> 00:11:41.440
会变得很乌木，所以我的钥匙比理想情况下的钥匙还要丑陋，

00:11:41.440 --> 00:11:44.720
这是我的错，也是我滥用CD的原因

00:11:44.720 --> 00:11:49.360
从某种意义上说，我相信人们会感到强烈并且

00:11:49.360 --> 00:11:54.639
为我的选择而高兴，但这就是我们的所在

00:11:59.120 --> 00:12:03.200
我有一个快速的问题，因为您写了ipldql

00:12:03.200 --> 00:12:08.240
这是实际名称吗？还是我有时称它为“是”

00:12:08.240 --> 00:12:14.160
因为那是我的目标，所以stateql是

00:12:14.160 --> 00:12:17.680
类似于文件硬币应用版本，但是ip的通用代码生成

00:12:17.680 --> 00:12:22.399
在ipld数据上建立graphql服务器的权利，因为有两层

00:12:22.399 --> 00:12:25.519
这是一个对ipld标记完全通用的标记，然后

00:12:25.519 --> 00:12:28.800
或架构，然后就是那个filecoin特定的二进制文件

00:12:28.800 --> 00:12:33.200
服务器的东西，所以如果我们愿意的话，我会很高兴

00:12:33.200 --> 00:12:38.320
保持dql以防万一我们提出查询语言之类的东西

00:12:38.320 --> 00:12:44.160
是的，是的，我不知道ipld不会完全脱离舌头，但是

00:12:44.160 --> 00:12:47.920
就像别人可能只是我一样

00:12:47.920 --> 00:12:52.000
就像是的，我认为

00:12:52.000 --> 00:12:55.920
推挤在那里或太肯定了

00:12:55.920 --> 00:13:01.839
但是，是的，所以刚开始研究查询语言

00:13:01.839 --> 00:13:05.920
用g其实更容易说

00:13:08.160 --> 00:13:13.360
是的，从d到q就像我舌头上的怪异过渡

00:13:13.360 --> 00:13:15.760
今晚

00:13:16.720 --> 00:13:26.079
是的，很抱歉，我完全是下一个艾瑞克（Eric），下一个是谁

00:13:28.560 --> 00:13:33.360
是的，对不起，我仍在努力不嘲笑他们的发音

00:13:33.360 --> 00:13:37.440
所以上周有录音

00:13:37.440 --> 00:13:40.880
嗯，我也在演讲的人群中

00:13:40.880 --> 00:13:44.800
因此，有一个新内容和ipld谈话记录为

00:13:44.800 --> 00:13:50.000
ipfs上周的聚会，有一个指向youtube上的位置的链接

00:13:50.000 --> 00:13:54.000
嗯，我的部分只有10分钟左右，所以如果您想要一个真正的

00:13:54.000 --> 00:13:57.440
关于最新情况和新功能的简要概述

00:13:57.440 --> 00:14:00.720
它尽可能简短

00:14:00.800 --> 00:14:03.440
该视频中还有很多其他内容，但我在其中与

00:14:03.440 --> 00:14:08.880
时间偏移量也去了，我觉得那里的主要代码

00:14:08.880 --> 00:14:12.639
合并了一些小东西，例如，热源输出重新排列

00:14:12.639 --> 00:14:15.120
所以最后cogen将输出一个有限的

00:14:15.120 --> 00:14:18.480
文件数量，而不是每种类型的文件

00:14:18.480 --> 00:14:24.720
操作上很烦人，所以固定

00:14:24.959 --> 00:14:28.880
我已经和遗嘱进行了讨论，因为他已经提到过我们如何

00:14:28.880 --> 00:14:32.959
可能在实践中整合adl内容

00:14:32.959 --> 00:14:36.480
我认为似乎我们可能会做

00:14:36.480 --> 00:14:42.240
一些当前的时态捷径，旨在让人们去做

00:14:42.240 --> 00:14:46.639
任意古怪的东西，然后那会让他去做他所要做的

00:14:46.639 --> 00:14:51.920
想要，然后会有一个非常独特的路线图，例如

00:14:51.920 --> 00:14:55.120
我们希望长期很好地整合adls，这将会

00:14:55.120 --> 00:14:58.639
少一点，我们要慢一点

00:14:58.639 --> 00:15:01.360
目前的时态捷径可能是

00:15:01.360 --> 00:15:04.880
cogen，就像真的让我们假设一个人非常

00:15:04.880 --> 00:15:10.839
在循环中，所以这将是安全的问题

00:15:10.839 --> 00:15:14.560
场景um，我们将看看情况如何，以及其他

00:15:14.560 --> 00:15:17.279
比这周的很多时间对我来说似乎也消失了

00:15:17.279 --> 00:15:20.480
um从事大量的规划和范围界定文档

00:15:20.480 --> 00:15:24.079
只是对未来的简单思考

00:15:24.079 --> 00:15:27.279
关于这个的更多文档可能会在以后发布

00:15:27.279 --> 00:15:30.399
这就是这个星期

00:15:30.880 --> 00:15:34.320
谢谢，下一个是彼得

00:15:34.560 --> 00:15:39.120
是的，所以本周很多胶水都可以使用

00:15:39.120 --> 00:15:44.399
呃，除了ipld有趣的东西，你知道

00:15:44.399 --> 00:15:50.720
猎鹰加上小飞象降落空间系列2嗯，开始了一些有趣的事情

00:15:50.720 --> 00:15:57.360
我们把呃的前端连接起来

00:15:58.160 --> 00:16:05.279
基于SQL的数据存储的尚不完整且有些不稳定的呃版本

00:16:05.279 --> 00:16:08.399
里面有所有的东西，包括状态和

00:16:08.399 --> 00:16:13.199
诊所收据嗯，据说一切都好

00:16:13.199 --> 00:16:18.240
目前已经有很多人在使用它了

00:16:18.240 --> 00:16:23.199
说起命名，我喜欢称它为graphil ql

00:16:23.199 --> 00:16:26.320
嗯，因为它很好地翻过了水箱

00:16:26.320 --> 00:16:31.600
嗯，是的，那很有趣

00:16:31.600 --> 00:16:37.880
在很短的时间内运行，因为团队真的需要那个

00:16:37.880 --> 00:16:44.079
做了很多事情的另一件事是在各个版本的

00:16:44.079 --> 00:16:50.320
用于各种用途的数据存储，然后再进行固化

00:16:50.320 --> 00:16:54.720
嗯，实际上需要发生什么

00:16:54.720 --> 00:17:00.959
你知道至少可以满足我们ipld的需求吗？

00:17:00.959 --> 00:17:06.720
希望在下周之前，我能够更详细地讨论这一点，但是

00:17:06.720 --> 00:17:10.720
现在一切都还悬而未决，只是

00:17:10.720 --> 00:17:14.319
真的很难导航

00:17:14.319 --> 00:17:17.600
所有这些，当您尝试一切时都需要一个小时

00:17:17.600 --> 00:17:21.839
差不多半，但欢迎来到大型连锁店

00:17:21.839 --> 00:17:27.839
嗯，是的，这是我本周几乎拥有的所有东西

00:17:27.839 --> 00:17:31.520
谢谢，下一个是迈克尔

00:17:31.600 --> 00:17:35.360
嘿，所以是的，我上周还有更多校准材料，然后

00:17:35.360 --> 00:17:42.240
还有更多的2021年规划工作要做，这周um和

00:17:42.240 --> 00:17:45.600
然后是的，我在cadb上做了很多工作

00:17:45.600 --> 00:17:51.039
它工作正常并进行基准测试，看起来很棒，真的很快

00:17:51.039 --> 00:17:56.400
尽管我只是没有真正实现这些树，但代码还是一团糟

00:17:56.400 --> 00:18:01.200
很多，然后是的，只是事情变得不可收拾了

00:18:01.200 --> 00:18:05.760
因此，它确实运作良好，但是存在一些错误，

00:18:05.760 --> 00:18:09.360
追捕他们的方式是如此痛苦

00:18:09.360 --> 00:18:12.720
嗯，所以我在看，就像在看

00:18:12.720 --> 00:18:16.240
分解并在其中放置一些更好的抽象层

00:18:16.240 --> 00:18:20.400
我意识到这些树只是我的抽象版本

00:18:20.400 --> 00:18:23.280
可以实现然后使用该实现

00:18:23.280 --> 00:18:26.720
那些树做这个数据库或任何其他数据结构，所以我开始

00:18:26.720 --> 00:18:31.360
戳一点，看看那是什么，就像缓存

00:18:31.360 --> 00:18:33.600
我们正在谈论的图层很有趣，我有这些捕捉图层之一

00:18:33.600 --> 00:18:37.760
已经在cadb中安装了um，现在我将其移植到了此

00:18:37.760 --> 00:18:40.640
另一个和有趣的事情是像嗯

00:18:40.640 --> 00:18:43.760
我实际上是在使节点的地址排序

00:18:43.760 --> 00:18:48.559
抽象，因为在cadb中，这些只是文件偏移量的整数

00:18:48.559 --> 00:18:52.640
嗯和嗯，然后就像在其他merkle结构中一样，它们显然是

00:18:52.640 --> 00:18:54.960
将会是cids um，所以我只想稍微说一点

00:18:54.960 --> 00:18:58.080
有点灵活，但是是的，就像您想快速制作出这些东西一样

00:18:58.080 --> 00:19:01.760
需要一个节点缓存，就像已经实现的节点一样

00:19:01.760 --> 00:19:05.600
嗯，那是最重要的

00:19:05.600 --> 00:19:11.679
我已经完成了，谢谢下一个是克里斯，好吧

00:19:11.679 --> 00:19:17.039
继续进行dia的图同步请求验证的工作

00:19:19.679 --> 00:19:25.520
谢谢，好，所以今天我们有议程项目

00:19:25.520 --> 00:19:29.280
从第一个开始

00:19:29.520 --> 00:19:33.520
我认为来自丹妮尔的人

00:19:33.520 --> 00:19:38.880
好吧，这是迈克尔的要求，我不知道你是否想谈谈

00:19:38.880 --> 00:19:43.120
是的，我不知道这种双重结合的东西效果如何，我实际上是

00:19:43.120 --> 00:19:49.360
希望埃里克（Eric）和罗德（Rod）告诉我这是否合理，嗯

00:19:50.480 --> 00:19:54.880
应该有效，我的意思是理论上应该有效

00:19:54.880 --> 00:19:59.280
是的，但是它也变形了，它包括我们已经讨论过的变化

00:19:59.280 --> 00:20:04.240
大约是um使根大麻引用a

00:20:04.240 --> 00:20:07.840
链接um而不是排队

00:20:11.840 --> 00:20:15.120
你被静音了，我听不到你的声音

00:20:15.440 --> 00:20:19.200
只是看这是针对规格库的请求

00:20:19.200 --> 00:20:22.799
是的，应该是最新的回购协议

00:20:22.799 --> 00:20:26.640
嗯，这是不完整的公关，如果您确实要合并，我们希望

00:20:26.640 --> 00:20:29.679
更改底部的文件代码部分，但我

00:20:29.679 --> 00:20:32.240
只是真的想谈论架构变更

00:20:32.240 --> 00:20:49.840
但这应该使我们能够同时支持双手

00:21:00.960 --> 00:21:04.880
我的意思是为什么这是一个理论问题

00:21:04.880 --> 00:21:08.159
不能，我们没有足够的工具来尝试

00:21:08.159 --> 00:21:12.320
已经可以看到发生了什么

00:21:14.840 --> 00:21:17.840
大概

00:21:20.480 --> 00:21:23.520
我看到的东西对此很有趣

00:21:23.520 --> 00:21:31.840
是由此产生的语义

00:21:32.640 --> 00:21:36.640
是您将能够混合两种结构

00:21:36.640 --> 00:21:39.760
在同一棵树上，我不知道那是不是

00:21:39.760 --> 00:21:45.760
理想的还是故意的，实现不是真的

00:21:45.760 --> 00:21:49.280
允许混合它们，至少从我的用例来看就足够了

00:21:49.280 --> 00:21:52.880
将是一个api入口点，上面写着使用旧的东西，另一个上面写着

00:21:52.880 --> 00:21:56.240
使用新的东西，然后根据我遵循的一个

00:21:56.240 --> 00:22:00.640
路径或其他确实有意义，但加载它们，我认为其中之一

00:22:00.640 --> 00:22:02.320
令人兴奋的是，如果您看起来可以

00:22:02.320 --> 00:22:08.320
加载混合的疯狂数据，然后我稍后拒绝

00:22:08.320 --> 00:22:12.000
你的意思是当你插入那个点到实例化的时候

00:22:12.000 --> 00:22:15.440
你可以说出它需要输入什么类型

00:22:15.440 --> 00:22:19.600
它只是转移了由架构为您完成的一堆检查

00:22:19.600 --> 00:22:22.640
为此，您必须在应用程序级逻辑中执行这些操作

00:22:22.640 --> 00:22:26.000
永远是你可以做到的事情

00:22:26.000 --> 00:22:30.799
只是应该问是的，它会移动

00:22:30.799 --> 00:22:34.080
我认为一张支票

00:22:34.159 --> 00:22:41.440
ii所以这是我可以的事情，但是最好不要这样做

00:22:41.440 --> 00:22:45.440
在正式的规范中，也许这可能是

00:22:45.440 --> 00:22:49.360
可能是这里的内容，您可以将两者结合起来

00:22:49.360 --> 00:22:54.320
你知道为什么两件事都不是因为那

00:22:54.320 --> 00:22:58.400
你知道关键的联合是如此可怕

00:22:58.400 --> 00:23:04.400
我真的不想把钥匙接头烤成我们理想的规格

00:23:06.000 --> 00:23:09.840
由于沟通不畅和事故

00:23:09.840 --> 00:23:18.080
就像没有人想要它，我不认为它，但是，如此理想

00:23:18.080 --> 00:23:21.120
所以我的意思是出现这种情况的原因仅仅是我们可以有一个模式

00:23:21.120 --> 00:23:24.799
丹尼尔可以将其用于热电联产并同时实现两者

00:23:24.799 --> 00:23:28.320
所以我认为这确实使我们到了那里

00:23:28.320 --> 00:23:31.280
我想拿

00:23:34.840 --> 00:23:40.880
嗯，我想吃这个

00:23:40.880 --> 00:23:44.640
链接根节点更改，我不知道您对此杆的感觉如何

00:23:44.640 --> 00:23:50.960
嗯，我不是很热衷，但是你知道我不知道这很好吗

00:23:50.960 --> 00:23:54.320
是你讨厌这些，我讨厌这些小块

00:23:54.320 --> 00:23:59.360
就像是一个很小的方块，是的，但是您只需要创建它

00:23:59.360 --> 00:24:04.640
当您想参考某人时，您没有

00:24:04.640 --> 00:24:09.279
您必须为每个突变创建一个新的，因此您必须拥有两个

00:24:09.279 --> 00:24:13.200
在每个突变中根都需要改变的两个节点

00:24:13.200 --> 00:24:18.799
是的，我的意思是，那不是你最讨厌的最小的锁

00:24:18.799 --> 00:24:21.919
我创造像[笑声]

00:24:21.919 --> 00:24:25.679
嗯但是嗯

00:24:25.760 --> 00:24:29.039
我不知道那是什么意思

00:24:29.039 --> 00:24:32.559
像这样可以下降到底部，我们基本上可以

00:24:32.559 --> 00:24:36.559
在底部有一个统一的东西的架构，而不是像

00:24:36.559 --> 00:24:40.640
如果我们要使用它来获得文件硬币

00:24:40.640 --> 00:24:43.919
是的，虽然从根开始链接的特定变化

00:24:43.919 --> 00:24:47.120
是的，这意味着统一一个，除非

00:24:47.120 --> 00:24:50.799
除非我们建立工会，否则您为

00:24:50.799 --> 00:24:55.520
一种链接的联合或

00:24:57.039 --> 00:25:00.720
可以做到这一点，我们可以把它放在主要规格中

00:25:00.720 --> 00:25:05.760
是的，嗯，很有意义

00:25:05.760 --> 00:25:10.159
是的，您应该可以邀请它，这似乎很合理

00:25:10.480 --> 00:25:18.720
我知道这个问题的um链接到根节点和

00:25:18.720 --> 00:25:25.679
将您的配置排除在外部因素之外我并没有完全卖掉

00:25:25.679 --> 00:25:28.320
除了根节点

00:25:28.320 --> 00:25:32.080
可以与图中的其他节点互换，例如

00:25:32.080 --> 00:25:36.720
在矢量规范中，您可以拉出其他任何任意节点，然后

00:25:36.720 --> 00:25:40.880
使其成为根节点呃，这是一个不错的模式

00:25:40.880 --> 00:25:43.360
如果您的配置多一点，可以

00:25:43.360 --> 00:25:46.480
高级，您可以将其分开，因此可以将其链接但与麻线连接

00:25:46.480 --> 00:25:50.320
就像那样行不通

00:25:52.720 --> 00:25:59.520
对对对，嗯，嗯，还有另一件事要考虑的是

00:25:59.520 --> 00:26:03.440
那些设置和数据都不会进入

00:26:03.440 --> 00:26:06.320
唯一块，不能保证该方案已应用于

00:26:06.320 --> 00:26:08.159
实际上可以嵌入的唯一块

00:26:08.159 --> 00:26:12.320
变成一个不同的模式，它可能在我的

00:26:14.320 --> 00:26:19.360
你有没有看到我在说什么，所以整个根节点可能是

00:26:19.360 --> 00:26:24.320
内联到不同的结构中，您可以采用此架构，并且

00:26:24.320 --> 00:26:27.919
使用um行中的值数据，实际上您可能想要在

00:26:27.919 --> 00:26:31.520
说像哦，不，我实际上想在这里链接，因为

00:26:31.520 --> 00:26:34.720
是的，因为这没什么大不了的，所以您不会制造微小的东西

00:26:34.720 --> 00:26:38.799
你知道那时候有微小的块可以做每个突变

00:26:38.799 --> 00:26:53.760
您已经必须重新链接到

00:26:53.760 --> 00:26:58.240
是的，我想我实际上会在dagda中做到这一点

00:26:59.440 --> 00:27:02.240
不要误会

00:27:03.520 --> 00:27:09.039
嗯，要提交的变量太多了，很难说

00:27:09.039 --> 00:27:12.799
一件事客观上比另一件事差，但

00:27:12.799 --> 00:27:19.120
我想我们知道，艾滋病的规模确实花费了很多钱，因为

00:27:19.120 --> 00:27:24.559
它们明确存储了所有内容，因此一旦您将其推向更小

00:27:24.559 --> 00:27:34.240
阻止，那么cid的大小就变成了一个真正的问题

00:27:34.240 --> 00:27:39.440
我的意思是不是我不想破坏这个特定的问题，但是

00:27:39.440 --> 00:27:43.520
嗯，这件事是我们星期四开会时遇到的

00:27:43.520 --> 00:27:47.200
不，那是另一回事，也许是

00:27:47.200 --> 00:27:51.840
上周的会议嗯

00:27:51.840 --> 00:27:56.320
因为filecoin显式存储所有内容um占用了太多空间

00:27:56.320 --> 00:28:00.080
而其他区块链都可以使用隐式结构

00:28:00.080 --> 00:28:05.520
您可以即时重新计算

00:28:05.520 --> 00:28:10.159
而这又直接回到了我们所在的ipld本身的本质

00:28:10.159 --> 00:28:15.360
明确的每个块作为一个事物而存在，而这些，它们是非常具体的

00:28:15.360 --> 00:28:20.640
关于CID和导航UM，这

00:28:20.640 --> 00:28:25.039
对ipld的更基本的批评是，如果您删除了

00:28:25.039 --> 00:28:30.000
对于真正简单的结构不能隐含，只说看

00:28:30.000 --> 00:28:32.640
存在，您可以在需要的时候重新计算它们

00:28:32.640 --> 00:28:37.120
最终导致数据消耗惨重，呃

00:28:37.120 --> 00:28:39.520
而且我们正在文件硬币中看到它

00:28:39.520 --> 00:28:44.320
嗯，有一堆地方，您可以想象这些隐式结构

00:28:44.320 --> 00:28:48.880
存在并且可以重新计算，每个人都可以共识构建它们

00:28:48.880 --> 00:28:52.720
但是因为我们在磁盘上布置了所有这些块

00:28:52.720 --> 00:28:58.399
无论如何这都是巨大的，我认为值得我们思考的事情

00:28:58.399 --> 00:29:05.200
作为一个集体，猎鹰是少数几个

00:29:05.200 --> 00:29:08.720
区域链几乎可以想到您可以在哪里

00:29:08.720 --> 00:29:12.080
从字面上的状态路线开始，并得到

00:29:12.080 --> 00:29:17.679
其他地方的所有其他东西，请放心，整个事情都是

00:29:17.679 --> 00:29:19.520
纠正你基本上没有任何

00:29:19.520 --> 00:29:23.039
您在比特币中战斗的东西，您知道自己拥有

00:29:23.039 --> 00:29:27.120
链中实际上没有编码为任何散列的部分

00:29:27.120 --> 00:29:29.520
他们只是在任何地方，你都知道废话之类的东西

00:29:29.520 --> 00:29:33.520
我们没有任何东西，就像字面上您拥有小费设置键

00:29:33.520 --> 00:29:37.120
它描述了整个类似多TB的链

00:29:37.120 --> 00:29:42.960
到最后一点，但这是ipld的优点，但是

00:29:42.960 --> 00:29:46.159
没有理由不能将两个世界结合起来，因为

00:29:46.159 --> 00:29:50.320
比特币的问题是他们没有这种镜头就已经接触了它

00:29:50.320 --> 00:29:53.440
在每个块中，每个可寻址块都是

00:29:53.440 --> 00:29:57.520
嗯，他们没有那个镜头，他们只是

00:29:57.520 --> 00:30:00.320
他们只是有这种感觉，我们需要能够解决这个问题

00:30:00.320 --> 00:30:05.760
全部或以某种形式将其全部哈希，而我认为我们处于a我们处于a

00:30:05.760 --> 00:30:10.720
指出我们看待事物的方式意味着一切都可以存在，但是它

00:30:10.720 --> 00:30:15.760
不必在磁盘上存在，所以应该有一个

00:30:15.760 --> 00:30:19.919
可以在您可以说出这些部分的情况下合成两个世界

00:30:19.919 --> 00:30:24.000
如此琐碎，以至于它们不需要存在于磁盘上

00:30:24.000 --> 00:30:27.039
我不知道他们是什么意思，我无法指出目前为止的任何例子

00:30:27.039 --> 00:30:31.440
只是硬币链，也许那可能是来自

00:30:31.440 --> 00:30:34.640
不承认这一点，而是说一切都必须存在，所以

00:30:34.640 --> 00:30:37.200
因此，我们将像这样布置所有内容

00:30:37.200 --> 00:30:40.960
但是，如果您说得好，并非所有内容都必须存在，那么这些隐含的部分

00:30:40.960 --> 00:30:46.640
如果你拥有一切，那将会存在

00:30:46.960 --> 00:30:50.159
是的，我不知道那是怎么回事，但这绝对是

00:30:50.159 --> 00:30:54.240
是很大的代价，是的，我相信当我们花一点时间

00:30:54.240 --> 00:30:57.200
花费更多的时间来实际分析链条，而您

00:30:57.200 --> 00:31:00.320
从一般的角度知道您对结构的内部了解

00:31:00.320 --> 00:31:03.200
而我们正在做的事情将最终导​​致这种情况

00:31:03.200 --> 00:31:06.159
会像哦，他们实际上需要所有这些，因为

00:31:06.159 --> 00:31:10.399
如果您考虑一下，连锁店的实际运作方式是前所未有的

00:31:10.399 --> 00:31:15.600
每件事都需要每24小时ping您一次

00:31:15.600 --> 00:31:18.960
就像那不是链条通常做的

00:31:18.960 --> 00:31:22.000
是的

00:31:29.360 --> 00:31:33.279
就像拿呃带走整个矢量ID系统一样

00:31:33.279 --> 00:31:36.640
从字面上看，嗯，如何增加主键，你知道

00:31:36.640 --> 00:31:39.760
一个整数，当您有链重组时，它是

00:31:39.760 --> 00:31:44.640
像这样在内部重写类型链

00:31:44.640 --> 00:31:48.240
恩用一个简单的整数指向事物，

00:31:48.240 --> 00:31:50.880
当您进行重组时，您需要返回

00:31:50.880 --> 00:31:55.039
将先前状态中的每个整数都匹配到一个稳定地址

00:31:55.039 --> 00:31:58.880
并将它们重写为现在在链中的新整数，因为

00:31:58.880 --> 00:32:03.039
状态是不同的，你继续前进，所以即使这种

00:32:03.039 --> 00:32:07.200
他们已经喜欢剃掉的东西

00:32:07.200 --> 00:32:10.960
通过基本不使用无密码稳定地址

00:32:10.960 --> 00:32:14.159
他们就像所有这些真正的编码

00:32:14.159 --> 00:32:18.880
对于所有您知道的分区人口之类的东西

00:32:18.880 --> 00:32:24.159
所以是的，我实际上不确定

00:32:24.159 --> 00:32:29.760
不用刮胡子，我不知道我们实际上会对此有所了解

00:32:29.760 --> 00:32:34.559
在这个阶段，他完成了最喜欢的人的生日照像

00:32:34.559 --> 00:32:37.440
我想的整个事情

00:32:37.840 --> 00:32:40.880
我不知道我们是否想花太多时间在这个话题上

00:32:40.880 --> 00:32:44.720
是的，收入很高，我是说我认为我们需要看一下三角洲，我的怀疑是

00:32:44.720 --> 00:32:50.880
那里的子树总是一起改变

00:32:50.880 --> 00:32:56.480
能够折叠链接对我们有益，因为

00:32:56.480 --> 00:33:00.559
他们没有被其他地方引用

00:33:00.559 --> 00:33:05.760
但是我没有ii认为我们需要工具来识别那些地方

00:33:05.760 --> 00:33:08.799
以便我们可以更好地了解如何

00:33:08.799 --> 00:33:13.039
结构化的东西我不认为我们只是一头雾水

00:33:14.399 --> 00:33:18.240
是的，这是汉普顿问题的后面

00:33:18.240 --> 00:33:21.440
好，所以从根链接到根

00:33:21.440 --> 00:33:27.360
根的配置让我们称之为它不是我不是它的忠实粉丝，但是它

00:33:27.360 --> 00:33:30.880
它是否确实有助于我们支持您所知道的硬币

00:33:30.880 --> 00:33:34.960
与其他模式更改，它也只是打开

00:33:34.960 --> 00:33:38.080
人们出现的用例之门

00:33:38.080 --> 00:33:40.880
并说我不想将配置与数据一起存储

00:33:40.880 --> 00:33:45.120
我在我的代码中有它，我认为这是一个合法的请求，而远处的硬币有

00:33:45.120 --> 00:33:48.799
其他人会有，也许这就是足够的理由

00:33:48.799 --> 00:33:53.519
为此，您要完全更改它，或者您执行

00:33:53.519 --> 00:33:56.399
你想参加工会

00:33:56.640 --> 00:34:01.200
我不知道，但是我可能对链接没问题

00:34:01.200 --> 00:34:04.799
这只是我对小块的感觉

00:34:04.799 --> 00:34:08.879
不得不不断地以大量的诱变来变异

00:34:08.879 --> 00:34:12.960
就像很多次一样，这不是因为你没有创造任何额外的东西

00:34:12.960 --> 00:34:15.440
只是您只是在移动链接的位置，因为另一个日期是

00:34:15.440 --> 00:34:21.839
插入上方

00:34:33.440 --> 00:34:36.800
像是强硬的意见，但像工会听起来像

00:34:36.800 --> 00:34:41.679
两全其美，因为喜欢你实际所做的就是喜欢你

00:34:41.679 --> 00:34:44.720
要么有一个使它隐含的硬币

00:34:44.720 --> 00:34:48.480
或者您基本上希望将其放在块中

00:34:48.480 --> 00:34:51.760
基本上与工会一起处理这两个案件

00:34:51.760 --> 00:34:56.639
如果您当然可以，那么可以用一个很小的块来做这件事，但是

00:34:56.639 --> 00:35:05.599
你可能不喜欢你为什么要这么做，迈克尔，我可以说没关系

00:35:07.920 --> 00:35:12.880
是的也许是正确的，只是当我们越做越多

00:35:12.880 --> 00:35:17.359
我们是说还有更多选择的余地

00:35:17.359 --> 00:35:19.680
可以做你喜欢的事情我们知道你不是我们没有出现

00:35:19.680 --> 00:35:24.480
这是做这件事的最好方法，理想的情况是就像你不

00:35:24.480 --> 00:35:27.119
需要做出这些复杂的选择，因为我们已经为您做出了选择

00:35:27.119 --> 00:35:32.160
嗯，因为这里有很多微妙的互动，

00:35:32.160 --> 00:35:36.000
对于我们来说，只是让ipld成为您必须了解所有内容的东西

00:35:36.000 --> 00:35:39.920
做出明智的选择不是一个好地方

00:35:39.920 --> 00:35:41.680
在那里，这就是所有的地方

00:35:41.680 --> 00:35:44.960
这些这些工会正在使我们获得成功，就像您可以在此布置它一样

00:35:44.960 --> 00:35:48.079
方式或可能是这种方式，或者您可以将两者结合使用，也可能是这样

00:35:48.079 --> 00:35:51.839
我的意思是看实现可以做的其他事情

00:35:51.839 --> 00:35:54.320
这些决定，他们将具有相同的默认值，

00:35:54.320 --> 00:35:57.440
他们将默认使用作者认为相同的操作

00:35:57.440 --> 00:36:00.160
然后他们只是会知道您对珊瑚礁的支持

00:36:00.160 --> 00:36:04.000
完全合理，是的，我不是，我不认为像我们这样

00:36:04.000 --> 00:36:07.119
需要让这种积极进取的选择

00:36:07.119 --> 00:36:10.720
规范ii确实认为实施应

00:36:10.720 --> 00:36:12.960
做一些

00:36:16.079 --> 00:36:19.839
我们之前提到的想法应该在规范中写一些东西

00:36:19.839 --> 00:36:25.920
那是简洁而干净的，这是我们想要的，然后推入

00:36:25.920 --> 00:36:28.240
替代方案作为附录，可以

00:36:28.240 --> 00:36:33.599
是这些实施选择中的任何一个，甚至是其中的几个，

00:36:33.599 --> 00:36:37.359
突出显示它们以形成对比，就像您可能想要做的实现者一样

00:36:37.359 --> 00:36:40.640
这在这里做了有趣的结合，因为它在实践中真的很有用

00:36:40.640 --> 00:36:44.800
由于这种兼容性原因，我认为其中有几个

00:36:44.800 --> 00:36:49.440
文件显示实际上是超级合理的

00:36:50.720 --> 00:36:54.000
那有什么实际的用例呢？

00:36:54.000 --> 00:36:57.599
就像支持一样

00:36:57.599 --> 00:37:01.680
就像您实施它总是执行以下任一操作一样，您不总是喜欢吗？

00:37:01.680 --> 00:37:05.599
他们不，我们实际上是在实现两者

00:37:05.599 --> 00:37:07.280
就像从字面上我们正在做的是

00:37:07.280 --> 00:37:10.960
计划两者兼有，因此我们至少为此需要统一的模式，但是它

00:37:10.960 --> 00:37:13.280
不必是主要模式，也可以只是底部

00:37:13.280 --> 00:37:17.760
是的，所以我要在javascript中做的是将前端算法片段

00:37:17.760 --> 00:37:25.040
然后是后端布局，但像ipld prime这样的地方是

00:37:25.040 --> 00:37:28.800
这变得非常棘手，因为布局部分与

00:37:28.800 --> 00:37:32.400
算法部分，我想我想你会说丹尼尔

00:37:32.400 --> 00:37:35.599
这样做的途径，但您最终不得不喜欢潜艇

00:37:35.599 --> 00:37:39.839
包，它只会变得凌乱和尴尬，所以如果有的话

00:37:39.839 --> 00:37:43.040
是一种将它们压缩为一个实现的方法

00:37:43.040 --> 00:37:47.839
然后那是一种理想

00:37:49.280 --> 00:37:52.480
我认为这在理论上是可能的，但它进入了

00:37:52.480 --> 00:37:58.640
我可以不知道要使用哪个单词，我可以通过代码生成代码吗？

00:37:58.640 --> 00:38:02.720
发电机足够喜欢让我这样做，我认为那可能是匆忙的

00:38:02.720 --> 00:38:05.839
太多了

00:38:06.160 --> 00:38:08.880
是的，当我们愿意的时候，我们不想让他们永远坚持下去

00:38:08.880 --> 00:38:11.920
准备打架

00:38:12.320 --> 00:38:15.200
嗯，也许eric对代码生成器是否

00:38:15.200 --> 00:38:20.800
足够聪明以支持那种魔法

00:38:22.880 --> 00:38:28.000
长话短说不，我们一个人都没有

00:38:31.040 --> 00:38:34.240
但是，是的，我认为沃尔克的问题也很好

00:38:34.240 --> 00:38:38.079
就像呃，在追求这一特定主题的统一架构的想法时一样

00:38:38.079 --> 00:38:42.880
实施，我认为我们正在大力索引

00:38:42.880 --> 00:38:47.440
的成本和实用性

00:38:47.440 --> 00:38:51.839
这个特定的go代码生成器，它的成本相对较高

00:38:51.839 --> 00:38:56.480
生成具有两个不同模式的两个完整程序包

00:38:56.960 --> 00:39:01.280
只要我们意识到这一点，就可以做出很好的权衡取舍

00:39:01.280 --> 00:39:03.599
但是我们可能确实想真正了解文档

00:39:03.599 --> 00:39:08.240
因为如果存在模式逻辑的其他完全实现，

00:39:08.240 --> 00:39:12.240
成本与此不同，我们可能不会

00:39:12.240 --> 00:39:16.240
感觉到想要做出所有选择的欲望，就像这样

00:39:16.240 --> 00:39:19.119
我在javascript中使用模式进行验证，就像我实际上更喜欢

00:39:19.119 --> 00:39:22.160
仅有两种模式，并找出要应用的模式，然后

00:39:22.160 --> 00:39:28.240
正确地验证不同，是的，没关系

00:39:28.240 --> 00:39:32.400
是的，让我们把这个留给我，也许我会提出一些建议

00:39:32.400 --> 00:39:36.079
在文档的底部说明了他的选择，这就是您的方式

00:39:36.079 --> 00:39:40.960
可以设计一个支持这些替代方案的模式

00:39:40.960 --> 00:39:44.640
嗯，酷，我知道我们还有点时间离开杆了，你想过去吗

00:39:44.640 --> 00:39:48.079
你等着的幻灯片我又有一张

00:39:48.079 --> 00:39:51.599
哦，你对不起对不起对不起对不起

00:39:51.599 --> 00:39:56.400
是不是如果我真的是关于弦乐的

00:39:56.400 --> 00:40:00.800
想提起它，所以现在我才刚收到请求

00:40:00.800 --> 00:40:05.839
在dag上的javascript平台协议缓冲区上

00:40:05.839 --> 00:40:10.400
实现有点像ipfs正在使用的

00:40:10.400 --> 00:40:13.920
实际上是关于[音乐]

00:40:13.920 --> 00:40:22.960
这个想法是链接仅具有大于31的字节

00:40:22.960 --> 00:40:27.440
所以基本上是控制字符所以基本上，这个想法是在javascript中

00:40:27.440 --> 00:40:33.440
链条的任何等分线控制字符

00:40:33.440 --> 00:40:38.720
链接名称，并希望这能使它成功

00:40:38.720 --> 00:40:41.599
显然，背景是如果您包含这些字符并且您

00:40:41.599 --> 00:40:44.880
带有这些字符的文件名会在输出上发生什么，例如

00:40:44.880 --> 00:40:47.760
您将其打印在终端上的某个地方或其他地方

00:40:47.760 --> 00:40:52.000
你得到的控制角色可能会妨碍你

00:40:52.000 --> 00:40:56.079
一切，然后我简短地讨论了这一点

00:40:56.079 --> 00:40:59.920
与亚历克斯一起，这是否应该在

00:40:59.920 --> 00:41:03.680
平台协议缓冲区层或是否应该

00:41:03.680 --> 00:41:09.280
因为它基本上是在打印输出层上打印东西

00:41:10.960 --> 00:41:17.520
我认为这很有意义，所以彼得想说些​​什么

00:41:17.520 --> 00:41:21.599
像ii一样的意见看到了这个，我看到了这个……

00:41:21.599 --> 00:41:28.160
这个问题刚刚出现在列表中的，我真的很喜欢

00:41:28.160 --> 00:41:32.800
对它很生气，因为像剥东西

00:41:32.800 --> 00:41:36.319
这就像我无法做的唯一事情，没有其他工具可以做到

00:41:36.319 --> 00:41:38.720
从三年前开始有一个问题

00:41:38.720 --> 00:41:42.079
当您执行操作时，使用控制字符对此进行了精确的探索

00:41:42.079 --> 00:41:45.760
基本上就像您知道的那样将内容写到屏幕上

00:41:45.760 --> 00:41:51.680
嗯，终端会解释，实际上没有其他工具会丢弃这些

00:41:51.680 --> 00:41:56.079
角色只是正确地称呼他们ls做正确的事情tartar

00:41:56.079 --> 00:41:59.119
写作等等等等，我们的答案就是我们要做的

00:41:59.119 --> 00:42:04.240
放下它们，我的意思是说我们需要喜欢要么逃避

00:42:04.240 --> 00:42:06.960
早上给他们写代码，或者您知道或以某种方式表明有一些

00:42:06.960 --> 00:42:10.480
他们只是放下更多的东西，就像

00:42:10.480 --> 00:42:13.760
傻我不知道

00:42:15.040 --> 00:42:18.640
好吧，我是我，我们也想完全摆脱他们

00:42:18.640 --> 00:42:22.000
喜欢某某某某也很重要所以它真的

00:42:22.000 --> 00:42:27.119
因此在javascript方面的本次PR中只有这样

00:42:27.119 --> 00:42:31.280
这真的像是将其作为javascript对象返回时一样

00:42:31.280 --> 00:42:35.599
所以当然就像创建哈希一样，等等

00:42:35.599 --> 00:42:38.720
保留原始数据，因为您不想拥有它

00:42:38.720 --> 00:42:41.359
改变了，但这只是为了你回来

00:42:41.359 --> 00:42:47.280
他们删除那些字符的javascript对象um

00:42:49.599 --> 00:42:52.240
他们在什么情况下将它们剥离掉，我想那是我不想要的

00:42:52.240 --> 00:42:54.960
理解就像在调用该字符串时

00:42:54.960 --> 00:42:58.560
还是喜欢，如果你喜欢，如果你，如果你，如果你

00:42:58.560 --> 00:43:02.960
反序列化，因此您已经序列化了协议

00:43:02.960 --> 00:43:06.720
缓冲区，然后将其反序列化为javascript，然后呢

00:43:06.720 --> 00:43:10.800
您会在javascript中看到，然后说点名称来获取

00:43:10.800 --> 00:43:13.359
链接将删除那些字符

00:43:13.359 --> 00:43:17.760
就像只是删除，这是当前公关正在做的事情，

00:43:17.760 --> 00:43:19.839
而且你不能正确地往返他们，这是

00:43:19.839 --> 00:43:23.760
这很遥远，就像您尝试对其进行编码一样，您很不走运

00:43:23.760 --> 00:43:27.680
不，请在聊天中删除与此相关的链接

00:43:27.680 --> 00:43:34.720
嗯，如果你愿意的话，他们也在等待中

00:43:34.720 --> 00:43:38.720
我也要把它发布在聊天中，也要放在议程项目的注释中

00:43:38.720 --> 00:43:45.359
啊，对不起，支票是呃，它在哪里[音乐]

00:43:45.359 --> 00:43:50.160
嗯抱歉

00:43:50.240 --> 00:43:54.079
所以这是公关，所以会发生什么

00:43:54.079 --> 00:43:57.839
在内部它仍然保持它周围，所以很清楚

00:43:57.839 --> 00:44:04.720
干净的往返旅行，就算您访问该物业，您也可以

00:44:04.720 --> 00:44:09.839
不要用JavaScript获取它

00:44:10.720 --> 00:44:17.359
所以好吧，基本上，如果您有对象并尝试对其进行编码

00:44:17.359 --> 00:44:20.319
它会像魔术般放回这些东西，但是如果您

00:44:20.319 --> 00:44:23.680
例如创建具有相同内容的新对象，那么您将最终

00:44:23.680 --> 00:44:28.240
在你的内心有一个新的是是的

00:44:31.200 --> 00:44:34.800
所以当你问名字的时候

00:44:34.880 --> 00:44:39.599
我想这是我想打印出的名字

00:44:39.599 --> 00:44:43.680
这就是为什么您会使用该版本的原因，为什么我们不给

00:44:43.680 --> 00:44:49.680
sid的基数32字符串表示形式，这是我们打印的标准方式

00:44:49.680 --> 00:44:54.880
并以人类可读的方式显示出来，不是，不是，不是，不是，不是

00:44:54.880 --> 00:45:00.240
cad这是它的名称是它的名称

00:45:00.240 --> 00:45:05.599
链接显然是文件名，因此本质上是一个映射键，但是在

00:45:05.599 --> 00:45:09.920
像protobuf这样的怪异方式，这需要

00:45:09.920 --> 00:45:14.000
无论在哪里消费，我都不明白为什么我们需要破坏我们的数据模型

00:45:14.000 --> 00:45:18.000
我的意思是这个包不是纯数据模型

00:45:18.000 --> 00:45:23.680
新的是js dag pb，所以我绝对不会在那儿做

00:45:23.680 --> 00:45:27.920
但是出于同样的原因，我也不想在这里做

00:45:28.800 --> 00:45:35.280
是的，所以基本上，答案是我们应该把它放进去

00:45:35.280 --> 00:45:39.040
就像在更高的层上一样

00:45:39.040 --> 00:45:43.119
像把它尽可能地往外推一样

00:45:43.119 --> 00:45:45.760
但是因为这是一个问题，所以这通常是一个问题，而不仅仅是

00:45:45.760 --> 00:45:50.480
关于这个领域，只要有一个字符串

00:45:50.480 --> 00:45:53.280
你在乎这个

00:45:54.079 --> 00:46:01.839
甚至就像我说的那样，无论他们如何推动

00:46:04.000 --> 00:46:07.280
是的，所以它是如此，甚至像

00:46:07.280 --> 00:46:11.760
就像八弦的有效职责一样，所以我们所说的不像

00:46:11.760 --> 00:46:14.000
我们不是在谈论上下文，而是在谈论任意字节

00:46:14.000 --> 00:46:17.040
就像是字符串的值，因为它是第一个

00:46:17.040 --> 00:46:20.880
s键的字符，就像接下来的内容一样

00:46:20.880 --> 00:46:26.720
好的，好的，嗯[音乐]

00:46:26.720 --> 00:46:31.440
 IPL团队说不可以

00:46:31.839 --> 00:46:34.960
好吧，这是我的意思之一

00:46:34.960 --> 00:46:39.440
您将不得不对此做出回应，但是一个原因是他们是否想要

00:46:39.440 --> 00:46:42.640
我的成长之路迁移到了下一代

00:46:42.640 --> 00:46:46.960
在堆栈中，这只是行不通，根本不会飞到那里

00:46:46.960 --> 00:46:49.520
因为我们对数据模型形式非常严格

00:46:49.520 --> 00:46:52.800
因为对象形状能够往返并且没有

00:46:52.800 --> 00:46:55.359
这些特殊属性中的任何一个都没有特殊属性，没有隐藏

00:46:55.359 --> 00:46:58.720
属性没有重写任何东西，这就是

00:46:58.720 --> 00:47:02.079
你得到的是那里存在的东西，所以你必须处理所有的垃圾

00:47:02.079 --> 00:47:07.520
如果您遇到问题，请向上堆叠，我们不会修补这些

00:47:07.520 --> 00:47:14.079
小事一路走下去，是的，因为如果你要的话，

00:47:14.079 --> 00:47:17.280
如果您是来此dag pb的来回，则另外一个论点

00:47:17.280 --> 00:47:20.880
出于某种原因将数据导入daxybore

00:47:20.880 --> 00:47:23.920
您有相同的问题，但现在在daxybor中没有这些

00:47:23.920 --> 00:47:27.040
在javascript中定义的属性，它们只是从

00:47:27.040 --> 00:47:30.720
数据从未命名的数据中出现，并且

00:47:30.720 --> 00:47:35.359
在代码中无法破解，因此对于字符串来说通常是个问题

00:47:35.359 --> 00:47:39.119
他们将在那里，你必须与他们打交道

00:47:39.119 --> 00:47:43.280
好的

00:47:43.680 --> 00:47:50.559
很酷，是的，谢谢您的输入，我会写一个响应，好吧，我要去

00:47:50.559 --> 00:47:52.000
问你要怎么写

00:47:52.000 --> 00:47:58.880
回复，是的，是的，太棒了，谢谢，嗯，很酷，嗯，那是

00:47:58.880 --> 00:48:04.079
是的，没什么别的

00:48:04.880 --> 00:48:11.920
好吧，是的，所以我们还有时间，所以，迈克尔，你想说点什么

00:48:11.920 --> 00:48:15.040
我实际上只是想说像杆可以显示幻灯片

00:48:15.040 --> 00:48:20.160
他写的，我实际上很想听罗迪克

00:48:20.160 --> 00:48:23.760
而不是我，看看那有多好

00:48:23.760 --> 00:48:28.480
这些工作的传播方式已经发生了

00:48:28.480 --> 00:48:34.400
哦，那意味着共享一个窗口并实际拉动

00:48:34.400 --> 00:48:37.440
他们在这台电脑上

00:48:37.520 --> 00:48:41.380
他们在Google [音乐]中

00:48:42.000 --> 00:48:49.839
是的，他们很抱歉，我只是在笔记本电脑上做到了这一点，

00:48:50.240 --> 00:48:53.920
不是在这里挂

00:48:54.160 --> 00:48:57.280
切换帐户和资料

00:49:00.240 --> 00:49:02.640
我实际上是在编辑幻灯片，而前几天您正在展示它们

00:49:02.640 --> 00:49:08.480
迈克尔，因为我看到了哦，真的哦，很高兴知道我需要

00:49:08.480 --> 00:49:12.319
很快将它们复制到新的演示文稿中，以便

00:49:12.640 --> 00:49:16.480
嗯是的好吧好吧让我们快速看一下我是否可以在七分钟内完成

00:49:16.480 --> 00:49:19.760
可能不是，但让我们看看

00:49:20.640 --> 00:49:23.520
让我们分享一下

00:49:28.720 --> 00:49:32.319
好吧，你看到那个屏幕

00:49:36.000 --> 00:49:39.200
所以，这就是迈克尔一直在与mikola合作的过程

00:49:39.200 --> 00:49:42.720
来回敲打它，发生了很多有趣的讨论

00:49:42.720 --> 00:49:45.680
那里的麦卡洛一直在堆焊这些

00:49:45.680 --> 00:49:50.480
有趣的想法，但基本的

00:49:50.480 --> 00:49:54.800
在这方面的核心，我认为理解真的很有趣

00:49:54.800 --> 00:49:58.880
就像这一个关键部分一样，我认为如果您能做到这一点，那么您可以

00:49:58.880 --> 00:50:02.720
看看发生了什么事，所以这就是我们要解决的问题

00:50:02.720 --> 00:50:07.760
尝试我们真正想要的是一种存储方式

00:50:07.760 --> 00:50:12.559
排序的条目列表，就像我们数据的圣杯

00:50:12.559 --> 00:50:16.960
一旦有了结构，我们就可以用那个嗯做很多事情，也许

00:50:16.960 --> 00:50:19.760
我们想要的东西有不同的变化

00:50:19.760 --> 00:50:23.280
因此，也许有不同的呃数据结构可以做到这一点

00:50:23.280 --> 00:50:27.359
我们，因为我们对他们有不同的效用

00:50:27.359 --> 00:50:30.400
但是但实际上一旦我们拥有了一些我们可以

00:50:30.400 --> 00:50:35.040
存储排序，我们可以以各种方式进行查询，以进行范围查询

00:50:35.040 --> 00:50:38.720
嗯，那么我们可以利用它来产生各种各样的

00:50:38.720 --> 00:50:43.599
在此之上非常有趣的工具，所以现在我们有了一个汉普顿

00:50:43.599 --> 00:50:46.559
实际上，我们的通用数据结构可满足多种用途

00:50:46.559 --> 00:50:49.200
但是嗯，真的很棒

00:50:49.200 --> 00:50:52.240
属性，但是缺少排序意味着

00:50:52.240 --> 00:50:57.040
它不只是一个通用的数据结构，所以让我们

00:50:57.040 --> 00:51:00.160
说我们在这里有一个清单，我们想对这个排序

00:51:00.160 --> 00:51:05.680
这些条目是通用问题空间吗

00:51:05.680 --> 00:51:08.800
他们在这里摆放的位置就像是cid的字符串一样，但它们可能是

00:51:08.800 --> 00:51:11.040
事实上，它们可能只是字符串

00:51:11.040 --> 00:51:14.400
um在一个列表中，您想存储一组字符串

00:51:14.400 --> 00:51:18.319
嗯，但是您可以在上面运行比较操作

00:51:18.319 --> 00:51:23.200
嗯，把它们整理好，还有一个附加的约束

00:51:23.200 --> 00:51:26.480
在这里做这项工作，这是他们应该是独特的，我认为

00:51:26.480 --> 00:51:30.000
一般而言，这是一个不错的属性，因为您可以解决

00:51:30.000 --> 00:51:33.440
如果您通过多种方式拥有非唯一物品

00:51:33.440 --> 00:51:36.880
嗯，所以幼稚的解决方案显然是使

00:51:36.880 --> 00:51:39.920
只是一棵普通的树，您在其中分支

00:51:39.920 --> 00:51:43.200
最大分支因子，所以在这里我们有一个

00:51:43.200 --> 00:51:46.720
最大分支因子为四，可将我们的数据分为两部分，并给我们一个

00:51:46.720 --> 00:51:51.359
指向两个um的根节点，除了

00:51:51.359 --> 00:51:55.359
突变成为一个问题，因为如果您要插入

00:51:55.359 --> 00:51:58.960
你有这个改组的问题，所以插入

00:51:58.960 --> 00:52:02.640
嗯，cr会产生溢出，从而影响

00:52:02.640 --> 00:52:05.359
如果在正确的位置进行操作，可能会影响整棵树，因此您必须

00:52:05.359 --> 00:52:08.240
重写每个节点，如果您在

00:52:08.240 --> 00:52:12.160
它的开始，所以这是一个令人讨厌的解决方案

00:52:12.160 --> 00:52:15.599
我们关心的与删除相同的东西

00:52:15.599 --> 00:52:18.800
腾出空间，您必须重新整理所有内容以备不时之需

00:52:18.800 --> 00:52:22.000
只是为了获得具有最大分支因子的规范形式，所以

00:52:22.000 --> 00:52:29.359
真的不是一个令人愉快的解决方案，所以迈克尔和尼古拉的想法

00:52:29.359 --> 00:52:33.440
一直在努力将这些条目视为

00:52:33.440 --> 00:52:37.359
它们是您正在通过分块算法进行处理的东西

00:52:37.359 --> 00:52:42.880
嗯，那对我来说这就是

00:52:42.880 --> 00:52:46.079
从不同角度看待这些事物，本质上将它们视为一连串的

00:52:46.079 --> 00:52:50.160
就像您正在扫描的一串字节并找到一些

00:52:50.160 --> 00:52:54.880
以可预测的方式将它们切成薄片的方式，因此，如果您

00:52:54.880 --> 00:53:00.240
如果您浏览此列表，在哪里可以找到可预测的断点

00:53:00.240 --> 00:53:04.400
你总是可以打破呃，把它们变成节点

00:53:04.400 --> 00:53:07.599
您可以使用分块和分块算法来做到这一点，

00:53:07.599 --> 00:53:11.440
您实际上可以执行非常简单的分块算法，所以在呃

00:53:11.440 --> 00:53:15.599
以这种形式，mccollum可能实际上已经使用了适当的形式

00:53:15.599 --> 00:53:19.200
分块um函数，所以michael刚决定

00:53:19.200 --> 00:53:22.400
好吧，我们这里有形式上的随机性

00:53:22.400 --> 00:53:25.040
cid形式的可预测的随机性

00:53:25.040 --> 00:53:31.040
所以嗯，如果你有一个很好的情况下，这个例子中的cid

00:53:31.040 --> 00:53:33.200
呃，你有，但是你，但是，如果你只是有一个

00:53:33.200 --> 00:53:37.359
该条目的哈希函数，因此，如果它只是一个字符串

00:53:37.359 --> 00:53:41.839
然后对字符串进行哈希处理，然后就可以从中获取身份

00:53:41.839 --> 00:53:45.280
该哈希函数um以某种方式打开

00:53:45.280 --> 00:53:49.760
可预测地或稳定地变成a内的一个数

00:53:49.760 --> 00:53:54.400
一定范围内，所以在迈克尔当前的范围内

00:53:54.400 --> 00:53:58.319
迭代仅占用最后四个字节，您将获得一个32位整数

00:53:58.319 --> 00:54:02.079
您的范围是零到最大值，您将赢得32。

00:54:02.079 --> 00:54:06.480
嗯，然后您可以选择一个分支因子

00:54:06.480 --> 00:54:10.720
这将为您提供切分这些东西的方式

00:54:10.720 --> 00:54:14.079
因此，如果您将索引空间划分为

00:54:14.079 --> 00:54:17.359
您的分支因子，所以假设您的分支因子为4

00:54:17.359 --> 00:54:21.040
您将最大u和32除以4，然后得到

00:54:21.040 --> 00:54:25.200
您只说四个插槽中的一个

00:54:25.200 --> 00:54:29.280
是我们分支的地方，所以如果有任何东西低于最低的一个

00:54:29.280 --> 00:54:35.280
那是一个休息，所以让我们来拿这些东西

00:54:35.280 --> 00:54:38.480
散列它们，并将它们转变为这些身份，

00:54:38.480 --> 00:54:43.040
那你说我们的门槛是这个较低的四分之一

00:54:43.040 --> 00:54:48.720
标识空间的地址空间和该较低四分之一的空间之和

00:54:48.720 --> 00:54:53.040
每当有人击中时，我们都应该在那儿休息，这样

00:54:53.040 --> 00:54:57.520
使我们有四分之一的概率击中突破，然后使我们

00:54:57.520 --> 00:55:01.839
大约四分之四左右的那个分支因子

00:55:01.839 --> 00:55:06.640
在这里，我们有两个这样的条目命中了um

00:55:06.640 --> 00:55:12.720
 um阈值，所以我们只是分块，所以我们说好

00:55:12.720 --> 00:55:15.599
我们我们，当我们长期阅读时，我们

00:55:15.599 --> 00:55:19.520
找到一个相遇的人，所以我们要说这是我们的分支

00:55:19.520 --> 00:55:23.280
因此，请将这些作为我们的封闭操作

00:55:23.280 --> 00:55:27.760
我们的节点，然后您最终将您的集合切片

00:55:27.760 --> 00:55:33.920
基于此关闭操作进入一组节点，所以我们有一个关闭

00:55:33.920 --> 00:55:38.799
在这里，在这里靠近一个，这给了我们三个节点，看来

00:55:38.799 --> 00:55:41.440
像这些东西有点草率，不完全是

00:55:41.440 --> 00:55:46.319
合适的尺寸，这是真的，他们弯曲了

00:55:46.319 --> 00:55:52.880
在目标尺寸um附近进出

00:55:52.880 --> 00:55:56.400
因为您正在寻找这一点，可以在

00:55:56.400 --> 00:56:00.880
分支因子为四分之一或一的概率

00:56:00.880 --> 00:56:05.760
所以你有一个目标，而不是一个绝对的目标

00:56:05.760 --> 00:56:09.119
但是伸缩已成为我们的数据结构的重要属性，例如

00:56:09.119 --> 00:56:13.599
汉普特人在许多不同的方面使用了很多屈曲

00:56:13.599 --> 00:56:16.319
表格，但随后您应用相同的算法

00:56:16.319 --> 00:56:21.599
一直到树的顶部，所以您可以对这些哈希和索引

00:56:21.599 --> 00:56:24.960
以及下一层中的条目

00:56:24.960 --> 00:56:28.559
在下一层中，它们只是链接到基础层

00:56:28.559 --> 00:56:31.839
它们是起始索引，以便您以后可以遍历

00:56:31.839 --> 00:56:34.559
但您可以对此运行相同的哈希并执行相同的操作，因此您可能

00:56:34.559 --> 00:56:39.599
最后也会在下一层分裂，所以如果你

00:56:39.599 --> 00:56:42.000
知道使这个阈值低于

00:56:42.000 --> 00:56:45.920
阈值，然后您再次分支，因此最终会出现多个层

00:56:45.920 --> 00:56:50.079
而且您只要继续运行算法，直到获得一个根即可

00:56:50.079 --> 00:56:54.799
um，然后插入表示您只需对集合再次运行算法，

00:56:54.799 --> 00:56:58.640
他们都是因为这很稳定他们都产生相同的

00:56:58.640 --> 00:57:03.119
索引相同的身份，您仍然会有相同的休息时间，因此

00:57:03.119 --> 00:57:07.280
新的然后是新的元素要么适合集合，要么引入新的突破

00:57:07.280 --> 00:57:10.559
所以在这里，我们在顶部有一个

00:57:10.559 --> 00:57:14.720
恰好适合该集合，因此该突变仅是那一个

00:57:14.720 --> 00:57:20.160
沿着树um或第二个树的路径是我们要分割树的路径

00:57:20.160 --> 00:57:23.359
结成两个，所以再次概率

00:57:23.359 --> 00:57:30.960
一个分支因子，您将获得一个新的分裂，引入新的节点

00:57:31.680 --> 00:57:36.559
然后要删除的内容相同，则可以删除这样的元素

00:57:36.559 --> 00:57:39.520
这里只是一个节点的中间，或者你

00:57:39.520 --> 00:57:43.520
可能会删除拆分，在这种情况下，您将要加入节点

00:57:43.520 --> 00:57:48.160
所以这些突变并不总是

00:57:48.160 --> 00:57:51.760
它们并不总是只影响一个节点和树上的路径

00:57:51.760 --> 00:57:58.720
它们也会影响邻居和嗯，就像您思考的方式一样

00:57:58.720 --> 00:58:02.319
那棵树起作用，你可以做到这一点吗

00:58:02.319 --> 00:58:07.040
当您在树上时会很复杂，因为您要在此处生成新数据，因为

00:58:07.040 --> 00:58:10.799
cids发生变化，因此这些东西可能会稍微改组，但

00:58:10.799 --> 00:58:15.839
您永远不会在这种情况下传播

00:58:15.839 --> 00:58:18.319
整个树肯定不在基础层

00:58:18.319 --> 00:58:22.880
但是树中间的突变成本会比树中的突变成本高

00:58:22.880 --> 00:58:25.119
障碍或其他数据结构，但是

00:58:25.119 --> 00:58:28.319
这是相对最小的，并且也在概率之内

00:58:28.319 --> 00:58:35.440
您定义的分支因子的总数um，所以这就是um

00:58:35.440 --> 00:58:39.440
这是什么说明了这一点，可能是

00:58:39.440 --> 00:58:43.200
花了你，这是一个错误的情况，所以不是

00:58:43.200 --> 00:58:48.079
是的，您可以将这个推到极限，所以我们插入的位置

00:58:48.079 --> 00:58:54.400
嗯，从这里开始，我们插入b，然后我们最终创建一个新的

00:58:54.400 --> 00:58:58.960
SC ID在这里，呃休息一下，然后下一个休息一下

00:58:58.960 --> 00:59:03.359
一个新的CID，因为您将其拆分了，所以它可以正常工作哦，您插入了一个

00:59:03.359 --> 00:59:05.599
在这里，然后您创建了一个新城市

00:59:05.599 --> 00:59:08.640
在阈值之内，所以在第二级

00:59:08.640 --> 00:59:11.839
这三个节点，然后您在此处执行相同的操作，然后您有了一个

00:59:11.839 --> 00:59:16.000
休息，所以您最终会在这里创建更多的关卡

00:59:16.000 --> 00:59:19.839
但是随着时间的流逝，它们又重新回到了

00:59:19.839 --> 00:59:24.240
正确的形状um查找操作您知道吗

00:59:24.240 --> 00:59:28.160
只是一棵树而已，您只需要向左走

00:59:28.160 --> 00:59:31.920
嗯，只是转到比您要查找的索引低的节点，所以请看

00:59:31.920 --> 00:59:36.000
间接索引不足八项，对不起操作便宜

00:59:36.000 --> 00:59:42.240
um大小的操作很昂贵um但我想我

00:59:42.240 --> 00:59:47.839
在某些地方摆在这里

00:59:50.640 --> 00:59:57.119
是的，如果您信任它，是的，所以请查找插入替换删除

00:59:57.119 --> 01:00:02.880
相对便宜的嗯，这给了足够

01:00:02.880 --> 01:00:05.760
随机散列函数节点将偏向

01:00:05.760 --> 01:00:09.040
目标分支因子呃，他们会知道吗

01:00:09.040 --> 01:00:13.440
在那种弹性呃和随机性

01:00:13.440 --> 01:00:17.680
不鼓励树木稀疏，所以我们遇到的问题是

01:00:17.680 --> 01:00:20.799
与amt一起使用，您可以拥有这些非常稀薄的树木

01:00:20.799 --> 01:00:26.880
um，因为没有办法将其偏向厚度um

01:00:26.880 --> 01:00:29.680
因为您是蛮横的，只是使用索引来

01:00:29.680 --> 01:00:33.200
定义非常粗糙的树的形状

01:00:33.200 --> 01:00:37.760
嗯，所以它具有类似于property的厚度属性

01:00:37.760 --> 01:00:42.000
最重要的是，对于任何给定的数据来说，这都是规范的

01:00:42.000 --> 01:00:45.040
设置好，即使看起来他们已经有了

01:00:45.040 --> 01:00:49.200
任何给定数据集上的这种随机疯狂

01:00:49.200 --> 01:00:53.119
不论中间去除或插入

01:00:53.119 --> 01:00:59.680
呃会形成一个规范的形式，带有一个规范的根cid呃

01:00:59.680 --> 01:01:04.319
我们想要的是这样，但是有一个

01:01:04.319 --> 01:01:08.440
问题是创建起来很便宜

01:01:08.440 --> 01:01:13.280
之所以发生碰撞，是因为分支因子

01:01:13.280 --> 01:01:20.240
只是将地址空间划分为您知道的那个段

01:01:20.240 --> 01:01:26.400
是的，制作您要制作的条目并不需要花费太多

01:01:26.400 --> 01:01:30.079
低于阈值以创建休息点或不创建休息点

01:01:30.079 --> 01:01:33.440
所以在这种情况下，我们知道有人可以创建一堆条目

01:01:33.440 --> 01:01:35.839
不会破裂，所以您最终会得到这些

01:01:35.839 --> 01:01:41.119
可能会破坏某些系统的大节点，我们确实对uH的节点大小有限制

01:01:41.119 --> 01:01:44.240
我们可以存储在存储系统中的

01:01:44.240 --> 01:01:49.440
或趋势或跨运输层的运输，所以我们确实需要

01:01:49.440 --> 01:01:55.119
防止受到这个伤害，所以这才是真正的杰出人物

01:01:55.119 --> 01:01:57.680
到目前为止，已经提出了一些解决方案

01:01:57.680 --> 01:02:00.960
而且我认为michael和michael正在讨论

01:02:00.960 --> 01:02:04.240
是的，有很多方法可以解决这个问题

01:02:04.240 --> 01:02:10.480
嗯，只是这些解决方案变得越来越复杂

01:02:10.480 --> 01:02:13.839
您控制访问模式的次数越少

01:02:13.839 --> 01:02:17.839
就像你拥有自己的数据结构一样

01:02:17.839 --> 01:02:21.520
只要看到溢出，就可以在结构中插入逻辑删除

01:02:21.520 --> 01:02:24.720
然后它已成为规范列表的一部分，所以它不是

01:02:24.720 --> 01:02:28.000
实际上没有哈希或任何正确的嗯，就像它仍然会

01:02:28.000 --> 01:02:31.440
保持恒定的哈希值，但是如果您不喜欢自己的结构

01:02:31.440 --> 01:02:35.359
或um，如果您没有某种共识机制说

01:02:35.359 --> 01:02:39.599
我们都将立即应用这些更改，那么您将无法真正使用该更改

01:02:39.599 --> 01:02:41.520
如果每个人都在应用更改类型的方法

01:02:41.520 --> 01:02:44.400
以不同的顺序排列，然后他们需要拿出

01:02:44.400 --> 01:02:48.240
特殊的结构变得有点困难

01:02:48.240 --> 01:02:51.200
嗯，因为您可能最终只会得到不同地方的墓碑

01:02:51.200 --> 01:02:55.520
取决于您何时拉动它或我在dagdb中遇到的情况是

01:02:55.520 --> 01:02:59.440
就像它是一个索引，因此规范形式

01:02:59.440 --> 01:03:02.000
实际上不是数据结构，而是

01:03:02.000 --> 01:03:05.119
视图的不同的数据结构，因此您不能插入这些

01:03:05.119 --> 01:03:08.240
墓碑真的意味着它不是真正的规范形式

01:03:08.240 --> 01:03:12.319
嗯，所以你可以像我一样使用

01:03:12.319 --> 01:03:15.680
有一种算法可以像浮动um一样使用

01:03:15.680 --> 01:03:19.680
指纹以便计算可以使用的序列ID

01:03:19.680 --> 01:03:24.240
嗯，如果您要隐藏某些数据（例如您拥有数据），也很喜欢

01:03:24.240 --> 01:03:28.000
结构和其他人不喜欢直接操纵它，您可以

01:03:28.000 --> 01:03:30.880
隐藏散列的随机数，然后他们就不能

01:03:30.880 --> 01:03:33.839
之所以产生这些攻击，是因为它们无法预测散列的方向

01:03:33.839 --> 01:03:37.920
是这样，如果您真的很容易修复

01:03:37.920 --> 01:03:43.599
如果您对秘密的秘密有任何同意的话，是的

01:03:43.599 --> 01:03:46.960
是的，根据种类的不同，有很多不同的解决方法

01:03:46.960 --> 01:03:50.319
您使用的访问模式是什么，只是需要一些工作才能弄清楚

01:03:50.319 --> 01:03:53.359
哪一个最有效

01:03:54.000 --> 01:03:58.160
好吧，我们时间不多了，我们加班了

01:03:58.160 --> 01:04:05.119
是的，非常感谢您的演示，这很有趣

01:04:05.119 --> 01:04:13.119
嗯，是的，所以，嗯，是的，哦，上帝，那我就明白了

01:04:13.119 --> 01:04:16.880
下个星期大家再见

