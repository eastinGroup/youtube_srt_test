WEBVTT
Kind: captions
Language: zh-Hans

00:00:15.280 --> 00:00:18.480
欢迎大家参加本周的ipl取消同步会议

00:00:18.480 --> 00:00:25.119
2020年10月19日，每周我们都去

00:00:25.119 --> 00:00:30.240
过去一周中我们所做的所有工作，然后讨论任何

00:00:30.240 --> 00:00:34.160
行动项目，今天我们甚至还有一个议程项目

00:00:34.160 --> 00:00:38.719
嗯，是的，尽管我们仍然从

00:00:38.719 --> 00:00:44.480
一轮更新，所以我开始我自己，实际上这周

00:00:44.480 --> 00:00:48.000
我在ipld世界上有很多事情要做

00:00:48.000 --> 00:00:53.280
很好，所以在文档方面也是如此

00:00:53.280 --> 00:01:01.440
我已经用一个小脚本将两个拉取请求发送到了um探索报告中

00:01:01.440 --> 00:01:04.720
它会自动执行所有操作，因此我必须对其进行修补，但现在已经相当

00:01:04.720 --> 00:01:08.240
很好，我认为前哨站读得很好

00:01:08.240 --> 00:01:12.880
作为减价，所以我做了那些嗯，在左边

00:01:12.880 --> 00:01:16.640
事情的一面，所以目前我仍在等待生锈

00:01:16.640 --> 00:01:21.439
多哈希发布，直到我确定它可以很好地工作

00:01:21.439 --> 00:01:24.960
对于p2p叉子，我已经完成了拉取请求

00:01:24.960 --> 00:01:29.200
在p2p上，我希望他们能尽快回复

00:01:29.200 --> 00:01:32.479
但是他们还没有，所以已经六天了

00:01:32.479 --> 00:01:36.159
所以我在irc上再次对其进行了ping操作，然后看看是否有什么我

00:01:36.159 --> 00:01:40.240
可以做得到这个审查，但与此同时

00:01:40.240 --> 00:01:45.040
阻止生锈的身份证发布，我本周要做的是那个我

00:01:45.040 --> 00:01:48.399
只是嗯，所以我有一些变化

00:01:48.399 --> 00:01:52.799
认为他们会需要我只是确保将那些合并

00:01:52.799 --> 00:01:57.759
与锈multihash，如果我然后在本周结束或

00:01:57.759 --> 00:02:00.000
所以没有他们的回音我会做

00:02:00.000 --> 00:02:04.880
发布，然后做一个名单，做这些嗯

00:02:04.880 --> 00:02:08.560
然后，如果还有他们仍然需要的东西，可能只是另一个

00:02:08.560 --> 00:02:10.879
打破这些变化，所以我不期望但是

00:02:10.879 --> 00:02:15.760
如果他们这样做，我会再发布一次，是的，我们会弄清楚这一点

00:02:15.760 --> 00:02:18.959
但是我不想在p2p上被阻止

00:02:18.959 --> 00:02:24.560
回顾一下我还做了什么，所以很简单

00:02:24.560 --> 00:02:29.360
这次会议上即将出现的套牌内容

00:02:29.360 --> 00:02:32.560
我又去看了一下，因为就像埃里克（Eric）一样

00:02:32.560 --> 00:02:35.360
提到这与黑海战争有何不同

00:02:35.360 --> 00:02:38.480
然后我调查了一下，并决定提出请求

00:02:38.480 --> 00:02:41.920
证明它实际上非常相似

00:02:41.920 --> 00:02:48.160
是的，它是链接的，所以基本上，它显示的是，如果您真的只

00:02:48.160 --> 00:02:51.519
为我们需要的c板实现一个子集

00:02:51.519 --> 00:02:54.640
敏捷，但如果您仅实现这些东西

00:02:54.640 --> 00:03:01.280
编码和解码器实际上很容易，不需要那么多代码

00:03:01.340 --> 00:03:05.920
[音乐]然后在星期五

00:03:05.920 --> 00:03:09.040
我们在星期五对irc进行了长时间的讨论

00:03:09.040 --> 00:03:15.200
关于ipd和字符串um，重点是我认为

00:03:15.200 --> 00:03:18.480
IPL数据球字符串应为有效UTF-8

00:03:18.480 --> 00:03:25.519
 eric认为id字符串应该只是um i 8-bit

00:03:25.519 --> 00:03:30.640
字节序列，他已经发布了一个文档，而我已经

00:03:30.640 --> 00:03:34.239
发表了对此的回复，是的，我认为这将是一个

00:03:34.239 --> 00:03:39.920
讨论将持续进行，是的，我们将持续一段时间

00:03:39.920 --> 00:03:43.360
我们将看看结果如何，这就是我所做的一切

00:03:43.360 --> 00:03:49.120
在ipld世界中，我名单上的下一个是danielle

00:03:50.799 --> 00:03:54.799
很酷，所以上周我要做的一件事就是换了新麦克风，

00:03:54.799 --> 00:04:00.640
希望我的音频现在更好，但除此之外

00:04:00.640 --> 00:04:03.519
对我来说是一周，因为我今天在外出演讲

00:04:03.519 --> 00:04:06.959
会议叫golab，所以我不得不为此录音，因为他们

00:04:06.959 --> 00:04:10.480
没有进行现场对话，而您却没有学到

00:04:10.480 --> 00:04:14.319
尝试一个小时的编辑后的演讲，直到您尝试完成，这是多么困难

00:04:14.319 --> 00:04:16.560
第一次，所以我花了很多时间

00:04:16.560 --> 00:04:20.479
但主要是周末，星期一也有点

00:04:20.479 --> 00:04:24.960
然后显然还有今天的现场质量检查

00:04:24.960 --> 00:04:28.960
我们和罗德和其他几个人打了个电话，以完成打击

00:04:28.960 --> 00:04:33.360
我们一直在讨论规格更改，以便一切顺利，谢谢Rod

00:04:33.360 --> 00:04:39.600
所以我试图将我的ADL存储库切换到该新架构，我

00:04:39.600 --> 00:04:42.960
今天大部分时间都花在那上面，我被困了一段时间

00:04:42.960 --> 00:04:46.160
最初我以为是我的错，因为当某事不起作用时

00:04:46.160 --> 00:04:49.360
你知道你有点假设这是你自己的错，但是经过一些挖掘

00:04:49.360 --> 00:04:53.040
我有点意识到规格不一致，因为

00:04:53.040 --> 00:04:57.600
新的哈希图节点类型um

00:04:57.600 --> 00:05:01.360
有时以地图表示，有时是元组或列表

00:05:01.360 --> 00:05:05.759
因此该架构无法真正起作用，然后是eric的代码生成器

00:05:05.759 --> 00:05:09.759
它可能会给出一个不错的错误，但是现在它只会吐出无效的go代码，因此

00:05:09.759 --> 00:05:13.600
那是让我迷惑了一阵子的原因，所以我想我们可以谈谈

00:05:13.600 --> 00:05:18.080
以后，而不是如何解决它，否则

00:05:18.080 --> 00:05:21.039
我一直在添加更多测试并修复待办事项

00:05:21.039 --> 00:05:25.039
ADL回购协议，但到目前为止我还没有提出任何建议

00:05:25.039 --> 00:05:29.600
我还提出了一些更简单的ipld主要问题

00:05:29.600 --> 00:05:32.880
或者更确切地说，我们已经讨论过的设计更改

00:05:32.880 --> 00:05:36.479
与eric讨论较困难的问题

00:05:36.479 --> 00:05:39.840
我暂时将它们留在草稿中，因为那不是

00:05:39.840 --> 00:05:42.960
这些不是我们很快就能解决的问题，因此

00:05:42.960 --> 00:05:46.000
这就是本周

00:05:46.400 --> 00:05:58.160
谢谢下一个是错的嗯好吧

00:05:58.160 --> 00:06:05.360
所以上周我大部分时间是去参加，所以我参加了其中的一些活动

00:06:05.360 --> 00:06:09.199
上周我们谈到的维护，我主要关注的是

00:06:09.199 --> 00:06:12.160
是去cid，现在已经完全更新并且很开心

00:06:12.160 --> 00:06:15.280
嗯，我的考试覆盖率增加了30

00:06:15.280 --> 00:06:18.960
而我当时只是因为回购有一个

00:06:18.960 --> 00:06:22.560
适用于要合并的事物的覆盖规则，只是我认为它只是滑落了

00:06:22.560 --> 00:06:27.120
在此之下，因此没有合并请求请求，所以与其尝试

00:06:27.120 --> 00:06:30.000
找一个具有管理访问权限的人，我决定只是增加测试

00:06:30.000 --> 00:06:32.000
覆盖范围，因为无论如何这都是一件好事，

00:06:32.000 --> 00:06:36.400
我实际上设法测试了一些不像整个区域的区域

00:06:36.400 --> 00:06:39.759
大量未被触及的代码

00:06:39.759 --> 00:06:45.360
因此，最好进行测试以触摸它们并验证什么

00:06:45.360 --> 00:06:49.840
他们正在做他们打算做的事情

00:06:49.840 --> 00:06:54.000
CID可能需要发布，但我不知道那里的程序是什么

00:06:54.000 --> 00:06:58.479
所以我可能需要弄清楚并确定我是否可以发布

00:06:58.479 --> 00:07:02.960
嗯，我也认为让Daniel进入ipfs可能很好

00:07:02.960 --> 00:07:08.240
团队，因为其中一些部分已在ipfs回购中结束

00:07:08.240 --> 00:07:12.880
去图书馆有点难

00:07:14.000 --> 00:07:21.520
我更喜欢iple素数和um，我认为是PB东西um

00:07:21.520 --> 00:07:26.400
从内部和嗯触碰我们素数素数内的许多事物

00:07:26.400 --> 00:07:31.280
到达一些有趣的地方，但主要是

00:07:31.280 --> 00:07:35.199
出奇的好，我你知道我没有那种痛苦

00:07:35.199 --> 00:07:38.319
我没有我可能会做的那么多痛苦

00:07:38.319 --> 00:07:42.639
试图使它至少起作用，所以在我最初的时候

00:07:42.639 --> 00:07:45.680
测试运行表明，事情正在按我的方式进行

00:07:45.680 --> 00:07:51.440
因为应该看起来很好，所以我们做了我们需要的麻料

00:07:51.440 --> 00:07:54.879
大概今天再来一次，我们可以在本次会议上解决这个问题

00:07:54.879 --> 00:08:00.960
嗯，最后才是行政内容，包括同级

00:08:00.960 --> 00:08:05.120
回顾那只是耳光的东西

00:08:05.120 --> 00:08:10.400
除了那一点点工作之外

00:08:10.400 --> 00:08:12.879
嗯所以

00:08:16.639 --> 00:08:21.840
下一个是micah哦，是的，我处理的很多事情是

00:08:21.840 --> 00:08:26.560
评论的东西，嗯，也许还有另一回合

00:08:26.560 --> 00:08:28.960
这个星期下周我实际上必须写一封

00:08:28.960 --> 00:08:32.080
谈论奎因升空，那会很有趣

00:08:32.080 --> 00:08:37.519
嗯，我做的最主要的代码是，我确实回到了那个地方

00:08:37.519 --> 00:08:41.200
呃dkb那个小小的键值存储区，刚刚开始增加覆盖率，

00:08:41.200 --> 00:08:44.240
调整它，我真的很喜欢，我想我要去

00:08:44.240 --> 00:08:49.519
嗯，可能会在ipfs博客上写一些关于种类的博客文章

00:08:49.519 --> 00:08:54.080
就像您将如何在ipfs上编写数据库，然后仅使用dkb

00:08:54.080 --> 00:08:59.279
像一个例子，图书馆基本上是个好主意

00:08:59.279 --> 00:09:06.320
但这就是我现在能想到的主要内容

00:09:06.320 --> 00:09:12.240
虽然对呃感兴趣，但稍后会谈论抢劫的变化

00:09:13.600 --> 00:09:20.399
下一个是彼得啊，对吧，上个礼拜

00:09:20.399 --> 00:09:23.760
我协助了那些协助发射猎鹰的人

00:09:23.760 --> 00:09:29.760
所以我们确实推出了valcoin呃，它非常安静，但实际上却悄悄地安静了下来

00:09:29.760 --> 00:09:34.480
也许这个星期会看到一些东西，你知道手指

00:09:34.480 --> 00:09:36.880
交叉没有看到任何东西，但一个人永远不知道

00:09:36.880 --> 00:09:42.399
嗯，我可以建立一件事吗？

00:09:42.399 --> 00:09:44.959
这个团队，因为你们中很多人都在做这件事

00:09:44.959 --> 00:09:50.399
就像您可能知道的那样，我们对我们的实际工作方式有些打h

00:09:50.399 --> 00:09:55.519
从我们组装的数据中传输了呃数据

00:09:55.519 --> 00:09:58.320
因为神奇宝贝发现了我们如何从

00:09:58.320 --> 00:10:04.079
原来是实际硬盘驱动器，还是犯了很多错误

00:10:04.079 --> 00:10:08.000
一路走来，所以，只是

00:10:08.000 --> 00:10:11.760
从字面上看，昨天我们结束了一个项目

00:10:11.760 --> 00:10:18.959
运送一个很小的非常简单的程序

00:10:18.959 --> 00:10:22.160
能够随机驾驶，基本上

00:10:22.160 --> 00:10:30.079
说出对我们有好处的目的是否对您有利

00:10:30.079 --> 00:10:33.120
它是否组装得足够好以达到我们试图使用的目的

00:10:33.120 --> 00:10:36.240
当我们实际上开始发送交易时

00:10:36.240 --> 00:10:39.279
像这样的东西，所以我们拥有的东西数量

00:10:39.279 --> 00:10:44.000
找出原因是因为

00:10:44.000 --> 00:10:47.120
运行此东西的敌对位置实际上并没有

00:10:47.120 --> 00:10:52.560
一个很好的呃，例如后端服务或类似的东西

00:10:52.560 --> 00:10:57.040
第一个步骤基本上只是从片段中取出整个发电机表

00:10:57.040 --> 00:11:03.600
像整个事情一样，将其缩减为16个字节

00:11:03.600 --> 00:11:07.120
每个cid的现金，而不是全部32

00:11:07.120 --> 00:11:10.399
并将整个东西捆绑到二进制文件中

00:11:10.399 --> 00:11:14.720
大概只有140兆字节，所以还算不错，所以基本上无论谁运行

00:11:14.720 --> 00:11:18.560
任何运行该程序的人都会拥有实际上是一台计算机的整个数据集

00:11:18.560 --> 00:11:20.959
预期以及预期的文件大小是多少

00:11:20.959 --> 00:11:24.399
哪些数据表明它们是所有这些的一部分，就像

00:11:24.399 --> 00:11:28.480
事情，我们也有一个

00:11:28.480 --> 00:11:32.079
不基于uh的实际compy计算器

00:11:32.079 --> 00:11:40.160
锈ffi的东西，但它完全实现go它是

00:11:40.160 --> 00:11:43.600
仅比我们现在使用的猎鹰快三倍

00:11:43.600 --> 00:11:48.800
我尚未与加密实验室的人交谈，因为

00:11:48.800 --> 00:11:51.839
它实现了效率，实际上应该是10到15倍

00:11:51.839 --> 00:11:54.480
当一切正常进行时，我们比以往任何时候都快

00:11:54.480 --> 00:11:58.560
基本上可以并行传输不同的层

00:11:58.560 --> 00:12:02.560
这样就可以在您的电脑上使用不错的CPU

00:12:02.560 --> 00:12:07.920
交易，所以它可以在大约运行时间

00:12:07.920 --> 00:12:10.959
每秒500兆字节每秒一千兆字节

00:12:10.959 --> 00:12:16.639
在持续的内存中，所以现在程序实际上占用了大约

00:12:16.639 --> 00:12:20.240
50 MB的内存来保护某些深色汽车文件比我慢

00:12:20.240 --> 00:12:24.480
我要不要做，一旦准备好就可以了

00:12:24.480 --> 00:12:28.160
希望这将能够清理这一点，我们将尝试

00:12:28.160 --> 00:12:33.680
也把它推入水里，是的

00:12:33.680 --> 00:12:40.000
差不多就是两三天的工作

00:12:40.000 --> 00:12:45.680
但终于出来了，现在我们要看看是否有多人

00:12:45.680 --> 00:12:49.920
运行它可以找到额外的钱或没有

00:12:49.920 --> 00:12:53.200
在她所有伙伴的实施中

00:12:53.200 --> 00:13:06.320
恩，是的，我想我所拥有的一切。下一步是埃里克

00:13:06.320 --> 00:13:10.639
所以本周我没有苔原报告，我有很多非iPod的东西要

00:13:10.639 --> 00:13:14.959
这个星期处理生活，但是我想，既然你提出来了

00:13:14.959 --> 00:13:21.279
非常粗俗的琴弦，我对琴弦有很多想法

00:13:21.279 --> 00:13:23.600
是我们真正需要指定的东西之一

00:13:23.600 --> 00:13:30.240
不幸的是，以某种方式令人沮丧的是，尽管有弦

00:13:30.240 --> 00:13:37.360
成为超级通用概念并不意味着明确规定，因此

00:13:37.360 --> 00:13:40.800
如果我们要尝试使整个生态系统充满各种不同的

00:13:40.800 --> 00:13:44.959
库的实现许多不同的编解码器许多不同的

00:13:44.959 --> 00:13:48.399
在它们之上构建的应用程序与许多其他不同的接口

00:13:48.399 --> 00:13:52.079
与内核接口与文件系统接口的各种应用程序

00:13:52.079 --> 00:13:53.920
与阳光下的一切交往

00:13:53.920 --> 00:13:58.399
我们真的必须指定真正的意思，即使是非常基础的东西

00:13:58.399 --> 00:14:03.120
就像我们想理所当然的字符串一样

00:14:03.120 --> 00:14:08.720
所以我试图做到这一点，我有一个很大的旧文件，是客人

00:14:08.720 --> 00:14:10.800
形式就是我曾经做过的那些事之一

00:14:10.800 --> 00:14:15.199
以勘探报告样式格式编写，因此

00:14:15.199 --> 00:14:18.079
占据一个位置并与它一起运行并被写入

00:14:18.079 --> 00:14:20.399
单一作者的方式，好像这是事实

00:14:20.399 --> 00:14:25.600
所以它分为几个部分，它比任何人都更长

00:14:25.600 --> 00:14:30.639
想读我很抱歉它谈论字符串在哪里

00:14:30.639 --> 00:14:34.959
出现，它提出了一个定义

00:14:34.959 --> 00:14:39.360
就像沃尔克学校那样，我已经提倡的定义是

00:14:39.360 --> 00:14:45.760
字符串应该大写锁定我们的功能，无论使用什么术语

00:14:45.760 --> 00:14:53.839
是utf-8，但是完整的ipld库必须使用大写锁定支持

00:14:53.839 --> 00:15:01.600
完整的8位字节序列范围，其详细信息已覆盖

00:15:01.600 --> 00:15:03.920
我有很多设计原理

00:15:03.920 --> 00:15:07.519
六个不同的人分开了吗？或者是七个

00:15:07.519 --> 00:15:12.399
然后整整一章中都有其他选择，所有这些都是

00:15:12.399 --> 00:15:15.440
标记为已拒绝，但我想重申一下这是

00:15:15.440 --> 00:15:18.880
因为这是用勘探报告样式编写的，所以花了一个

00:15:18.880 --> 00:15:21.680
位置，并与之一起运行其中的一些

00:15:21.680 --> 00:15:24.800
事情比别人更彻底地被拒绝了

00:15:24.800 --> 00:15:27.440
但它们有两个到八个原因

00:15:27.440 --> 00:15:33.600
为什么我认为它们不是一个好主意，但是其中一些我可能不知道

00:15:33.600 --> 00:15:36.320
如果有人想将所有这些都放在一个文件夹中，那么它们是可挽救的

00:15:36.320 --> 00:15:39.839
我建议的不同方向是

00:15:39.839 --> 00:15:44.639
阅读此书，如果您想采摘这些东西之一

00:15:44.639 --> 00:15:49.920
挑选其中之一，并尝试与所有

00:15:49.920 --> 00:15:52.560
我们需要改变的具体含义

00:15:52.560 --> 00:15:55.839
为了实现这一目标，例如

00:15:55.839 --> 00:16:00.399
被拒绝的是地图

00:16:00.399 --> 00:16:05.199
混合键类型，因为如果我们支持混合键类型的地图

00:16:05.199 --> 00:16:07.600
整整一堆关于如何进行的辩论

00:16:07.600 --> 00:16:10.720
需要指定的字符串实际上会改变

00:16:10.720 --> 00:16:14.720
它将放松一些约束，将增加一些新的约束

00:16:14.720 --> 00:16:18.320
这是非常不本地的，它会影响哪些因素

00:16:18.320 --> 00:16:22.720
因此，如果有人想尝试采用该定义并且对此有误

00:16:22.720 --> 00:16:26.800
那真的很酷，但祝你好运，因为只是说

00:16:26.800 --> 00:16:30.720
不，我不希望它被拒绝不会使您走得很远

00:16:30.720 --> 00:16:33.279
通过所有这些事情的含义来工作

00:16:33.279 --> 00:16:36.480
我尝试过的一切最终都无法通过含义来解决

00:16:36.480 --> 00:16:39.040
其中很多，但也许其中一些是可能的，

00:16:39.040 --> 00:16:42.480
只是没有足够的顶空而已。

00:16:42.480 --> 00:16:45.199
在这里我被标记为拒绝，但也许不应该

00:16:45.199 --> 00:16:50.320
也许您可以这样做，因为我们可以将数据模型更改为

00:16:50.320 --> 00:16:54.160
多种地图类型，我们可以将带有字符串键的地图作为

00:16:54.160 --> 00:16:58.480
与带字节键的映射和另一种映射不同的类型

00:16:58.480 --> 00:17:03.519
键内不同类型的映射，这将是一个选择

00:17:03.519 --> 00:17:06.480
这将与我们到目前为止所定义的完全不同，

00:17:06.480 --> 00:17:09.919
需要更新很多规格并重新考虑很多有关如何

00:17:09.919 --> 00:17:14.880
编解码器在规范上有两难处，等等，但可能是连贯的

00:17:14.880 --> 00:17:17.280
可能的

00:17:17.360 --> 00:17:21.439
无论如何，所以这支股票涵盖了很多东西

00:17:21.439 --> 00:17:26.319
嗯，所以我进行了一次疯狂的讨论

00:17:26.319 --> 00:17:29.440
今天和沃尔克在一起，这就像是一个好时机

00:17:29.440 --> 00:17:34.000
把这个放在你的雷达上，我们在谈论地图的关键

00:17:34.000 --> 00:17:36.480
在字符串的上下文中，我们正在谈论

00:17:36.480 --> 00:17:39.600
有点像，如果你向后拉

00:17:39.600 --> 00:17:42.640
您不再想像数据建模类型一样

00:17:42.640 --> 00:17:45.919
我们要确保的是什么，我们要做的主要是

00:17:45.919 --> 00:17:48.240
关心的是往返旅行，就像我们只是

00:17:48.240 --> 00:17:50.160
希望确保我们可以始终往返

00:17:50.160 --> 00:17:57.360
所有这些在语言之间进行往返实际上不需要的事情

00:17:57.360 --> 00:18:03.840
所有地图甚至所有语言对此的一致决定

00:18:03.840 --> 00:18:07.919
您需要为每个人做出非常一致的决定

00:18:07.919 --> 00:18:11.679
每种语言和主要语言的编解码器

00:18:11.679 --> 00:18:16.080
您所拥有的约束是它不能是混合类型

00:18:16.080 --> 00:18:19.600
是的，所以我想在您最终到达的地方

00:18:19.600 --> 00:18:27.919
您不能混合使用密钥类型，但是我们实际上不需要指定哪种类型的密钥

00:18:27.919 --> 00:18:31.919
键是um例如，如果您

00:18:31.919 --> 00:18:36.559
如果您要做的是决定编码任意二进制

00:18:36.559 --> 00:18:43.919
变成一个字符串，嗯键和一个ac键，这就是爆米花现在正在做的事情

00:18:43.919 --> 00:18:47.360
实际上使用javascript来回就可以了

00:18:47.360 --> 00:18:51.919
因为javascript的地图只接受字符串，但是这些字符串可以

00:18:51.919 --> 00:18:55.520
包含字符，以便您实际上可以

00:18:55.520 --> 00:18:59.039
往返，没关系，然后如果您知道那是您的意思，

00:18:59.039 --> 00:19:01.039
想做的事，如果你真正想要的是

00:19:01.039 --> 00:19:05.440
是二进制键，但是您将它们键入字符串，因为就像

00:19:05.440 --> 00:19:09.039
然后在您的编解码器中，您可以说哦，就像我在

00:19:09.039 --> 00:19:13.120
我使用的语言支持二进制密钥，它始终是地图的二进制密钥

00:19:13.120 --> 00:19:16.559
就像那就是我的编解码器如何工作，我总是很酷地执行二进制密钥

00:19:16.559 --> 00:19:20.240
那些实际上在这两种语言之间来回传递相同数据的人

00:19:20.240 --> 00:19:23.679
因为没有人在改变它，这很好，你只是在改变

00:19:23.679 --> 00:19:28.000
您在使用特定语言的特定编解码器中所做的决定

00:19:28.000 --> 00:19:32.880
所以我真的不认为数据模型必须定义

00:19:32.880 --> 00:19:36.080
类型是什么，一致类型是什么

00:19:36.080 --> 00:19:39.039
我认为它的按键实际上可以由语言和编解码器决定

00:19:39.039 --> 00:19:42.640
决定它必须保持一致并且

00:19:42.640 --> 00:19:47.039
成为一种，它必须是一种你不能拥有的类型

00:19:47.039 --> 00:19:49.520
混合类型，所以这很有趣

00:19:49.520 --> 00:19:54.160
就像我认为我们的很多字符串约束都倾向于指出

00:19:54.160 --> 00:19:57.120
有时候我们会喜欢在地图上使用它们

00:19:57.120 --> 00:20:00.240
但我认为我们也许应该像我们实际上不去耦那样

00:20:00.240 --> 00:20:02.640
需要的是，我们可以这样说

00:20:02.640 --> 00:20:06.640
映射具有一种密钥类型，并为该编解码器和

00:20:06.640 --> 00:20:09.760
用这种语言，也许就像我们的决定

00:20:09.760 --> 00:20:13.200
在鹿皮草中，从历史和人们的角度出发，这是完全有意义的

00:20:13.200 --> 00:20:16.159
已经在做的是它必须是字符串类型，但是

00:20:16.159 --> 00:20:19.280
它可以是任意数据，而不必是utf-8

00:20:19.280 --> 00:20:22.960
这就像我们实际需要时不时支持的某些语言一样

00:20:22.960 --> 00:20:26.000
甚至就像您在该库中从字面上知道的那样

00:20:26.000 --> 00:20:29.440
在文件硬币中，他们只是将它们视为叮咬而已

00:20:29.440 --> 00:20:32.840
我不知道您如何看待这像您的照片

00:20:32.840 --> 00:20:36.880
埃里克大致一致，但我认为

00:20:36.880 --> 00:20:40.240
您尝试承诺的事情越少，我们的规格就变得越无用

00:20:40.240 --> 00:20:43.280
就像我希望有人看看我们的规格，知道他们

00:20:43.280 --> 00:20:46.880
他们用新语言编写新库时应该做的

00:20:46.880 --> 00:20:50.080
好吧，是的，所以是的，是的，所以如此

00:20:50.080 --> 00:20:54.480
deg seabor规范应非常具体地说明如何编码

00:20:54.480 --> 00:20:58.559
我的意思是说数据模型需要设置一些约束

00:20:58.559 --> 00:21:06.159
编解码器希望说出正确的做法，然后

00:21:06.159 --> 00:21:08.960
当您使用自己的语言实施该规范时，您将制定

00:21:08.960 --> 00:21:12.480
像这样的特别决定，这是一个很好的例子

00:21:12.480 --> 00:21:16.720
如果您看问题，那就像字符串值一样

00:21:16.720 --> 00:21:20.559
我们这里确实是语言不同意

00:21:20.559 --> 00:21:25.360
关于字符串，就像我们无法解决那样

00:21:25.360 --> 00:21:29.760
我们不会解决这个问题，所以选择就变成了

00:21:29.760 --> 00:21:35.840
我们会做些什么吗？我们会努力让自己变得束手无策，强迫人们使用

00:21:35.840 --> 00:21:38.880
不是代表字符串的字符串类型的类型，以便它们可以

00:21:38.880 --> 00:21:41.120
支持其他人可以做的事情

00:21:41.120 --> 00:21:46.000
语言还是我们基本上会说看，如果您做的不是utf-8

00:21:46.000 --> 00:21:48.480
您将度过一段非常糟糕的时光，您将看到一些异常

00:21:48.480 --> 00:21:50.960
语言，因为他们将尝试转换

00:21:50.960 --> 00:21:54.960
实际上，就像我们在数据模型中所说的一样

00:21:54.960 --> 00:21:58.320
这将是我们实际上没有能力的情况

00:21:58.320 --> 00:22:01.360
任何解决这个问题的方法，因为即使

00:22:01.360 --> 00:22:08.000
我们运送的所有编解码器都具有这种ffi类型，基本上就像一个二进制呃

00:22:08.000 --> 00:22:11.760
字符串的价值每个人都要做的第一件事就是将它们转换

00:22:11.760 --> 00:22:14.640
到一个字符串，如果它具有无效的utf-8字符

00:22:14.640 --> 00:22:18.159
它会引发异常，所以我们要做的就是将错误从

00:22:18.159 --> 00:22:21.360
编解码器喜欢人们在处理数据时会立即做的事情

00:22:21.360 --> 00:22:23.600
首先得到它实际上并没有解决任何人的问题

00:22:23.600 --> 00:22:28.000
问题就像让我们觉得自己使之保持一致，但是

00:22:28.000 --> 00:22:34.559
所以你在说的是，字符串应该大写锁定是的

00:22:34.559 --> 00:22:37.760
是的，是的，不，当你说

00:22:37.760 --> 00:22:41.840
大写锁定应

00:22:44.320 --> 00:22:47.919
就像那就是100规格中正确的东西

00:22:47.919 --> 00:22:53.760
我认为我们无法真正做到，我们真的没有能力

00:22:53.760 --> 00:22:58.559
决定是必须支持的部分

00:22:58.559 --> 00:23:02.720
这项权利的一个很好的例子是

00:23:03.039 --> 00:23:07.280
json不是二进制文件，那么我认为我们将必须定义

00:23:07.280 --> 00:23:10.480
兼容性水平或至少

00:23:10.480 --> 00:23:14.880
A级和A级类似的兼容性

00:23:14.880 --> 00:23:18.320
因为已经有很多东西依赖这些东西了

00:23:18.320 --> 00:23:21.440
字符串域，包括任意字节等等

00:23:21.440 --> 00:23:24.720
不支持的库将具有b

00:23:24.720 --> 00:23:29.039
最好的等级兼容性，因为它们将无法与专业

00:23:29.039 --> 00:23:32.080
这些规格上已经存在的产品

00:23:32.080 --> 00:23:36.559
是的，但是就像经常一样

00:23:37.520 --> 00:23:42.320
如果不是fico，例如五枚硬币未使用二进制密钥，那不是真的

00:23:42.320 --> 00:23:45.600
在法线贴图中，就像在sibo中一样，它们不是

00:23:45.600 --> 00:23:49.440
使用二进制文件是因为他们不使用它们

00:23:49.440 --> 00:23:53.520
像在c-ball地图中一样使用c-bar二进制文件，没有

00:23:53.520 --> 00:23:56.640
二进制的任意饮食数据仅对我而言

00:23:56.640 --> 00:24:00.640
想强调这一点，但他们是

00:24:01.360 --> 00:24:06.320
我昨天刚刚检查了八个字节，他说是的，上面有字符串

00:24:06.320 --> 00:24:08.960
utf-8字节，例如是否将其解码

00:24:08.960 --> 00:24:13.200
餐馆好吧，我然后他们可以像我一样与我分享

00:24:13.200 --> 00:24:17.039
因为三，我试图喜欢我基本上写了一个

00:24:17.039 --> 00:24:20.400
与意志，并尝试找到那些，所以请是的

00:24:20.400 --> 00:24:24.400
跟我分享吧，好酷，我的意思是可能很难找到一个发生的事情

00:24:24.400 --> 00:24:28.720
像utf-8一样是无效的，我想这是怎么回事

00:24:28.720 --> 00:24:33.120
我们发现的是，所有内容都是在seabor编码的

00:24:33.120 --> 00:24:36.559
预期最基本的水平，因此

00:24:36.559 --> 00:24:40.159
问题是将它们存储在cbor中的值不是

00:24:40.159 --> 00:24:43.600
地图键，它们成为的地图键

00:24:43.600 --> 00:24:46.880
意识到，所以是那些字节

00:24:46.880 --> 00:24:50.320
实际编码的Sea的值段为

00:24:50.320 --> 00:24:52.159
有二进制数据的地方

00:24:52.159 --> 00:24:55.679
是的，但是现在你在adl土地上

00:24:55.679 --> 00:24:58.159
事情发生了一些变化，就像它们将不会由编解码器在

00:24:58.159 --> 00:25:02.240
嗯，就像

00:25:02.240 --> 00:25:08.880
回到它，就像尝试再次放松，您经常配对

00:25:08.880 --> 00:25:12.640
我应该带一个梅而不是衬衫和一个必须的东西，所以我认为

00:25:12.640 --> 00:25:15.279
就像规范可能要说的那样

00:25:15.279 --> 00:25:21.760
是您应该以utf-8编码字符串，还是可以编码任意数据

00:25:21.760 --> 00:25:25.120
到那些字符串中，但您应该知道

00:25:25.120 --> 00:25:29.279
这会给您带来一些不支持该语言的问题

00:25:29.279 --> 00:25:32.320
像那样做的结果

00:25:32.320 --> 00:25:36.159
说像你一样，你必须支持它，这意味着

00:25:36.159 --> 00:25:41.120
它会在某些我不认为我们在

00:25:41.120 --> 00:25:45.279
愿意做的就是说现在所有的琴弦

00:25:45.279 --> 00:25:49.919
使用非本地类型um或or是的，我的意思是

00:25:49.919 --> 00:25:52.960
甚至锈中的ffi类型实际上就像是类型的非名称

00:25:52.960 --> 00:25:56.880
嗯，或者您使用的是类似标记的二进制类型之类的东西

00:25:56.880 --> 00:25:59.840
就像你将要对他们做一些特殊的事情，这不是常规的

00:25:59.840 --> 00:26:02.640
顺序排列，那样就不会了

00:26:02.640 --> 00:26:06.480
使编解码器非常有用，到最后，我们不再

00:26:06.480 --> 00:26:10.720
真正控制它，就像某人不难

00:26:10.720 --> 00:26:14.080
然后编写一个编解码器，将它们解码为所有字符串，然后

00:26:14.080 --> 00:26:18.000
只是在他们不在的时候抛出，而是使用它来代替，实际上

00:26:18.000 --> 00:26:20.799
就像人们通常会做的那样

00:26:20.799 --> 00:26:25.120
而且也是另一面，我们不能说必须是utf-8

00:26:25.120 --> 00:26:28.400
因为我们知道人们不会去做那个验证

00:26:28.400 --> 00:26:31.440
并且他们有时会将无效的东西编码成字符串

00:26:31.440 --> 00:26:34.720
utf-8字符，就像您应该意识到的那样

00:26:34.720 --> 00:26:38.240
人们做的一件事情，如果您真的需要它是utf-8

00:26:38.240 --> 00:26:41.760
您将不得不对其进行验证，就像无法绕开它一样

00:26:41.760 --> 00:26:45.200
对，所以我认为那可能就是

00:26:45.200 --> 00:26:48.880
语言的位置，然后当我们查看特定的编解码器时

00:26:48.880 --> 00:26:51.360
特定的语言，我们对此可以更加严格

00:26:51.360 --> 00:26:56.240
就像我们可以特别在seabor中说的那样，这些必须是字符串，例如

00:26:56.240 --> 00:26:58.720
它们中可能包含任意数据，但需要输入

00:26:58.720 --> 00:27:02.400
数学键值的字符串就像我们可以得到的那样

00:27:02.400 --> 00:27:07.440
我们甚至可以在某些法典中说，就像您知道您实际上只能做什么

00:27:07.440 --> 00:27:11.760
utf-8用于此编解码器um中的字符串，这就像您的操作方式

00:27:11.760 --> 00:27:13.840
清理或该编解码器的翻译

00:27:13.840 --> 00:27:19.600
无论出于何种原因，事实上json中已经发生了这种情况

00:27:19.600 --> 00:27:23.120
因为json不是二进制格式，所以它是字符串格式，所以像末尾一样

00:27:23.120 --> 00:27:26.240
最终输出的整个东西必须是您的价值

00:27:26.240 --> 00:27:30.159
字符串，因此，如果您尝试将某些任意字节推入字符串中

00:27:30.159 --> 00:27:33.840
值，它实际上会弄乱编码，所以您需要做后

00:27:33.840 --> 00:27:37.600
有时会逃脱，所以是这样

00:27:37.600 --> 00:27:39.360
就像我们一样，其中一些决策

00:27:39.360 --> 00:27:43.120
我们必须使用特定的编解码器和语言，

00:27:43.120 --> 00:27:46.320
是的，只是警告像您这样的人可能不想这样做

00:27:46.320 --> 00:27:49.600
我的意思是，就像我们也必须警告人们有关内陆城市的事情一样，

00:27:49.600 --> 00:27:52.480
只是说，就像你知道这样的事情是可能的，但就像你

00:27:52.480 --> 00:27:55.360
有时会遇到不好的时光，因为关于

00:27:55.360 --> 00:28:00.399
代表什么是嗯

00:28:00.399 --> 00:28:03.520
是的，我是说我同意该规范应发挥最大作用，但同时

00:28:03.520 --> 00:28:06.960
像实际的实现需要最大程度地有用

00:28:06.960 --> 00:28:10.559
在这里，我们就像打了一些冲突的东西一样

00:28:10.559 --> 00:28:13.039
一点，但我认为我认为

00:28:13.039 --> 00:28:16.960
您想出了一些作品，如果我们只替换那些必须的作品

00:28:16.960 --> 00:28:23.120
用mma来支持任意东西

00:28:25.679 --> 00:28:30.640
好吧，就像它一样，我们认为我认为我们应该去议程项目

00:28:30.640 --> 00:28:34.480
首先，然后像我们可能会讨论这个

00:28:34.480 --> 00:28:36.960
再像我们一样继续三个小时

00:28:36.960 --> 00:28:39.919
星期五，所以没关系，如果我们继续前进，

00:28:39.919 --> 00:28:45.760
首先，然后好吧，嗯，嗯，嗯

00:28:45.760 --> 00:28:49.679
我只是想作为触发条件，我也想讨论一下

00:28:49.679 --> 00:28:53.520
但我也要保持冷静

00:28:53.520 --> 00:28:59.440
嗯，好吧，所以嗯，是的，性别项目是同一主题

00:28:59.440 --> 00:29:04.720
是的，但是像是什么，实际是什么

00:29:06.880 --> 00:29:12.720
但是我去了，我去了一个带给你的，因为你们

00:29:12.720 --> 00:29:19.360
看起来这是同一个话题，但是这样，所以um链安全

00:29:19.360 --> 00:29:22.799
是他正在做最终代币的罗素实施的人们

00:29:22.799 --> 00:29:27.039
打开这个问题，然后遇到麻烦

00:29:27.039 --> 00:29:32.640
滥用地图键，看起来像是

00:29:32.640 --> 00:29:35.440
使用标准的调查实施方案，以及

00:29:35.440 --> 00:29:39.919
它只是停留在它转换为的任意字节上

00:29:39.919 --> 00:29:44.880
他们在go和um中正在做的字符串

00:29:44.880 --> 00:29:48.320
彼得指出这是因为

00:29:48.320 --> 00:29:52.480
包含任意标签的序列化标签

00:29:52.480 --> 00:29:56.399
嗯，就像用户甚至可以

00:29:56.399 --> 00:29:59.919
控制这是怎么回事，但我认为嗯，所以

00:29:59.919 --> 00:30:03.919
实际的交易是只有用户

00:30:03.919 --> 00:30:11.360
控制字面上是正确的，所以这是我不知道我在跟谁说话

00:30:11.360 --> 00:30:14.240
昨天亚历克斯（Alex）大约做了很多事情

00:30:14.240 --> 00:30:19.600
规范演员和嗯，以及他们的表现如何

00:30:19.600 --> 00:30:22.320
他们计划定期进行升级，他向我展示了一些

00:30:22.320 --> 00:30:26.399
迁移的东西对我和我来说都是个黑匣子

00:30:26.399 --> 00:30:30.159
嗯，所以我们有空间提出一些建议

00:30:30.159 --> 00:30:37.120
这些事情发生了变化，这不是我们可以

00:30:37.120 --> 00:30:41.120
重写历史记录，因为历史记录有些卡住，但是您

00:30:41.120 --> 00:30:45.200
我们可以有时间点来重写历史记录

00:30:45.200 --> 00:30:48.880
向前一点，他们就是他们，他们将定期这样做

00:30:48.880 --> 00:30:53.200
无论如何，所以这里有几件事

00:30:53.200 --> 00:30:58.320
一个是我们已经打算在这个空间说话

00:30:58.320 --> 00:31:03.120
提交硬币并说这是一种更好的方式，例如也许我们说你认识你

00:31:03.120 --> 00:31:06.159
应该使用utf-8清洁，您知道那只是一个

00:31:06.159 --> 00:31:09.039
假设的你知道，但是也许有一种方法你应该做

00:31:09.039 --> 00:31:12.960
这将在各个实现之间变得更加稳定，因为

00:31:12.960 --> 00:31:18.320
由于种种原因，这有点像是的

00:31:18.320 --> 00:31:21.679
谈论只是说说而已

00:31:21.679 --> 00:31:25.039
据说文件硬币实施在多个地方做了什么

00:31:25.039 --> 00:31:28.720
好的ipld人们说，除了字符串键，我们什么都没有

00:31:28.720 --> 00:31:32.640
所以我们将所有内容都以字节为单位，并对其进行字符串化，

00:31:32.640 --> 00:31:37.840
生锈，我对go um的一串亮光实现感到抱歉

00:31:37.840 --> 00:31:42.320
好吧，对别人不是很友善

00:31:42.320 --> 00:31:48.399
嗯，所以我们可以在这里建议更改嗯，但另一件事是ii

00:31:48.399 --> 00:31:51.120
其实就是这个

00:31:51.120 --> 00:31:56.320
实施人员建议，像这样改变的嗯，但我

00:31:56.320 --> 00:32:00.000
也因为我们被召集到此，所以我们有任何反馈意见

00:32:00.000 --> 00:32:04.640
关于这个，我们要做，因为我认为生锈的人会拥有

00:32:04.640 --> 00:32:07.760
无论如何都可以与之共存，因为他们已经在链上了，所以

00:32:07.760 --> 00:32:11.679
无论如何，您将不得不处理这部分历史

00:32:11.679 --> 00:32:15.200
但是我们有什么建议可以使他们更满意

00:32:15.200 --> 00:32:18.880
像沃尔克一样，您将能够提供更好的服务

00:32:18.880 --> 00:32:22.960
就未来某个时候的编解码器而言

00:32:22.960 --> 00:32:30.640
处理这个或是的，这是这个标签吗？

00:32:30.640 --> 00:32:33.120
我们只是喜欢它可以从

00:32:33.120 --> 00:32:38.720
字符串转换为字节，所以如果可以选择的话，那是什么意思

00:32:38.720 --> 00:32:42.080
虽然因为我们无法更改编码值，但是您可以更改

00:32:42.080 --> 00:32:44.480
代表，所以如果你只是想做到这一点

00:32:44.480 --> 00:32:48.000
dag cboard使用自行车钥匙的生锈图

00:32:48.000 --> 00:32:52.559
然后他们将它们序列化为基本上被占用的字节

00:32:52.559 --> 00:32:59.279
是标签也是关于键的还是现在没有标签是关于值的

00:32:59.279 --> 00:33:02.799
是的，它是可用的，所以基本上，哦，等一下，所以它不是

00:33:02.799 --> 00:33:07.039
关于键，所以这实际上是关于一个值，是的，所以是的，所以有两件事

00:33:07.039 --> 00:33:12.240
右边有竖琴和adls

00:33:12.240 --> 00:33:15.679
在其中cbor正确编码

00:33:15.679 --> 00:33:20.159
他们是他们，这是一个奇怪的地图事物，具有一对值和多个值

00:33:20.159 --> 00:33:24.559
是字节，那么您应该将其解释为具有

00:33:24.559 --> 00:33:28.320
这些字节作为可能正在进行字符串转换的键，但是

00:33:28.320 --> 00:33:31.519
c4表示形式很好，然后我们得到了

00:33:31.519 --> 00:33:34.880
在市场上，他们有一个标签字段

00:33:34.880 --> 00:33:40.960
用户指定了任意内容，并且他们正在推动seabit咬编码

00:33:40.960 --> 00:33:44.480
到那个字符串字段，所以这是无效的

00:33:44.480 --> 00:33:48.640
我猜的地方是正确的，为什么用于标签

00:33:48.640 --> 00:33:50.799
那里

00:33:51.039 --> 00:33:54.080
我认为这就是杰森本来的领域，不是吗

00:33:54.080 --> 00:33:57.200
是的，那是从简单的事情开始的。

00:33:57.200 --> 00:34:00.640
然后变成了杰森，但那不是重点

00:34:00.640 --> 00:34:06.480
现在区块链中有地方吗

00:34:06.480 --> 00:34:09.280
接受任意用户输入，因为标签

00:34:09.280 --> 00:34:12.399
只是常规内容，现在您可以从字面上

00:34:12.399 --> 00:34:15.760
在上面写任何东西，是的，有两个

00:34:15.760 --> 00:34:18.720
放置模板是放置交易之一

00:34:18.720 --> 00:34:21.919
抱歉，您已发送交易并发送了交易

00:34:21.919 --> 00:34:26.399
它是字节，因此您可以按字面意思将任何内容写入往返

00:34:26.399 --> 00:34:29.359
不幸的是，您还可以写任何内容的标签是

00:34:29.359 --> 00:34:31.520
弦，这就是整个摩擦的地方

00:34:31.520 --> 00:34:35.839
来自为什么他们要那样做

00:34:35.919 --> 00:34:39.359
这实际上看起来很清晰，这应该是

00:34:39.359 --> 00:34:43.440
咬一口，让我们改变它来改变咬

00:34:43.440 --> 00:34:47.599
是的，但听起来他们正在尝试，是的，这可能超出了

00:34:47.599 --> 00:34:52.159
我们，因为它不是ipl它不是daxy但它很简单

00:34:55.679 --> 00:35:03.839
我实际上不确定ii认为这是税项我不确定自己

00:35:07.839 --> 00:35:10.880
我认为问题是，如果您将其更改为

00:35:10.880 --> 00:35:14.160
个字节，然后您使用自动嵌入

00:35:14.160 --> 00:35:17.680
代码生成或序列化，就像他们默认的代码一样

00:35:17.680 --> 00:35:20.480
目前在罗素计算中存在的问题是

00:35:20.480 --> 00:35:24.079
目前在xc球中听起来像这样

00:35:24.079 --> 00:35:28.560
事物具有标签字符串，但具有任意字节，如果您进行更改，

00:35:28.560 --> 00:35:32.800
到更高级别的两个字节，这变成

00:35:32.800 --> 00:35:36.079
个字节和任意字节，但是我想当然是一个区块链，您需要

00:35:36.079 --> 00:35:38.560
仍然在静止的地方处理旧的

00:35:38.560 --> 00:35:42.079
有弦乐和分隔线，是的，所以真正的问题是

00:35:42.079 --> 00:35:44.720
从字面上看，他们正在按规范进行更改，而实际上我们只是

00:35:44.720 --> 00:35:48.560
谈论哪个就像他们将事物编码成不是utf-8的字符串一样

00:35:48.560 --> 00:35:51.599
现在他们使用的是一种需要评估tfa的语言，因此

00:35:51.599 --> 00:35:56.240
他们得到一个x这样的字面问题就好了，所以

00:35:56.240 --> 00:36:01.440
好，所以他们需要弄清楚的是他们将如何

00:36:01.440 --> 00:36:04.880
弄清楚他们何时编码这些特定的块

00:36:04.880 --> 00:36:08.960
以及他们如何以某种方式告诉解码器将其编码为一个字节

00:36:08.960 --> 00:36:12.480
取而代之的是他们目前正在做的事情

00:36:12.480 --> 00:36:14.560
他们目前使用的是什么

00:36:14.560 --> 00:36:17.760
分叉得很生锈，所以他们肯定分叉来做这件事

00:36:17.760 --> 00:36:21.920
因此他们基本上无法使用默认值

00:36:21.920 --> 00:36:25.359
生锈严重了，是因为

00:36:25.359 --> 00:36:28.720
是的，我的意思是，当您将无效的字符串数据编码为

00:36:28.720 --> 00:36:30.800
像您这样的字符串会破坏某些语言

00:36:30.800 --> 00:36:34.079
这就像预期的行为，我不知道他们为什么会这样认为

00:36:34.079 --> 00:36:38.400
是别人会破坏某些现场照片的东西

00:36:38.400 --> 00:36:42.320
像某些人也可以选择在这里使用ffi字符串，

00:36:42.320 --> 00:36:45.760
我认为他们还不错，但是像我这样不合理

00:36:45.760 --> 00:36:48.640
意味着像他们有一个字符串类型，他们将使用它来像这样的字符串

00:36:48.640 --> 00:36:50.720
那就是每个人都喜欢的

00:36:50.720 --> 00:36:54.320
那差不多就是一个特定的问题

00:36:54.320 --> 00:36:57.680
因为应该有一种更简单的方式让您说

00:36:57.680 --> 00:37:01.839
嘿，不要编码，这在某种程度上可能是一个问题

00:37:01.839 --> 00:37:08.160
我认为基本上只是快速解决方案，我想只是为了使其正常工作

00:37:08.160 --> 00:37:10.400
因为这就是重点，但我认为是的

00:37:10.400 --> 00:37:12.960
但仍然喜欢它在那里，所以实际上它在那里我认为那是

00:37:12.960 --> 00:37:18.720
问题回到那里，字符串是对的，如果您击败了所有这些字符串，那将是有效的

00:37:18.720 --> 00:37:22.000
一切，但我们会没事的，所以我的意思是

00:37:22.000 --> 00:37:25.200
像他们，他们应该只使用字节，我的意思是我不知道你为什么不

00:37:25.200 --> 00:37:27.920
原来是这样会更好

00:37:27.920 --> 00:37:30.560
鉴于链上有数据，他们将不得不像

00:37:30.560 --> 00:37:35.680
知道可以解决这个问题的编解码器，尽管我的意思是也许我们的反馈是

00:37:35.680 --> 00:37:37.760
简单地说，您应该改变尊重以说

00:37:37.760 --> 00:37:41.599
这是字节，然后它们就不像历史数据那样工作了

00:37:41.599 --> 00:37:45.359
意味着他们必须像走人一样插话，人们会说很好，这可能是一个

00:37:45.359 --> 00:37:47.760
在某个地方串起来，例如我不知道，也许是有原因的

00:37:47.760 --> 00:37:50.320
这也许是我们实际上向汉娜讨价还价的东西

00:37:50.320 --> 00:37:54.720
因为这是真的，实际上到目前为止所有历史数据

00:37:54.720 --> 00:37:58.880
是二进制海战，并且已经编码了半机械人

00:37:58.880 --> 00:38:04.800
或ascii，所以它不会破坏任何东西，是的，也许这是我们最喜欢的东西

00:38:04.800 --> 00:38:08.480
像这样被错误地标记为字​​符串，只是因为它是如此简单并且

00:38:08.480 --> 00:38:13.200
去做字符串和字节的转换，但是应该只是字节

00:38:13.200 --> 00:38:16.640
好的，也许这是搁置的东西，但是像ii一样想要

00:38:16.640 --> 00:38:22.000
只是说像eric一样，您可能会

00:38:22.000 --> 00:38:27.920
最终需要一个功能，然后有人可以应用表示以下内容的架构

00:38:27.920 --> 00:38:31.440
这是字节，我不在乎它是否表示数据中的字符串

00:38:31.440 --> 00:38:35.520
您将其编码和解码为字节的模型，以便它们甚至获得一致的值

00:38:35.520 --> 00:38:40.160
在他们做得很好之后，是的，我的意思是从字面上看

00:38:40.160 --> 00:38:47.839
像是的迁移权

00:38:49.200 --> 00:38:51.760
我知道您对于迁移的工作方式有一个完整的计划，但是

00:38:51.760 --> 00:38:54.960
就像在迁移中一样，您会重新解释旧的

00:38:54.960 --> 00:38:58.960
新格式的数据，您不必喜欢重写数据

00:38:58.960 --> 00:39:02.079
因为我们无法重写数据，这是一个区块链

00:39:02.079 --> 00:39:05.599
像是的，是的，如果您像您这样编写两个架构，

00:39:05.599 --> 00:39:10.720
只要匹配一个就可以了，他们就像啊，好吧，就是这样

00:39:10.720 --> 00:39:14.400
但您不能再像匹配那样做那样的事情

00:39:14.400 --> 00:39:18.160
ii链接了大约五分钟前的内容，这就是升级的工作方式

00:39:18.160 --> 00:39:21.440
我们像七月一样进行了如此大的讨论

00:39:21.440 --> 00:39:24.640
签名将如何工作信号是链高

00:39:24.640 --> 00:39:28.560
从字面上看，就像你有确切的身高好吧，那就是切换模式

00:39:28.560 --> 00:39:31.760
之类的东西，所以我的意思是你会

00:39:31.760 --> 00:39:36.400
想要在通过链条时提供模式

00:39:36.400 --> 00:39:38.960
改变，您实际上可以只看数据并说

00:39:38.960 --> 00:39:41.920
哪个类型的标签没有，如果它有字符串标签，那么你知道

00:39:41.920 --> 00:39:45.119
您正在谈论哪种模式嗯，是的

00:39:45.119 --> 00:39:46.880
是的，就像我们不必看它哦

00:39:46.880 --> 00:39:50.240
哦，哦，我的意思是我们需要标签的c好的，是的

00:39:50.240 --> 00:39:53.200
是的，我们已经准备好描述迁移了，我对这些模式很感兴趣

00:39:53.200 --> 00:39:55.119
没有什么具体的，我们有信心

00:39:55.119 --> 00:39:59.040
关于我确定filecoin也有一些迁移机制，我知道

00:39:59.040 --> 00:40:02.079
没什么，但是我会认为这很好，我不在乎

00:40:02.079 --> 00:40:05.839
是我可以接受的知识量

00:40:05.839 --> 00:40:11.280
我们似乎都同意在这种情况下这个特定问题一二

00:40:11.280 --> 00:40:13.520
四八有这个领域是

00:40:13.520 --> 00:40:17.760
当前指定为字符串，并且包含非utf可信字节和

00:40:17.760 --> 00:40:20.480
我们认为这很愚蠢，应该只是一个字节

00:40:20.480 --> 00:40:24.400
领域，因为这显然在行为上是可以的

00:40:24.400 --> 00:40:28.480
非常简单，我们是这里唯一要运行的东西

00:40:28.480 --> 00:40:32.480
我们可能会作为一个团队将其视为

00:40:32.480 --> 00:40:37.599
潜在的学习经验是什么时候而不是如果发生的

00:40:37.599 --> 00:40:41.680
人们确实将非utf-8字节放在串行字符串中，然后

00:40:41.680 --> 00:40:44.880
其他人必须处理结果，这就是一件事

00:40:44.880 --> 00:40:49.119
有趣的建立在顶部的库之一

00:40:49.119 --> 00:40:53.200
您正在写的东西中的一部分将需要能够阅读此部分

00:40:53.200 --> 00:40:56.079
C板输入错误的链条

00:40:56.079 --> 00:40:58.880
你是怎样做的

00:40:59.119 --> 00:41:03.040
是的，这就是迁移计划的内容，实际上您最终会得到

00:41:03.040 --> 00:41:07.839
这两个版本都有两个模式，我们已经序列化了数据

00:41:07.839 --> 00:41:14.720
存在并且在cbor中被标记为说我是一个字符串，它包含

00:41:14.720 --> 00:41:18.319
这些非utf-8字节，您将如何处理

00:41:18.319 --> 00:41:22.800
实施者一天结束时您将要做什么

00:41:23.200 --> 00:41:27.119
这就是问题

00:41:27.119 --> 00:41:31.119
这就是为什么我主张您的图书馆应该抓紧处理它的原因

00:41:31.119 --> 00:41:36.240
知道叮咬是什么，就像别随便走动，因为那是

00:41:36.240 --> 00:41:39.680
我在这样的一天看到的唯一定义有一个问题

00:41:39.680 --> 00:41:44.640
这导致我的实施工作

00:41:44.960 --> 00:41:48.000
我的意思是你可能想用某种语言来做

00:41:48.000 --> 00:41:53.760
锈在这是一个问题的地方是尝试反序列化字符串和

00:41:53.760 --> 00:41:56.720
如果由于无效字符而失败

00:41:56.720 --> 00:42:00.480
然后您基本上会检查自己是否处于严格模式下，以及

00:42:00.480 --> 00:42:02.960
如果您处于转换模式，则不处于严格模式

00:42:02.960 --> 00:42:06.800
然后您将其更改为一个字节值

00:42:08.079 --> 00:42:12.560
那会很烂，但是这是克服这个障碍的唯一方法

00:42:12.560 --> 00:42:16.560
像超级显式的代码一样，总是说这样的属性

00:42:16.560 --> 00:42:19.920
作为他们正在做什么的字节值，我认为

00:42:19.920 --> 00:42:22.640
在其余的时候，它会正常工作，实际上

00:42:22.640 --> 00:42:30.240
像是的一样，将一些受邀的数据无声地扔掉。

00:42:30.240 --> 00:42:34.079
我们将只接受流中的无效数据

00:42:34.079 --> 00:42:38.319
但是想用uh替换它，这个unicode的东西好吧，它将

00:42:38.319 --> 00:42:41.599
它将保持正确，好吧，这是你们说的唯一的地方

00:42:41.599 --> 00:42:44.560
上一次好极了，是的，没有山羊

00:42:44.560 --> 00:42:47.200
夫妇有一些图书馆的功能

00:42:47.200 --> 00:42:50.720
我不太喜欢它关于Unicode的行为

00:42:50.720 --> 00:42:57.040
错误字节，但它显示在json库之类的内容中，而某些字符串

00:42:57.040 --> 00:42:59.359
漂亮的打印机和东西，但这是在

00:42:59.359 --> 00:43:04.640
我们可以选择不使用的相对较高级别的库，这很好

00:43:08.240 --> 00:43:15.920
嗯，那杆的动作项目是什么，您会在

00:43:15.920 --> 00:43:21.440
关于这个问题，也许抱歉，我会回去，我只是说看一下

00:43:21.440 --> 00:43:25.040
这是不幸的事情之一吗

00:43:25.040 --> 00:43:28.880
语言的想象力和生锈的人将不得不处理

00:43:28.880 --> 00:43:33.040
至少有历史数据，但我们的建议是该领域

00:43:33.040 --> 00:43:37.280
只是应该更改为字节，以备将来升级

00:43:37.280 --> 00:43:40.319
以便将其编码为字节字符串，然后

00:43:40.319 --> 00:43:43.839
每个人都很容易，因为我们只承认这件事是任意的

00:43:43.839 --> 00:43:46.240
它在规范中实际上是任意的

00:43:46.240 --> 00:43:50.560
因此，将其设为任意um，然后停止处理字符串，那就是

00:43:50.560 --> 00:43:53.440
那是我们能做的最好的事，但是不幸的是

00:43:53.440 --> 00:43:55.839
我的意思是，对不起，我确定罗斯人已经知道他们将要

00:43:55.839 --> 00:43:58.000
无论如何都要处理这些数据，就像

00:43:58.000 --> 00:44:01.280
我们必须处理历史工艺，所以

00:44:01.280 --> 00:44:05.359
是的，但让我们在未来做得更好，然后也许我会

00:44:05.359 --> 00:44:08.720
把汉娜拉进去，因为我不知道汉娜是否要处理更多事情

00:44:08.720 --> 00:44:13.839
但是，这有点像汉娜的篮子

00:44:15.680 --> 00:44:19.440
好的，谢谢，我想就是这样

00:44:19.440 --> 00:44:27.280
是的，在gen项目上做到了，接下来，我的名字叫chris

00:44:27.680 --> 00:44:31.680
 chris uh是的，我们只是问了一个简短的问题

00:44:31.680 --> 00:44:38.079
曾经喜欢ab tree adl的最新想法是什么

00:44:43.359 --> 00:44:48.160
那是什么意思

00:44:49.040 --> 00:44:52.880
我认为在此通话中没有任何人需要任何人的许可

00:44:52.880 --> 00:44:56.560
被列入白名单以制作新的adl

00:44:56.560 --> 00:45:00.000
梦想是，这应该像一般的插件一样

00:45:00.000 --> 00:45:03.359
你想今天就去做

00:45:03.359 --> 00:45:06.400
获准与某人签约，所以嗯

00:45:06.400 --> 00:45:10.000
我们在说罗恩，我现在正在和某人说话

00:45:10.000 --> 00:45:14.880
但是那样的话甚至还没有准备好谈论嗯

00:45:14.880 --> 00:45:19.040
我们很好，就像它可能是一棵红黑树

00:45:19.040 --> 00:45:23.440
是的，可以让你做某事的东西

00:45:23.440 --> 00:45:26.960
就像这里的非精确查询一样，我们很谦虚

00:45:26.960 --> 00:45:31.680
大麻，用于完全匹配的精确查找，但是如果您想

00:45:31.680 --> 00:45:35.599
范围或类似的东西，那么你需要被对待，

00:45:35.599 --> 00:45:37.599
是的，所以我只是想知道我的意思是因为我们没有一个我没看到的

00:45:37.599 --> 00:45:39.839
规格中的任何内容我想知道我们是否谈论过

00:45:39.839 --> 00:45:42.640
不，我们出于某种原因永远不会这样做，但这听起来

00:45:42.640 --> 00:45:46.240
就像没有人一样，这是个好消息，是的，甚至

00:45:46.240 --> 00:45:51.200
更好的人实际上建造了它，是的，我是说Rod做了很多

00:45:51.200 --> 00:45:53.599
当他第一次开始探索时

00:45:53.599 --> 00:45:57.040
我们想看一堆各种各样不同的收藏

00:45:57.040 --> 00:45:59.119
嗯，为什么他们没有做的原因

00:45:59.119 --> 00:46:02.079
到目前为止，已经完成了很多工作

00:46:02.079 --> 00:46:06.560
进入文件币，这些数据结构将不会

00:46:06.560 --> 00:46:11.680
像您一样哈希连续的um，除非您可以保证

00:46:11.680 --> 00:46:14.480
你总是要做一个平衡，然后他们将不会有相同的

00:46:14.480 --> 00:46:18.079
与其他人使用相同的数据进行散列，因为插入顺序确实在进行

00:46:18.079 --> 00:46:22.880
改变结构，所以它们对区块链没有用

00:46:22.880 --> 00:46:26.960
它们对于某些不同的内容寻址用途没有用

00:46:26.960 --> 00:46:29.839
案例，但它们对于数据库确实很重要

00:46:29.839 --> 00:46:33.359
和其他类似的东西，例如我真的想要dagdb，因为

00:46:33.359 --> 00:46:35.839
对于二级索引，我不需要一致的

00:46:35.839 --> 00:46:40.000
哈希，但因为您实际上没有像我这样在各方之间共享

00:46:40.000 --> 00:46:44.960
主要商店需要它，所以很好，但是像我们一样

00:46:44.960 --> 00:46:48.640
我们终于可以解决这个问题了，然后

00:46:48.640 --> 00:46:52.240
一次，我们那里有一些好的模式和一些好的东西，然后像

00:46:52.240 --> 00:46:57.520
我想在射箭场上做支点沃克需要写射箭

00:46:57.520 --> 00:47:03.359
好吧，什么是射箭地理空间索引

00:47:04.400 --> 00:47:07.359
我还要提到UM暂时不在通话中的其他人，但是

00:47:07.359 --> 00:47:11.119
与Piergos的ian聊天可能很好

00:47:11.119 --> 00:47:15.760
我知道的项目在某些时候他们已经使用了其他

00:47:15.760 --> 00:47:19.839
我认为更接近b加这样的树结构，然后它们移到了

00:47:19.839 --> 00:47:23.280
汉普顿冠军，但您可能会有一些有趣的事情

00:47:23.280 --> 00:47:26.720
关于我的观察，我认为他们是受嗯驱动的

00:47:26.720 --> 00:47:30.160
有关融合故事的内容，但他们

00:47:30.160 --> 00:47:34.559
他们运送了一堆其他树形结构已有一段时间了，所以可能

00:47:34.559 --> 00:47:38.079
那里的学习经验，是的，绝对是的

00:47:38.079 --> 00:47:43.280
很好，他潜伏着，我想他也很可靠地在我们的IRC上工作

00:47:43.280 --> 00:47:47.440
找不到电子邮件，我不知道我做什么，我有一种预感

00:47:47.440 --> 00:47:50.559
一种形式，至少有一种形式，我们可以

00:47:50.559 --> 00:47:54.480
确实有一些接近规范的工具

00:47:54.480 --> 00:47:58.160
结构这将是非常新颖的

00:47:58.160 --> 00:48:02.640
实现某种b或红黑或其他平衡

00:48:02.640 --> 00:48:07.920
如此收敛的数据结构，我认为与这些

00:48:07.920 --> 00:48:11.520
数据结构将必须有多个

00:48:11.520 --> 00:48:14.559
每个都有不同权衡的图像实现

00:48:14.559 --> 00:48:17.760
这是正确的方法，因为不同的用户

00:48:17.760 --> 00:48:21.440
需要不同的权衡，所以一些用户不会在乎我在乎交易

00:48:21.440 --> 00:48:24.079
关于融合，他们只是想提高一些用户的效率

00:48:24.079 --> 00:48:29.280
不会在乎块大小，因此就像您知道的那样，二叉树可能是

00:48:29.280 --> 00:48:32.720
很好，但有些用户会关心

00:48:32.720 --> 00:48:35.839
块大小如此，然后突变成为问题

00:48:35.839 --> 00:48:38.559
我认为应该有多个邀请函，所以如果

00:48:38.559 --> 00:48:41.440
您有想法，您绝对应该尝试一下，因为

00:48:41.440 --> 00:48:44.079
看到什么摆脱了这个过程真的很有趣，

00:48:44.079 --> 00:48:48.720
然后找出这些权衡的优势是什么

00:48:48.720 --> 00:48:51.680
是的，我认为我们有时会错误地认为像ipld一样

00:48:51.680 --> 00:48:54.640
数据库的级别类似于

00:48:54.640 --> 00:48:58.240
集中式模型um，但实际上就像

00:48:58.240 --> 00:49:02.640
磁盘正确，所以这不像我们要拥有数据库或方法

00:49:02.640 --> 00:49:06.079
这就像有许多数据库一样，因为

00:49:06.079 --> 00:49:08.240
它们都有非常不同的性能配置文件，

00:49:08.240 --> 00:49:11.200
他们实现这两种性能差异的方式主要是

00:49:11.200 --> 00:49:13.920
他们如何将这些内容写入磁盘以及如何进行事务架构

00:49:13.920 --> 00:49:16.800
彼此之间，所以就像我们最终要

00:49:16.800 --> 00:49:20.160
许多不同的树在功能上执行相同的操作，但具有

00:49:20.160 --> 00:49:22.960
完全不同的性能特征

00:49:22.960 --> 00:49:26.240
也许我们不是光碟，但我们喜欢玫瑰的概念

00:49:26.240 --> 00:49:29.599
结构[笑声]

00:49:29.599 --> 00:49:34.240
是的，我的意思是像您在其中实现链接的地方

00:49:34.240 --> 00:49:38.559
在数据库中，您的字面写法就像其他位置

00:49:38.559 --> 00:49:41.599
磁盘是正确的，嗯，我们基本上就像

00:49:41.599 --> 00:49:44.000
链接层，例如我们在哪里定义的方式

00:49:44.000 --> 00:49:49.440
这些东西是如何联系在一起的，所以有点类似

00:49:49.920 --> 00:49:53.119
我也认为研究类似的东西很酷

00:49:53.119 --> 00:49:57.280
贵族树的结构，因为在我看来，你可以

00:49:57.280 --> 00:50:02.240
做一些patricia b plus树的杂种，你可能会到某个地方

00:50:02.240 --> 00:50:05.760
既经过分类又合理有效且合理

00:50:05.760 --> 00:50:08.640
融合友好

00:50:08.880 --> 00:50:12.240
有趣的是，我认为我们在这里有点

00:50:12.240 --> 00:50:16.720
低估了我们可以在原始的adl错误之上完成多少工作

00:50:16.720 --> 00:50:19.839
嗯，因为就像你像匕首一样看

00:50:19.839 --> 00:50:23.200
你已经是你了，所以你必须在不同状态之间散列数据库

00:50:23.200 --> 00:50:26.800
然后您总是可以对这些状态之间的主存储进行比较

00:50:26.800 --> 00:50:30.960
因此，这意味着只要您将每个索引与一个索引配对

00:50:30.960 --> 00:50:34.480
那么对于任何状态，您始终只能应用差异

00:50:34.480 --> 00:50:38.559
越过它们，因此您实际上会变得非常有趣且更好

00:50:38.559 --> 00:50:41.839
我会拥有的批处理性能特征

00:50:41.839 --> 00:50:46.319
像在红色的黑树旁边的根旁边放一个汉普

00:50:46.319 --> 00:50:49.440
就像您已经拥有非常好的性能特征一样

00:50:49.440 --> 00:50:51.760
在他们和你之间，你正在克服

00:50:51.760 --> 00:50:55.920
你会有很多问题，我想知道你能走多远

00:50:55.920 --> 00:50:58.960
像我们在哪里一样如何获得混合动力

00:50:58.960 --> 00:51:01.040
将这些不同的数据结构中的一些推到一起以获得不同的

00:51:01.040 --> 00:51:03.760
特征

00:51:04.400 --> 00:51:09.200
这是一个很酷的问题空间，例如我想停止管理

00:51:09.200 --> 00:51:12.640
就像玩这个，但是

00:51:14.240 --> 00:51:17.920
如果我刚穿上红色外套，那应该是我的果酱，我们有

00:51:17.920 --> 00:51:25.280
还有五分钟的路程，人们可能想谈谈其他事情

00:51:25.280 --> 00:51:30.240
关于，所以我只是在我中加入了一个链接

00:51:30.240 --> 00:51:33.359
使用cddl进行了很多工作，因此您可能需要看一下

00:51:33.359 --> 00:51:36.960
写了整个规格，我一直在做一些

00:51:36.960 --> 00:51:39.520
我的工作分支逻辑，它确实起作用

00:51:39.520 --> 00:51:47.119
因此，如果测试ncdl的有效性，则进行分支，如果

00:51:47.119 --> 00:51:53.920
基于它的类型，只是这个uh休息库是

00:51:53.920 --> 00:51:57.680
昨天刚刚更新，我认为它现在支持同时验证seabor

00:51:57.680 --> 00:52:00.079
也

00:52:02.839 --> 00:52:07.599
json可怜

00:52:08.800 --> 00:52:12.160
还要别的吗

00:52:14.559 --> 00:52:20.079
不，然后是的，然后我关闭会议，看到大家，

00:52:20.079 --> 00:52:25.760
下周再见大家好

00:52:26.079 --> 00:52:30.640
挂上抱歉，嗯，这是火腿的事，我们要谈谈

00:52:30.640 --> 00:52:34.720
汉普特哦斯图

00:52:34.720 --> 00:52:41.200
嗯，好吧，我们现在遇到的问题是上周合并的更改

00:52:41.490 --> 00:52:46.079
[音乐]工会有冲突，所以

00:52:46.079 --> 00:52:52.960
我去了一个元组代表

00:52:52.960 --> 00:52:56.720
我认为我已被感染的节点

00:52:56.720 --> 00:53:00.880
远的硬币需要使一切紧凑和小巧

00:53:00.880 --> 00:53:07.920
嗯，那里是链接，嗯，等等，但是当您转到此链接时，

00:53:07.920 --> 00:53:14.079
您所在的递归点

00:53:14.079 --> 00:53:18.800
呃或到子节点的链接，这是一种结合和存储桶

00:53:18.800 --> 00:53:21.920
本身是一个列表，并且散列图节点具有

00:53:21.920 --> 00:53:27.280
我们已被列为地图，所以嗯

00:53:27.520 --> 00:53:31.520
在我看来，最简单的答案是删除那里的表示形式元组

00:53:31.520 --> 00:53:36.800
然后将它们作为地图um使用，对此的反对只是

00:53:36.800 --> 00:53:40.839
通过在您的地图中插入地图键来浪费空间

00:53:40.839 --> 00:53:45.280
编码um也许我们缩短它们或者也许我们不

00:53:45.280 --> 00:53:48.000
担心那个

00:53:48.160 --> 00:53:53.040
那是我认为这是前进的主要途径

00:53:53.040 --> 00:53:56.480
前进就是将其重新变成地图

00:53:56.480 --> 00:53:59.359
任何人有任何想法

00:53:59.760 --> 00:54:03.040
这两个两个在地图中有两个字段一个是地图，一个是数据

00:54:03.040 --> 00:54:06.480
有一个映射是一个绑定器，以字节为单位，数据是一个

00:54:06.480 --> 00:54:11.839
数组um so

00:54:12.160 --> 00:54:18.160
不，是的，把它拉回到地图上听起来不错

00:54:18.160 --> 00:54:22.000
我称它们为位字段重命名b和数据重命名

00:54:22.000 --> 00:54:26.160
d我个人也认为该字段的名称映射确实

00:54:26.160 --> 00:54:31.200
没让我感到困惑这是一个很大的领域

00:54:33.280 --> 00:54:40.480
嗯，我会说这是一张地图，好吧，它仍然会缩短为b

00:54:40.480 --> 00:54:45.520
这是一个映射，嗯，好吧，我们这样做，是吗，您认为

00:54:45.520 --> 00:54:47.920
我们应该在其中使用重命名还是我们应该

00:54:47.920 --> 00:54:53.440
使名称简短化，为此要重命名用户

00:54:53.440 --> 00:54:55.839
他们是为了

00:54:56.319 --> 00:55:01.839
好吧，也许吧，好吧，位图，位字段，然后重命名

00:55:01.839 --> 00:55:06.160
它到b和数据，我们说我会读

00:55:06.160 --> 00:55:09.119
将数据重命名为d

00:55:10.160 --> 00:55:15.200
是的，我不知道我现在会做

00:55:16.720 --> 00:55:22.000
这样就可以了，还有什么我们还要做的吗

00:55:22.000 --> 00:55:24.799
一分钟

00:55:26.799 --> 00:55:32.960
不，看起来好像不那么嗯，然后再见大家，再见

00:55:32.960 --> 00:55:35.839
下周

00:55:38.920 --> 00:55:41.920
再见

