WEBVTT
Kind: captions
Language: zh-Hans

00:00:12.230 --> 00:00:21.390
欢迎大家参加本周的IPL同步，这意味着2020年4月6日，

00:00:21.390 --> 00:00:25.680
每周我们都会谈论过去一周中所做的事情，

00:00:25.680 --> 00:00:33.390
计划去做，然后讨论我们可能拥有的任何议程项目，以及

00:00:33.390 --> 00:00:38.610
请把您的名字放在与会者名单上，尽管大多数人都在那里

00:00:38.610 --> 00:00:46.010
已经是因为我是从上周开始复制的，所以我从我自己开始

00:00:46.010 --> 00:00:51.030
真的不记得我上周实际做了什么，但是其中之一

00:00:51.030 --> 00:00:57.420
事情是我仍然在做Matthew格式的事情，还是他在一周前

00:00:57.420 --> 00:01:05.159
但是现在事情已经合并，这导致我使用了适当的块API

00:01:05.159 --> 00:01:10.590
将会在本周工作，而在讨论锈蚀问题时，我也

00:01:10.590 --> 00:01:17.670
想到了这些东西，我基本上答应了，这个星期我会得到一些

00:01:17.670 --> 00:01:22.560
代码与Block API配合使用，使人们认可，是如何工作的

00:01:22.560 --> 00:01:28.850
因为即使是最后一个问题，我也认为东区已经过时了，是的，

00:01:28.850 --> 00:01:38.670
他们仍然对锈病CID公关开放，但我的主要评论毫无结果，真的很忙

00:01:38.670 --> 00:01:43.229
有五枚硬币，我不想退回，这不是非常紧急，所以我只是等待

00:01:43.229 --> 00:01:49.020
他有时间对其进行审查，但本周可能也有习惯，或者

00:01:49.020 --> 00:01:57.740
下周再说一点，我将在星期五和星期一休息

00:01:57.740 --> 00:02:02.240
是的，这就是我所拥有的

00:02:02.299 --> 00:02:07.880
我名单上的下一个是迈克尔

00:02:11.400 --> 00:02:16.670
是的，对不起，检查，是的，是的，所以嗯，我做了很多

00:02:16.670 --> 00:02:21.410
我一直在做的数据处理方面的主要重构工作

00:02:21.410 --> 00:02:26.930
好消息是，就像我突破了一堆限制

00:02:26.930 --> 00:02:34.060
我们在lambda和整个管道中都使用过，所以现在我们在处理数据

00:02:34.060 --> 00:02:39.710
每个存储桶大约每秒6吉比特，然后在以下位置创建汽车文件：

00:02:39.710 --> 00:02:45.830
大约每秒10到14 GB，并以20左右的速度为他们生成了kompy

00:02:45.830 --> 00:02:52.820
再加上大量的并发um，每秒就可以增加千兆字节

00:02:52.820 --> 00:02:58.250
最终，您可以同时在lambda中同时推动约3000

00:02:58.250 --> 00:03:04.670
 3000，您开始使用其他AWS基础架构，例如速率限制和

00:03:04.670 --> 00:03:10.550
滥用检测机制非常无证，无法更改，因此

00:03:10.550 --> 00:03:14.330
即使我们的极限技术上是一万，我们实际上也无法做到

00:03:14.330 --> 00:03:18.770
这么多非常糟糕的事情开始发生，所以

00:03:18.770 --> 00:03:22.610
不管怎么说，这太棒了，很快就会结束

00:03:22.610 --> 00:03:27.380
我们将有很多我剥离了原始数据，是的，我们将拥有

00:03:27.380 --> 00:03:33.920
就像我的字段数据的PB级一样，我们想要做类似的事情，然后您

00:03:33.920 --> 00:03:41.780
知道在周末和我们的休息日，我花了很多时间在dagby上

00:03:41.780 --> 00:03:47.360
所有这个图形存储界面都可能对您很有趣的事情，

00:03:47.360 --> 00:03:51.050
谈论了一段时间，不仅是存储块，而且还存储了

00:03:51.050 --> 00:03:54.740
试图了解一些图形信息，例如没有完整的信息

00:03:54.740 --> 00:04:00.040
图以及我基本上建立的GC可以完成的链接是什么

00:04:00.040 --> 00:04:04.490
有点符合我们一直在谈论的规范，我现在也

00:04:04.490 --> 00:04:09.200
在具有该图形信息的两个商店之间进行复制，因此您

00:04:09.200 --> 00:04:13.610
可以非常有效地不解析整个图形信息，以便

00:04:13.610 --> 00:04:18.680
弄清楚您是否需要从一个到另一个的任何数据，以及谁拥有什么

00:04:18.680 --> 00:04:23.690
所以这很酷，测试大概是八到十次

00:04:23.690 --> 00:04:26.810
乘以实际实现的大小

00:04:26.810 --> 00:04:33.139
令人难以置信的难以测试的事情，这很酷

00:04:33.139 --> 00:04:36.200
很快就会被大肆杀人，当它处于

00:04:36.200 --> 00:04:39.650
稍微好一点的状态，现在我只需要一个内存中的实现

00:04:39.650 --> 00:04:46.160
在II认为这之前完成s3的实现

00:04:46.160 --> 00:04:50.600
稳定，对大家来说，看看我们已经拥有的东西会很有趣

00:04:50.600 --> 00:04:54.940
谈论了一段时间，就到我了

00:04:54.940 --> 00:05:05.210
混合杆，所以对我来说，这就是本周有关比特币的全部内容

00:05:05.210 --> 00:05:12.560
格式化并找出将区块链提取到IP LD的最干净方法

00:05:12.560 --> 00:05:19.700
我们可以将其存储在汽车文件形式的扁平化图形中的块，以及

00:05:19.700 --> 00:05:24.020
恰到好处的感觉就像一个兔子洞，我预料到了，但是有一个

00:05:24.020 --> 00:05:29.240
这里的兔子洞是我没想到的那种性质，但你知道这一点

00:05:29.240 --> 00:05:35.840
提出一些有趣的问题，我想让团队了解我

00:05:35.840 --> 00:05:41.690
打算在本周的某个时候对此进行公关，以得到讨论

00:05:41.690 --> 00:05:52.190
帮助，这将帮助我在这里形成一种方法，但这是我们的

00:05:52.190 --> 00:05:56.450
CID加阻止的概念在您了解这些内容时会有点分解

00:05:56.450 --> 00:06:01.280
区块链，因为它们构想出识别区块链的方式

00:06:01.280 --> 00:06:10.190
数据，我想知道我们的概念有哪些优势，以及

00:06:10.190 --> 00:06:17.020
我们有一个哈希值是在多重哈希中将double char设为256

00:06:17.020 --> 00:06:23.390
这表明我们在边缘具有这种灵活性，但是能走多远

00:06:23.390 --> 00:06:32.539
例如在一个区块链区块中，有一些复合的例子

00:06:32.539 --> 00:06:36.490
在这里，随着您的前进，它变得越来越疯狂，因此您可以推动，您可以推动

00:06:36.490 --> 00:06:40.129
距离您很远，所以我们要么要决定

00:06:40.129 --> 00:06:44.839
线，或者我们说的很好，这是非常灵活的，您可以选择

00:06:44.839 --> 00:06:48.739
您在连续体上的观点，但那又暗示了多重

00:06:48.739 --> 00:06:56.539
哈希和多编解码器，是的，所以对于比特币，您有一个障碍是

00:06:56.539 --> 00:07:03.259
实际上是标题加上事务，而IP LD现在所做的方式是

00:07:03.259 --> 00:07:08.800
说的很好，在彩色编解码器意义上的一个比特币块就是标题

00:07:08.800 --> 00:07:14.330
这很好，因为您可以使用标头中的这九十个部分

00:07:14.330 --> 00:07:22.240
字节或其他大小，然后您可以运行double-sha-256，这是多has

00:07:22.240 --> 00:07:32.259
您可以得出一个CID，它与

00:07:32.259 --> 00:07:36.469
他们将在比特币世界中使用的标识符，除了我们提供的标识符

00:07:36.469 --> 00:07:40.749
他们以不同的方式将其呈现为年轻的大端琴弦

00:07:40.749 --> 00:07:46.490
Hextall如此，但您可以将他们的身份之一视为一个区块

00:07:46.490 --> 00:07:51.529
并反转它，并在它前面粘贴一些东西以进行CID

00:07:51.529 --> 00:07:54.589
而且您可以将其设为CID，以便从那里获取ID作为ID

00:07:54.589 --> 00:07:58.519
标识，所以它确实很干净，但不是整个块

00:07:58.519 --> 00:08:03.319
比特币区块也有交易，交易通过

00:08:03.319 --> 00:08:09.499
交易的默克尔路线，因此您必须通过此默克尔

00:08:09.499 --> 00:08:17.629
树状流程以获取实际交易，并在其中之一

00:08:17.629 --> 00:08:20.899
我认为是写原始库的人的有趣方法

00:08:20.899 --> 00:08:26.800
是杰里米还是史蒂芬

00:08:27.459 --> 00:08:33.740
因为我们有这两个多编解码器，这是比特币区块和比特币TX，所以

00:08:33.740 --> 00:08:39.889
Go库中有趣的方法之一是，Bitcoin TX可以识别

00:08:39.889 --> 00:08:47.509
可以是适当的交易部分，也可以是奇迹树上的叶子

00:08:47.509 --> 00:08:53.690
那笔交易，所以有一种可能是交易的想法

00:08:53.690 --> 00:08:57.440
通过这个块，这可能是交易，而该块可能是

00:08:57.440 --> 00:09:04.730
要么将两个哈希值放在一起，要么是60个64字节，要么长于64个字节

00:09:04.730 --> 00:09:11.080
字节，这是一个实际的事务，因此您可以拥有一个CID和一个块

00:09:11.080 --> 00:09:17.330
进行交易，这可能是实际交易，也可能是我继续进行的一部分

00:09:17.330 --> 00:09:21.590
默克尔树进行交易，因此理论上您可以

00:09:21.590 --> 00:09:31.070
用CR天数将一个比特币块分解为大量的IP LD块，然后

00:09:31.070 --> 00:09:35.570
那将是交易的标题，然后是所有的叶子

00:09:35.570 --> 00:09:39.860
默克尔树的名称来完成交易，所以这是

00:09:39.860 --> 00:09:44.180
有趣，因此扩展了多编解码器的想法，所以比特币TX

00:09:44.180 --> 00:09:49.400
识别两种不同类型的事物，如果您有

00:09:49.400 --> 00:09:53.510
数据，你知道它的长度，但是当它

00:09:53.510 --> 00:09:59.180
您可以进行交易，因为seg Witte向您介绍了这件事

00:09:59.180 --> 00:10:04.940
两个散列交易，您删除了所有见证人签名

00:10:04.940 --> 00:10:10.000
从交易中签名见证人数据，以便您将它们拉出并

00:10:10.000 --> 00:10:18.680
然后您将其散列，就好像它们不存在一样，然后给您

00:10:18.680 --> 00:10:24.890
交易的哈希值，因此您不能再获取原始的二进制数据并

00:10:24.890 --> 00:10:30.560
将其应用于double sha-256，并获得与该标识符相同的标识符

00:10:30.560 --> 00:10:38.270
标识符，因为他们使用您要么必须遵守他们的规则，

00:10:38.270 --> 00:10:42.589
认为会为您提供另一种途径来正确地散列所有数据

00:10:42.589 --> 00:10:46.550
但是它可能涉及创建另一个Multi multi

00:10:46.550 --> 00:10:53.240
编解码器至少另一个多编解码器，然后在其中添加其他IP LD块

00:10:53.240 --> 00:11:02.660
这棵树在这棵看起来很古怪的树中，或者回到了我最初的想法

00:11:02.660 --> 00:11:09.070
什么是哈希的概念，并且可能您可以做类似的事情

00:11:09.070 --> 00:11:16.510
说好吧，这个区块已经用比特币进行了哈希处理，这只是意味着您

00:11:16.510 --> 00:11:22.570
可以获取一个数据块并从中获取哈希值，该哈希值恰好包含一个

00:11:22.570 --> 00:11:27.970
256次加倍拍摄，加上一棵Merkle树，再加上256 s，这又怪异

00:11:27.970 --> 00:11:33.400
这是神圣的，而哈希算法就是所有这些东西，

00:11:33.400 --> 00:11:38.800
可以从数据中得出，但这不是经典的哈希算法

00:11:38.800 --> 00:11:41.350
感觉不是，这不是256的字符

00:11:41.350 --> 00:11:47.710
这是一种比特币方法，可从我们那里获得干净的可哈希事物标识符

00:11:47.710 --> 00:11:54.400
数据部分，然后扔掉比特币TX多编解码器，然后说

00:11:54.400 --> 00:11:58.510
这只是一个采用比特币散列的比特币区块，但这是一种方法，但是

00:11:58.510 --> 00:12:01.960
您可以采取许多其他方法，所有这些都进行

00:12:01.960 --> 00:12:06.520
回到哪里，我们围绕灵活性的想法的优势在哪里？

00:12:06.520 --> 00:12:12.870
多哈希或多编解码器，以及CID Plus块意味着一起执行什么操作

00:12:12.870 --> 00:12:20.290
好吧，我的问题就像在他们的演讲中，他们实际上有

00:12:20.290 --> 00:12:25.240
所有这些散列或他们认为地址如此的

00:12:25.240 --> 00:12:31.360
更好的问题是，当他们对该块进行哈希处理时，它们会丢失数据

00:12:31.360 --> 00:12:38.410
数据指向该数据的指针是的，是的，我仍然是那一点

00:12:38.410 --> 00:12:45.400
我现在正在工作，因为那让我有点困惑

00:12:45.400 --> 00:12:51.930
但我想我的意思是他们不能只喜欢耶，我知道我知道我知道我知道

00:12:51.930 --> 00:12:56.890
但重点是他们想从那时开始将其删除

00:12:56.890 --> 00:13:01.330
标准的哈希算法，因为人们正在使用它来做一些骇人听闻的事情

00:13:01.330 --> 00:13:05.380
与采矿业合作，因为他们拥有整个见证人数据部分，然后

00:13:05.380 --> 00:13:09.490
他们可以摆弄更有效的采矿，那时人们

00:13:09.490 --> 00:13:13.780
插入垃圾数据之类的东西变得一团糟，所以这个主意是

00:13:13.780 --> 00:13:19.240
将其从流程中删除，但我相信这里有一个

00:13:19.240 --> 00:13:22.990
指向所有这些东西的指针不被指定

00:13:22.990 --> 00:13:28.840
到Merkle树的根到存储在字段中的所有这些东西

00:13:28.840 --> 00:13:34.720
第二个区块的第一笔交易还没有弄清楚

00:13:34.720 --> 00:13:40.950
之所以起作用，是因为那里有一个先启事件，但是我

00:13:40.950 --> 00:13:48.340
相信它仍然是完整树的一部分，因此您可以扩展此比特币

00:13:48.340 --> 00:13:53.320
阻止比特币TX，然后让比特币作为另一位Majah同事见证，

00:13:53.320 --> 00:13:56.710
那么您仍然可以将它们全部链接在一起，并进行

00:13:56.710 --> 00:14:02.290
比特币的见证人，说默克尔树上的叶子也是这个东西

00:14:02.290 --> 00:14:08.500
我想你也可以做到，所以我的直觉在这里，我想知道

00:14:08.500 --> 00:14:13.840
埃里克（Eric）认为-我的直觉是完全不希望破坏链接，包括

00:14:13.840 --> 00:14:18.670
多重哈希，如果他们没有将此信息放在链接中，例如if

00:14:18.670 --> 00:14:27.700
他们就像是在其他地方以其他方式链接数据一样，

00:14:27.700 --> 00:14:31.920
您可以仅使用标题中的信息来得出如何到达那里

00:14:31.920 --> 00:14:36.160
那么我不明白为什么我们需要破解更多的链接，只有在

00:14:36.160 --> 00:14:41.020
他们实际上在链接或链接中的某些位置包含了这些信息

00:14:41.020 --> 00:14:44.140
他们的标题，这就是他们的方式，这就是信息被复制的方式

00:14:44.140 --> 00:14:49.180
周围，​​我们将需要在某处修改链接并添加另一个哦哥们

00:14:49.180 --> 00:14:54.070
像我知道的哈希，如果标题包括

00:14:54.070 --> 00:14:57.610
一个更充分的链接，即内容的长度，但是如果这像一个

00:14:57.610 --> 00:15:00.490
特定于应用程序的东西，以及它们如何处理数据结构，而您只是

00:15:00.490 --> 00:15:02.890
必须了解有关遍历的一些知识才能找到

00:15:02.890 --> 00:15:08.280
信息，只要像我们图表中的部分一样，将以某种方式获取所有数据

00:15:08.280 --> 00:15:12.430
如果您知道清洁的工作原理，您总是可以将其弄清楚

00:15:12.430 --> 00:15:18.970
我不认为我们应该进一步扩展它，但是是的，我想

00:15:18.970 --> 00:15:21.420
知道什么埃里克

00:15:22.710 --> 00:15:28.600
听起来对我来说是正确的，我不知道我不确定它是否较低

00:15:28.600 --> 00:15:37.700
在那里，我们现在可以同时使用JavaScript和go

00:15:37.700 --> 00:15:45.320
库将为您提供比特币阻止的CID到比特币标头的清晰映射

00:15:45.320 --> 00:15:53.389
如果您以前90个字节为单位进食，那么您会选择一个比特币块，而您

00:15:53.389 --> 00:15:57.470
从前90个切片中剔除，但成功之后，您将获得一个不错的方块来查看id

00:15:57.470 --> 00:16:02.779
映射，我们可以做到，这样您就可以输入整个块，它将完成

00:16:02.779 --> 00:16:06.740
同样的事情，只是给你一个比特币块加上CID，这就是

00:16:06.740 --> 00:16:11.240
运用1990年有偏见的双重份额，然后说出自己的模样

00:16:11.240 --> 00:16:16.070
从这里开始，如果您知道如何进入标头，则可以使用

00:16:16.070 --> 00:16:19.790
只要您拥有其余的

00:16:19.790 --> 00:16:24.290
阻止数据，但是现在我们已经介绍了

00:16:24.290 --> 00:16:27.980
切片标题并说不，这是块

00:16:27.980 --> 00:16:32.120
这是90个字节，所以我们不得不往回走，说不，不，我们什么也不做

00:16:32.120 --> 00:16:41.029
切成片状还是不可以，是的，不，是的，绝对，我们必须这样做

00:16:41.029 --> 00:16:45.320
我们必须按照我的意思做，如果我们要把这些适合我们

00:16:45.320 --> 00:16:51.130
块存储机制附加的块中没有数据，因此

00:16:51.130 --> 00:16:56.029
就像跑对了一样，我说过我们显示了收入，因此其余数据将

00:16:56.029 --> 00:16:59.149
必须在其他梅克尔树中必须要走的其他地方

00:16:59.149 --> 00:17:06.470
查找，是的，但在某种意义上来说，它像是散列的

00:17:06.470 --> 00:17:11.480
Merkle路线，但后来真正中断了IPL D ID的是

00:17:11.480 --> 00:17:19.189
您知道另一个链接，但是这一切都像blegh这样会中断

00:17:19.189 --> 00:17:24.140
当他们完成向多播存储的迁移时，我很快就可以了，因为

00:17:24.140 --> 00:17:28.069
对于他们来说，就像块存储在我的多重哈希中，

00:17:28.069 --> 00:17:31.880
哈希必须在块出现时对其进行验证，因此，如果

00:17:31.880 --> 00:17:40.400
阻止，就像你不能，你不喜欢在块上有额外的数据，所以我们

00:17:40.400 --> 00:17:45.230
基本上只会通过该CID存储标头，而其他数据将拥有

00:17:45.230 --> 00:17:48.570
您将只能通过其他方式获得其他某种查找机制

00:17:48.570 --> 00:17:52.980
树，这回到了我关于扩展多重哈希概念的观点

00:17:52.980 --> 00:17:57.620
因为我们已经通过将double sha引入256来做到这一点，这是一个

00:17:57.620 --> 00:18:03.720
那不是一个标准的哈希算法，分片为我们的256乘以2

00:18:03.720 --> 00:18:09.059
是为块比特币引入的，所以我们已经说了所有这些，这很奇怪

00:18:09.059 --> 00:18:11.669
您必须在此处执行的哈希算法，您不能只是整体地查找它

00:18:11.669 --> 00:18:14.970
哈希表，必须要在其他地方实现它

00:18:14.970 --> 00:18:17.910
因为我不认为多重哈希或任何这些库的影响

00:18:17.910 --> 00:18:26.970
本身，所以它们是同一件事，所以双256就像

00:18:26.970 --> 00:18:32.070
它只是将它的2p6应用于天堂两次，是的，好的

00:18:32.070 --> 00:18:35.280
好吧，不是，我的意思是，这就像是有效的激情函数，尽管那样

00:18:35.280 --> 00:18:40.169
像不可知论者一样，但是我们可以对其中的任何数据进行排序，然后获得正确的哈希值，并且

00:18:40.169 --> 00:18:44.460
我们会很好，就像我的意思是说这将是一件愚蠢的事情，但是就像你可以做到的那样

00:18:44.460 --> 00:18:47.669
从理论上讲，我认为就像我们在哪里

00:18:47.669 --> 00:18:53.280
可能是搞砸了，是的，是的，我们不应该存储

00:18:53.280 --> 00:19:00.299
块数据不是哈希的一部分，因为那是我认为我们

00:19:00.299 --> 00:19:11.820
否定了，但我完全明白了你的观点，就像我的意思是，即使

00:19:11.820 --> 00:19:15.360
我们有特殊的比特币功能，您也可以通过以下方式对其进行基本编码：

00:19:15.360 --> 00:19:20.760
您可以输入所需的任何数据，为什么不忙呢？它需要前90个

00:19:20.760 --> 00:19:24.750
个字节，如果Plata不够长，则可以用零或其他内容填充

00:19:24.750 --> 00:19:31.200
也将是一个散列，适用于您想要的人但对其他人而言的任何数据

00:19:31.200 --> 00:19:34.919
可以具有不同的数据并获得相同的哈希值，因为它们只是添加了不同的数据

00:19:34.919 --> 00:19:38.720
垃圾比利亚是问题所在

00:19:39.470 --> 00:19:47.490
是的，那不是那么好，那意味着我想攻击你的

00:19:47.490 --> 00:19:53.790
像发送给您一堆存储，您知道带有无效数据的有效标头，并且

00:19:53.790 --> 00:20:00.150
是的，对吧，这是一件好事

00:20:00.150 --> 00:20:04.800
当你看着那里时，这种窗帘落下了，我去剥了比特币

00:20:04.800 --> 00:20:15.420
代码，因为它会执行此操作以得出CID，因此会先对数据进行解码，然后再对数据进行解码

00:20:15.420 --> 00:20:21.960
然后在没有见证人数据的情况下重建它，然后对其进行哈希处理

00:20:21.960 --> 00:20:27.570
我们有交易ID，但您刚刚丢弃了该见证数据

00:20:27.570 --> 00:20:34.320
在那儿让您获得CID，我不知道当前是否直接映射到

00:20:34.320 --> 00:20:38.730
您希望从Merkle树获得的交易ID，但它

00:20:38.730 --> 00:20:45.060
比特币已经进入IPL d阶段，它正在做一个丢弃来做一个哈希，它说好吧，

00:20:45.060 --> 00:20:50.280
解码这个东西，我们现在拥有的对象，让我们把它的一部分放在一边

00:20:50.280 --> 00:20:56.550
再次将其放回去，然后对其进行哈希处理，使其包含哈希值

00:20:56.550 --> 00:21:00.650
所有数据，其中包含一个哈希

00:21:01.340 --> 00:21:12.330
所以不是，所以他现在是我的问题，好吧，我已经完成了，我已经解码了

00:21:12.330 --> 00:21:16.170
在JavaScript中，我可以解码整个比特币块，一切都出来了

00:21:16.170 --> 00:21:21.780
所有的部分，但是然后但是我知道我在做我的测试

00:21:21.780 --> 00:21:28.560
好的，这就是Jason中的结构，比特币API告诉我

00:21:28.560 --> 00:21:32.100
这个代码块包含的，这就是我的代码告诉我的结构

00:21:32.100 --> 00:21:38.870
它包含我，然后每五或七次交易标识符是错误的

00:21:38.870 --> 00:21:43.860
因为它们是包含此单独见证数据的数据，因此它们是

00:21:43.860 --> 00:21:49.260
一种是细分交易，因为我已经能够

00:21:49.260 --> 00:21:54.210
仅仅通过说就可以得出哈希值，因为我的哈希算法是如此

00:21:54.210 --> 00:22:01.350
它只是说开始块结束块在该部分上做双char 256，

00:22:01.350 --> 00:22:06.180
应该是标识符，而对于所有包含以下内容的标识符来说，它们都是错误的

00:22:06.180 --> 00:22:12.330
隔离数据，所以我需要抱歉，我想，我希望这会

00:22:12.330 --> 00:22:17.340
验证今天和明天，如果我要这样做，但是

00:22:17.340 --> 00:22:20.910
基本上，它将块解码，然后在没有见证人数据I的情况下进行重建

00:22:20.910 --> 00:22:24.900
将获得与他们正在使用的相同的标识符，然后我将通过但

00:22:24.900 --> 00:22:27.930
那我就不会散列同样的东西，我不会散列整个数据

00:22:27.930 --> 00:22:32.730
把它的一部分放在一边，然后说不，我们不去散列那是

00:22:32.730 --> 00:22:37.200
到底是什么原因是删除它的原因之一

00:22:37.200 --> 00:22:42.180
从完整的散列算法中得出，但是接下来有一个问题，那就是

00:22:42.180 --> 00:22:45.630
被链接到某个地方，是的，我同意，确实如此，这对我来说很奇怪，它不会

00:22:45.630 --> 00:22:51.240
是，但基本上是，它们是交易ID，不包含

00:22:51.240 --> 00:22:56.700
交易的数据，是的，我需要考虑一下

00:22:56.700 --> 00:23:02.160
无论如何，实际上是这样，就是这样

00:23:02.160 --> 00:23:06.300
困扰了我好几天了，这东西到底是如何联系在一起的，

00:23:06.300 --> 00:23:09.900
是否以一致的方式链接，如果是，这意味着我们需要使用

00:23:09.900 --> 00:23:17.130
包括另一个多编解码器，可以帮助您实现目标，然后我们可以

00:23:17.130 --> 00:23:23.550
这些多编解码器中的一些实际上指向默克尔树的叶子，

00:23:23.550 --> 00:23:31.380
然后拥有这些解码器，是的，我必须考虑一下

00:23:31.380 --> 00:23:38.790
还有更多的II知道我知道第一部分是错误的，就像我们知道的那样

00:23:38.790 --> 00:23:42.960
就像我们不能在医学哈希中存储具有数据的块一样

00:23:42.960 --> 00:23:47.790
像这样的听报的一部分，但这会破坏我们需要的一堆东西，因此

00:23:47.790 --> 00:23:53.010
从他们的意义上讲，第一个比特币块中的第一个必须很好

00:23:53.010 --> 00:23:56.250
解码成IPL体面的许多块，这就是您要说的

00:23:56.250 --> 00:24:00.600
在那里，我们不能只是存储，而一周我们现在就知道，我们可以存储

00:24:00.600 --> 00:24:03.270
标头，然后我们就可以打出很多击打者，我们有所有的代码要做

00:24:03.270 --> 00:24:07.170
现在，但随后我们要丢弃质量，您知道质量表达块

00:24:07.170 --> 00:24:11.520
交易的真实数据，因此我们不得不同意，

00:24:11.520 --> 00:24:15.420
需要弄清楚有人在哪里链接到我，就像我一样

00:24:15.420 --> 00:24:19.560
想象一下，就像我们可能不得不添加编解码器或重新利用

00:24:19.560 --> 00:24:27.690
GX编解码器之类的东西，因为喜欢基本要指向

00:24:27.690 --> 00:24:32.490
直观地操作指针，对不起我阻止了交易要点

00:24:32.490 --> 00:24:37.530
以及想像成哈希的一部分的其他基础数据，但我们将

00:24:37.530 --> 00:24:42.600
看到链上某处正在引用该数据，所以我们只是

00:24:42.600 --> 00:24:47.430
我得弄清楚我会怎么做，因为我只是

00:24:47.430 --> 00:25:06.930
充分利用它，所以埃里克（Eric）上周去的很开心，我

00:25:06.930 --> 00:25:12.000
谈到在选择器中遇到一些有趣的问题，因为他们太渴望探索

00:25:12.000 --> 00:25:17.550
一般而言，解决这种问题的某些形式的树木可能会很难

00:25:17.550 --> 00:25:22.320
但是本周有一些新代码，所以现在遍历了

00:25:22.320 --> 00:25:28.050
可以处理的瘦值，因此任何用户都可以提供链接加载器回调

00:25:28.050 --> 00:25:32.430
在多块遍历中做一些工作，我现在可以做的事情之一

00:25:32.430 --> 00:25:36.540
只是返回皮包骨头的令牌，并按照罐头上的说明操作，

00:25:36.540 --> 00:25:40.830
导致遍历逻辑测试正常，因此您可以使用它来实现

00:25:40.830 --> 00:25:47.610
您可以用CID轻松地记住它，说跳过评估

00:25:47.610 --> 00:25:51.960
如果我自己没有子树，我已经听说过诸如图之类的东西

00:25:51.960 --> 00:25:56.370
收入可能希望此建筑能够正确构建该应用程序

00:25:56.370 --> 00:26:00.690
是需要护理的东西，但无论人们做什么，图书馆

00:26:00.690 --> 00:26:06.150
除了我在cochin和

00:26:06.150 --> 00:26:11.610
就像我上周提到的那样，我有点重启了，因为界面

00:26:11.610 --> 00:26:16.350
变化足够大，就像我们重新开始一样，

00:26:16.350 --> 00:26:22.740
继续进行得非常好，因此结构Cochin已再次实施

00:26:22.740 --> 00:26:28.890
并且除了现在的表示和测试

00:26:28.890 --> 00:26:33.960
结构的类型级别和表示级别的解释，因此

00:26:33.960 --> 00:26:38.670
如果您有一个结构，则涵盖了它们各自发散的迭代

00:26:38.670 --> 00:26:46.030
假设有五个字段和一些贵族，并且两个迭代器都可能

00:26:46.030 --> 00:26:51.070
说总是会说五种类型的关卡迭代会告诉您每个

00:26:51.070 --> 00:26:54.850
字段，即使它们不存在，我也会告诉您，并且

00:26:54.850 --> 00:26:58.900
表示层迭代器可能会说，如果其中两个

00:26:58.900 --> 00:27:02.890
可选选项绝对正确，因此所有这些东西都是值得的，这是测试

00:27:02.890 --> 00:27:08.080
说实话，我认为这比前一代曲风要远

00:27:08.080 --> 00:27:15.669
所以界面真的很有帮助，值得的是，还学到了一些

00:27:15.669 --> 00:27:20.650
再次使用编译器的新事物，事实证明这变得容易得多

00:27:20.650 --> 00:27:25.860
那一堆我能够实现它，所以它使用相同的

00:27:25.860 --> 00:27:32.590
内存来描述一堆这些类型，但是我可以强制转换指针类型

00:27:32.590 --> 00:27:38.740
以这样一种方式，我可以用不同的方法来装饰它们

00:27:38.740 --> 00:27:45.100
局部表示与表示表示等等

00:27:45.100 --> 00:27:48.250
只是使整个事情在冰岛真正变得高效

00:27:48.250 --> 00:27:54.280
我很兴奋，我想出一些有关贵族如何有趣的问题

00:27:54.280 --> 00:28:01.030
和可选选项以它们现在定义的方式工作

00:28:01.030 --> 00:28:09.210
您是否可以说列表值和map内的值中的nullable以及

00:28:09.210 --> 00:28:14.169
指示字段，您可以说可选也可以指示字段，但不能在

00:28:14.169 --> 00:28:19.630
其他情况，因为如果地图上没有东西，那就就在那里

00:28:19.630 --> 00:28:22.929
而在结构上，我们能够明确地说出

00:28:22.929 --> 00:28:28.179
之所以说是绝对的，是因为我们拥有有限数量的已知字段名称，

00:28:28.179 --> 00:28:35.230
在地图上您不是这样，所以这一切都很好，我们最终选择了

00:28:35.230 --> 00:28:39.400
将这些事情作为特定修饰语在上下文中作为关键词

00:28:39.400 --> 00:28:46.270
他们被使用，这也大多有效，但一种情况我一直盯着

00:28:46.270 --> 00:28:50.260
最近很多，想知道这是否有效

00:28:50.260 --> 00:28:55.270
如果我想，我们想要的方式就是根本

00:28:55.270 --> 00:29:02.170
解组一些序列化文档，从根本上讲，我想

00:29:02.170 --> 00:29:09.850
是否接受像某种孔结构，实际上很难

00:29:09.850 --> 00:29:16.600
在当前指数中表示，因为我们之前曾考虑过有价值的东西

00:29:16.600 --> 00:29:23.190
提及具有类似食物类型的语法是可知道的类型名称

00:29:23.190 --> 00:29:29.260
bar bar是其他标题，我们决定不这样做，因为它会

00:29:29.260 --> 00:29:32.800
意味着您可以编写描述链，最终将在其中进行描述

00:29:32.800 --> 00:29:37.840
隐式地，当我们解决它时，您将具有可知的知识，而事实并非如此

00:29:37.840 --> 00:29:41.200
在任何意义上我们都不想使它在语法上可表达，所以我们

00:29:41.200 --> 00:29:47.950
不允许这样的类型定义，但是这使得放置null变得困难

00:29:47.950 --> 00:29:53.050
如果您出于某种原因想要这样做，请在文档的根目录中查找Abul

00:29:53.050 --> 00:30:00.510
好，我不知道我正在重新考虑这一问题，事实证明您可以解决

00:30:00.510 --> 00:30:07.840
因为您可以编写一种Union，其中null是内容之一，所以对于

00:30:07.840 --> 00:30:13.780
就像某人的游戏一样，是的，它是如此强大，所以这有点冗长，但是

00:30:13.780 --> 00:30:18.730
它可以描述正确的行为，而且我认为

00:30:18.730 --> 00:30:23.740
一些最终用户想要做到这一点不要太冗长

00:30:23.740 --> 00:30:31.570
真正希望这是对的，但是如果我们想表达

00:30:31.570 --> 00:30:41.890
允许整个文档或不存在，我不知道如何表达它的存在

00:30:41.890 --> 00:30:47.200
卡系统，这只是让我此刻在夜间起床的一种方式

00:30:47.200 --> 00:30:51.670
我真的不知道该怎么办，我不知道是否还有其他人

00:30:51.670 --> 00:30:54.490
对此有任何想法，我现在会推动他们，因为这很友善

00:30:54.490 --> 00:30:59.860
好，随着时间的推移，它变得怪异，这只是这种情况

00:30:59.860 --> 00:31:08.700
根您可以注意到的架构的根是，您说的是，是的

00:31:16.650 --> 00:31:27.610
是的，比起大多数情况，这是因为您不能真正地隐含地

00:31:27.610 --> 00:31:32.919
每当您要向修女元帅传递一些信息时

00:31:32.919 --> 00:31:37.330
它已经被紧缩所标识，并且没有办法

00:31:37.330 --> 00:31:42.610
具有可选的音频属性之一的命名类型，以及

00:31:42.610 --> 00:31:46.480
还有其他一些原因使我们认为这很好，但是对于这一特殊情况

00:31:46.480 --> 00:32:01.750
就像mmm这样的应用程序，它在租金水平上是可选的，也许我是

00:32:01.750 --> 00:32:06.010
只是想想例如是否要使用它来编写一些应用程序

00:32:06.010 --> 00:32:14.400
我正在做配置文件加载人正确的空配置文件，我想

00:32:14.400 --> 00:32:22.299
这样就可以将足够的功能加载到

00:32:22.299 --> 00:32:26.289
不同类型的错误类型，所以也许我们可以说这就是您

00:32:26.289 --> 00:32:32.409
得到一个错误并记录下来，那只是存在的一种特殊的箭头类型

00:32:32.409 --> 00:32:40.090
也许那很好，所以这是您的喜好，在这种情况下，您会

00:32:40.090 --> 00:32:46.150
希望能够有一种方法能够表达来自以下方面的默认配置：

00:32:46.150 --> 00:32:52.360
没有指定任何内容时使用的模式，因此可以使用可选选项来派生

00:32:52.360 --> 00:33:00.880
该文档中几乎所有内容的默认设置可能更像是

00:33:00.880 --> 00:33:08.830
隐式功能，如果这样等待，它将隐式您知道是的，尽管没有

00:33:08.830 --> 00:33:16.450
因为关于编码可选的隐式更多，不，你知道那似乎

00:33:16.450 --> 00:33:20.159
就像它正在推向应用程序的小事

00:33:20.159 --> 00:33:25.109
所以看起来好像只是有一个没有指定的信号

00:33:25.109 --> 00:33:28.989
应该足以将其备份到应用程序中，然后说

00:33:28.989 --> 00:33:35.499
调用一些特殊的逻辑，这意味着什么，是的，我想我认为是

00:33:35.499 --> 00:33:40.059
通过将这些信息推送到空中，绝对可以解决某些问题

00:33:40.059 --> 00:33:46.690
我只是在摇晃那是否可取，因为它使我

00:33:46.690 --> 00:33:52.029
有点感动，因为我对周围的事物有相当大的恐惧

00:33:52.029 --> 00:33:57.309
空气处理就像是F错误一样，在我看来，这些都是

00:33:57.309 --> 00:34:01.450
只是一个有害的来源错误，我想知道我们是否正在生产其中的一个

00:34:01.450 --> 00:34:07.179
通过不处理这种情况的那些错误工厂，也许很好，这是自然

00:34:07.179 --> 00:34:15.760
的野兽，但我对它有些不自信或不舒服

00:34:15.760 --> 00:34:20.139
也许那是最好的处理方式，我不知道这是我们在做的事情

00:34:20.139 --> 00:34:28.089
慢炖锅想出的主意特别好，您还没有

00:34:28.089 --> 00:34:32.529
关于这个问题不要难道我认为是出土冰还是我的问题

00:34:32.529 --> 00:34:40.629
认为发布给几个人，因为格式不正确，只是

00:34:40.629 --> 00:34:55.779
我的大脑，我应该清理它，并将其张贴在更可讨论的地方，我有一个

00:34:55.779 --> 00:35:02.200
向您的可疑遍历问题提问

00:35:02.200 --> 00:35:07.990
您能否在链接中解释我们正在处理记忆的用例是什么

00:35:07.990 --> 00:35:14.230
加载程序会比仅在选定的处理程序中更有益

00:35:14.230 --> 00:35:25.720
遍历引擎不是最强大的

00:35:25.720 --> 00:35:30.640
辩护，因为如果我了解那个记忆是

00:35:30.640 --> 00:35:36.720
确实是您和Reba绕过这些问题

00:35:36.720 --> 00:35:46.590
效率低下的新闻案例不是吗，并且解决问题的方法无关紧要

00:35:46.590 --> 00:35:49.320
他们，因为好像您将其推到一个单独的水平

00:35:49.320 --> 00:35:55.820
那是，但是你绝对是在做同样的事情

00:35:56.960 --> 00:36:09.330
因此，记忆的正确性比起初看的要难得多

00:36:09.330 --> 00:36:19.650
不能仅仅通过cid为所有选择器做记忆并运行，是的，因为有些你

00:36:19.650 --> 00:36:23.580
需要以不同的方式去寻找不同的东西

00:36:23.580 --> 00:36:35.850
是的，好的，所以您可能会以算法官的身份认识一些算法

00:36:35.850 --> 00:36:39.180
那不会有问题，然后您就可以通过CID不再起诉他们了

00:36:39.180 --> 00:36:43.830
并继续进行下去，这很好，因此基本上可以使用此功能

00:36:43.830 --> 00:36:47.570
如果那是他们知道自己在的情况，那就去做

00:36:47.570 --> 00:36:52.160
我今天看着他们这样做，因为我认为我无法完成实施

00:36:52.160 --> 00:36:57.690
通过CID +选择获得的花式高能矿化版本

00:36:57.690 --> 00:37:06.660
子句我当然可以并且可以连接在一起，这是不可思议的，所以这

00:37:06.660 --> 00:37:10.110
只是一种机制，您可以在此用例中说出所有这些内容

00:37:10.110 --> 00:37:16.650
只是继续下去，所以有人从草地上告诉我

00:37:16.650 --> 00:37:20.910
显然，有时候说不像我这样跳过这棵子树会很不错

00:37:20.910 --> 00:37:26.250
如果我必须给您IO阅读器，那事情就说对了，那是

00:37:26.250 --> 00:37:31.200
突然调用遍历，而我真正想要做的是继续

00:37:31.200 --> 00:37:41.790
在其他地方，所以这也使迈克尔有点我很想得到

00:37:41.790 --> 00:37:50.960
由CA元组和选择器子句记忆的演讲者幻想，但这也是

00:37:50.960 --> 00:37:57.810
不幸的是，这是不平凡的，因为您需要对一些选择器子句进行排序

00:37:57.810 --> 00:38:04.500
粉碎一些细节，例如在递归上，您不希望该递归

00:38:04.500 --> 00:38:08.820
深度计数器递减字段，因为这当然是一种突破

00:38:08.820 --> 00:38:15.930
门你知道，但是如果那个字段在某处要倒数到零怎么办

00:38:15.930 --> 00:38:20.000
中段，现在您需要它是正确的

00:38:20.000 --> 00:38:28.070
哇，是的，这里的触感令人愉悦

00:38:28.070 --> 00:38:33.210
现在它在做什么，现在没有记忆，或者只是没有撒谎

00:38:33.210 --> 00:38:37.770
平安夜走好，这就是为什么出现这种情况的原因，因为有一些明显的情况

00:38:37.770 --> 00:38:41.250
那里花了太多时间，是的，有趣的是

00:38:41.250 --> 00:38:49.170
所以现在就这样，如果您知道您可以使用简单的优化来完成我要做的事情

00:38:49.170 --> 00:38:53.580
想知道这怎么可能甚至会坚持下去，我不确定

00:38:53.580 --> 00:38:59.910
因为即使我们进行CI D的高级记忆再加上仔细的按摩

00:38:59.910 --> 00:39:06.210
和选择器列入白名单的子条款是不可能免费的

00:39:06.210 --> 00:39:13.230
是的，我不知道Richter的成本规模是多少，但是

00:39:13.230 --> 00:39:17.340
很有可能是，如果您知道不需要该备忘录，则可能

00:39:17.340 --> 00:39:22.860
也不想要它，所以一定要注意如何做到这一点

00:39:22.860 --> 00:39:25.850
实际上在某个时候想通了

00:39:26.870 --> 00:39:31.890
所以是的，这是最小的可行的东西，如果有人

00:39:31.890 --> 00:39:46.200
他们有更清楚的案例头饰欢迎您的到来

00:39:46.200 --> 00:39:53.430
后续活动我们显然是第一个在南方参加的

00:39:53.430 --> 00:40:00.730
他们只是以某种方式犁过的小岛，然后继续前进

00:40:00.730 --> 00:40:06.050
在芬兰，他们在另一个案例中遇到了这个问题，并写下来

00:40:06.050 --> 00:40:20.660
他们写了一个不同的选择器，但是没有遇到这种情况

00:40:20.660 --> 00:40:24.340
那就是我这周所做的一切

00:40:24.340 --> 00:40:30.190
是的，所以我实际上有一个优势，那就不是它也可以被提升

00:40:30.190 --> 00:40:35.990
如果我们将时间段从半小时延长到一小时，则非常合适

00:40:35.990 --> 00:40:42.680
小时，我的建议是因为喜欢我，但这并不重要，因为

00:40:42.680 --> 00:40:49.280
我肯定以后不会再开会了，但是喜欢

00:40:49.280 --> 00:40:52.850
基本上将它延长到正式喜欢一个小时，但试图

00:40:52.850 --> 00:40:57.020
仍然保持半个小时，这是因为我就是

00:40:57.020 --> 00:41:04.490
超级累，现在是11:45，但是基本上很忙，很基础，人们喜欢

00:41:04.490 --> 00:41:09.770
迈克尔把它挡住了，所以感觉就像在开票的那一天一样，他也是

00:41:09.770 --> 00:41:16.820
正式扩展，但如果这听起来不错，请尝试使其保持强壮

00:41:16.820 --> 00:41:22.700
是的，这是一个好点，但是我的这个星期在本周刚刚感动，

00:41:22.700 --> 00:41:30.350
向后移动了一个小时，但仍然不是，对我来说是七点钟，但我有

00:41:30.350 --> 00:41:35.840
当怀疑再次上午6:00开会时有这种恐惧，但后来我想起来了

00:41:35.840 --> 00:41:40.610
我们之所以选择UTC，是因为当我定期与美国人民会面时

00:41:40.610 --> 00:41:48.100
我们将有两个小时的班次，所以我经常在早上6:00结束，这很糟糕

00:41:48.700 --> 00:41:54.320
所以是的，所以我会这样，我会照顾像得到所有那样的事情

00:41:54.320 --> 00:42:02.630
所有提到的地方都很酷，嗯，那里有什么东西吗

00:42:02.630 --> 00:42:05.050
别的

00:42:05.750 --> 00:42:21.510
人们可能会在下个星期与我联系，所以我会离开，所以我想你还是

00:42:21.510 --> 00:42:30.930
我没有钱的地方，没有我，你一定会做到的。我想有人

00:42:30.930 --> 00:42:38.040
拥有第一次访问权限，我认为是我的肩膀，是的，迈克尔，我应该不知道该怎么做

00:42:38.040 --> 00:42:44.460
做那行冷却我，就像任何人一样，所以我停了下来

00:42:44.460 --> 00:42:48.450
会议，因为对其他人来说完全不有趣

00:42:48.450 --> 00:42:53.880
让它真正运行，所以我会说再见，然后我们讨论它

00:42:53.880 --> 00:42:58.190
以后再见，大家好

