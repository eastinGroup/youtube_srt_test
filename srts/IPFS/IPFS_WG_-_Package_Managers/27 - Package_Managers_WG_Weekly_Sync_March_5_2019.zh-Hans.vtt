WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.140 --> 00:00:05.339
酷雪，我们正在录制您好，大家好，欢迎来到包装经理

00:00:05.339 --> 00:00:12.660
2019年3月的每周汇水大厦，我们将玩我最后一次做的游戏

00:00:12.660 --> 00:00:20.690
为何我受阻的一周以及下一步要做的事

00:00:22.279 --> 00:00:28.680
谢谢吉姆酷，所以我一直在做什么

00:00:28.680 --> 00:00:34.469
对，所以我去了一个假期，所以实际上我做了很多，我发现了一个

00:00:34.469 --> 00:00:39.989
NPM ipfs的问题，它曾经广播的发布/订阅机制

00:00:39.989 --> 00:00:44.820
不久之后，新模块的更新将停止工作

00:00:44.820 --> 00:00:51.390
一个神奇的数字，它表示发布/订阅消息的大小，以及是否发送消息

00:00:51.390 --> 00:00:56.699
这比订阅此每日断开连接要大得多，但我没有

00:00:56.699 --> 00:01:02.789
看到记录在任何地方，但有一个问题说这可能是

00:01:02.789 --> 00:01:06.720
好主意，好像在那边实现了某些东西

00:01:06.720 --> 00:01:10.799
瓦斯卡（Vaska）将研究实施情况，了解她的去向

00:01:10.799 --> 00:01:14.490
说请确保并得到它抛出适当的错误信息，如果

00:01:14.490 --> 00:01:18.000
如果您要发送一条消息，将会导致人们

00:01:18.000 --> 00:01:23.700
断开连接并不会阻止恶意客户端的明显运行，但是

00:01:23.700 --> 00:01:27.630
您知道谁正在尝试做正确的事情的开发人员将是很好的

00:01:27.630 --> 00:01:31.950
他们要早点知道而不是以后，是的，我没有被阻止

00:01:31.950 --> 00:01:36.420
接下来我要停止工作了

00:01:36.420 --> 00:01:41.820
好吧，我意识到我并没有真正为我的目标做任何事情

00:01:41.820 --> 00:01:44.399
是我的事，因为我已经被很多软件包管理器所消耗

00:01:44.399 --> 00:01:47.990
东西，所以下周可能是我

00:01:47.990 --> 00:01:59.729
任何人都有任何疑问，你还好吗，他们只是私人的东西

00:01:59.729 --> 00:02:04.979
不，不，我认为他们可以确定是的，可以确定这是像添加

00:02:04.979 --> 00:02:08.729
ipfs缺少一些功能，我将告诉您知道如何尝试添加

00:02:08.729 --> 00:02:13.930
支持修改ipfs，后来证明是获得支持

00:02:13.930 --> 00:02:21.099
pm本身有五个FS，因为pink仅使用NPM CLI来安装依赖项，并且

00:02:21.099 --> 00:02:25.480
我有点太深了，很明显，这将需要

00:02:25.480 --> 00:02:31.060
NPM团队愿意接受的工作比我想象的要多

00:02:31.060 --> 00:02:34.780
您知道的事前咨询是因为他们希望他们对自己的工作有所投入

00:02:34.780 --> 00:02:38.439
因为没有像这样的不同运输方式的概念

00:02:38.439 --> 00:02:44.260
您可以在应用程序或任何我的谎言中使用HTTP，到处都是

00:02:44.260 --> 00:02:49.209
您知道，例如您拥有这样的模块

00:02:49.209 --> 00:02:53.169
返回HTTP响应，然后该用户将开始查看

00:02:53.169 --> 00:02:57.489
像标头之类的东西以及响应中提取的元数据

00:02:57.489 --> 00:03:02.290
会用来处理依赖关系，所以没有一个很好的清晰分离

00:03:02.290 --> 00:03:07.780
在传输和数据之间，这样的事情将需要选择一个

00:03:07.780 --> 00:03:22.299
重构超出了我试图做的原因的范围

00:03:22.299 --> 00:03:28.780
所以本周我玩得很开心，而亚历克斯已经离开了，

00:03:28.780 --> 00:03:34.359
上周我提出的要求不高的要求，以添加词汇表和清单

00:03:34.359 --> 00:03:41.019
包管理器到包管理器存储库中，然后我实际进行了管理

00:03:41.019 --> 00:03:49.120
在自制软件中实现ipfs支持，我尚未发送拉取请求，因为

00:03:49.120 --> 00:03:57.790
II确实分享了我与Mike McQuaid所做的工作，他说

00:03:57.790 --> 00:04:04.720
他们不太可能合并ipfs传输，直到该软件包

00:04:04.720 --> 00:04:13.120
有其主要来源需要ipfs，这很有趣

00:04:13.120 --> 00:04:18.820
因为ipfs是自制的公式，所以可能会有一个杠杆

00:04:18.820 --> 00:04:25.779
习惯于稍微弯曲，但实际上却很容易

00:04:25.779 --> 00:04:27.700
自制酒已经有很多不同的

00:04:27.700 --> 00:04:32.710
您可以用来将链接实际粘贴到聊天室中的交通工具

00:04:32.710 --> 00:04:44.650
以及使用原始网址进行不同类型的结帐

00:04:44.650 --> 00:04:50.860
那么您基本上会将哈希作为附加参数添加，如果该哈希为

00:04:50.860 --> 00:04:56.830
可用，它将尝试通过IP FS下载它，然后关于

00:04:56.830 --> 00:05:00.940
自制程序是，您可以派生整个注册表并将其添加进去，以便我们可以

00:05:00.940 --> 00:05:09.280
可能有一种非常简单的说法，例如brew install ipfs斜杠核心

00:05:09.280 --> 00:05:16.210
斜杠软件包名称，并假设我们已经备份了所有软件包，并从ipfs中提取了软件包名称

00:05:16.210 --> 00:05:20.650
这些公式的某个地方，这样总会有人播种它们

00:05:20.650 --> 00:05:26.800
从最终用户的角度来看，唯一不支持的实际区域是

00:05:26.800 --> 00:05:30.760
预装的二进制文件的瓶子，但我不认为那也是

00:05:30.760 --> 00:05:35.440
很难添加，因为它们使用相同的传输基础传输机制

00:05:35.440 --> 00:05:40.720
因此，我认为相同的ipfs传输将可用于

00:05:40.720 --> 00:05:46.840
瓶子只是没有声明URL被推断是因为它们

00:05:46.840 --> 00:05:52.840
只能使用一种来源的瓶子或内置的瓶子

00:05:52.840 --> 00:05:59.830
是自制的垃圾箱托盘，然后Linux brew在Linux brew下使用类似于别针托盘的方式

00:05:59.830 --> 00:06:06.700
而不是使用自制的其他名称，因此添加起来相当容易

00:06:06.700 --> 00:06:12.570
特别是完整的IP FS很难实现的领域是

00:06:12.570 --> 00:06:19.569
从我克隆自制配方公式存储库

00:06:19.569 --> 00:06:25.539
PFS而不是来自github，因为它是一个巨大的存储库，就像

00:06:25.539 --> 00:06:28.830
200兆字节，因此它们最终可能是一些

00:06:28.830 --> 00:06:36.639
在那里相当大，并使其与现有的工作基本上得到了它

00:06:36.639 --> 00:06:42.399
总是克隆或像shadow一样克隆存储库的最新版本，因此

00:06:42.399 --> 00:06:46.990
他们没有同一种不同的方式来运送他们的

00:06:46.990 --> 00:06:53.169
注册表，这意味着我们不能只像文件的副本那样采摘

00:06:53.169 --> 00:06:59.319
系统就像最新的结帐一样，这有点可惜，但可能是

00:06:59.319 --> 00:07:06.189
可行，但这也是您可以涉足的事情

00:07:06.189 --> 00:07:12.580
吉姆（Jim）我确实检查了ipfs的号码，这个号码有一个棘手的限制

00:07:12.580 --> 00:07:20.709
尝试进入的文件的最大大小

00:07:20.709 --> 00:07:25.869
就像说可以用ipfs进行git clone一样，

00:07:25.869 --> 00:07:32.979
比起像下载git储存库这样的签出

00:07:32.979 --> 00:07:37.029
碰巧在ipfs上，但是我认为有些事情可以在那做

00:07:37.029 --> 00:07:42.869
并不一定要一目了然

00:07:42.869 --> 00:07:47.199
因此尝试添加更多的脚本可能会很有趣

00:07:47.199 --> 00:07:52.149
将通过公式将它们全部添加到ipfs并将哈希提交到

00:07:52.149 --> 00:07:58.719
有人可以代替的叉子和自制维护者Mike McQuaid

00:07:58.719 --> 00:08:04.779
似乎很开放，就像对它感兴趣，而不是对她不屑一顾

00:08:04.779 --> 00:08:09.449
这是可能有一个选择

00:08:09.449 --> 00:08:17.419
他们还做什么？我还花了一些时间进行工作或写出

00:08:17.419 --> 00:08:23.759
不同的分类方法，按实施方式分组

00:08:23.759 --> 00:08:30.740
ipfs的观点，基本上将三种不同的类别分组

00:08:30.740 --> 00:08:37.050
该报价与我之前对multi的分类非常接近

00:08:37.050 --> 00:08:43.349
注册表集中注册表便携式注册表主要分组是

00:08:43.349 --> 00:08:49.910
基于文件系统的大多数系统软件包管理器，这可能是因为

00:08:49.910 --> 00:08:55.529
我们的同步非常有效，可以保留它们可以镜像的东西

00:08:55.529 --> 00:09:00.449
从字面上看，只是将所有内容都视为文件系统中的文件，将其复制

00:09:00.449 --> 00:09:04.500
其实很简单，但这意味着它们都是元数据

00:09:04.500 --> 00:09:09.839
存储在文件maven和Sipan中也可以那样工作，那么您已经

00:09:09.839 --> 00:09:15.750
数据库后代，它们往往更现代，并且具有续集或类似的特征

00:09:15.750 --> 00:09:20.519
某种带有数据库的Web应用程序正在执行身份验证

00:09:20.519 --> 00:09:26.670
就像处理软件包的转换一样，通常意味着它相当

00:09:26.670 --> 00:09:32.639
自助服务，您无需找人将软件包添加到文件中

00:09:32.639 --> 00:09:37.709
系统自己发生在Maven上，例如，您需要发送您的

00:09:37.709 --> 00:09:44.160
打包到Maven Central，然后说可以发布吗，而大多数

00:09:44.160 --> 00:09:49.319
数据库不需要共享，就像不需要其他人共享

00:09:49.319 --> 00:09:54.180
可用于发布软件包，但缺点是

00:09:54.180 --> 00:09:58.350
几乎不容易反映出来，因为您需要数据库的副本

00:09:58.350 --> 00:10:02.880
您需要运行Web应用程序服务器，或者需要做一些事情

00:10:02.880 --> 00:10:07.949
假装是Web应用程序服务器，而所有或至少我还没有

00:10:07.949 --> 00:10:14.040
看到他们在不同注册表之间使用的任何类型的共享API规范

00:10:14.040 --> 00:10:20.130
所有人都实现自己独特的JSON或XML，或者

00:10:20.130 --> 00:10:28.250
通过HTTP关闭注册表以与他们的个人交谈

00:10:28.250 --> 00:10:34.340
客户，然后是的，我可以看到迈克尔笑了，我很可笑，

00:10:34.340 --> 00:10:40.850
实际上就像执行，您将获得回闭合映射，它们是数据，您

00:10:40.850 --> 00:10:44.930
可以在关闭时加载，但是尝试工作真的不是很好

00:10:44.930 --> 00:10:49.370
如果您不是在关闭时编写解析器或客户端，请使用它

00:10:49.370 --> 00:10:57.250
然后第三个是基于哪种两种不同的

00:10:57.250 --> 00:11:03.650
便携式注册表最终将git用作他们放置的数据库

00:11:03.650 --> 00:11:09.370
所有已发布内容的历史记录，通常只是元数据

00:11:09.370 --> 00:11:17.270
直接进入文件系统，其形状与文件系统非常相似

00:11:17.270 --> 00:11:24.650
除此之外，几乎总是对注册表进行版本控制以使用github作为

00:11:24.650 --> 00:11:28.430
基础架构，因此他们不必托管自己的数据库并成为他们的

00:11:28.430 --> 00:11:34.810
拥有自己的DBA，而且还拥有某种版本控制的历史记录

00:11:34.810 --> 00:11:38.630
如果您要自己进行，则需要更多的实现，因此

00:11:38.630 --> 00:11:42.950
有点像懒惰的维护者zwey，这是完全合理的

00:11:42.950 --> 00:11:46.400
意味着当您喜欢自家酿造的啤酒的大小和历史时，您实际上无法查看

00:11:46.400 --> 00:11:50.990
git中任何一个软件包的历史，因为github就是这样

00:11:50.990 --> 00:11:56.390
超时，这需要很长的时间才能遍历git历史，但是有

00:11:56.390 --> 00:12:00.170
还有一些有趣的事情，除了自制

00:12:00.170 --> 00:12:04.720
其中大多数都具有一个数据库来支持其Web应用程序

00:12:04.720 --> 00:12:09.530
自制程序实际上将其注册表导出到JSON文件中，并将其放在github上

00:12:09.530 --> 00:12:16.430
页面，这样您就可以不必将git用作数据库

00:12:16.430 --> 00:12:21.710
生产，因为这通常会导致令人难以置信的缓慢，然后

00:12:21.710 --> 00:12:29.830
注册表，当注册表列表样式为get时，基本上就像go或

00:12:29.830 --> 00:12:35.590
迅捷或迦太基，您只需将自己指向

00:12:35.590 --> 00:12:40.150
没有名称空间，并且在Internet上指向git的URL的情况下

00:12:40.150 --> 00:12:44.530
版本库和版本历史记录存储在以下每个数据库中

00:12:44.530 --> 00:12:49.240
那些git仓库，所以实际的依赖解决方案最终是

00:12:49.240 --> 00:12:54.310
相当慢，因为您克隆了递归git存储库并拖网

00:12:54.310 --> 00:12:58.510
他们的标签历史或git提交可能在不同的分支上，因为

00:12:58.510 --> 00:13:08.100
好吧，但最终就像没有任何人要求的

00:13:08.100 --> 00:13:13.540
当任何新发布的软件包消失时检查任何东西，所以几乎没有

00:13:13.540 --> 00:13:20.500
在看门人的方式是什么，然后再来像

00:13:20.500 --> 00:13:25.210
一切都将在谷歌内部出售，这也会发生

00:13:25.210 --> 00:13:30.040
可能为其他人工作，他们正在慢慢带您重新变得有用

00:13:30.040 --> 00:13:36.130
面向Google外部的用户，但它仍在不断变化，而

00:13:36.130 --> 00:13:41.350
斯威夫特和迦太基更加稳定，不会定期更改

00:13:41.350 --> 00:13:46.120
他们都容易受到存储库的影响而离开存储库

00:13:46.120 --> 00:13:51.070
被强行推入其中的一些存储库将跟踪存储库的外观

00:13:51.070 --> 00:13:56.290
就像他们上一次与他们交谈时，其他人不会，所以这有点像

00:13:56.290 --> 00:14:02.860
提供了一种有趣的方式思考何时解决问题

00:14:02.860 --> 00:14:09.010
对于ipfs上可能与之类似的注册管理机构之一

00:14:09.010 --> 00:14:13.390
可以记录该过程，然后去哦，这也可以用于所有这些

00:14:13.390 --> 00:14:17.650
假设客户将拥有的其他类型的工作非常简单

00:14:17.650 --> 00:14:24.970
他们自己的实现和事物，但来自类似文件的ipfs映射

00:14:24.970 --> 00:14:30.400
系统还是邪恶的，我们必须在这里保留某种数据库，或者至少保留一个

00:14:30.400 --> 00:14:39.130
假装数据库中可能包含API结果的路径

00:14:39.130 --> 00:14:44.410
处理每个单独的事物时，稍微容易一些或至少将其分块

00:14:44.410 --> 00:14:49.660
他们还擅长什么呢，所以就把它放出来，打开关于

00:14:49.660 --> 00:14:55.030
使这个工作组公开，这实际上是更多讨论的起点

00:14:55.030 --> 00:15:00.850
作为婴儿床垫中的链接，它在github存储库中只是在想

00:15:00.850 --> 00:15:04.540
大概有什么需要做的步骤，然后我们才能开始拥有

00:15:04.540 --> 00:15:11.200
这些公开讨论，以便我们可以指出有人在那里，我试图组织一个

00:15:11.200 --> 00:15:15.460
跟新西兰的人打个电话，实际上很难安排一个

00:15:15.460 --> 00:15:20.230
时间不适合我们中的一个人，例如凌晨三点，所以我认为如果

00:15:20.230 --> 00:15:27.640
我们可以在github和

00:15:27.640 --> 00:15:31.060
当我正在学习自制的东西以及那是怎么做的另一件事

00:15:31.060 --> 00:15:37.210
工作，我发现IP FS套件取决于

00:15:37.210 --> 00:15:41.860
由于IP FS是make文件而实际上未使用的事物数

00:15:41.860 --> 00:15:48.640
通过网关通过IP FS进行自我引导，但实际上在以下情况下不使用GX

00:15:48.640 --> 00:15:54.010
它正在下载它自己的GX副本，因此我能够删除三个

00:15:54.010 --> 00:15:58.420
与自制方法不同的依赖关系，因此安装IP fsy的任何人

00:15:58.420 --> 00:16:02.800
自制软件现在有了它，因为他们没有在玩，所以速度要快得多

00:16:02.800 --> 00:16:08.410
依赖关系，永远不会被使用，它与许多

00:16:08.410 --> 00:16:12.520
我发现可以执行一些公式的修复程序基本上实现了自己的解决方案

00:16:12.520 --> 00:16:18.310
包管理器的包装器，它不信任Python并成为

00:16:18.310 --> 00:16:22.270
我偶然发现了两个，就像它们被很好地放入一样，每一个

00:16:22.270 --> 00:16:25.020
个人

00:16:25.360 --> 00:16:31.029
级别甚至潜在的可传递依赖项，例如我们的git存储库

00:16:31.029 --> 00:16:34.750
自制配方，它们将被克隆到期望的路径中

00:16:34.750 --> 00:16:38.500
一旦包管理器将完成其正在执行的操作，以便

00:16:38.500 --> 00:16:42.519
公式是可重复的，而不是每次都更改

00:16:42.519 --> 00:16:50.140
瓶子服务器将构建的，这非常有趣，因为

00:16:50.140 --> 00:16:54.850
有点a脚，他们基本上是围绕其他包装经理的工作方式工作的

00:16:54.850 --> 00:16:58.240
工作，尽管自制酒有他们自己的问题所在

00:16:58.240 --> 00:17:03.010
基本上总是喜欢它仅在最新版本的

00:17:03.010 --> 00:17:09.429
我认为所有内容和以前的版本均不受支持，但是

00:17:09.429 --> 00:17:14.500
当涉及到家庭自制的人时，也建立了一些善意

00:17:14.500 --> 00:17:21.419
其实就像在说嘿，我们应该把这个IPFs的东西实现为kirok，

00:17:21.419 --> 00:17:30.340
像让ipfs自制软件那样添加，您知道安装要求ipfs太厚脸皮

00:17:30.340 --> 00:17:41.260
像FS一样在内部运输，真是厚颜无耻，就像最坏的样子

00:17:41.260 --> 00:17:53.559
模式，但是如果您像mmm一样，我们如何第一次得到它是

00:17:53.559 --> 00:17:59.710
有点痛苦，因为这更像是我们需要这个，因为这是一个

00:17:59.710 --> 00:18:05.290
良好的传输，这就是ipfs项目所说的最好的下载方法

00:18:05.290 --> 00:18:09.730
即使是您第一次要通过HTTP通过HTTP下载它，

00:18:09.730 --> 00:18:15.700
网关而不是必须以某种方式找到IP FS二进制文件的网关

00:18:15.700 --> 00:18:20.130
通过新安装IP FS

00:18:22.130 --> 00:18:29.570
迈克尔（Michael）是的，在包装经理类别中，

00:18:29.570 --> 00:18:32.900
可能可以拿走数据库并与之一起运行

00:18:32.900 --> 00:18:40.340
我担心的一件事是很多时候您导出它们的方式

00:18:40.340 --> 00:18:43.910
或者您获取的数据提要有点过时，或者最终

00:18:43.910 --> 00:18:48.919
变得过时了，这实际上发生在NPM上，所以像最初

00:18:48.919 --> 00:18:52.610
用来复制数据库的供稿是实时的

00:18:52.610 --> 00:18:56.539
数据库，然后随着我的扩展而变化，它不再像

00:18:56.539 --> 00:19:00.470
几秒钟后到现在，实际上存在着不同的系统，因为

00:19:00.470 --> 00:19:04.520
更新是如此之快，比现在晚了十分钟，所以它仍然是一个真正的

00:19:04.520 --> 00:19:08.150
如果我们要构建像脱机版本一样的软件包，这是一个不错的选择

00:19:08.150 --> 00:19:11.600
经理，例如我们可以提取数据，可以将其转换为IP LD术语或其他任何形式

00:19:11.600 --> 00:19:16.490
我们需要移动数据，但是如果我们像现场一样

00:19:16.490 --> 00:19:21.200
软件包安装，我们始终必须使用实时API，因为如果您只是

00:19:21.200 --> 00:19:25.460
发布该程序包，然后尝试安装它，除非您不正确，否则将无法正确安装它。

00:19:25.460 --> 00:19:31.190
我们总是击中那个现场​​，我们实际上有联系，是的，所有这一切

00:19:31.190 --> 00:19:36.980
数据库软件包管理器会遇到类似的问题，例如NPM实际上

00:19:36.980 --> 00:19:40.010
提取数据非常合理，其中一些甚至没有RSS提要

00:19:40.010 --> 00:19:44.690
或以任何方式说说这里真的有一个新包裹需要拖网

00:19:44.690 --> 00:19:50.780
甚至翻页页面上的HTML链接列表以了解是否

00:19:50.780 --> 00:19:55.909
有一个新事物，所以有一些我认为这种方法是

00:19:55.909 --> 00:20:01.039
有两种方法，我可以看到一种，就像我们实际上得到了ipfs

00:20:01.039 --> 00:20:09.919
直接在生产注册表（如API）中提供支持，因此

00:20:09.919 --> 00:20:15.919
哦，如果我发布了一个新软件包，我也会宣布它并将其添加到

00:20:15.919 --> 00:20:22.580
ipfs并将see ID添加到我的数据库中，并且可以通过API使用

00:20:22.580 --> 00:20:30.100
另一种方式是e一种人工风格的代理，它将

00:20:30.100 --> 00:20:34.320
懒洋洋地去注册表，理想地喜欢

00:20:34.320 --> 00:20:40.980
有足够的缓存或像BFS返现一样可以脱机或可以

00:20:40.980 --> 00:20:46.400
懒惰的做事方式，但是是的，你不能他们也

00:20:46.400 --> 00:20:52.680
从来没有像我认为NPM最近增加了

00:20:52.680 --> 00:20:59.550
时光倒流，说，哦，我要这个日期之前的包裹

00:20:59.550 --> 00:21:05.730
他们没有那种类似的能力

00:21:05.730 --> 00:21:09.660
您正在注册表的最前沿运行，可能会或可能不会

00:21:09.660 --> 00:21:18.030
工作，否则对我来说很有趣的地方就是我们的

00:21:18.030 --> 00:21:23.310
社区有一个名为cran的软件包管理器，而他们的软件包管理器没有

00:21:23.310 --> 00:21:31.650
允许您固定最新的信息，而您基本上不能说有最大值

00:21:31.650 --> 00:21:36.840
版本号，这意味着您总是选择最新版本，没有

00:21:36.840 --> 00:21:41.970
表示您不想要的方式，因此社区绕过该路线

00:21:41.970 --> 00:21:45.150
每天制作注册表快照

00:21:45.150 --> 00:21:51.450
这是由Microsoft托管的，它被称为M ran，用于Microsoft cran和

00:21:51.450 --> 00:21:56.070
因此当您说我要安装所有

00:21:56.070 --> 00:22:01.020
此程序的软件包，可以节省您想要安装的日期

00:22:01.020 --> 00:22:05.550
然后每个人基本上都及时冻结了整个社区，因为

00:22:05.550 --> 00:22:11.160
他们不能，因为他们只能翻滚坏了的新版本而退出

00:22:11.160 --> 00:22:17.460
转发，这实际上不是一种可以接受的方式，因此ipfs

00:22:17.460 --> 00:22:23.160
拥有理想的复制品并能顺利进行，您可以随时回滚到

00:22:23.160 --> 00:22:28.140
尤其是如果我们使用某种类似于某些顶级路线的路线，

00:22:28.140 --> 00:22:35.190
包含您可以始终指向其先前版本的所有元数据

00:22:35.190 --> 00:22:38.700
假设有人在托管或已使其可用的元数据，或者

00:22:38.700 --> 00:22:42.660
我猜你已经对自己在这里的混乱负责

00:22:42.660 --> 00:22:46.940
我认为我们应该真正地分享一点

00:22:46.940 --> 00:22:51.320
对于第一个让人们添加CID的选项，直接添加到元数据中

00:22:51.320 --> 00:22:53.600
对于我们正在使用的实际注册表

00:22:53.600 --> 00:22:58.730
您知道我们正在努力瞄准，因为我们已经进行了这项传入的IP投资，

00:22:58.730 --> 00:23:02.660
说实话，它确实不应该存在，因为我们必须

00:23:02.660 --> 00:23:06.560
维护我们必须编写它，我们必须维护它我们必须托管它

00:23:06.560 --> 00:23:12.800
而如果实际注册管理机构只是增加了可逆性，那么我认为

00:23:12.800 --> 00:23:16.640
为了让他们接受，尽管我们必须展示其价值

00:23:16.640 --> 00:23:21.140
首先，所以我们至少要在一段时间内

00:23:21.140 --> 00:23:28.970
给他们看是这样的说到不变性那么有多少包装

00:23:28.970 --> 00:23:33.670
管理员注册表在元数据中具有任何形式的不变性保证

00:23:33.670 --> 00:23:45.860
像任何逸夫之类的东西，或者你做了什么，哦，是的，所以我们是你的

00:23:45.860 --> 00:23:50.300
音乐家伙，我认为您必须像麦克风或其他东西一样保持静音，因为它

00:23:50.300 --> 00:23:58.480
并没有说您对变焦静音，哦，迈克，也许他没有说，是的，你好

00:23:58.480 --> 00:24:06.760
你去那里我不知道这是如此安静

00:24:08.750 --> 00:24:15.920
让别人接听我的电话嗯，所以很多包裹经理

00:24:15.920 --> 00:24:21.110
个别包装上有某种sha-256，但很少有

00:24:21.110 --> 00:24:30.200
像元数据之类的任何一种通常被视为几乎短暂的

00:24:30.200 --> 00:24:38.060
很难做到的是尼克和怪胎，所以基本上

00:24:38.060 --> 00:24:42.950
就像我们无时无刻地为所有内容拍摄快照

00:24:42.950 --> 00:24:50.120
也有Eric悄悄地潜伏在底部，我

00:24:50.120 --> 00:24:54.370
猜猜你有点喜欢得到支持

00:24:54.370 --> 00:25:02.080
但是，您希望那样，很多回头客都会有

00:25:02.080 --> 00:25:09.539
元数据以不变的方式存储，但它们指向s3上的HTTP URL或

00:25:09.539 --> 00:25:15.370
随机在类似自制的点上的先生先生，最初托管来源的人

00:25:15.370 --> 00:25:19.690
可能是一些大学，也可能是任何不代表我可以的事情

00:25:19.690 --> 00:25:24.610
回滚六个月，所有这些公式上的所有URL都将

00:25:24.610 --> 00:25:30.309
正确解决问题，这样您就不会拥有像那样好的方法

00:25:30.309 --> 00:25:34.809
快照并回滚整个事情，这就是为什么您看到很多公司的原因

00:25:34.809 --> 00:25:38.409
使用我认为的人工制品之类的东西，因为他们希望能够

00:25:38.409 --> 00:25:46.270
冻结世界或供应商的字面意思是供应商每一个方面都一丝不苟

00:25:46.270 --> 00:25:51.179
进入您的单声道回购协议是保证的另一种方式，但您却损失了很多

00:25:51.179 --> 00:26:00.059
加工过程中，几分钟后还有其他问题

00:26:00.059 --> 00:26:09.130
吉姆（Jim）我已经对es6模块做了一些实验，也许如果我屏蔽了sherek

00:26:09.130 --> 00:26:12.120
我可以展示一些东西

00:26:14.640 --> 00:26:23.370
分离一些项目，所以主要的是人们在那儿es6模块

00:26:23.370 --> 00:26:30.490
他们已经在网络浏览器中使用了几年了，它们可以让您编写es6

00:26:30.490 --> 00:26:36.880
 javascript，而不是在nodejs中，我们需要使用NPM名称，您可以

00:26:36.880 --> 00:26:42.610
导入，您可以从HTTP URL导入，因此它实际上与软件包相反

00:26:42.610 --> 00:26:51.059
经理，但事实是所有JavaScript都生活在NPM上，所以人们

00:26:51.059 --> 00:26:59.140
CDN有一个称为unpackage的服务，可让您使用此服务

00:26:59.140 --> 00:27:07.530
通过HTTP将语法导入CDN，然后在CDN中解压缩所有NPM

00:27:07.530 --> 00:27:14.020
所以有点把所有NPM都炸掉了，所以它们都可以被HTTP引用

00:27:14.020 --> 00:27:19.780
但是要做一些特殊的小技巧才能做到

00:27:19.780 --> 00:27:25.210
在这里，但这是项目，对我来说似乎很有趣，因为如果我们

00:27:25.210 --> 00:27:32.410
拥有所有NPM，我们也可以将其爆炸，然后我们将看到ID

00:27:32.410 --> 00:27:36.550
每个小文件，如果它们通过HTTP公开，

00:27:36.550 --> 00:27:44.230
可以很好地工作，所以与解包一起工作，我想您是TB级圣洁吗？

00:27:44.230 --> 00:27:50.050
通过解包，它只是由um托管内容，因此该内容才能正常工作

00:27:50.050 --> 00:27:55.330
您基本上必须在发布步骤中进行构建，然后包括

00:27:55.330 --> 00:28:02.590
NPM软件包中用于浏览器的构建文件，因此有点依赖

00:28:02.590 --> 00:28:06.970
就像您预先为浏览器Piku程序包提供了一些工具一样

00:28:06.970 --> 00:28:13.360
走了一条不同的路线，到达那里他们已经把它弄出来，但是他们在那里

00:28:13.360 --> 00:28:19.510
为他们的新服务（例如HTTP）提供接口，如果您使用的是导入

00:28:19.510 --> 00:28:25.600
原始模块中的语法，它将只提取没有构建的原始文件

00:28:25.600 --> 00:28:29.590
必要的权利，这就是为什么他们一直在索引所有

00:28:29.590 --> 00:28:33.670
实际上这样做是没有意义的，直到他们发布了更愚蠢的东西

00:28:33.670 --> 00:28:37.030
现在他们真的很喜欢哦，是的，它真的很优雅

00:28:37.030 --> 00:28:41.950
就像你不需要单独建立单独的想法一样

00:28:41.950 --> 00:28:47.310
通过NPM中的源文件通过HTTP导入，我认为这是一个强大的主意

00:28:47.310 --> 00:28:53.020
有一些相关的东西，所以没有GS由Ryan Dahl编写，很适合与

00:28:53.020 --> 00:28:58.780
那个巨人，他正在做这个叫做denno的新事物，就像节点，但是他

00:28:58.780 --> 00:29:05.890
换了角色，他基本上是说没有NPM我讨厌NPM

00:29:05.890 --> 00:29:11.140
很有趣，因为您知道他在艾萨克（Isaac）曾使用过最好的朋友，但喜欢他的主要

00:29:11.140 --> 00:29:17.820
做这个项目的动机是他不喜欢他和他说话

00:29:17.820 --> 00:29:25.169
但这有点很棒，因为无论如何我们都拥有原始文件

00:29:25.169 --> 00:29:31.200
另一个奇怪的事情是他只说打字稿文件，但他已经在

00:29:31.200 --> 00:29:35.609
他关闭了有关denno的一个问题，他说这是对IP FS的支持，

00:29:35.609 --> 00:29:43.200
就像嘿，他很棒，这是我很快就能做到的这一举动

00:29:43.200 --> 00:29:46.859
设想有一天会发生，但是将来会出现，但是ipfs并不是很

00:29:46.859 --> 00:29:48.690
现在好，天线不是很好

00:29:48.690 --> 00:29:58.799
因为它只是一条金丝雀，但就在这点上，就在21天前

00:29:58.799 --> 00:30:04.609
瑞安（Ryan）我喜欢瑞安（Ryan），所以我认为这很有趣

00:30:05.029 --> 00:30:11.429
抱歉，我认为那里有机会，因为这有点

00:30:11.429 --> 00:30:18.509
最初开始这个项目，所以我不知道他要走多远

00:30:18.509 --> 00:30:23.249
他抱怨的是不变性问题，就像必须解决一样

00:30:23.249 --> 00:30:28.440
版本和所有类似的混乱，他有点喜欢go模型，

00:30:28.440 --> 00:30:31.409
你就像是指着伯爵，但他讨厌这样的事实，那就是可变

00:30:31.409 --> 00:30:35.039
所以我认为他们到达那里是的，可能会有一个有趣的

00:30:35.039 --> 00:30:40.830
是的机会，然后另一个是什么

00:30:40.830 --> 00:30:46.499
参与其中的人进行了一个有趣的项目，他实际上是为

00:30:46.499 --> 00:30:52.169
ipfs基本上就像他没有GS和Mr。在装载机上，这样您

00:30:52.169 --> 00:30:59.849
可以直接通过HTTP加载工作表es6模块，因此您可以使用进口和征税

00:30:59.849 --> 00:31:09.629
在nodejs本身上，因此您可以使用unpackage so和Kosala伊拉克联赛

00:31:09.629 --> 00:31:17.729
实际上在他的lunette项目中使用了这个，这就是你好受伤的原因

00:31:17.729 --> 00:31:21.779
不会像第一次加载时那样被缓存

00:31:21.779 --> 00:31:27.659
会有点慢，但我从未见过有人做得非常好

00:31:27.659 --> 00:31:31.230
事情，所以我自己也做了一些es6模块的经验

00:31:31.230 --> 00:31:35.639
我在网上或像大包装一样将胶水分开，它可以

00:31:35.639 --> 00:31:41.370
速度很慢，但是我把它们放在上面，一旦一切都知道就本地同步

00:31:41.370 --> 00:31:46.559
这样还不错，所以去年我做了一些实验，我可以证明

00:31:46.559 --> 00:31:52.740
所以我认为这是我们可以去的地方我认为另一个项目

00:31:52.740 --> 00:32:03.179
尺寸是TX GS，它是我们的之一，所以BFS的JavaScript模块我不知道

00:32:03.179 --> 00:32:06.179
知道这一切适合吗，但就像我们拥有的那样，我们将拥有NPM

00:32:06.179 --> 00:32:11.460
所有这些都适合JavaScript，我们可以将其分解并发布

00:32:11.460 --> 00:32:17.220
马上这样，但是我可以将其中的一些链接放到该项目的一个问题中

00:32:17.220 --> 00:32:23.190
我不知道它是否适合这里的范围，将它们粘贴在注释中

00:32:23.190 --> 00:32:31.710
哦，随着时间的流逝，这很酷，所以如果您需要这样做，我们可以继续

00:32:31.710 --> 00:32:36.750
聊了些关于GX的话题我一直在寻找，我正在观看一些

00:32:36.750 --> 00:32:44.120
线程，特别是go项目的协议实验室集群上的线程

00:32:44.120 --> 00:32:49.830
很多人对此感到非常痛苦，而且似乎也

00:32:49.830 --> 00:32:54.480
所使用的模块是它们所使用的ipfs的依赖项

00:32:54.480 --> 00:33:00.090
其他项目，他们也确实希望不那么痛苦，我认为

00:33:00.090 --> 00:33:07.110
痛苦的主要根源是GX要求每一个传递

00:33:07.110 --> 00:33:12.450
依赖项将其依赖项声明为哈希，而不是像基本一样

00:33:12.450 --> 00:33:16.409
冻结在时间版本中，这意味着您是否要更新任何运输

00:33:16.409 --> 00:33:19.590
依赖关系，您需要更新链中的所有内容才能获得

00:33:19.590 --> 00:33:24.389
最新版本的吸引人的，所以要写一些建议，但

00:33:24.389 --> 00:33:27.419
还不清楚似乎有多少不同

00:33:27.419 --> 00:33:33.630
协议内部对多少GX感到困惑，我们绝对希望保留

00:33:33.630 --> 00:33:39.820
使用它与我们应该放手模块

00:33:39.820 --> 00:33:46.509
喜欢接管而不必担心，所以我认为这是一个问题并坚持下去

00:33:46.509 --> 00:33:55.600
在上面插一个小旗，就像嘿，这应该像薪水一样

00:33:55.600 --> 00:34:00.999
注意或者可能是喜欢进行对话的好地方

00:34:00.999 --> 00:34:05.679
一种或另一种方式，我认为这就像是一回事，就像你一样

00:34:05.679 --> 00:34:09.819
知道让我们吃我们自己的狗食吧，让我们把它弄乱，但就像我们

00:34:09.819 --> 00:34:14.109
策略性地尝试让这种语言在我认为的语言中被实际采用

00:34:14.109 --> 00:34:18.429
去吧，我们大概有最少的机会做到这一点哦，是的，是的

00:34:18.429 --> 00:34:23.230
我的意思是，就像是go维护者，我们称之为敌意

00:34:23.230 --> 00:34:29.290
对其他试图出售有据可查的人的是的

00:34:29.290 --> 00:34:37.899
是的，我们造成了0％的机会，您可以看到我们是否GX变成了更多

00:34:37.899 --> 00:34:43.389
用于最终用户或类似最终应用程序的Web应用程序的工具

00:34:43.389 --> 00:34:48.879
及时查看冻结的依赖关系的快照，但事实并非如此

00:34:48.879 --> 00:34:52.690
实际上继续使用每个项目具有的基础工具

00:34:52.690 --> 00:34:58.540
决定使用它，如果在非常

00:34:58.540 --> 00:35:02.559
缓慢的一种类似的转换方式，它类似于

00:35:02.559 --> 00:35:09.880
节点和浏览器如何都朝着es6模块发展

00:35:09.880 --> 00:35:16.119
如果有一些维护者，总是必须对以前的事情有某种支持

00:35:16.119 --> 00:35:18.880
x'不想直接上船或有已完成的项目

00:35:18.880 --> 00:35:22.780
这仍然在很大程度上取决于要花很长时间才能彻底摆脱一切

00:35:22.780 --> 00:35:28.079
是那个庞大的图的叶节点的边缘，是的，所以我有点像

00:35:28.079 --> 00:35:37.119
GX GX现在内部几乎已经死了，因为基本上两个GSI都可以使用

00:35:37.119 --> 00:35:44.500
ipfs和p2p已经移到了go模块，所以就像我们一样

00:35:44.500 --> 00:35:49.990
想要保持X不变，但我认为它作为学习练习很有用

00:35:49.990 --> 00:35:54.630
从很多方面来说，就像您知道自己是否确实尝试

00:35:54.630 --> 00:35:59.640
冻结所有内容并将其公开，就像开发人员必须处理的一样

00:35:59.640 --> 00:36:06.029
与哈希，就像你检查哈希和东西，这只是我试图做

00:36:06.029 --> 00:36:10.170
与Jax一起玩的鬼东西，我一直不断摔进去，是的

00:36:10.170 --> 00:36:15.420
传递依赖的东西真的很难，尤其是只有那里

00:36:15.420 --> 00:36:21.480
当您进行导入时，该字符串也包含所有元数据

00:36:21.480 --> 00:36:26.609
你会说像整个模块一样，不一定

00:36:26.609 --> 00:36:30.779
直到出现go模块为止，没有其他文件说出您想要的任何内容

00:36:30.779 --> 00:36:36.119
需要一些第三方工具来跟踪您喜欢的实际修订

00:36:36.119 --> 00:36:40.890
这些模块中任何一个的已知工作版本，然后将散列交换出去

00:36:40.890 --> 00:36:45.569
你就像哦，突然之间，这对我没什么意义，我完全不喜欢

00:36:45.569 --> 00:36:50.970
这里的参考点在其他地方，没有我不知道的人

00:36:50.970 --> 00:36:55.740
认为没有GX的ipfs将会存在，因为go生态系统不存在

00:36:55.740 --> 00:37:01.650
有用于管理依赖项的工具，所以就像Jax一样

00:37:01.650 --> 00:37:07.349
被创建，以便您可以创建ipfs，就像您进行递归排序一样

00:37:07.349 --> 00:37:13.890
但我认为这也很有启发性，因为就像我可以看到的一样

00:37:13.890 --> 00:37:20.220
就像我在谈论像这样的未包装的东西

00:37:20.220 --> 00:37:24.240
几乎就像您经历的某种内部构建步骤，然后您

00:37:24.240 --> 00:37:29.730
就减少事物类型而言，冻结就像捆绑程序步骤

00:37:29.730 --> 00:37:33.089
散乱的哈希是不可变的，永远不会改变，它们是排序的

00:37:33.089 --> 00:37:38.130
就像您用培根散列一样发布，而不是像

00:37:38.130 --> 00:37:42.470
运行时解析器查找我认为将成为解决问题的方法

00:37:42.470 --> 00:37:49.349
大多数包装经理将需要任何更改，可以想象一下

00:37:49.349 --> 00:37:57.200
你还在上伦敦吗？是的，我的日历上有它要上

00:37:57.200 --> 00:38:04.299
1450因为我工作，也许是您的床或沙发

00:38:04.299 --> 00:38:06.930
可用的

00:38:07.780 --> 00:38:15.069
我的是，他们对尝试制定某种计划非常有用

00:38:15.069 --> 00:38:19.660
继续前进，以便其他工作组可以开始做他们喜欢的事情

00:38:19.660 --> 00:38:29.049
基于是的计划，我的意思是到目前为止，此图钉将我尝试过的所有内容都固定了

00:38:29.049 --> 00:38:37.839
当与任何人一起工作时，确实受到性能的严重限制

00:38:37.839 --> 00:38:45.339
喜欢下载的数量很多，我想如果您尝试下载所有

00:38:45.339 --> 00:38:53.890
GX上的ipfs软件包，总计约180个，花了很多时间才能完成

00:38:53.890 --> 00:39:00.490
而且不仅仅只是从DHT下载而没有

00:39:00.490 --> 00:39:14.440
像任何一个空的有什么好处的是空ipfs缓存，我记得嗯，所以这

00:39:14.440 --> 00:39:19.990
就像回去，但在NPM成为一家公司之前，没有人提起诉讼

00:39:19.990 --> 00:39:23.349
一分钟运行注册表，因为他们收购了其他Smith公司

00:39:23.349 --> 00:39:27.400
运行了VM注册表，他们建立了这个人的概念，

00:39:27.400 --> 00:39:30.640
从来没有作为产品发布过，但本质上是在您发布产品时

00:39:30.640 --> 00:39:36.160
给它一个软件包版本来安装它会返回你基本上是

00:39:36.160 --> 00:39:41.470
它需要的所有东西的计算深度像图，所以它

00:39:41.470 --> 00:39:45.549
像这样无法缓存，这是您无法解决的主要问题之一

00:39:45.549 --> 00:39:48.309
真正给它您的本地缓存，您将像这样尝试返回

00:39:48.309 --> 00:39:51.880
使用您已经拥有的东西进行强力击球，但是速度要快得多

00:39:51.880 --> 00:39:55.930
而不是像将数据整理下来然后进行解析，如果您查看

00:39:55.930 --> 00:39:59.049
NPM进行了很多性能改进，因为很多

00:39:59.049 --> 00:40:03.099
就像在按顺序下拉包之前使用注册表元数据一样

00:40:03.099 --> 00:40:08.109
了解正确的图我特别想知道我们是否做了点什么

00:40:08.109 --> 00:40:13.420
我喜欢允许离线离线功能，您可以创建这些

00:40:13.420 --> 00:40:16.640
非常好的缓存状态，然后当您给出

00:40:16.640 --> 00:40:21.170
将该高速缓存状态像一个无罪的图形一样返回，它会让您知道

00:40:21.170 --> 00:40:24.530
引用了您实际上可能已经在本地缓存的一堆东西，因此

00:40:24.530 --> 00:40:29.020
您可以执行实际上比安装快得多的操作

00:40:29.020 --> 00:40:33.350
如果需要，但需要像我们建立一些基础设施来做到这一点

00:40:33.350 --> 00:40:38.030
红宝石宝石具有非常优雅的解决方案，因为它们具有特定的

00:40:38.030 --> 00:40:42.710
他们必须为捆扎机建立API，因为随着红宝石宝石长成包子，它得到了

00:40:42.710 --> 00:40:48.560
像下载gem一样慢一些，检查依赖项在哪里，

00:40:48.560 --> 00:40:52.610
再次做同样的工作，他们有安全感，我认为大约是四个

00:40:52.610 --> 00:41:00.650
兆字节的文件非常像是塞满了信息，可以提供任何信息

00:41:00.650 --> 00:41:04.820
所有版本及其所有依赖项的当前状态

00:41:04.820 --> 00:41:10.010
发布在红宝石宝石上，您可以下载该文件并进行解析

00:41:10.010 --> 00:41:16.220
你去下载任何gem，他们还提供了一个HTTP api，这是基本的哦，我

00:41:16.220 --> 00:41:24.560
想要这些顶级的十个顶级宝石，而取决于所有这些

00:41:24.560 --> 00:41:28.250
那些特别是红宝石宝石的东西必须要确保

00:41:28.250 --> 00:41:32.840
任何一件事情只有一个版本，但是它将返回您完整的列表

00:41:32.840 --> 00:41:37.520
如果可以去这里，这是您实际需要做的所有工作，因此他们

00:41:37.520 --> 00:41:44.530
基本上将依赖项解析作为服务与当前快照

00:41:44.530 --> 00:41:50.900
所有这些宝石中，然后，如果您有自己的发言权，例如宝石，

00:41:50.900 --> 00:41:56.720
然后从github复制所有本地文件

00:41:56.720 --> 00:42:01.340
事物或我们所有的辅助注册表事物，然后使用发送

00:42:01.340 --> 00:42:05.720
就像我绝对需要这些东西的这些版本一样

00:42:05.720 --> 00:42:09.680
您想要对您的依赖解决方案有额外的要求

00:42:09.680 --> 00:42:16.700
像更多的包裹管理者可以使用它来加快我的工作速度

00:42:16.700 --> 00:42:22.280
和Swift他们就像我需要继续克隆git存储库，直到我已经和

00:42:22.280 --> 00:42:26.300
特别是当您觉得还可以的时候，为什么我要克隆所有的kubernetes

00:42:26.300 --> 00:42:32.809
两个拉这个嵌入其中的是的，是的，我的意思是像

00:42:32.809 --> 00:42:37.069
这就是为什么我对docker之类的东西更感兴趣的原因

00:42:37.069 --> 00:42:41.029
层模型，因为我们可以做些什么，因为关于这些医生的有趣事情

00:42:41.029 --> 00:42:46.130
层是它们在文件系统上是不可变的快照，因此如果我们有

00:42:46.130 --> 00:42:50.599
他们的哈希值，我们可以有效地说，好吧，在撤下之前，我们已经知道了

00:42:50.599 --> 00:42:55.069
任何数据，当他们尝试访问该文件系统中的数据时，我们可以给它

00:42:55.069 --> 00:42:59.599
实时地向他们展示了Matthias所使用的概念证明

00:42:59.599 --> 00:43:03.190
很久以前就在网络洪流上写了，就像四，五年前一样

00:43:03.190 --> 00:43:09.709
他在那里写了一些基于Web torrent的文件系统，基本上

00:43:09.709 --> 00:43:14.449
挂载docker映像，他将没有任何文件，然后它将启动

00:43:14.449 --> 00:43:18.469
它会像一个半个演出图像之类的东西，并且会像

00:43:18.469 --> 00:43:22.699
10秒是因为启动Linux映像的过程就像一对Meg一样

00:43:22.699 --> 00:43:28.279
您只是不知道这些文件是什么，直到您把它放进去，我们才能得到

00:43:28.279 --> 00:43:32.059
就像您知道的那样，可能会从根本上改善疯狂的性能

00:43:32.059 --> 00:43:36.349
从理论上讲，我们可以将其视为分层文件系统

00:43:36.349 --> 00:43:42.380
任何gzip都一样，这简直令人难以置信地昂贵

00:43:42.380 --> 00:43:46.130
前期工作要拆开星星球的包装，然后将它们变成真正的穆斯林，

00:43:46.130 --> 00:43:51.440
我做了一个概念验证，就像我之前剥去UNIX MSB一样

00:43:51.440 --> 00:43:55.369
只是想看看如果我们做过重复数据删除，我们该怎么办

00:43:55.369 --> 00:43:59.299
解压缩gzip，结果发现重复数据删除并不能将您保存为

00:43:59.299 --> 00:44:02.900
正如您所说的那样，空间很大，我们将要存储的数据本身也将是

00:44:02.900 --> 00:44:11.749
更高，这将是有问题的教练吉姆，好吧，您所描述的是

00:44:11.749 --> 00:44:15.109
基本上，我博客中的最​​后一件事是我一年没有更新的

00:44:15.109 --> 00:44:21.499
一半就像所谓的移液器，正在极大地增加工作量和耗材

00:44:21.499 --> 00:44:27.440
我们正在努力提高意识，但是我喜欢在整个Linux容器中添加食物，然后

00:44:27.440 --> 00:44:32.390
会在上面加载块，但是我会吃掉，因为它会

00:44:32.390 --> 00:44:38.569
患者稀疏，我只想捕捉页面中的内容，然后我

00:44:38.569 --> 00:44:41.430
想要被zip压缩或类似的东西

00:44:41.430 --> 00:44:44.940
事实证明，启动特定linux所需的一切

00:44:44.940 --> 00:44:49.200
图像可以打包成30兆字节，并像一些漂亮的

00:44:49.200 --> 00:44:53.609
繁重的工作，因为大多数东西在典型的图像中（例如99）

00:44:53.609 --> 00:44:57.329
百分比从未使用过，这真的很有趣，因为这样您就可以

00:44:57.329 --> 00:45:06.359
只是退出小拉链球，是的，哦，是的，我想我们可能已经达到了

00:45:06.359 --> 00:45:15.450
Ender在本次会议结束时只是一个简单的问题，我喜欢这是呃，我看到了

00:45:15.450 --> 00:45:18.780
以前的会议上有一个指向此内容的链接，这些是视频所在的位置，并且

00:45:18.780 --> 00:45:21.240
github问题，但现在都没有

00:45:21.240 --> 00:45:26.010
所以有人想错过会议的一部分我很希望能够看到

00:45:26.010 --> 00:45:33.270
并且经常在协议团队管理仓库中有一个PR白蛋白

00:45:33.270 --> 00:45:37.530
合并，该合并将主持前两次会议，并具有指向Google的链接

00:45:37.530 --> 00:45:42.300
开车作为他们中的录音，我们没有设法记录上次会议

00:45:42.300 --> 00:45:47.940
因为亚历克斯（Alex）正在滑雪，而会议锁定了他的帐户

00:45:47.940 --> 00:45:56.400
不幸的是经典的东西还可以，谢谢大家，所以我发布了一个有趣的

00:45:56.400 --> 00:46:01.380
我在指标存储库中发布了指向此处的链接的可视化，但这只是

00:46:01.380 --> 00:46:06.780
每个包管理器中有28个团队的第4季度补充，它为您提供了

00:46:06.780 --> 00:46:10.589
像是很好地可视化了许多

00:46:10.589 --> 00:46:12.780
不同类型的评论程序包管理器以及它们有多少个程序包

00:46:12.780 --> 00:46:17.750
我上次查看此数据时也添加了参考

00:46:17.750 --> 00:46:23.490
更新两个软件包的NPM发生率也要高得多

00:46:23.490 --> 00:46:27.299
如果我们想做像Ruby这样的事情，那么您将所有

00:46:27.299 --> 00:46:31.109
注册表状态的元数据将是巨大的，因为它还将具有

00:46:31.109 --> 00:46:37.470
包括所有单独的版本，那您知道天文学吗

00:46:37.470 --> 00:46:43.920
NPM很抱歉，模块数量仅仅是顶级软件包名称，

00:46:43.920 --> 00:46:49.339
不是单个版本计数库具有相当好的计数

00:46:49.339 --> 00:46:55.329
以及独特的版本，因此可能是一个额外的数据指向

00:46:55.329 --> 00:47:01.239
但是上午/下午是真的很难确定的另一个距离

00:47:01.239 --> 00:47:07.930
他会像燃烧器和蜂鸣器一样走动哦，因为他可以取决于您声明为

00:47:07.930 --> 00:47:12.130
包，因此一般而言，所有与go包管理相关的统计信息都可以

00:47:12.130 --> 00:47:15.910
刚出去的窗户是的，不，我实际上是这样的，模块帐户

00:47:15.910 --> 00:47:21.249
一段时间以来一直在跟踪Godox作为软件包管理器的编号，所以我做到了

00:47:21.249 --> 00:47:25.119
快速分析之后，我感觉报告的效率大约是原来的四倍

00:47:25.119 --> 00:47:31.960
实际的包装是看它的回购，还是我做到了，这是非常糟糕的

00:47:31.960 --> 00:47:36.519
是的，没有办法做任何事情，就像我认为我们可以

00:47:36.519 --> 00:47:41.499
如果我们想查看特定程序包的依赖关系，可能会做

00:47:41.499 --> 00:47:47.710
可以使用bigquery进行某些操作以实际查询每个go文件中的内容

00:47:47.710 --> 00:47:52.479
在每个主分支中，这将为我们提供一张相当不错的图片，

00:47:52.479 --> 00:47:58.210
就像一个庞大的查询，是的，运行一些查询是很昂贵的

00:47:58.210 --> 00:48:02.410
所以有一篇我喜欢把它挖出来的中等帖子，肯定有人做到了

00:48:02.410 --> 00:48:07.900
好的之前可能会发现那块大栅栏是的

00:48:07.900 --> 00:48:11.710
是的，所以我的问题就好像我想不出办法

00:48:11.710 --> 00:48:16.089
它不只是一个包，所以如果我想寻找

00:48:16.089 --> 00:48:20.619
取决于它里面有ipfs的东西是可行的，但是如果你

00:48:20.619 --> 00:48:24.279
只是想喜欢对任何包装进行分类，并获得像我一样的唯一列表

00:48:24.279 --> 00:48:27.400
以为您看起来很快就会达到查询限制

00:48:27.400 --> 00:48:38.079
我认为我们已经超出了软件包管理器的范围，每周更新一次

00:48:38.079 --> 00:48:42.160
现在要停止录制并结束本次会议，但您知道

00:48:42.160 --> 00:48:50.279
自由地让詹姆斯成为确切的时间

00:48:50.590 --> 00:48:53.619
[音乐]

