WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.089 --> 00:00:07.230
感谢大家加入，是的，乔治只是说这是目的

00:00:07.230 --> 00:00:13.320
这些是使它具有交互性，所以我让您胆怯

00:00:13.320 --> 00:00:20.220
幻灯片的各个部分，以向我们提出您所遇到的任何问题

00:00:20.220 --> 00:00:26.369
在此过程中不了解，但是是的，这些事情应该是简短的

00:00:26.369 --> 00:00:30.630
以信息为中心的乳头病史，我的意思是我们已经与大多数人讨论过

00:00:30.630 --> 00:00:37.620
你们当中有些人是一个涉及学术界的平行研究领域，但是

00:00:37.620 --> 00:00:42.870
只有大的网络，那里有大的行业，那里有

00:00:42.870 --> 00:00:47.309
在那里做了很多工作，所以我认为这对

00:00:47.309 --> 00:00:54.570
人们知道在ipfs和BJP上工作只是为了了解

00:00:54.570 --> 00:01:00.809
完成，然后可能跳得更深，我要跟进衣橱或

00:01:00.809 --> 00:01:05.189
面对面的会议，看看您是否知道我们有一些有趣的功能

00:01:05.189 --> 00:01:16.470
可以在b2b的PFS中采用和跟进

00:01:16.470 --> 00:01:22.110
还没认识我的名字是伦敦大学学院的Yummy讲师，我是

00:01:22.110 --> 00:01:30.780
研究实验室，主要工作在与避孕套常规DHD和事物有关的领域

00:01:30.780 --> 00:01:35.850
像这样，其实我没那么久

00:01:35.850 --> 00:01:42.119
以前，是的，也许我们对你们中的许多人没有打扰太多，所以

00:01:42.119 --> 00:01:49.200
自2010年初以来一直在UCL工作，并且所有这些

00:01:49.200 --> 00:01:53.610
那些年的工作重点基本上是以信息为中心

00:01:53.610 --> 00:01:59.579
网络，我们从安排

00:01:59.579 --> 00:02:04.560
从缓存的角度从架构的角度看建筑

00:02:04.560 --> 00:02:09.660
从内容交付的角度来看，移动性和几乎所有类型的

00:02:09.660 --> 00:02:16.660
最近我们一直在努力分散他们的权力

00:02:16.660 --> 00:02:22.750
计算我们所看到的是，而不是处理静态内容，我们

00:02:22.750 --> 00:02:27.400
想要解决计算本身并能够基本触发

00:02:27.400 --> 00:02:35.170
通过一些可寻址结构进行对抗，因此那里有一个漂亮的页面

00:02:35.170 --> 00:02:42.070
最近我将故事和可能链接到论文的文章放在一起

00:02:42.070 --> 00:02:47.290
如果您想了解我们在这里所做的事情，请阅读有趣的文章

00:02:47.290 --> 00:02:55.540
网络的未来，因此就ICN社区的icin而言

00:02:55.540 --> 00:03:01.690
可以从中找到有趣信息的是IRT F小组，因此

00:03:01.690 --> 00:03:07.810
IRT F代表互联网研究工作组，它是

00:03:07.810 --> 00:03:14.790
互联网工程任务组（IETF）的大多数标准

00:03:14.790 --> 00:03:19.960
互联网协议正在开发中，因此IRT F看起来有点

00:03:19.960 --> 00:03:26.350
进入更未来的事物，或者您知道没有空间的事物

00:03:26.350 --> 00:03:32.730
标准社区呢，或者您知道那是每个小组的主席之一

00:03:32.730 --> 00:03:39.870
事情，所以那里有很多有趣的参考草案

00:03:39.870 --> 00:03:45.730
所以这很重要，它不像纯粹的研究内容那样涵盖研究

00:03:45.730 --> 00:03:50.140
所以它不涵盖论文之类的东西，但重点是

00:03:50.140 --> 00:03:54.220
有趣的互联网思想和信息是RFC，有些人可以

00:03:54.220 --> 00:04:01.690
很好地了解您所知道的方向

00:04:01.690 --> 00:04:07.870
所以我的意思是OSI能源集团正在与您认识的所有人一起努力

00:04:07.870 --> 00:04:13.090
iedf一年举行三期，有时是中期

00:04:13.090 --> 00:04:20.859
IETF主要会议之间的会议之间的会议

00:04:20.859 --> 00:04:24.539
这些年来通常有趣的讨论

00:04:24.539 --> 00:04:34.240
该地区还有一个由ACM赞助的会议，不知道

00:04:34.240 --> 00:04:37.960
自2011年以来一直在公开场合或他作为研讨会开始的活动

00:04:37.960 --> 00:04:43.629
连同CMC Compa一起，今年它成为了一个会议

00:04:43.629 --> 00:04:48.669
九月份在香港，他们将发表很多有趣的论文

00:04:48.669 --> 00:04:54.400
在那里可能要留意那些可以参加的人，但是那些

00:04:54.400 --> 00:05:03.069
不会有一些有趣的论文出来，那是什么

00:05:03.069 --> 00:05:09.669
好吧，那大致就是我想谈的话题的概要

00:05:09.669 --> 00:05:14.349
三个部分，所以我将快速介绍一下信息

00:05:14.349 --> 00:05:18.699
中心网络，您知道它们比技术要多一些

00:05:18.699 --> 00:05:24.939
我刚刚说过，然后有一部分我选择了三个

00:05:24.939 --> 00:05:32.319
这样的代表性项目具有我认为可能具有的特定功能

00:05:32.319 --> 00:05:37.599
对我绝对有用，因为我将要谈论其中的每一个

00:05:37.599 --> 00:05:41.710
大约15分钟，然后我们可以进行一些讨论，您会知道一些问题

00:05:41.710 --> 00:05:46.659
和答案，但可以随意打断，但这只是粗略的

00:05:46.659 --> 00:05:50.529
它会是什么样子，然后在最后一部分，我有一些

00:05:50.529 --> 00:05:56.860
到目前为止我自己的想法和设计建议

00:05:56.860 --> 00:06:01.689
已经深入研究了想法节日并留下了它

00:06:01.689 --> 00:06:07.270
因此，实际上值得一提的是，术语可能无处不在

00:06:07.270 --> 00:06:11.560
或者您可能会使用两种不同的方式说相同的话

00:06:11.560 --> 00:06:18.279
不同的单词，所以基本上可以随意打扰，是的，问什么是

00:06:18.279 --> 00:06:23.199
您所知道的是否在字典中做了不同的处理，以避免

00:06:23.199 --> 00:06:35.199
进一步的混乱，是的，所以ICN的动机很低

00:06:35.199 --> 00:06:39.789
动力哦，我看到n几乎是一样的

00:06:39.789 --> 00:06:44.729
就像从一开始就使用ipfs一样，网络基本上是

00:06:44.729 --> 00:06:51.759
内容不可知，且内容取决于位置，因此使

00:06:51.759 --> 00:06:57.550
您知道网络有点陡峭和困难，您可以将网络视为

00:06:57.550 --> 00:07:02.770
原生内容分发，这样您认识的人就会出现

00:07:02.770 --> 00:07:07.419
你知道的观察和测量表明

00:07:07.419 --> 00:07:11.740
我们今天使用的哪些应用程序需要本机非常高效

00:07:11.740 --> 00:07:15.310
内容分发网络，但是我们所拥有的却是两点

00:07:15.310 --> 00:07:21.879
从长远来看，这些连接并不会非常支持

00:07:21.879 --> 00:07:27.509
所有我们想要与Internet有关的事情，因此通过命名

00:07:27.509 --> 00:07:32.889
单个内容对象正在发生的事情是，我们可以拥有更多

00:07:32.889 --> 00:07:38.500
在某些情况下，安全性为移动性提供了更好的支持，并且

00:07:38.500 --> 00:07:44.919
支持多播或非多播，可以轻松实现，因此

00:07:44.919 --> 00:07:48.430
这是起点，我的意思是我听了很多人的话。

00:07:48.430 --> 00:07:55.569
外遇说完全一样的话，所以我想允许他们这样的人

00:07:55.569 --> 00:08:00.069
开始就知道X我们到今天为止能做什么

00:08:00.069 --> 00:08:05.800
我认为这并不是一个正确的问题，所以您

00:08:05.800 --> 00:08:09.879
知道我们是否可以更轻松地做事，那已经是一个开始

00:08:09.879 --> 00:08:14.919
你知道我们总是可以做事情，但是如果性能和我们在哪里做

00:08:14.919 --> 00:08:21.099
最优，那么事情最终将变得令人望而却步，所以一些

00:08:21.099 --> 00:08:26.020
我确定您知道，IEP存在问题，您知道我们是否希望您这样做

00:08:26.020 --> 00:08:31.000
有一些内容，如果我们有一些网络内容或我们拥有的任何文件

00:08:31.000 --> 00:08:37.709
知道我们可以现金或身份验证，我们不能做，我们永远都不能做

00:08:37.709 --> 00:08:42.909
有效地，我们正在确保内容透明且渠道透明的渠道

00:08:42.909 --> 00:08:47.649
不是保护用户自身安全和有效的内容本身

00:08:47.649 --> 00:08:50.870
询问我们是什么网络正在答复

00:08:50.870 --> 00:08:54.710
谁买了这只表，我是说他误会是

00:08:54.710 --> 00:09:02.089
有点想念一个例子，例如我实际上给游戏买了一些东西

00:09:02.089 --> 00:09:09.020
过去是仓库与高街零售商的例子，如果我们

00:09:09.020 --> 00:09:15.080
认为内容是一种物质哦，好，今天发生的事情是，我们

00:09:15.080 --> 00:09:19.970
总是不得不去一些外面的后端仓库，要安全地进入

00:09:19.970 --> 00:09:25.490
为了获得我们想要的以及我们应该实际实现的目标是

00:09:25.490 --> 00:09:31.040
说您知道许多人想要的流行事物应该更近一些，我们

00:09:31.040 --> 00:09:35.870
不要头发，我们不应该走那么远，你知道要去喝一瓶牛奶

00:09:35.870 --> 00:09:41.330
要在海外购物更多，所以要这样做

00:09:41.330 --> 00:09:44.839
我们需要知道我们到底在寻找什么，所以这就是为什么我们需要名字

00:09:44.839 --> 00:09:50.839
数据，我们需要有空间来抽烟做这些事

00:09:50.839 --> 00:09:58.310
事情马上关闭了，这基本上是过去了，而ICN的主要承诺是

00:09:58.310 --> 00:10:03.740
网络现在能够支持网络缓存的原因是什么

00:10:03.740 --> 00:10:08.540
大于，但一直都是这样的假设：

00:10:08.540 --> 00:10:13.100
支持您在那里进行缓存，然后您当然需要资源

00:10:13.100 --> 00:10:20.390
管理和对安全机制的信任，那么一个好的单元该做什么呢？

00:10:20.390 --> 00:10:24.740
您看起来像这样，所以我们拥有名称解析功能，这是所有功能的基本组成部分

00:10:24.740 --> 00:10:31.339
架构，我们必须做一个名字-位置映射，所以我们有一个名字和

00:10:31.339 --> 00:10:35.420
我们需要映射到某个位置，然后一旦有了我们就需要去

00:10:35.420 --> 00:10:40.160
取回我们现在想要的内容，具体取决于

00:10:40.160 --> 00:10:44.839
邻居解决方案中的代码中的解析过程处理此名称-

00:10:44.839 --> 00:10:52.940
位置映射或绑定已完成，我们可以实现很多好处

00:10:52.940 --> 00:10:57.010
前面提到的安全多播移动性对移动性的支持以及

00:10:57.010 --> 00:11:00.060
有效地在本地内容分发网络中

00:11:00.060 --> 00:11:06.930
并且您知道以后您将名称和

00:11:06.930 --> 00:11:14.220
位置越多，您可以获得的收益就越多

00:11:14.220 --> 00:11:22.770
主要有两种方法，所以一种是本机数据平面方法

00:11:22.770 --> 00:11:29.160
基于呼叫名称的路由，并且这些主要支持已进行铺设绑定，因此

00:11:29.160 --> 00:11:33.360
发生的事情是，我们假设一个网络提供了实际的食物

00:11:33.360 --> 00:11:39.600
网络编码员可以说这种IC，语言可以说产品

00:11:39.600 --> 00:11:44.280
协议栈，因此它们可以接收并进行路由选择和

00:11:44.280 --> 00:11:51.420
直接根据这些名称转发，因此存在一种隔离

00:11:51.420 --> 00:11:56.790
主要是支持他们维护的网络项目，我是

00:11:56.790 --> 00:12:01.770
稍后将提供更多详细信息，但要记住的重要一点是

00:12:01.770 --> 00:12:06.030
我们有说语言的网络路透社，因此说接收者

00:12:06.030 --> 00:12:11.760
请求，他们可以本地转发，因此您有一种希望

00:12:11.760 --> 00:12:18.270
通过希望解析，然后我们有了名称解析库，可以按名称查找

00:12:18.270 --> 00:12:25.530
那里有几个项目的方法

00:12:25.530 --> 00:12:30.120
一种早期绑定，因此在名称解析过程开始时

00:12:30.120 --> 00:12:35.630
最终客户正在询问某个外部实体，我在哪里可以找到此内容

00:12:35.630 --> 00:12:41.340
收到一些有关IP地址或类似地址或对等ID的位置信息，或者

00:12:41.340 --> 00:12:46.080
随便什么，然后根据效率如何立即获取合同

00:12:46.080 --> 00:12:50.730
这些都是可以做到的，您可以获得大部分好处，但是如果您忽略了

00:12:50.730 --> 00:12:56.250
您只需执行此操作，便会知道早期绑定，然后基本上对您进行排序

00:12:56.250 --> 00:13:00.990
失去了许多好处现在那里有很多项目

00:13:00.990 --> 00:13:07.350
在欧洲运行，就像由欧洲委员会资助的一样，

00:13:07.350 --> 00:13:11.540
来自像这样的项目

00:13:12.540 --> 00:13:15.620
[音乐]

00:13:16.019 --> 00:13:22.540
激光笔哇，所以有很多项目

00:13:22.540 --> 00:13:31.209
从2000年2009-2010年开始，直到最后一个ICN 2020项目，

00:13:31.209 --> 00:13:36.519
我们与欧洲其他国家和地区的合作伙伴共同完成的项目中，

00:13:36.519 --> 00:13:42.459
日本实际上是在上个月完成的，当然，我们有IDF，

00:13:42.459 --> 00:13:47.380
仍在进行中，而其中许多项目仍未永久或永久地进行中

00:13:47.380 --> 00:13:55.170
不好的原因，所以只有少数几个名称可以使用命名方式

00:13:55.170 --> 00:14:03.819
ICN架构的基石，而且有很多很大，这是一个

00:14:03.819 --> 00:14:09.519
主题领域很大，但是名称的一些基本要求是

00:14:09.519 --> 00:14:15.009
内容新闻之后，它们应该保持不变

00:14:15.009 --> 00:14:18.850
取内容并取其不同是名称应保持相同

00:14:18.850 --> 00:14:23.589
为了能够再次找到它，应该让他们允许内容

00:14:23.589 --> 00:14:27.100
缓存，这是非常重要的，您实际上无法拥有

00:14:27.100 --> 00:14:32.889
与您一起了解IP网络，因为您知道所有缓存或网络都是

00:14:32.889 --> 00:14:36.759
看到的是IP地址，而您不知道其背后的内容是什么

00:14:36.759 --> 00:14:42.880
而如果您有Ange内容块或内容对象，则意味着

00:14:42.880 --> 00:14:47.139
您可以识别，因为您是按名称要求的，因此您可以

00:14:47.139 --> 00:14:53.949
现在可以从网络中的任何地方检索它，所以命名本身并不是真的

00:14:53.949 --> 00:14:58.959
问题，但是如果我们想让您知道命名不应该是拓扑

00:14:58.959 --> 00:15:03.699
依赖性，这就是ICN正在建立的位置独立性原则

00:15:03.699 --> 00:15:09.220
最重要的是，问题在于路由是Balaji的依存关系，因此在

00:15:09.220 --> 00:15:14.199
看看，如果您想通过命名来解决这个问题，这就是

00:15:14.199 --> 00:15:18.130
做对非常重要的事情，国家基本上是在命名

00:15:18.130 --> 00:15:26.170
确定现在的路线再往前走一点有这个著名的世界

00:15:26.170 --> 00:15:31.900
由雅科夫（Jakov）校长（有时被称为导演规则）说

00:15:31.900 --> 00:15:36.100
寻址可以遵循策略，拓扑可以遵循您拥有的地址

00:15:36.100 --> 00:15:42.340
如果您考虑一下，就选择一个非常合理的选择，我的意思不是

00:15:42.340 --> 00:15:47.770
设计BGP协议的主要人物

00:15:47.770 --> 00:15:56.680
建议认为夜间码头路线如此之多，是的，是的，还可以

00:15:56.680 --> 00:16:06.670
有人举起了两只手，是的，你好，托比

00:16:06.670 --> 00:16:12.370
当人们说命名时，在这种情况下，他们的意思是

00:16:12.370 --> 00:16:18.340
名称是名称，地址是您知道可变的东西

00:16:18.340 --> 00:16:21.850
与不可变是人类可读还是机器可读的东西

00:16:21.850 --> 00:16:30.880
像是正确的意思，那么好点和几乎所有的东西

00:16:30.880 --> 00:16:34.450
你说的，所以有些方法说

00:16:34.450 --> 00:16:40.720
开始时说您知道命名应该是人类可读的，但随后这些

00:16:40.720 --> 00:16:44.860
当然每个人都意识到它并不需要像它不需要那样

00:16:44.860 --> 00:16:50.380
是人类可读的主要区别主要是两个属性，所以主要

00:16:50.380 --> 00:16:55.300
多年来的区别是名称是通量还是名称

00:16:55.300 --> 00:16:59.680
名称中包含一些层次结构，因此如果您具有层次结构

00:16:59.680 --> 00:17:04.990
结构，就像我们在URL中一样，那么这些可以帮助很多

00:17:04.990 --> 00:17:10.420
在进行路由和转发时在网络rooter中进行聚合，因此这是

00:17:10.420 --> 00:17:18.100
这是分层路由的一种积极特征，现在

00:17:18.100 --> 00:17:22.780
在层次结构中并不一定需要人类可读，可以

00:17:22.780 --> 00:17:30.700
基本上所有的东西，这就是我们进入flats名称空间的地方

00:17:30.700 --> 00:17:36.820
知道很多人已经提出过建议，但是您知道基于散列的寻址方式

00:17:36.820 --> 00:17:39.890
知道别人更难理解该怎么做

00:17:39.890 --> 00:17:43.340
给您一些内容，但是您需要知道是否有一个内容

00:17:43.340 --> 00:17:50.210
名称解析系统，然后您就可以路由和转发

00:17:50.210 --> 00:17:57.940
所有这些人都需要拥有的特性是名称应该是唯一的

00:17:57.940 --> 00:18:02.990
我不知道这是否能回答整个问题，所以有一些例子

00:18:02.990 --> 00:18:09.040
稍后我将要讨论的每种架构都有用

00:18:10.300 --> 00:18:15.320
是的，这是在回答问题还是您在做什么，尽管我们可以

00:18:15.320 --> 00:18:20.120
得到我们以后可以去看它，只看到一些例子，但是因为你说

00:18:20.120 --> 00:18:27.230
是唯一的，但是就什么而言，这就像是唯一的-是的-中的每个其他名称

00:18:27.230 --> 00:18:33.670
危险就好像您知道基于对象的内容具有哈希值，并且

00:18:33.670 --> 00:18:38.090
你想要那个，因为你想以此来识别这个特定的对象

00:18:38.090 --> 00:18:44.960
正确的名称，适用于可变数据或不可变数据，因为

00:18:44.960 --> 00:18:49.970
可变数据将更改，因此名称不一定是唯一的

00:18:49.970 --> 00:18:57.670
对于数据来说，它就像独特的数据一样独特，所以让我们假设我的意思是

00:18:57.670 --> 00:19:06.110
在大多数情况下，假定内容保持至少保持静态

00:19:06.110 --> 00:19:11.750
课程内容的基本设计本身可能会改变您所知道的内容

00:19:11.750 --> 00:19:18.080
的对象可能会更改，然后讨论您是否知道

00:19:18.080 --> 00:19:22.730
这是一个基于哈希的东西，那很好，因为哈希在变化，但是如果它在变化，

00:19:22.730 --> 00:19:29.960
不，这是一个人给的名字，那么也许应该遵循

00:19:29.960 --> 00:19:35.350
通过您知道名称的第2版或类似内容

00:19:39.340 --> 00:19:46.429
就是回答我的意思是，是的，对我有帮助，谢谢，好的，好的

00:19:46.429 --> 00:19:58.520
好的，是的，所以让我们继续前进，在命名方面，我刚刚做了一个

00:19:58.520 --> 00:20:04.070
小，你知道这里的参考文献，这是一个很大的话题，但正如我所说

00:20:04.070 --> 00:20:09.140
每个架构都有其自己的名称命名方案和命名

00:20:09.140 --> 00:20:17.600
结构，所以我们将回到命名，所以其他任何问题都可以

00:20:17.600 --> 00:20:24.309
直到这一点，我们现在将进入第二部分

00:20:24.309 --> 00:20:30.980
我提到的第三个项目是命名数据网络

00:20:30.980 --> 00:20:40.640
该项目最初是在2006年设计并提出的，因此

00:20:40.640 --> 00:20:49.640
是沃恩·雅各布森（Vaughn Jacobson）当施乐PARC时所构思的，所以当

00:20:49.640 --> 00:20:53.080
杰里米（Jeremy）是主要设计拥塞控制的主要人员

00:20:53.080 --> 00:21:00.679
您可能知道，算法可以消除不快感，所以他对

00:21:00.679 --> 00:21:05.360
很长一段时间，您当然可以在拥塞控制和类似方面还可以

00:21:05.360 --> 00:21:10.669
事情，但又如何实现多播，所以他先讲了

00:21:10.669 --> 00:21:15.710
2006年的Google Tech Talk这是一个非常有趣的演讲，我强烈推荐

00:21:15.710 --> 00:21:19.700
有点长，但是一定很有趣，然后第一篇论文

00:21:19.700 --> 00:21:27.530
他们在ACM上发表的文章与Gees兄弟建立了很好的会议关系

00:21:27.530 --> 00:21:34.280
2009年的网络空间，所以那时主要是您知道一个项目

00:21:34.280 --> 00:21:39.530
在Xerox PARC中运行，然后由于各种原因超出了范围

00:21:39.530 --> 00:21:47.059
在这里，该项目已被重命名，并从Xerox PARC移到了

00:21:47.059 --> 00:21:52.250
一堆美国大学

00:21:52.250 --> 00:22:02.030
由美国国家科学基金会（NSF），加州大学洛杉矶分校（UCLA）和张艾莉卡（Alicia Zhang）担任PI，他们进行了跟进

00:22:02.030 --> 00:22:09.920
2014年纸质CCR计算机通讯评论，而该网站是

00:22:09.920 --> 00:22:16.040
他们从论文演讲中收集了大量的资料

00:22:16.040 --> 00:22:20.990
视频教程，这是一个非常活跃的项目，它仍在继续

00:22:20.990 --> 00:22:28.220
有一个活跃的测试平台存在，人们习惯于对其进行实验，因此

00:22:28.220 --> 00:22:33.560
它基本上是一个，另一个是我们不讨论的

00:22:33.560 --> 00:22:39.650
谈论今天仍然很活跃，所以提议的是

00:22:39.650 --> 00:22:45.920
协议栈的薄薄浪费而不是成为IEP派克大衣

00:22:45.920 --> 00:22:50.180
成为内容块，所以我很确定您对此非常熟悉

00:22:50.180 --> 00:22:57.020
因为我现在肯定会被尝试做几乎相同的事情，

00:22:57.020 --> 00:23:03.050
 IEP的观点是，它被压低了，而且显然没有

00:23:03.050 --> 00:23:08.680
最初建议将其消失作为干净的平板网络架构，

00:23:08.680 --> 00:23:14.510
您知道IP协议将要被替换或其他任何东西，但是当然

00:23:14.510 --> 00:23:21.050
我的意图不是要与我们不一定要使用MAC的方式相同

00:23:21.050 --> 00:23:26.210
地址以便与IB一样通过广域网路由事物

00:23:26.210 --> 00:23:31.280
将成为一个较低层的协议，并在其之上被命名为named

00:23:31.280 --> 00:23:39.140
内容块，因此在此设计中，主要有两种数据包类型

00:23:39.140 --> 00:23:45.200
是兴趣包和数据包，并且两者都是基本的

00:23:45.200 --> 00:23:50.120
组件是内容名称，因此我们将在下一张幻灯片中看到的名称，但是

00:23:50.120 --> 00:23:54.320
在这种情况下，它们是分层的，如果

00:23:54.320 --> 00:24:02.420
有人想要访问我的网页，他们就可以了

00:24:02.420 --> 00:24:08.179
迹象，并有一些日期签名的特征，例如新鲜度

00:24:08.179 --> 00:24:15.169
时期，诸如此类的事情，您知道TT Ellen以及类似的事物，而

00:24:15.169 --> 00:24:21.559
这里要注意的重要一点是，非常有效的利率市场

00:24:21.559 --> 00:24:27.490
数据包类似于我们今天拥有的IP包，

00:24:27.490 --> 00:24:33.380
致谢知识的消失，所以值得思考一下

00:24:33.380 --> 00:24:37.549
关于它的一点，你知道你有一个大约30字节的兴趣包

00:24:37.549 --> 00:24:43.730
很长或很小的东西，它问是否有每个请求，

00:24:43.730 --> 00:24:50.120
对某些数据的兴趣将被发送回该数据包不是一个完整的数据包

00:24:50.120 --> 00:24:55.549
内容对象，但大约有1 KB左右，所以我们在谈论

00:24:55.549 --> 00:25:01.159
有些您知道非常彻底的修改，而今天您知道什么

00:25:01.159 --> 00:25:06.380
你有一个HTTP GET应用程序层，然后是网络

00:25:06.380 --> 00:25:11.330
发生的情况是发件人将数据推向

00:25:11.330 --> 00:25:16.580
接收器正在通过TCP启动连接，之后在我们各种

00:25:16.580 --> 00:25:24.140
现在，消失的发送者会将即将来临的数据推回此处

00:25:24.140 --> 00:25:29.450
我们有一种，然后在收到您知道的数据包后，

00:25:29.450 --> 00:25:35.929
接收器正在发送回确认，说他们现在已经收到了

00:25:35.929 --> 00:25:40.549
到Andy any Easy的地方，我们需要稍微改变一下

00:25:40.549 --> 00:25:47.360
并说发送方正在发送第一个关注数据包，并且在接收到

00:25:47.360 --> 00:25:53.000
兴趣包，任何发件人都将用数据回复，所以有点

00:25:53.000 --> 00:25:56.990
颠倒了，当然是的，你知道这些会来

00:25:56.990 --> 00:26:01.760
以及一些直接应用于网络的拥塞控制算法

00:26:01.760 --> 00:26:09.950
命名的兴趣包比命名的数据包，因此在其中命名

00:26:09.950 --> 00:26:15.230
正如我刚才提到的，该体系结构是分层的-我认为这是其中之一

00:26:15.230 --> 00:26:22.020
架构使用层次结构名称

00:26:22.020 --> 00:26:27.060
名称，它们不一定必须是人类可读的，可以是任何东西，

00:26:27.060 --> 00:26:31.770
但是必须要有一定的等级制度，因为路透社在

00:26:31.770 --> 00:26:36.740
网络他们所做的是有效地执行最长前缀machi和

00:26:36.740 --> 00:26:42.180
取决于您是否知道他们从所有这些知识中知道什么以及他们可以到达的地方

00:26:42.180 --> 00:26:47.310
他们会相应地转发，例如，如果您想联系您，

00:26:47.310 --> 00:26:52.560
来自澳大利亚的英国学术机构，您至少需要

00:26:52.560 --> 00:27:00.030
能够以UK斜杠开头的单词口袋中的单词和单词

00:27:00.030 --> 00:27:06.750
您与人们认识的人越接近，路透社可能就知道更多的部分

00:27:06.750 --> 00:27:10.710
的名字，因此他们现在可以做出更明智的决定，如果

00:27:10.710 --> 00:27:17.130
有人偶然下载了这些文件，并且有一个额外的请求

00:27:17.130 --> 00:27:22.890
那么路透社可能已经在遥远的某个地方

00:27:22.890 --> 00:27:29.010
了解所有这些内容，因此通过进行最长前缀匹配可以发现

00:27:29.010 --> 00:27:34.620
并从近处检索它，因此它不必一直走到这个位置

00:27:34.620 --> 00:27:41.850
内容最初停滞不前，可能是最终用户参与其中，也可能是用户建议

00:27:41.850 --> 00:27:46.770
它可能在哪里存放缓存或其他内容，因此越来越多的内容

00:27:46.770 --> 00:27:53.190
越来越多的是，rooters越来越了解整个部分

00:27:53.190 --> 00:27:59.790
名称，因此他们可以从更近的地方自然地服务它，以实现

00:27:59.790 --> 00:28:06.090
在主要的印度节点体系结构中有三个表，第一个

00:28:06.090 --> 00:28:12.450
是内容存储，假设它是一个缓存，并且

00:28:12.450 --> 00:28:16.860
好吧，那里有一个大辩论，是否一切都通过了

00:28:16.860 --> 00:28:22.830
路透社应先进入缓存，否则最初一分钟内不能解释

00:28:22.830 --> 00:28:29.760
基本上是为了恢复TCP或传输层损失而提出的

00:28:29.760 --> 00:28:32.350
并且不愿意一路回到发件人

00:28:32.350 --> 00:28:38.230
弄清楚已经丢失了很久的东西，然后

00:28:38.230 --> 00:28:44.620
您认识的人会建立各种缓存算法，以使您知道

00:28:44.620 --> 00:28:48.550
整个网络的执行效率更高，因此这是内容存储库

00:28:48.550 --> 00:28:54.550
是一个悬而未决的兴趣表，它基本上是一个表和索引，其中每个

00:28:54.550 --> 00:29:02.920
节点正在存储他们刚刚转发的兴趣，然后当

00:29:02.920 --> 00:29:07.900
为了利益的数据，数据又回来消耗了利益

00:29:07.900 --> 00:29:13.780
并且一旦它说它将要从该挂起中删除该名称

00:29:13.780 --> 00:29:18.190
兴趣表，然后有一个供稿表，该供稿表类似于

00:29:18.190 --> 00:29:22.840
当然，今天规则所拥有的fib表当然在哪里而不是拥有IP

00:29:22.840 --> 00:29:27.429
地址中有前缀，您知道，正如我之前所说，这取决于

00:29:27.429 --> 00:29:35.010
您收到的前缀有多长，然后您将其转发出某个界面

00:29:35.010 --> 00:29:40.780
所以这就是每个返回都应该具有的节点结构

00:29:40.780 --> 00:29:45.940
在这个模型中，它是一个非常有趣的结构，它带来了很多

00:29:45.940 --> 00:29:50.380
一分钟我会说一些挑战，但这仍然很有趣

00:29:50.380 --> 00:29:58.330
设计，因此，如果我们要进行更图形化的说明，请在此处找到请求者

00:29:58.330 --> 00:30:04.270
我们有一堆果渣，源节点在那下面，所以正在发生的事情是

00:30:04.270 --> 00:30:08.440
请求者正在发送一个将要到达的兴趣桶

00:30:08.440 --> 00:30:12.820
网络中的第一行，这些轮换让对手产生了兴趣

00:30:12.820 --> 00:30:18.250
是他们首先检查缓存以查看内容是否已经存在

00:30:18.250 --> 00:30:24.280
如果是送达，则直接返回，如果不是，则他们检查待处理

00:30:24.280 --> 00:30:28.330
兴趣表，这很有趣，因为您可以

00:30:28.330 --> 00:30:34.960
了解您所知道的兴趣所在，因为它们可以使本地用户受益

00:30:34.960 --> 00:30:40.720
多播，所以我将在一分钟内解释一下，如果没有什么大的问题

00:30:40.720 --> 00:30:43.600
桌子，然后他们检查自己的脚，他们为

00:30:43.600 --> 00:30:48.610
因此，下一个Rooter会执行相同的操作，他们将检查缓存页面并

00:30:48.610 --> 00:30:51.370
如果没有的话，世界博览会上有一个自助乐队

00:30:51.370 --> 00:30:57.100
现在在某个时候，我们缓存中的主要内容是哪些内容

00:30:57.100 --> 00:31:01.960
或他们拥有的任何内存，他们都会获取内容并立即将其发送回去

00:31:01.960 --> 00:31:08.140
root正在本地缓存内容，最终将内容返回给

00:31:08.140 --> 00:31:14.049
现在，当其他人为另一个任务而来的请求时，请求者

00:31:14.049 --> 00:31:17.320
相同的内容显然要命中缓存并将其取回

00:31:17.320 --> 00:31:21.549
直接提高了课程的效率，他是什么

00:31:21.549 --> 00:31:28.539
就像我说的那样，它还可以启用时移多播，因为如果我们有

00:31:28.539 --> 00:31:34.150
第一个请求者发送的兴趣正在对未决进行排序

00:31:34.150 --> 00:31:39.100
兴趣表（如果发送了另一个请求者）

00:31:39.100 --> 00:31:44.049
对同一事物的兴趣，这条路线不会转发兴趣

00:31:44.049 --> 00:31:47.950
第二次要说的是我希望这个内容能回来

00:31:47.950 --> 00:31:53.559
因此，我不会转发几天，而当我收到内容时，

00:31:53.559 --> 00:32:00.789
只是要从两个接口发送出去，所以原生

00:32:00.789 --> 00:32:06.220
多播问题很好，这里很好地介绍了另一件事

00:32:06.220 --> 00:32:10.900
涵盖了对流动性的支持，所以如果我们假设这些是

00:32:10.900 --> 00:32:16.600
例如，不是两个不同的请求者，而您正在发送一个请求，但是

00:32:16.600 --> 00:32:22.270
您从存在Wi-Fi或蜂窝基站的任何接入点断开连接，并且

00:32:22.270 --> 00:32:27.429
您可以连接到另一个，而无需拆除并获得新的TCP

00:32:27.429 --> 00:32:32.110
连接完成后，您只需发送您感兴趣的兴趣

00:32:32.110 --> 00:32:37.179
您在此处连接时发送的内容可能

00:32:37.179 --> 00:32:42.760
回来，这个缓存在这里，所以即使您由于连接错误而丢失了它

00:32:42.760 --> 00:32:47.169
当您转至第二天的第二站时，发生了什么事

00:32:47.169 --> 00:32:50.980
是您只是再次发送兴趣，然后直接检索内容

00:32:50.980 --> 00:32:55.980
来自网络中的最后希望，所以非常有趣

00:32:55.980 --> 00:33:01.590
当然还可以带来挑战，其中有两个主要特征

00:33:01.590 --> 00:33:07.200
这种架构是，除了我提到的其余部分之外，还有一个

00:33:07.200 --> 00:33:11.970
无连接模型，因此基本上没有建立连接的用户

00:33:11.970 --> 00:33:18.510
只是发出兴趣，而数据中心的数据可以追溯到

00:33:18.510 --> 00:33:25.559
消耗兴趣，并且始终有一个相当严格的基于推送的模型，因此

00:33:25.559 --> 00:33:29.010
抱歉，基于池的模型无法传输数据

00:33:29.010 --> 00:33:34.230
只有在有人请求时才在网络中

00:33:34.230 --> 00:33:40.049
就像我说的那样，充满勇气的有趣物业是的

00:33:40.049 --> 00:33:44.690
这是一个有趣的数据包，它是TCP连接，基本上是颠倒的

00:33:44.690 --> 00:33:52.169
当然还有一些挑战，因此缩放fib的大小是

00:33:52.169 --> 00:33:56.460
问题，这不是一件容易的事，因为我们必须假设您知道自己需要

00:33:56.460 --> 00:34:03.299
跟踪Internet中几乎所有存在的名称空间

00:34:03.299 --> 00:34:07.799
对，所以您当然不需要像我一样跟踪整个名字

00:34:07.799 --> 00:34:17.000
说路透社做最长的前缀匹配，但即使是让您知道前几个

00:34:17.089 --> 00:34:22.020
层次结构名称的前几个部分已显示该字段是

00:34:22.020 --> 00:34:27.060
会爆炸，然后出现专利缓存中毒攻击，因此

00:34:27.060 --> 00:34:35.069
这不是一个解决的问题，我的意思是演出很糟糕

00:34:35.069 --> 00:34:39.179
不知道该说些什么对不对，但这是一个寻找问题的问题。

00:34:39.179 --> 00:34:46.470
解决方案基本上是因为某人可以对那些不感兴趣的内容发出兴趣

00:34:46.470 --> 00:34:51.349
对于使用随机泳道不存在的内容存在，并且这些和

00:34:51.349 --> 00:34:58.319
填写路透社的未决利益表，有效启动

00:34:58.319 --> 00:35:03.920
拒绝服务攻击，因为您知道那里什么也不能存储

00:35:03.920 --> 00:35:10.020
我认为那是对的，是的，这是最后一张幻灯片，因为我说过

00:35:10.020 --> 00:35:15.270
该项目正在进行中，有一个人们正在使用的活着的病床

00:35:15.270 --> 00:35:20.730
主要用于研究活组织检查，这是唯一的提议，它相当激进，但

00:35:20.730 --> 00:35:26.490
我认为这是一个非常好的设计，这是您唯一的唯一建议

00:35:26.490 --> 00:35:33.240
知道实际上是基于名称的路由，从发送方到接收方还是在

00:35:33.240 --> 00:35:40.950
至少那是主要设计，是的，而且像您一样轻松地快速进行操作

00:35:40.950 --> 00:35:47.400
在这里暂停并查看您是否知道您认为有任何有趣的功能

00:35:47.400 --> 00:35:52.830
在此项目或更多项目中应进一步考虑

00:35:52.830 --> 00:36:02.400
通常哦，不管有什么问题，我都会

00:36:02.400 --> 00:36:09.270
询问您基于名称的路由和名称解析，例如查找我的名称类型和

00:36:09.270 --> 00:36:14.370
架构是解决此问题的两种不同方式

00:36:14.370 --> 00:36:19.340
不同的架构两者之间有多少重叠或相似之处

00:36:19.340 --> 00:36:24.660
像nd M会出现问题，您会期望

00:36:24.660 --> 00:36:30.810
Ike尚未撤资以查看它们，还是它们相差悬殊，以至于您只希望得到

00:36:30.810 --> 00:36:36.660
看看我们是否愿意开始转向船的路线-是的

00:36:36.660 --> 00:36:43.770
实际上是一个很好的问题，因为我的一个建议是基于该名称的

00:36:43.770 --> 00:36:50.700
路由其带来的一个有趣的功能或原理

00:36:50.700 --> 00:36:57.390
它可以解析本地内容，因此在我看来，您知道

00:36:57.390 --> 00:37:03.510
拥有一个基于名称的系统，直到某个时候，再到某个解析实体

00:37:03.510 --> 00:37:11.190
那将尝试找到什么本地名称基本路由找不到我认为

00:37:11.190 --> 00:37:15.500
他可以达到适当的平衡

00:37:15.609 --> 00:37:22.579
对不起，但是直到现在，这两种方法都非常重要

00:37:22.579 --> 00:37:28.309
已经采取了一个或另一个，我的看法是这两者的结合

00:37:28.309 --> 00:37:33.020
两个都存在可伸缩性问题或性能问题

00:37:33.020 --> 00:37:42.230
我们稍后会看到的问题，但实际上并没有将两者结合在一起

00:37:42.230 --> 00:37:46.849
被看过，我认为这是非常非常有趣的

00:37:46.849 --> 00:37:51.819
方向，但有人应该考虑

00:37:52.370 --> 00:37:57.170
[音乐]好的，你好，队友

00:37:57.170 --> 00:38:07.390
是的，对不起，如果有两个人在说这大概是

00:38:07.390 --> 00:38:16.730
名称的层次结构是由某个权限分配的名称，还是存在

00:38:16.730 --> 00:38:20.839
好点是的，有人假设会发生什么事

00:38:20.839 --> 00:38:26.359
类似于我们今天拥有的图标，但无论您知道哪里，都应该有一些

00:38:26.359 --> 00:38:33.380
中央注册中心的名称，或者不是每个名称，显然不是每个文档

00:38:33.380 --> 00:38:39.170
我们每天制作和发布需要注册的内容

00:38:39.170 --> 00:38:45.920
直到某个点的层次结构以获取前缀，它们之间需要达成共识

00:38:45.920 --> 00:38:53.270
是的，每个人都对，我有同样的疑问，听起来像是名字的基础

00:38:53.270 --> 00:38:59.569
对，它与DNS相同，我想是这样，您可以重复它

00:38:59.569 --> 00:39:06.049
哦，对不起，我有同样的问题，我的意思是关于汽车的确切名称

00:39:06.049 --> 00:39:09.529
推动您知道他们如何知道您知道哪里的下一台服务器在哪里

00:39:09.529 --> 00:39:15.049
应该是这样，这听起来与DNS字词非常相似

00:39:15.049 --> 00:39:20.960
所以是的，这里有一些问题您不一定需要知道在哪里

00:39:20.960 --> 00:39:26.630
确实是服务器，但是需要一些引导程序

00:39:26.630 --> 00:39:35.150
是的，因为最初的第一天，你如何获得实际的

00:39:35.150 --> 00:39:44.470
fib表中的第一个条目，因此必须通过一些静态操作来完成

00:39:44.470 --> 00:39:50.750
链接状态路由协议，基本上需要运行以进行引导

00:39:50.750 --> 00:40:00.109
他把饲料放在桌子上，是的，所以我看到了，Steve举起了一个

00:40:00.109 --> 00:40:06.980
据我所知，可以肯定地说这是DNS是DNS的关键

00:40:06.980 --> 00:40:10.220
就像我问一个服务器的名字，他们告诉我下一步要去哪里，你

00:40:10.220 --> 00:40:14.150
继续递归执行此操作，但这更像是我要问一台服务器而不是

00:40:14.150 --> 00:40:17.869
他们将在福特公司转发它们，然后转发并最终像一些缓存一样

00:40:17.869 --> 00:40:20.660
希望是这样，或者车站的时间会向前转回

00:40:20.660 --> 00:40:24.500
内容，更像是我是转发系统，而不是

00:40:24.500 --> 00:40:33.529
是一个递归查找系统，是的，是的，完全正确，但是没有权利，这是

00:40:33.529 --> 00:40:39.049
轮到我了，我正在使用聊天举起我的头，这是正确的方法，所以我

00:40:39.049 --> 00:40:44.150
这里有两个问题供您回答是取消利息如何

00:40:44.150 --> 00:40:47.690
一个节点向网络的其余部分发出信号，表示他们已经收到了

00:40:47.690 --> 00:40:52.250
他们对此感兴趣，所以我假设该块不会向后移动

00:40:52.250 --> 00:40:55.519
每当我猜到兴趣来自

00:40:55.519 --> 00:41:00.849
开胃菜网这我不知道是这样的情况下是的是的

00:41:00.849 --> 00:41:05.960
是的，我忘了提及，但这是一个好点，所以这是一个非常

00:41:05.960 --> 00:41:10.910
您可以在此处假设的对称例程，因此返回路径必须

00:41:10.910 --> 00:41:15.009
一样，这基本上是

00:41:15.759 --> 00:41:23.089
因为作为请求者发送某种感兴趣的内容来安装某种状态

00:41:23.089 --> 00:41:30.140
在那里的PPT中，然后通过小费，您知道它说我有

00:41:30.140 --> 00:41:36.619
在这条车道何时何地收到了我的兴趣，我必须将其发送

00:41:36.619 --> 00:41:40.349
向下通过该接口，因此它不会通过发送回去

00:41:40.349 --> 00:41:46.140
是的，是另一个接口，所以这有效地创建了一个

00:41:46.140 --> 00:41:51.479
在网络情况下此请求的路径将非常困难

00:41:51.479 --> 00:41:55.410
对，因为在一天结束时，就像您的双眼有

00:41:55.410 --> 00:41:59.759
您采取多条路径，最终将使网络中的需求泛滥

00:41:59.759 --> 00:42:05.190
一种方式和需求产生的数据传输

00:42:05.190 --> 00:42:09.869
正确，是的，是的，是的

00:42:09.869 --> 00:42:14.160
最初在基础设计中，您知道单路径和对称路由是

00:42:14.160 --> 00:42:20.039
假设，但是您知道如果

00:42:20.039 --> 00:42:24.390
你想做一些多路径的事，然后你的知识就知道了

00:42:24.390 --> 00:42:29.430
沿着数条不同的路径，如果有任何东西

00:42:29.430 --> 00:42:36.150
考虑具有弹性和冗余性，因为如果这些节点之一

00:42:36.150 --> 00:42:44.009
往下走，那么路径会被右断，是的，所以主要前提是

00:42:44.009 --> 00:42:51.559
这是您知道是否这样，这取决于这些节点是否断开，然后这

00:42:51.559 --> 00:42:57.749
如果这些节点说掉了，那么这些请求者将没有任何遗憾

00:42:57.749 --> 00:43:03.299
之所以会说罗塔尔，是因为他们有基本上相互连接的供稿表

00:43:03.299 --> 00:43:08.969
每个人都知道周围有谁，他们可以将请求转发给某人

00:43:08.969 --> 00:43:14.130
否则，这不是一个大问题，显然正在进行的一切

00:43:14.130 --> 00:43:19.739
丢失，但是网络正在恢复弹性

00:43:19.739 --> 00:43:23.579
我可以支持的东西

00:43:23.579 --> 00:43:31.140
因此，这种持久覆盖的方式有点像我们喜欢对其进行改造

00:43:31.140 --> 00:43:36.569
可以，只要其他人直接连接到该节点，就可以使用不同的路径

00:43:36.569 --> 00:43:40.769
注意到该节点已变得不可用，确切地说是

00:43:40.769 --> 00:43:46.890
明白了我的第二个问题是你提到一个1 KB的硬限制

00:43:46.890 --> 00:43:53.349
考虑大块，仅网络如何处理更大的块，

00:43:53.349 --> 00:44:00.279
比垃圾或杂物大，所以我的意思是

00:44:00.279 --> 00:44:05.259
硬限制，是的，必须存在，没有硬限制，我认为

00:44:05.259 --> 00:44:12.339
他们目前正在使用的内容大约是4 KB

00:44:12.339 --> 00:44:15.880
意思是没有，我不认为这是已经同意或标准的不安。

00:44:15.880 --> 00:44:20.529
指出所有较大的事物都必须经过碎片化处理

00:44:20.529 --> 00:44:24.640
基本上像今天这样发生，还有巨型帧之类的东西

00:44:24.640 --> 00:44:31.799
嗯，到最后，它有点像文件本身或

00:44:31.799 --> 00:44:39.789
对用户有意义的块，它可以在一个单元中获取

00:44:39.789 --> 00:44:45.729
可寻址的，您不会使较大的Blob的内部块可寻址

00:44:45.729 --> 00:44:50.920
对不起，我没有得到，所以想象你有一个1兆字节

00:44:50.920 --> 00:44:56.710
文件，它将是一个1兆字节的文件，其地址不想要

00:44:56.710 --> 00:45:01.150
它不是没有块，也没有内部地址

00:45:01.150 --> 00:45:06.819
所谓的大块，是由你们所说的是的碎片组成的

00:45:06.819 --> 00:45:12.219
是的，每个人都有一个名字

00:45:12.219 --> 00:45:19.989
块，所以长名称可以这样说，这不是一个HTML文件，而是一个

00:45:19.989 --> 00:45:25.119
巨大的PDF文件巨大的视频文件（1兆字节）将分割成大块

00:45:25.119 --> 00:45:31.239
1 KB或4或5或其他任何内容，好吧，应该有一些命名

00:45:31.239 --> 00:45:38.109
约定，这将是X点PDF块，一个块，两个块，然后

00:45:38.109 --> 00:45:42.069
那里会有一些序列号，您知道我们在谈论块

00:45:42.069 --> 00:45:47.710
第一个与序列中的序列号类似，在我消失后，我的孩子明白了

00:45:47.710 --> 00:45:51.490
谢谢[音乐]

00:45:51.490 --> 00:45:59.740
好吧，如果是的话，如果我们没有其他问题，我想我们可以提出

00:45:59.740 --> 00:46:06.490
因此，基于名称的路由方法或其中的一小部分与某些方法一起使用

00:46:06.490 --> 00:46:11.620
我认为另一座高架桥可能会很有趣

00:46:11.620 --> 00:46:19.810
考虑在我的PFS中，所以第二部分现在是第二个项目

00:46:19.810 --> 00:46:24.760
实际上这是一篇名为供体数据导向网络架构的论文

00:46:24.760 --> 00:46:31.780
从来没有，这不是一个项目，它是2007年发表的论文，还是ACM发表的六篇论文

00:46:31.780 --> 00:46:40.800
盲肠，因为在时间上如此早，所以基本上落后了

00:46:40.800 --> 00:46:49.390
在您认识他们之前，Park和Jacobson的印度或CCN项目

00:46:49.390 --> 00:46:55.890
这就是为什么它非常及时，并且引起了人们的极大兴趣，

00:46:55.890 --> 00:47:03.400
数以千计的引用只是因为它是如此及时，所以主要动机

00:47:03.400 --> 00:47:08.170
是一样的，您知道内容很重要，而不是确切地由谁托管

00:47:08.170 --> 00:47:12.820
内容原本应该是互联网的干净设计，

00:47:12.820 --> 00:47:18.580
主要设计目标具有持久性名称时，

00:47:18.580 --> 00:47:23.020
内容移动到另一个域或另一个位置可用性

00:47:23.020 --> 00:47:28.660
意味着访问应该可靠，快速，然后是您所知道的真实性

00:47:28.660 --> 00:47:34.060
通过一些机制，我们需要确保我们得到的是

00:47:34.060 --> 00:47:42.070
我们要求的内容以及发件人声称要发送的内容，因此命名为

00:47:42.070 --> 00:47:48.580
捐助者进入下午，这实际上并不意味着脱胎换胎

00:47:48.580 --> 00:47:57.760
它包含在P主体和标签中，因此您可以想到主体，因为它很漂亮

00:47:57.760 --> 00:48:02.620
捐助者体系结构的中心概念，您可以想到

00:48:02.620 --> 00:48:07.840
校长基本上是网络，对不起内容发布者或某人

00:48:07.840 --> 00:48:14.020
谁在兑现或存储内容，以及实际上是什么，这些电脑

00:48:14.020 --> 00:48:20.080
内容发布者网站的公共密钥的加密哈希值，用于还原

00:48:20.080 --> 00:48:24.730
内容，然后是Rahzel，这是根据原理选择的标签

00:48:24.730 --> 00:48:30.310
再次必须是唯一的，所以它可以是哈希或其他东西，但必须是

00:48:30.310 --> 00:48:34.840
与互联网上的其他任何内容相比都是独一无二的，因此它必须以某种方式

00:48:34.840 --> 00:48:42.850
知道可以用该对象中的某些位来唯一标识数据包格式

00:48:42.850 --> 00:48:49.960
这次是数据公钥和签名以及客户端

00:48:49.960 --> 00:48:54.580
通过比较公钥的哈希值和什么值，显然可以验证数据

00:48:54.580 --> 00:49:02.350
原则或内容发布者已经提供的内容，现在有一个

00:49:02.350 --> 00:49:07.960
供体检测器中另一个非常重要的事情是分辨率处理程序是

00:49:07.960 --> 00:49:15.460
是放置在网络内部和内部的网络实体之类的东西

00:49:15.460 --> 00:49:20.920
ISP网络以处理请求并重定向进行路由和

00:49:20.920 --> 00:49:26.350
基本上是转发，所以主要操作是已注册的数据包，因此

00:49:26.350 --> 00:49:29.950
您可以将其视为已发布，因此您要注册一个内容

00:49:29.950 --> 00:49:34.750
在网络中说我有此内容，如果有人要

00:49:34.750 --> 00:49:42.100
它来找我并定义哪个基本上看到了什么状态

00:49:42.100 --> 00:49:47.590
通过注册消息安装在分辨率处理程序中以进行转发

00:49:47.590 --> 00:50:03.520
相应的请求好吗，请好吧，任何人都对此有疑问

00:50:03.520 --> 00:50:09.220
注册过程像这样，所以有解析处理程序

00:50:09.220 --> 00:50:14.140
您几乎可以知道，您假设每个isp中至少有一个

00:50:14.140 --> 00:50:21.130
域，无论谁拥有我们，我们都有一些内容需要

00:50:21.130 --> 00:50:25.570
现在向本地分辨率处理程序注册什么分辨率的相机

00:50:25.570 --> 00:50:31.990
这样做是因为它在isp层次结构或任何层次结构中向上传播

00:50:31.990 --> 00:50:38.440
对等域，他们不得不说我知道如何找到这些内容

00:50:38.440 --> 00:50:45.070
加上这个详细的名字，这些就一直到顶部

00:50:45.070 --> 00:50:53.260
第一层是P或顶层实体，因此按顺序完成

00:50:53.260 --> 00:50:58.300
从而能够真正找到内容，如果有客户

00:50:58.300 --> 00:51:02.950
要求提供我们刚刚注册和发布的内容的此副本

00:51:02.950 --> 00:51:07.540
从该分辨率处理程序中发生的事情将是击中那个那个

00:51:07.540 --> 00:51:12.250
这个家伙不知道那个查找器正在向上转发

00:51:12.250 --> 00:51:17.050
看到此解析处理程序中已保留安装状态

00:51:17.050 --> 00:51:22.330
之前，所以他们要向前走去找到副本，所以这个数字

00:51:22.330 --> 00:51:26.950
这里并不完全准确，因为我认为我很确定在捐助者中

00:51:26.950 --> 00:51:32.680
头的架构也一直是对等消息

00:51:32.680 --> 00:51:37.360
这些人在这里会将消息注册给这个人和这个人

00:51:37.360 --> 00:51:43.510
因此可以将它们缩短并在这两者之间转发

00:51:43.510 --> 00:51:50.310
解决数百个问题并找到内容的方法，但这是一般思路

00:51:50.310 --> 00:51:55.240
非常棒，我们在一个项目中做了一些优化，这是

00:51:55.240 --> 00:52:00.760
称为颂歌，因此基本上是对

00:52:00.760 --> 00:52:07.870
状态中的几个术语被保留在brutus中，但是那里正在发生的事情是

00:52:07.870 --> 00:52:13.330
有效地使请求者发送了很好的消息，然后

00:52:13.330 --> 00:52:18.070
解析处理程序将路由至不知道是否到达的位置

00:52:18.070 --> 00:52:22.930
缓存中没有任何内容，然后他们将其向上转发

00:52:22.930 --> 00:52:28.540
层次结构，直到找到需要进一步深入的顶级域

00:52:28.540 --> 00:52:35.150
再次找到内容，是的，这是一个新实体，一个新实体

00:52:35.150 --> 00:52:40.010
那里的分辨率处理程序的实体，这显然是一个有趣的架构

00:52:40.010 --> 00:52:59.140
您可以了解需要保持规范的状态和信息

00:52:59.140 --> 00:53:18.110
这就是为什么我问我认为您与您的关系破裂了的原因

00:53:18.110 --> 00:53:20.440
少量

00:53:29.779 --> 00:53:33.289
正是我所拥有的

00:53:36.850 --> 00:53:44.410
好了，所以我们刚刚失去了Janice希望为第二是好了，所以又回来了

00:53:55.910 --> 00:54:07.280
珍妮丝（Janice），你目前正静音，好吧，好吧，现在好吧，好吧，好吧，闭嘴，好吧

00:54:07.280 --> 00:54:15.270
非常糟糕，相当神奇，为您添加了自己的名称，好了，您需要恢复屏幕

00:54:15.270 --> 00:54:26.550
共享所有的权利，好吧，所以我们突然之间做了，所以我被那把刀切断了

00:54:26.550 --> 00:54:31.650
我说的时候，我想说的是，如您所知

00:54:31.650 --> 00:54:36.690
顶级分辨率处理程序将承受很大的压力

00:54:36.690 --> 00:54:41.250
需要保持正确状态的条件，因为每个有效条件

00:54:41.250 --> 00:54:46.099
互联网上的单个内容片段需要在此处注册

00:54:46.099 --> 00:54:55.470
为了能够最终返回并找到它，所以我们进行了研究

00:54:55.470 --> 00:55:02.599
几年前尝试估算大概需要多少个状态

00:55:02.599 --> 00:55:11.579
保持ISP的等级，因此我们为Donna和

00:55:11.579 --> 00:55:18.690
我们进行了卷曲优化，您可以在此处看到D是从小型ISP开始的

00:55:18.690 --> 00:55:24.750
基本上是从子域开始，然后是小的所有ISP，但随您所愿

00:55:24.750 --> 00:55:29.910
一直在寻找第一个Tier，他们需要将所有内容保留在BC中

00:55:29.910 --> 00:55:34.650
宇宙，即使在其中进行了优化，也非常相似

00:55:34.650 --> 00:55:39.000
卷曲，顶级域名不一定需要保留所有

00:55:39.000 --> 00:55:42.990
内容，但他们需要获取大部分内容，情况有点

00:55:42.990 --> 00:55:52.049
现在假设ISP的10乘以13的幂，则对大型和小型ISP来说更好

00:55:52.049 --> 00:55:56.460
互联网上发布的信息对象转化为

00:55:56.460 --> 00:56:01.500
很有意思的是，第一层的服务器数量

00:56:01.500 --> 00:56:08.220
域需要保留以具有状态存储，所以这就像

00:56:08.220 --> 00:56:15.120
2.66万个千兆ram服务器以便能够存储

00:56:15.120 --> 00:56:23.190
内存中的所有内容都可以执行两个转发请求

00:56:23.190 --> 00:56:31.260
因此，现在总而言之，好的，有效地归结为

00:56:31.260 --> 00:56:34.890
您有解析处理程序，每个解析处理程序都需要保留

00:56:34.890 --> 00:56:40.620
压力最小的数据的路由状态进入第一层

00:56:40.620 --> 00:56:47.160
我们说过的作品，所以最初的设计声称应该是主要基础

00:56:47.160 --> 00:56:51.630
路由，但这取决于您实际拥有多少个解析处理程序

00:56:51.630 --> 00:56:57.030
域，所以如果您只有一个，那么它不是很简单，基本路由只是一个

00:56:57.030 --> 00:57:01.770
不同的分辨率系统（如果您拥有的分辨率处理程序越多）

00:57:01.770 --> 00:57:09.210
您实际上可以有效地做自己想做的就是知道利用

00:57:09.210 --> 00:57:14.850
本地连接并在本地转发请求，避免给其余部分造成压力

00:57:14.850 --> 00:57:26.330
随着网络的发展，是的，是的，得出的结论是第二部分和

00:57:26.330 --> 00:57:31.680
是的，对我来说，任何问题或有趣的功能

00:57:31.680 --> 00:57:38.310
作为一个网络，在这种特殊情况下，这可能会很有趣

00:57:38.310 --> 00:57:46.950
AFS网络ROS是为了确定是否存在

00:57:46.950 --> 00:57:52.950
层次结构，或者您知道域或自治系统结构，以及这些

00:57:52.950 --> 00:57:58.770
傻瓜不需要像Dom中那样与ISP本身相关

00:57:58.770 --> 00:58:04.290
建筑，但具有某种结构将有助于

00:58:04.290 --> 00:58:08.990
可扩展性，但是当您基本上知道内容基本上都是兼具性能时

00:58:08.990 --> 00:58:14.260
解决并从中心发送回接收方

00:58:14.260 --> 00:58:20.110
任何其他想法或问题，或者是否已经在结构之前进行了讨论

00:58:20.110 --> 00:58:28.260
某种领域之类的术语

00:58:30.210 --> 00:58:37.930
我现在听到的是一些需要考虑的想法，然后我一直在思考

00:58:37.930 --> 00:58:42.970
这条线在后期怎么说有组织的协作固定这样

00:58:42.970 --> 00:58:48.700
朋友，他们的其他朋友对此表示满意，然后啊，如果您以某种方式知道

00:58:48.700 --> 00:58:52.900
可以从您的朋友那里获得该内容，您可以直接进行

00:58:52.900 --> 00:58:55.930
而不是去DHT

00:58:55.930 --> 00:59:05.380
是的，是的，请确保没有考虑任何拓扑结构

00:59:05.380 --> 00:59:09.580
因此，如果您在加拿大，而我在这里，但我们是朋友，我仍然会

00:59:09.580 --> 00:59:13.110
直接向你走去，把它弄对

00:59:13.530 --> 00:59:18.780
是的，我的意思是说，您可能会喜欢地理位置优越的朋友

00:59:18.780 --> 00:59:29.500
是的，我不知道，是的，我认为某些拓扑的嵌入

00:59:29.500 --> 00:59:36.010
具有一些基于名称的路由结构好，我的意思是它将解决本地

00:59:36.010 --> 00:59:41.350
本地化，这将通过辩论和是提高绩效

00:59:41.350 --> 00:59:49.750
你好，斯蒂芬，对了，院长，哦，我不知道，是的，继续前进。Kaneesha有一个

00:59:49.750 --> 00:59:54.160
就像这样，这个名称又在这个系统中看起来是什么样的，以便包含

00:59:54.160 --> 01:00:03.280
既喜欢签名标识符，又喜欢层次结构，所以

01:00:03.280 --> 01:00:07.150
此处的层次结构并不涉及名称，因此这就是名称的方式

01:00:07.150 --> 01:00:13.420
看起来只是原理所在的PL结构

01:00:13.420 --> 01:00:17.440
从本质上讲，库珀图形散列了该人的公钥

01:00:17.440 --> 01:00:23.440
存储内容或发布内容，并且L是

01:00:23.440 --> 01:00:25.880
再次必须如此，我本以为那可能是

01:00:25.880 --> 01:00:30.980
基本上是该特定内容唯一的内容的哈希

01:00:30.980 --> 01:00:41.150
对象是的，所以这里没有层次结构，更像是一种扁平的结构

01:00:41.150 --> 01:00:49.450
在名称上，我实际上认为是层次结构

01:00:49.450 --> 01:00:54.260
真的为所有关心的人唱歌

01:00:54.260 --> 01:00:59.690
结构，您隐含地拥有权威，是的，这是我们的事情

01:00:59.690 --> 01:01:03.170
倾向于避开它，我本质上会有点像没有

01:01:03.170 --> 01:01:07.310
就像拥有您的密钥一样拥有您的命名空间，可以吗？

01:01:07.310 --> 01:01:12.170
再说一遍，因为那是削减我一开始就没假期说

01:01:12.170 --> 01:01:18.350
说层次结构，是的，所以您知道IPS我们目前没有层次结构

01:01:18.350 --> 01:01:22.670
主要是因为就我而言，这需要名称空间或任何权限

01:01:22.670 --> 01:01:30.950
我知道我们可能不希望它是基于位置的，因为

01:01:30.950 --> 01:01:35.180
然后像其中一个关键目标一样，感觉就像是在移动，并且仍然拥有

01:01:35.180 --> 01:01:38.900
内容已解决，是的，但您仍可以进行层次调整而无需进行

01:01:38.900 --> 01:01:45.590
就像更新一样，它丢失了到地理的地图，我猜是下一层了，

01:01:45.590 --> 01:01:50.440
说，嘿，我搬到这里，然后

01:01:51.820 --> 01:02:00.530
是的，所以这很有意义，因此他们同意认为

01:02:00.530 --> 01:02:07.520
命名空间可以是我的意思，它可能很有用，而这可能是

01:02:07.520 --> 01:02:13.430
认为这很危险，因为这样的问题是

01:02:13.430 --> 01:02:18.350
网络的命名结构和拓扑是两个不同的东西

01:02:18.350 --> 01:02:23.660
是并行发展中的一种，它们可以完全融入

01:02:23.660 --> 01:02:28.160
不同的方向，然后你最终会得到一些不适合的结构

01:02:28.160 --> 01:02:31.520
完全遵循拓扑，这几乎已经是

01:02:31.520 --> 01:02:36.770
IP之前发生过，但ipv6会更多

01:02:36.770 --> 01:02:40.930
有点危险，另一方面我也同意

01:02:40.930 --> 01:02:50.780
他说拓扑不需要您知道是的，对不起，对不起，让我们尝试

01:02:50.780 --> 01:02:54.700
正确清除头部，这样拓扑就不需要了

01:02:54.700 --> 01:02:59.480
并不意味着一定意味着如果我们说此内容在这里，

01:02:59.480 --> 01:03:04.640
不能移动到其他地方，不需要我不说要在名字内

01:03:04.640 --> 01:03:09.740
如果我们有的话，您知道是否有索引在其中

01:03:09.740 --> 01:03:16.910
大都市区的区域，您可以找到这些内容，那么这将是很多

01:03:16.910 --> 01:03:20.180
当您尝试基本上相反地交付内容时，速度更快

01:03:20.180 --> 01:03:26.809
正确的方向，因为您知道，所以我认为一些拓扑嵌入需求

01:03:26.809 --> 01:03:31.549
发生，但我当然同意，这不应该限制

01:03:31.549 --> 01:03:37.700
命名条款以及以后我们要移动名称时会发生什么

01:03:37.700 --> 01:03:44.690
满足于我们现在与我们合作的方式就像您的身体健康，这就是我们拥有

01:03:44.690 --> 01:03:48.140
像国家压倒一切的贡献文字会在这里说“嘿”

01:03:48.140 --> 01:03:51.170
您可以在这里找到理想的内容，就像我们将获得其他信息一样

01:03:51.170 --> 01:03:56.660
在这里，但像内容产品一样，我们可以将范围限制在您所处的位置，

01:03:56.660 --> 01:04:01.220
认为这对您有帮助，那么您会自动在附近找到人

01:04:01.220 --> 01:04:04.849
t5您走得更远，但总的来说，问题就像是把它放进去

01:04:04.849 --> 01:04:10.089
名称或以名称为基础的位置等礼帽，因此我喜欢

01:04:10.089 --> 01:04:18.530
你有，是的，我不是说在名字里放任何位置的东西

01:04:18.530 --> 01:04:23.210
所以我很抱歉是的，可能没有表达

01:04:23.210 --> 01:04:31.270
正确，但是这里的层次结构不存在，这并不意味着要说

01:04:31.270 --> 01:04:36.020
名称必须与位置无关，这不是我想表达的意思

01:04:36.020 --> 01:04:43.960
它的名字，所以就像网络通过某种方式

01:04:43.960 --> 01:04:49.460
网关或类似的结构（例如解析处理程序）可以跟踪

01:04:49.460 --> 01:04:54.470
哪些内容正确，而无需在名称中插入

01:04:54.470 --> 01:04:58.789
我认为这种结构可以解决本地内容并提高性能

01:04:58.789 --> 01:05:04.400
基本上可以归结为我们之前所说的每当询问混合名称时

01:05:04.400 --> 01:05:12.019
基于和基于名称解析的方式还可以，所以吉姆

01:05:12.019 --> 01:05:19.519
我可以听到你的歉意，对，这些都很有趣

01:05:19.519 --> 01:05:25.220
方案似乎有一种紧张感，我还没有真正听说过

01:05:25.220 --> 01:05:29.960
隐私，所以就像您在说话一样，您知道所有信息

01:05:29.960 --> 01:05:37.069
您正在Internet上访问什么社区

01:05:37.069 --> 01:05:48.499
有正确的解决方案，所以关于它的好处是转子

01:05:48.499 --> 01:05:54.049
在网络内部（如果您使用基于名称的路由绕转子的路由）

01:05:54.049 --> 01:05:57.950
网络中的用户不知道该发送到哪里，因为没有IP

01:05:57.950 --> 01:06:02.180
您刚关注的地址，并且您发送的邮件基本上是基于

01:06:02.180 --> 01:06:06.440
内容，并通过每条路线中安装的状态进行操作

01:06:06.440 --> 01:06:11.509
回到要求的人那里，所以在这方面比

01:06:11.509 --> 01:06:14.960
现在的问题是第一个希望，所以

01:06:14.960 --> 01:06:19.069
因为第一个希望基本上可以看到您要求的所有内容

01:06:19.069 --> 01:06:23.660
并且我们已经安装了指向您的状态，因此在这方面

01:06:23.660 --> 01:06:29.539
有一个未解决的问题，曾经有过一些

01:06:29.539 --> 01:06:34.970
是一些方法，但我已经过了几年，但是，是的，这是一个

01:06:34.970 --> 01:06:39.319
好地方，但它是在社区中，并且有一个

01:06:39.319 --> 01:06:48.230
如果您将其作为司法拇指使用，是的，是的，您好，是的，所以是一个想法

01:06:48.230 --> 01:06:53.869
这是等级制度，也许让人想起法院

01:06:53.869 --> 01:06:58.970
如果我可以依靠每个人都是对的，那么我可以创建

01:06:58.970 --> 01:07:03.019
就像我走了多少位的层次结构，我喜欢跳来跳去

01:07:03.019 --> 01:07:06.140
网络对，是的，可能是

01:07:06.140 --> 01:07:11.930
类似的东西，虽然是的，记得所有的细节，但脐带有一些

01:07:11.930 --> 01:07:19.299
很好的功能是，您知道，因为它最终是DHT

01:07:19.299 --> 01:07:24.200
表，你知道这已经不是最理想的

01:07:24.200 --> 01:07:29.779
因为一旦您必须进入DHD，您可能不得不远行

01:07:29.779 --> 01:07:35.480
因此，这样做并发送回答案的等待时间可能

01:07:35.480 --> 01:07:41.390
增加但彻底的ISP权利，就像每个ISP都有自己的一套

01:07:41.390 --> 01:07:45.829
分辨率处理程序，您基本上像迷你DHT一样运行

01:07:45.829 --> 01:07:53.359
在每个isp网络内部，然后访问它们，是的，是的，在

01:07:53.359 --> 01:07:59.660
在完成的情况下，这种特殊情况就像索引一样，所以您没有

01:07:59.660 --> 01:08:03.799
必须去运行DHT，但是其他方法也可以

01:08:03.799 --> 01:08:09.769
DHT，您又要绕圈找到您要的内容

01:08:09.769 --> 01:08:16.520
寻找，但假设这是一种拓扑嵌入

01:08:16.520 --> 01:08:28.600
是的，您不必走很远的地方，是的，还有其他问题

01:08:29.109 --> 01:08:39.460
好的，好的，所以最后一个项目是对项目或网络进行净额结算

01:08:39.460 --> 01:08:45.469
信息，实际上是结果是两个结果

01:08:45.469 --> 01:08:53.350
从大约2009年到大约2015年的连续欧盟项目

01:08:53.350 --> 01:08:59.420
这是这个项目，这个项目的设计非常相似

01:08:59.420 --> 01:09:06.259
到ipfs仅使用p2p，这很有趣，他们俩都有

01:09:06.259 --> 01:09:12.589
大约是在同一时间设计的，但完全是独立的路径，因此

01:09:12.589 --> 01:09:16.069
所以同一项目值得一提的是

01:09:16.069 --> 01:09:21.769
相当大，如果我们去那里的所有大型网站，就会有很多公司

01:09:21.769 --> 01:09:28.929
公司已经参与或以某种方式参与了该项目

01:09:28.929 --> 01:09:35.420
所以在这个架构中发生的是如果您有一个请求哦

01:09:35.420 --> 01:09:40.880
有一个正在使用的名称解析系统，所以这是名称

01:09:40.880 --> 01:09:47.599
基于分辨率的体系结构，在第一步中，您需要解析名称

01:09:47.599 --> 01:09:51.170
您要的-名称解析服务，然后这给出了

01:09:51.170 --> 01:09:56.659
您返回定位器，然后就可以获取所需的数据

01:09:56.659 --> 01:10:01.039
他们应该被缓存在那里，所以如果有东西被缓存，因为你会

01:10:01.039 --> 01:10:05.900
根据您的特定名称获取您要的东西

01:10:05.900 --> 01:10:11.000
内容，那么您可以从网络的中间包中获取它，或者也可以是

01:10:11.000 --> 01:10:15.260
您正在寻找的非洲大陆的某些地区就在那，然后一些

01:10:15.260 --> 01:10:19.340
其他部分不在其他注释之内，因此您将拆分请求并

01:10:19.340 --> 01:10:27.980
现在尝试从NRF系统的许多不同节点获取数据

01:10:27.980 --> 01:10:35.119
正在开发净额结算项目的是DHT系统和多级DHT

01:10:35.119 --> 01:10:41.329
我认为最低限度是三个级别的方案，但可能会更多

01:10:41.329 --> 01:10:47.780
认为他们至少在理论上进行了更多的实验，如果我们

01:10:47.780 --> 01:10:53.239
如果我们假设有一个对象X，则进一步详细介绍

01:10:53.239 --> 01:11:02.239
那是哪个ET k的房子，那么另一个节点就是这个网域

01:11:02.239 --> 01:11:08.840
或者它可以是一个自治域，并且与该自治域相关联的DHT

01:11:08.840 --> 01:11:15.079
系统，然后您具有发布级别的HDS，并且请求正在处理中

01:11:15.079 --> 01:11:22.250
现在一些访问该比率已达到此流行级别的DHD，

01:11:22.250 --> 01:11:29.340
如果该弹出窗口确实会进一步上升到高层THD

01:11:29.340 --> 01:11:34.800
实际上，它没有看到实际内容在本地被认为是什么，然后

01:11:34.800 --> 01:11:40.500
他要走下去，发现我的意思是，它与IPS非常相似

01:11:40.500 --> 01:11:45.810
只是在多层次上做，然后内容当然会随之而来

01:11:45.810 --> 01:11:51.390
最快的返回方式值得一提的是，此访问权限知道

01:11:51.390 --> 01:11:57.300
访问记录，他们没有做任何事情，他们实际上没有保留任何记录

01:11:57.300 --> 01:12:03.870
的存储内容，所以我怀疑这里是否有用户并询问

01:12:03.870 --> 01:12:09.660
对于完全相同的对象X，那么您知道除非那里的某个节点具有缓存

01:12:09.660 --> 01:12:15.450
同样的事情必须再次发生，所以您知道一件事是，如果存在

01:12:15.450 --> 01:12:20.490
这里某个地方的节点可以保存一些已经存在的事物的索引

01:12:20.490 --> 01:12:25.730
最近转发给其他用户和其他主机，那么这些

01:12:25.730 --> 01:12:33.080
最终您知道转发了请求，然后知道了本地节点中的内容

01:12:33.080 --> 01:12:39.690
所以命名方案看起来与您所看到的非常相似

01:12:39.690 --> 01:12:46.770
在此之前，我也有一个权限部分，这是内容

01:12:46.770 --> 01:12:53.610
发布者，但B这部分是可选的，主要是是否

01:12:53.610 --> 01:12:58.620
然后使用摘要算法，然后在其中使用哈希值的值

01:12:58.620 --> 01:13:06.060
如此有效地非常类似于IB FS中使用的内容，或者至少

01:13:06.060 --> 01:13:14.640
您知道发布之前的版本的初始CID，我看到了

01:13:14.640 --> 01:13:19.470
他们在讨论一些有趣的事情时

01:13:19.470 --> 01:13:23.880
某人必须记住的有趣功能和命名位置

01:13:23.880 --> 01:13:33.450
可以在那找到哈希，是的，所以有趣的是

01:13:33.450 --> 01:13:40.290
有一些论文，他们在其中构建了一个非常简单的模拟器，以便了解

01:13:40.290 --> 01:13:46.560
当您拥有多级DHT系统时，这样做有什么好处？

01:13:46.560 --> 01:13:52.160
他们的假设是，他们假设有几百万个节点

01:13:52.160 --> 01:13:58.350
传播延迟每秒约二十万公里，这些

01:13:58.350 --> 01:14:04.050
是他们为这些距离假定的延迟，这当然是

01:14:04.050 --> 01:14:07.830
模拟器，我的意思是，不是，不是完全一样，不是，不是那样

01:14:07.830 --> 01:14:15.090
互联网上当然没有胡说八道或多余的东西

01:14:15.090 --> 01:14:19.050
延迟，因此我们在下一张幻灯片中将看到的趋势基本上是

01:14:19.050 --> 01:14:24.120
看起来不太现实我是说我可能会说

01:14:24.120 --> 01:14:31.110
这些这些在这里乘以2左右，所以它们可能会多一点，是的

01:14:31.110 --> 01:14:37.560
因此，这里我们在y轴上看到的是检索某些内容的延迟

01:14:37.560 --> 01:14:45.420
所以有两个请求去找到它并发回我要的对象，而这个

01:14:45.420 --> 01:14:49.170
是网络中的节点数，似乎并没有

01:14:49.170 --> 01:14:53.870
现在有很大的不同，这是有趣的地方

01:14:53.870 --> 01:15:02.430
他们正在比较一个多级DHT，这里是mdhd，因此跳过了网络

01:15:02.430 --> 01:15:08.160
今晚跳过网，这是一张旧报纸，被称为不能

01:15:08.160 --> 01:15:14.100
记住标题是什么，但实际上是在绘制名称空间

01:15:14.100 --> 01:15:19.350
为了不去询问网络中的每个节点，而是取决于

01:15:19.350 --> 01:15:25.200
绘制完成的图表，然后仅询问那些节点，这似乎是

01:15:25.200 --> 01:15:30.630
此处报告的内容非常有效，但正如之前所说的那样

01:15:30.630 --> 01:15:38.310
斯蒂芬斯（Stephens）评论说，如果添加的话，这样做会有些危险

01:15:38.310 --> 01:15:45.000
名称中的某种拓扑事物，您尤其将名称空间分片

01:15:45.000 --> 01:15:51.270
就基于成本的名称而言，随着拓扑结构的发展，这两件事可能

01:15:51.270 --> 01:15:55.810
变得彼此相距很远，并且本来应该是不同的

01:15:55.810 --> 01:16:01.420
现在好了，让我们专注于虚线这一条线

01:16:01.420 --> 01:16:06.970
有人说如果有一天我们尝试解决内容会发生什么

01:16:06.970 --> 01:16:12.850
高清，当您上升时，您会看到如果三层到五层会发生什么

01:16:12.850 --> 01:16:18.490
七层和九层现在，您在此处显示了多层HD

01:16:18.490 --> 01:16:24.880
在THD级别具有单一级别的墙性能，但这是为了

01:16:24.880 --> 01:16:31.330
如果我们去到假设双方将统一请求分配

01:16:31.330 --> 01:16:37.750
达到30％的水平概率，或者我的意思是说这有效地表明30

01:16:37.750 --> 01:16:46.900
请求的百分比可以在某些DHD的本地请求上，也可以在DHD自身的某些请求上

01:16:46.900 --> 01:16:52.870
被拓扑嵌入到某个地理区域中，那么这些就变得非常重要

01:16:52.870 --> 01:16:56.740
因此此处未显示一个级别，因为它应该是一千

01:16:56.740 --> 01:17:01.630
在那边的某个地方，但我们可以看到的是，有九个级别的

01:17:01.630 --> 01:17:08.200
HD可以达到的性能大大低于之前的水平，并且

01:17:08.200 --> 01:17:13.780
然后您走的越远，您看到的是三级d HD 5级d

01:17:13.780 --> 01:17:23.070
 HD 7等级d HD本身等，因此在这里实际显示的效果要好一些

01:17:23.070 --> 01:17:27.850
在这里，我们再次有等待时间，在这里，我们有水平概率，所以如何

01:17:27.850 --> 01:17:33.430
可能是连续不断的用户要问的东西已经

01:17:33.430 --> 01:17:41.380
之前要求的，并且它在某些地理区域内，您知道

01:17:41.380 --> 01:17:46.360
有效地关注感兴趣的地方现在我们在这里看到的是

01:17:46.360 --> 01:17:55.750
级别d HD到了这一点，这里我们有多层h DS

01:17:55.750 --> 01:18:02.830
从我的9级开始，我们看到7级，5级和3级

01:18:02.830 --> 01:18:09.169
水平，直到我们达到20％的折扣为止

01:18:09.169 --> 01:18:14.899
在网络中的内容分发方面具有相似性

01:18:14.899 --> 01:18:19.729
我的意思是，您拥有的级别越多，事情就变得越有效

01:18:19.729 --> 01:18:24.589
您永远不会知道任何接近0.8或任何其他值的地方，但是有

01:18:24.589 --> 01:18:31.099
研究表明，zip指数似乎可以分布

01:18:31.099 --> 01:18:41.449
介于0.8到1.2之间，所以还可以，因此我想说的是这个区域的值

01:18:41.449 --> 01:18:46.189
这是可以合理假设的，因此这表明该地点

01:18:46.189 --> 01:18:52.519
如果我们设计这样的系统，那么感兴趣就会带来巨大的利益。

01:18:52.519 --> 01:19:00.949
考虑到这些事情是正确的，所以它的总结非常

01:19:00.949 --> 01:19:08.479
这非常类似于今天是否可以缓解以及流动方式的不同之处

01:19:08.479 --> 01:19:14.719
拥有一个DHT正在变得越来越重要，因为您知道在哪里

01:19:14.719 --> 01:19:19.399
必须去解决内容，你知道没有概念

01:19:19.399 --> 01:19:24.589
有效地使您知道解决靠近内容的问题，因此，如果有人

01:19:24.589 --> 01:19:30.229
靠近你的习惯，你知道好吧，这不完全是ipfs中发生的事情，而我

01:19:30.229 --> 01:19:35.269
知道他们在兑现钞票之类的东西，但实际上您知道

01:19:35.269 --> 01:19:43.809
更多层次结构多层次结构可以带来更多好处

01:19:44.559 --> 01:19:48.439
是的，在这里先摆个简单的姿势

01:19:48.439 --> 01:19:54.649
我认为有趣的功能是日期的不同级别

01:19:54.649 --> 01:20:00.199
是否还有其他想法或先前的讨论得到了支持

01:20:00.199 --> 01:20:05.239
诸如此类的东西在拓扑嵌入或在拓扑嵌入方面都是有意义的。

01:20:05.239 --> 01:20:17.229
主题级别或竖框的条件

01:20:17.770 --> 01:20:25.940
我很好奇是否有关于类似互联网请求人口的研究

01:20:25.940 --> 01:20:32.570
以及拓扑区域中有多少重叠，因为那

01:20:32.570 --> 01:20:37.340
似乎有很大的不同，所以分析一下

01:20:37.340 --> 01:20:42.969
实际上有很多重叠，往往是在一个地方内以了解在哪里

01:20:42.969 --> 01:20:48.160
当前的网络实践取决于该图

01:20:48.160 --> 01:20:54.469
是的，绝对有研究，有旧的研究和最新的研究，但是

01:20:54.469 --> 01:21:01.010
人们一直试图找出你知道合理的百分比是多少

01:21:01.010 --> 01:21:06.710
doxa假设他们在构建网络和优化网络时处于正常状态

01:21:06.710 --> 01:21:16.760
假设是合理的，所以值得对那些进行研究-两个

01:21:16.760 --> 01:21:24.380
问题之一是，这都是处理不可变内容的问题，是的

01:21:24.380 --> 01:21:31.010
另一个是从我记得那已经有一段时间了

01:21:31.010 --> 01:21:35.120
只有孩子，这样的出版物已经发表了，好吧，好吧，让我们

01:21:35.120 --> 01:21:40.730
尝试并喜欢将拓扑更多地嵌入到系统中，然后让孩子艾米丽（Emily）

01:21:40.730 --> 01:21:46.370
有点像啊，这很难，如果我们只是随机地做，那主要是因为

01:21:46.370 --> 01:21:51.860
实际上就像在不像ISP一样工作时查找拓扑

01:21:51.860 --> 01:21:57.110
就像从上到下命令他们一样，就像我一样困难

01:21:57.110 --> 01:22:02.150
不知道这样的多级DHT是实际运行还是大部分运行

01:22:02.150 --> 01:22:07.910
只是模拟，所以有一个测试台

01:22:07.910 --> 01:22:15.320
我不知道这有多全球化，但是有代码

01:22:15.320 --> 01:22:20.060
可用，并且会看到一个实际构建的系统，而不是

01:22:20.060 --> 01:22:24.710
只是模拟的是的，肯定有去过那里，我不知道有多大压力

01:22:24.710 --> 01:22:31.020
测试这是一个压力测试，但是的，因为当您开始交易时

01:22:31.020 --> 01:22:35.610
和那些像怪人一样喜欢像对称的人

01:22:35.610 --> 01:22:41.880
连接和结，所有这些都像弄清楚哪里一样

01:22:41.880 --> 01:22:46.850
实际上每个人都在帮助建立最佳拓扑会变得困难

01:22:46.850 --> 01:22:58.380
是的，保持节点以查看代码及其产生的效果

01:22:58.380 --> 01:23:05.730
是的，我看过迪伦（Dylan）老猫头鹰的其他东西，或两者都给同事看

01:23:05.730 --> 01:23:09.890
是bb / df / c本来应该有一个

01:23:09.890 --> 01:23:16.590
使用珊瑚的多级高清，它仅根据延迟来猜测其级别

01:23:16.590 --> 01:23:19.070
就像大多数观众会一起工作一样

01:23:19.070 --> 01:23:24.660
协作找出它们恰好在某个低延迟组中，然后

01:23:24.660 --> 01:23:31.650
经过了改革，这才是真正的好吧，所以礁石计划将这些

01:23:31.650 --> 01:23:39.150
我的意思是在某个时候将其作为主要部分，或者最终是的，是的，是的

01:23:39.150 --> 01:23:46.620
是的，您认为人群设计是一种最佳设计，以便尝试

01:23:46.620 --> 01:23:51.030
并捕获感兴趣的地点和邻里效应之类的东西，或者

01:23:51.030 --> 01:23:56.310
不管我们叫谁，我都不知道目前是否有更好的妹妹

01:23:56.310 --> 01:24:02.280
认为可能会有像混合动力系统那样使用您的外观的空间

01:24:02.280 --> 01:24:06.210
就像您的本地局域网就像底层一样，那么也许您可以

01:24:06.210 --> 01:24:09.930
自动为下一年配置某些IP范围，或者您可以使用

01:24:09.930 --> 01:24:14.520
例如您当地的ISP信息，但除此之外，

01:24:14.520 --> 01:24:25.470
通常是最正确的，我猜是的，绝对是的，我同意，是的，是的，我

01:24:25.470 --> 01:24:32.100
一直以来，我认为其中大部分都将应用或部署在

01:24:32.100 --> 01:24:38.030
ISP级别正确，因此有点像一些预先安排的交易或

01:24:38.030 --> 01:24:42.840
具有隐式信任的关系各方之间没有关系等等

01:24:42.840 --> 01:24:49.020
关于如何将这些概念进行任何研究

01:24:49.020 --> 01:24:53.909
推断为似乎是固有信任的空中网络

01:24:53.909 --> 01:24:58.409
较少需要为拜占庭建模，而您知道是虚假的，依此类推

01:24:58.409 --> 01:25:07.650
你知道一个叫做ifs和p2p的项目，所以也许我忘记了

01:25:07.650 --> 01:25:12.090
首先要提到的是，所有这些都是

01:25:12.090 --> 01:25:18.750
作为替代品而不是替代品而提出的，是互联网的下一个层次

01:25:18.750 --> 01:25:23.969
协议栈应该看起来像这样，如果它们应该能够解决

01:25:23.969 --> 01:25:29.429
他们将把整个内容中的所有内容连网，

01:25:29.429 --> 01:25:35.040
您知道像今天的IP一样做所有事情，所以风险很大

01:25:35.040 --> 01:25:41.820
项目，你不知道蓝天，但你知道森林，让我们做

01:25:41.820 --> 01:25:48.750
一件非常激进的事情，这是一件事，其次是，在那里

01:25:48.750 --> 01:25:56.000
在所有这些人中，IASB都在某种程度上参与了花圈

01:25:56.000 --> 01:26:03.570
但例如，解析程序处理程序应该是我每一个RESP中的一个

01:26:03.570 --> 01:26:09.120
不知道是否需要达成协议，但我想从一家企业

01:26:09.120 --> 01:26:12.750
从模型的角度来看，有人将不得不拿起这台机器并把它放回去

01:26:12.750 --> 01:26:18.300
与您认识的每个人都有联系，因此谁愿意为此付出代价

01:26:18.300 --> 01:26:23.100
因此，ISP是您所了解的最直接的方法

01:26:23.100 --> 01:26:30.600
然后把它放在那里，是的，是的，所以我看到有一些讨论，如果

01:26:30.600 --> 01:26:36.150
我们希望将这些信任从IASB或IASB的图片中剔除出来，因为

01:26:36.150 --> 01:26:41.639
我们如何构建系统，即不涉及或不涉及的系统

01:26:41.639 --> 01:26:47.520
盲目地信任ISP，或者当然是基础设施提供商

01:26:47.520 --> 01:26:51.929
我认为进来的是激励措施，我已经看到了

01:26:51.929 --> 01:26:57.040
关于它的一些讨论，您知道激励措施不仅应该是

01:26:57.040 --> 01:27:02.469
周围的存储，你知道这种事情，甚至路由

01:27:02.469 --> 01:27:07.830
如果删除信任，则提供路由信息和路由提示

01:27:07.830 --> 01:27:20.500
有人必须替换掉它，所以你该怎么做，是的，我同意，是的，好的

01:27:20.500 --> 01:27:27.790
然后对了，所以我在这里放了一些资源，有些人可能你知道我们

01:27:27.790 --> 01:27:33.910
稍后可能想看看，有一种混合的ICN方法，它也是一种

01:27:33.910 --> 01:27:38.920
活跃的项目，可能值得一看当前开发的sping

01:27:38.920 --> 01:27:42.520
在思科，这不是一个死项目，在某个时候没有完成，这是一个开放的过程

01:27:42.520 --> 01:27:47.770
思科的源项目，为什么在那里发生了他们正在做的事情

01:27:47.770 --> 01:27:52.630
他们正在分配自己的穿衣内容块或内容项

01:27:52.630 --> 01:27:59.020
带有ipv6地址，因此除ipv6地址外，每个项目都会获得IP BC

01:27:59.020 --> 01:28:04.060
这就是他们的种类，他们对数据包也很感兴趣

01:28:04.060 --> 01:28:08.800
大小几乎一样，只是命名很

01:28:08.800 --> 01:28:15.340
与众不同，同时关注代码是一件非常有趣的事情

01:28:15.340 --> 01:28:20.170
这些链接的这些开源目前我认为这仅仅是思科

01:28:20.170 --> 01:28:26.260
一部分人正在发展这一点，实际上我们是同事

01:28:26.260 --> 01:28:30.850
我们一起在同一个项目上工作，但我有他们只是

01:28:30.850 --> 01:28:39.280
发布了他们正在做的新版本，然后在模拟工具中

01:28:39.280 --> 01:28:43.989
莫莉（Molly）关于测量的建议的最重要的部分，您知道尝试寻找

01:28:43.989 --> 01:28:48.580
进行测量我认为有趣的另一件事是尝试

01:28:48.580 --> 01:28:53.440
找到仿真工具，所以我们有例如数据模拟器

01:28:53.440 --> 01:28:59.830
基本上是一个缓存模拟器，我们拥有房地产，我的意思是已经有好几年了，

01:28:59.830 --> 01:29:06.940
开发他们的主要人有一些可行性

01:29:06.940 --> 01:29:12.610
感动了，我知道他们一直在快速使用模拟器，因此

01:29:12.610 --> 01:29:19.449
它已经过开发和维护，这是您可能知道得到的东西

01:29:19.449 --> 01:29:25.989
数据作为输入并预测什么，然后性能将像

01:29:25.989 --> 01:29:32.320
输出，所以在发布之前，我知道角色是他在为此工作，并且非常

01:29:32.320 --> 01:29:39.730
有趣，所以我的意思是其中一些可能是那些牙科Ducker模拟器

01:29:39.730 --> 01:29:45.880
NS 3，它在关系3中起作用，所以我们实际上在这里做了

01:29:45.880 --> 01:29:52.810
您是否获得了上帝发布的FSA的Docker版本，并把它放进去了

01:29:52.810 --> 01:29:57.550
进入NS三个模拟器，然后无论脚本还是网络

01:29:57.550 --> 01:30:03.600
您想在很大的3D空间中运行的拓扑，并且您知道模拟器

01:30:03.600 --> 01:30:08.199
许多特性，因此您可以基于以下内容获得相当逼真的拓扑

01:30:08.199 --> 01:30:13.030
生产代码没有基于生产代码的拓扑性能，因此可以正常工作

01:30:13.030 --> 01:30:21.670
在这种情况下可能看起来很有趣，是的，所以有一些

01:30:21.670 --> 01:30:27.820
是的，我主要是想说一些想法，但主要是

01:30:27.820 --> 01:30:33.130
事情是你知道我这些讨论的结果应该是你知道吗

01:30:33.130 --> 01:30:37.780
我们可以借用一些有趣的东西吗？

01:30:37.780 --> 01:30:44.020
在知道分配像大资源这样的资源之前先思考

01:30:44.020 --> 01:30:50.380
认为我们应该并且可以让您知道后续的在线讨论

01:30:50.380 --> 01:30:55.330
或物理会议，您知道我们从中挑选了一些东西

01:30:55.330 --> 01:31:04.090
我们今天讨论的内容，看看您知道我们可以考虑的内容，因此在我的

01:31:04.090 --> 01:31:10.390
正如我所说的那样，某些结构或某些结构的拓扑嵌入

01:31:10.390 --> 01:31:14.949
节点是否会大大提高性能

01:31:14.949 --> 01:31:20.889
通过畜栏技术或其他我不知道的技术，但我认为

01:31:20.889 --> 01:31:26.559
系统移动，您知道交货延迟将要开始

01:31:26.559 --> 01:31:31.479
成为一个问题，也许现在可能不在五年之内，但是您知道系统是否

01:31:31.479 --> 01:31:38.409
应该是CDN的一种内容传递网络，这些方法

01:31:38.409 --> 01:31:44.320
伙计们做了疯狂的事情，为了更接近那个表现

01:31:44.320 --> 01:31:51.610
您知道整个系统中需要一些拓扑结构，而不能缺少

01:31:51.610 --> 01:31:58.059
命名我不是在说系统中的内容，所以这些可以根据

01:31:58.059 --> 01:32:04.329
基于某些名称基于某些名称的路由，而不是仅基于名称解析的路由

01:32:04.329 --> 01:32:10.449
进行路由，以便某些节点可以跟踪本地缓存的内容

01:32:10.449 --> 01:32:16.840
在流行之前先重定向本地节点，然后再重定向

01:32:16.840 --> 01:32:22.479
达到DHD，我认为这也是可以利用的巨大优势

01:32:22.479 --> 01:32:29.349
这种兴趣，然后就像我们刚才所说的，路由和信任基本上是这样

01:32:29.349 --> 01:32:33.550
你怎么做的所有这一切哦，他们都假设有一个漂亮的孩子

01:32:33.550 --> 01:32:37.479
我们在盒子里放了一些软件，然后这样做，我们相信它确实可以

01:32:37.479 --> 01:32:47.489
因此，如果我们取消信任，那么对于那些人，还需要采取其他措施

01:32:47.489 --> 01:32:55.510
是的，吉姆，是我为基于名称的想法而想做的一件事

01:32:55.510 --> 01:33:01.479
东西是我们实际上确实在IP NS中做了一些基于名称的东西，对，您可以吗

01:33:01.479 --> 01:33:10.899
可以使用DNS名称，然后将其解析为IP NS密钥，然后

01:33:10.899 --> 01:33:17.769
曾经在DHT中查找，但好像我们不是，我们只是在使用那个

01:33:17.769 --> 01:33:23.709
在DNS查找的解析过程中，然后将其丢弃，或者

01:33:23.709 --> 01:33:32.199
并没有把它扔掉，我们实际上是在使用Dean有，我认为

01:33:32.199 --> 01:33:35.710
这个地方，接下来我想看看更多

01:33:35.710 --> 01:33:41.290
紧密连接到您的IP NS中，并且有一个线程或DNS链接占用了

01:33:41.290 --> 01:33:46.150
在那里的XD可能会停留更长的时间，或者可能还有其他一些元数据

01:33:46.150 --> 01:33:52.840
可以保留或以其他方式提供帮助的信息，但是很好

01:33:52.840 --> 01:33:55.080
观点

01:33:58.650 --> 01:34:05.200
与此类似的一点是，我们不使用这些IP和查询

01:34:05.200 --> 01:34:10.810
很多时候就像只有网站容易使用的用途

01:34:10.810 --> 01:34:20.920
是的，所以我们不是因为它是可变的，所以我们希望具有不变性，这很酷

01:34:20.920 --> 01:34:29.140
是的，太好了，是的，我在这里提出了一些想法，主要是

01:34:29.140 --> 01:34:33.190
内容生命周期的三个部分，所以一个是内容发布

01:34:33.190 --> 01:34:38.020
关于如何提供，如何提供

01:34:38.020 --> 01:34:42.670
记录您如何基本上在注册内容中发布，然后有一个内容

01:34:42.670 --> 01:34:47.860
存储是可以的五点存储市场，然后需要

01:34:47.860 --> 01:34:52.960
相信我不知道，但最终也需要及时交货

01:34:52.960 --> 01:35:01.500
因此需要提供内容，但要保持一定的隔离，以保证某些内容的有效性

01:35:01.500 --> 01:35:06.430
很冷或服务水平很高，因此在内容发布方面

01:35:06.430 --> 01:35:10.630
上周某个时候与史蒂芬（Steven）简要讨论过的内容，或者

01:35:10.630 --> 01:35:15.640
在我看来，他开始的一周之前，缓存是不同的存储，所以

01:35:15.640 --> 01:35:19.060
说某人正在存储东西而这将是不同的

01:35:19.060 --> 01:35:23.500
在那里呆了更长的时间，你知道它会变得不可用

01:35:23.500 --> 01:35:27.580
你知道克里斯蒂（Christy）是否外出而且与众不同，你所拥有的是

01:35:27.580 --> 01:35:32.160
缓存并且不稳定，因为它们会抛出很多东西

01:35:32.160 --> 01:35:40.590
所以我认为这需要反映在某种节点类的东西上

01:35:40.590 --> 01:35:45.250
有一些不稳定的缓存节点有一些缓存节点

01:35:45.250 --> 01:35:49.850
这是稳定的，然后实际上是存储内容

01:35:49.850 --> 01:35:58.510
为了使您知道，实际上需要有一些技巧

01:35:58.510 --> 01:36:04.640
测量网络中节点的参与程度，从而进行分配

01:36:04.640 --> 01:36:11.090
他们或建立某种声誉，你知道他们被分配在一个

01:36:11.090 --> 01:36:18.710
这些类别，然后我们如何实际为您提供记录

01:36:18.710 --> 01:36:24.950
知道我有此内容缓存，这是完全不同的事情，并且有

01:36:24.950 --> 01:36:30.770
有趣的技巧，说您知道基本上可以估计何时进行操作

01:36:30.770 --> 01:36:37.460
节点开始兑现，自那时以来已经花费了多少时间

01:36:37.460 --> 01:36:42.320
可以从概率上推断出是否仍存在某些内容

01:36:42.320 --> 01:36:46.550
显示它已过期并且此Alice已被推出缓存

01:36:46.550 --> 01:36:51.680
你知道我们可以假设而不必提供发送记录

01:36:51.680 --> 01:36:57.010
我们一直可以尽可能地知道是否

01:36:57.010 --> 01:37:04.670
是否与某个节点联系，那么它就是您必须知道的内容存储

01:37:04.670 --> 01:37:09.380
可靠且可用，并且基本上需要智能复制，因此

01:37:09.380 --> 01:37:13.880
内容展示位置必须智能，以便您知道我何时

01:37:13.880 --> 01:37:20.990
在这里接收一些其他内容，我们需要一种机制来查看它是否

01:37:20.990 --> 01:37:25.460
将此内容复制到附近的其他节点很有意义，因为

01:37:25.460 --> 01:37:30.040
您知道我可能会从网络中消失，但是此内容可能会变成

01:37:30.040 --> 01:37:35.180
突然流行起来，因此最好将它放在某个地方

01:37:35.180 --> 01:37:40.400
并能够如此识别它，以便为其他用户提供其他内容

01:37:40.400 --> 01:37:45.380
你知道而不必去追求DHD并必须解决梳子

01:37:45.380 --> 01:37:52.250
还是从头开始，然后您当然知道内容的交付

01:37:52.250 --> 01:37:56.720
他是另一个棘手的问题，但我想这是计划中的一点

01:37:56.720 --> 01:38:05.780
进一步，面向未来，是的，这样的设计建议

01:38:05.780 --> 01:38:10.850
我确定我已经在github页面中看到了其中的一些内容

01:38:10.850 --> 01:38:17.630
将其放在一张或两张幻灯片中，不是每个客户都应该

01:38:17.630 --> 01:38:23.210
提供路由信息时，应该有一个网关节点或入口节点

01:38:23.210 --> 01:38:30.350
或者，如果您不知道我们首先信任哪个，然后这些就坐了

01:38:30.350 --> 01:38:39.110
在DHD之前，以便我们可以解析本地有效的内容

01:38:39.110 --> 01:38:46.040
通过多然后多层DHT方法显然提供了指针

01:38:46.040 --> 01:38:51.560
服务而不是静态内容，这归结为

01:38:51.560 --> 01:38:57.920
我把桌子放在一起的可怕数字，但是如果要点是

01:38:57.920 --> 01:39:02.570
您在这里有客户，并且在这个本地门口，还有其他任何地方

01:39:02.570 --> 01:39:09.080
我们想要整理的事情您知道它是否保持不变，如果此网关在此处保持

01:39:09.080 --> 01:39:14.000
其他客户提出的请求的索引可以在本地解决

01:39:14.000 --> 01:39:19.490
甚至没有碰到那里的本地DHT，然后如果没有东西

01:39:19.490 --> 01:39:22.970
显然，你需要去神灵，这可能是不同层次的

01:39:22.970 --> 01:39:26.870
HDS，但您知道他有一个节点

01:39:26.870 --> 01:39:33.050
基本上附在几个不同的页面上，这让你知道

01:39:33.050 --> 01:39:40.400
延迟在这里或那里指向不同的水平，这是您不希望达到的最低水平

01:39:40.400 --> 01:39:43.610
必须去到地球的另一边才能获得指向

01:39:43.610 --> 01:39:48.650
神，你需要走得如此身体，这是一台机器，只是保持

01:39:48.650 --> 01:39:53.060
索引是两个不同的东西，下面是你知道不是因为他是

01:39:53.060 --> 01:39:59.930
在进入DHD之前，不要像在表中那样保留索引，因此结构

01:39:59.930 --> 01:40:05.270
像这样，我认为从长远来看，您是否应该知道

01:40:05.270 --> 01:40:10.910
考虑过，当然他是信任权的问题，所以我不会忘记

01:40:10.910 --> 01:40:17.420
是的，是的，当然，我的设计

01:40:17.420 --> 01:40:23.120
思考取决于期望的结果，如果我们不这样做，它会更快吗？

01:40:23.120 --> 01:40:28.310
尝试将p2p设为更快的CDN网络，然后您就知道需要

01:40:28.310 --> 01:40:34.070
正如我说过的，您需要做很多工作，如果CDN系统

01:40:34.070 --> 01:40:40.040
一个永久性的，您知道存储和备份网络，那么您就知道一个

01:40:40.040 --> 01:40:45.440
或一些类似的东西，然后我认为目标就在那里，这是完全的

01:40:45.440 --> 01:40:51.470
很好，是的，您可能已经注意到，我没有提到安全一词，

01:40:51.470 --> 01:40:57.890
隐私过多，但这当然是必须存在的，并且

01:40:57.890 --> 01:41:02.900
有相关的工作，我知道崩溃中的其他人已经

01:41:02.900 --> 01:41:08.450
只是我决定你知道要把它排除在主题之外

01:41:08.450 --> 01:41:16.370
如果我们愿意，可以参加另一个会议，如果您睡着了，实际上可以，我不愿意

01:41:16.370 --> 01:41:23.720
知道现在该醒了，是的，还有其他问题和反馈

01:41:23.720 --> 01:41:30.820
乔治目前将发送或已发送的此反馈表是

01:41:30.820 --> 01:41:35.300
但是，是的，现在有任何反馈

01:41:35.300 --> 01:41:41.420
稍后，是的，是的，非常感谢你，我真的很喜欢

01:41:41.420 --> 01:41:45.740
回顾很多这些概念，例如提醒我很多我曾经在做的事情

01:41:45.740 --> 01:41:51.190
喜欢学习新事物，非常感谢您组织这次活动

01:41:52.570 --> 01:41:59.180
绝对失去兴趣是是很棒很棒所以我有一堆

01:41:59.180 --> 01:42:06.320
想到我会选择喜欢的那个就是和你一样

01:42:06.320 --> 01:42:09.830
有点像您最后需要的东西，在我看来，就像

01:42:09.830 --> 01:42:13.670
这两个社区要么很快就消失了，现在我消失了，所以他们

01:42:13.670 --> 01:42:19.420
命名数据网络，甚至像DHT研究一样，都是这样

01:42:19.420 --> 01:42:24.080
信念或希望找到一个适合所有DHT的尺寸

01:42:24.080 --> 01:42:28.099
即使是多层或类似群集的EHT也没关系

01:42:28.099 --> 01:42:33.709
就像我们总是像在存储数据存储一样发推文

01:42:33.709 --> 01:42:39.139
在现实中就像是数据访问一样会产生数据库问题，所以让我们来看看

01:42:39.139 --> 01:42:43.879
这样的发布问题，就像我在这里看到缺少的东西，然后我

01:42:43.879 --> 01:42:48.829
希望您像您知道一些工作，或者像我一样已经完成了

01:42:48.829 --> 01:42:54.469
我只是不知道这就像我们创建时如何分辨

01:42:54.469 --> 01:42:59.239
数据我们该如何用数据本身进行描述，就像应该如何

01:42:59.239 --> 01:43:03.139
被访问，所以我想像一个博客，也许每周都有一个博客帖子，所以

01:43:03.139 --> 01:43:07.039
像用户不应该像每秒解决高清记录一样，因为他们

01:43:07.039 --> 01:43:12.919
他们可能不会或或者作为用户想要我想要的某些数据

01:43:12.919 --> 01:43:18.199
访问数据，但我希望我的访问权限是私有的，所以我想选择其他数据

01:43:18.199 --> 01:43:23.769
鉴于可用的资源类型，各种机制使我能够做到这一点

01:43:23.769 --> 01:43:33.919
是否有任何朝着方向或正确方向的工作，所以这与某些工作非常接近

01:43:33.919 --> 01:43:42.039
我过去曾经有过自己，但在很遥远的过去却没有，

01:43:42.039 --> 01:43:50.629
那就是您知道每条内容都带有一些元数据，

01:43:50.629 --> 01:43:55.489
这些是您是否知道这是每分钟更新一次的博客文章，然后这些

01:43:55.489 --> 01:44:01.489
听过的RT喂我的网页，这里有数据碎片，那么如果

01:44:01.489 --> 01:44:05.179
甚至说这是一些个人信息

01:44:05.179 --> 01:44:10.429
在我的可穿戴设备中，我想保持完全私密和完全

01:44:10.429 --> 01:44:15.530
加密并仅授予我的医生访问权限，没有人甚至没有我的访问权限

01:44:15.530 --> 01:44:19.789
家庭或其他人，那么这些人需要具有完全不同的属性

01:44:19.789 --> 01:44:31.069
是的，所以我完全同意你的意思。

01:44:31.069 --> 01:44:39.700
一种支持这一点的体系结构，但是最近已经有一些方法

01:44:39.700 --> 01:44:45.940
您知道您会附加元数据数据，这就是实现

01:44:45.940 --> 01:44:50.440
可以解决整个互联网问题的几件事

01:44:50.440 --> 01:44:58.090
不太确定，但我同意有人可以很好地指导

01:44:58.090 --> 01:45:01.810
看着我真的很想知道这是否是一个问题

01:45:01.810 --> 01:45:06.250
不仅可以像使用ml这样的AI这样来解决，因为

01:45:06.250 --> 01:45:10.210
我们谈论的是这么多的变量和那么多的选择，以至于您

01:45:10.210 --> 01:45:14.290
实际上将需要一些帮助，例如实际上选择正确的路径

01:45:14.290 --> 01:45:21.540
就像您将发布某些内容或访问某些内容一样，是的，很酷

01:45:21.540 --> 01:45:37.240
好的，这是一个单独的问题，但是这项研究很多

01:45:37.240 --> 01:45:40.930
和喜欢，我一直在关注诸如组播之类的事情

01:45:40.930 --> 01:45:45.280
从80年代开始，他们真的起飞了，我觉得其中有些东西

01:45:45.280 --> 01:45:50.560
就像技术更有效率或想法更多

01:45:50.560 --> 01:45:54.750
高效，但与艺术家等现有的业务模型不兼容

01:45:54.750 --> 01:45:59.530
倾向于卖出超额认购，他们不将存储或鱿鱼缓存放入或

01:45:59.530 --> 01:46:05.140
可以改善体验的任何东西CD端可以改善体验

01:46:05.140 --> 01:46:09.280
拥有独立的商业模式，发布商或谷歌等公司付费

01:46:09.280 --> 01:46:15.940
因此，当前的环境有利于大型的大型公司，例如

01:46:15.940 --> 01:46:20.500
谷歌和亚马逊，所以没有那么丰富的动机或没有太多

01:46:20.500 --> 01:46:25.750
可以赚到的利润我们正处在与您一样的ispeed水平上

01:46:25.750 --> 01:46:32.290
昂贵的Cisco路由器，我的意思是，我同意这是一个非常重要的讨论，

01:46:32.290 --> 01:46:41.560
这主要是业务问题，所以我说可以解决更多的问题

01:46:41.560 --> 01:46:47.140
这不仅是关于存储的问题，而且还成为

01:46:47.140 --> 01:46:52.480
再次信任，因为他们想知道的内容提供商

01:46:52.480 --> 01:46:57.330
他们的内容获得了多少点击，他们并不一定

01:46:57.330 --> 01:47:02.680
相信ISP他们会提供记录以表明您有

01:47:02.680 --> 01:47:08.380
即使在您信任的情况下，也可以在每年的这个时候在一天的这个时间获得多次点击

01:47:08.380 --> 01:47:12.900
您当地的ISP或您不一定信任的某人

01:47:12.900 --> 01:47:18.700
就在10,000英里之外

01:47:18.700 --> 01:47:26.020
从根本上说，缓存是一件大事，但是并没有那么多

01:47:26.020 --> 01:47:28.720
尽其所能，然后有一家大型CDN公司

01:47:28.720 --> 01:47:34.989
那来了，每个人都信任他们，这就是为什么他们向您提供内容的原因

01:47:34.989 --> 01:47:41.170
它们现在具有类似您所知道的永久名称和名称数据的结构

01:47:41.170 --> 01:47:45.910
正确做起来容易得多，因为您可以证明

01:47:45.910 --> 01:47:50.950
已经请求了某些内容，然后转发了该内容，如果有人在询问

01:47:50.950 --> 01:47:55.300
因为那个名字叫那个名字，这无法改变，你知道，你

01:47:55.300 --> 01:48:00.840
基本上不需要任何dpi或您可以知道的任何内容

01:48:00.840 --> 01:48:10.510
但它完全同意商业模式问题，是的，现在的事情是

01:48:10.510 --> 01:48:17.560
是的，还有一个问题，就像这些测试垫的规模和

01:48:17.560 --> 01:48:29.920
他们喜欢他们的可用性了解和测试喜欢是多么容易

01:48:29.920 --> 01:48:35.590
所有这些项目都是从您的经验中得出的

01:48:35.590 --> 01:48:39.940
例如，如果我们想尝试其中一些项目，就会存在摩擦

01:48:39.940 --> 01:48:43.330
只是为了我们自己还是喜欢尝试检查他们的测试，以便我们

01:48:43.330 --> 01:48:47.110
可以共享统计数据并进行比较，就像我们要发展您的同龄人一样

01:48:47.110 --> 01:48:52.780
在分辨率等方面与这些项目中的某些项目进行比较的基准

01:48:52.780 --> 01:49:01.870
等等，是的，我们可用的是那些，所以有很多，我

01:49:01.870 --> 01:49:06.039
谈论的主要是结局

01:49:06.039 --> 01:49:12.999
活着的物体，有一张病床，一切都可以

01:49:12.999 --> 01:49:17.619
可以比较它们，可以衡量它们对任何人都非常开放

01:49:17.619 --> 01:49:24.039
新用户，任何新的协作或任何新的测试，所以我知道

01:49:24.039 --> 01:49:30.010
那边是的，一切都很好，例如NetBeans项目

01:49:30.010 --> 01:49:34.479
不再运行了，我知道有一个原型，我知道有一个测试台

01:49:34.479 --> 01:49:40.329
某种形式，并且肯定有开放源代码，我不认为

01:49:40.329 --> 01:49:44.499
它已经维护了，但是事实是我们可以获取代码并进行部署

01:49:44.499 --> 01:49:51.569
在可以完成的测试中，我不仅有一个地方，所以我要检查一下

01:49:51.569 --> 01:49:58.629
和他们一起看看代码在哪里，是的，就像我说的那样

01:49:58.629 --> 01:50:03.159
捐助者的东西是捐助者的体系结构是纸，所以可能会有一些指导

01:50:03.159 --> 01:50:08.289
甚至还有一些github仓库的文件，但那从来不是你真正的

01:50:08.289 --> 01:50:15.849
知道它从来没有像一个大项目那样增长是的，是的，是的，我想要

01:50:15.849 --> 01:50:19.780
提及添加到珠子的想法，我们可以多少

01:50:19.780 --> 01:50:24.669
实际评估我们可能会使用，您知道我认为这是一个基本

01:50:24.669 --> 01:50:30.159
这些项目试图解决的问题与

01:50:30.159 --> 01:50:35.530
他们实际看到的那片土地是可以解决的

01:50:35.530 --> 01:50:41.219
相对于我们尝试做的事情，我们天生就是点对点的，所以这些

01:50:41.219 --> 01:50:46.809
项目实际上是在假设互联网将被重塑，

01:50:46.809 --> 01:50:51.369
将需要非常强大的演员进行积极的协作，所以我

01:50:51.369 --> 01:50:58.059
我认为这是非常糟糕的使命，这真是太好了，我想

01:50:58.059 --> 01:51:03.039
为了保持实用性，我想说的是让我们尝试了解

01:51:03.039 --> 01:51:08.559
这些项目，尤其是您知道的问题解决方案，范围很紧

01:51:08.559 --> 01:51:12.909
解决方案可以解决您实际上已经知道的特定问题领域

01:51:12.909 --> 01:51:17.789
部署或提议，建模或模拟等

01:51:17.789 --> 01:51:23.429
尝试将其作为灵感，而不是尝试不复制或

01:51:23.429 --> 01:51:28.469
甚至考虑更深层次的考虑，因为我们尝试

01:51:28.469 --> 01:51:33.179
要做的是根本不同的雅知道，以保持像超级实用

01:51:33.179 --> 01:51:39.030
就像我们将这些项目切成小方块，将它们切成小块，以了解

01:51:39.030 --> 01:51:44.699
他们了解我们可以从中获得灵感并可能使用的零件

01:51:44.699 --> 01:51:52.500
作为对我们研究过程的投入，是的，我同意，这都是基于

01:51:52.500 --> 01:52:04.260
就像我们首先要思考的方式一样

01:52:04.260 --> 01:52:09.059
是的，我认为您举起了Dean和Davina的事，哦，好吧，让我

01:52:09.059 --> 01:52:13.320
赶快介入，请大家继续讨论，但万一您

01:52:13.320 --> 01:52:18.989
还没有看到聊天的方式，如果我们能在这里聊天，我们将不胜感激

01:52:18.989 --> 01:52:24.300
可以在通话结束时立即回答，但现在我认为Kadeem是

01:52:24.300 --> 01:52:32.820
下一步是的，所以只是想一想你在说什么

01:52:32.820 --> 01:52:37.349
多级DHT内容以及vid对您所知道的某些内容的评论

01:52:37.349 --> 01:52:43.500
机器学习类型的方法，以帮助您将这些事情绘制出来并给出

01:52:43.500 --> 01:52:47.579
让你想起来像呃，你知道数学家只知道像三个

01:52:47.579 --> 01:52:55.829
数字中存在大于零的零一，依此类推，当您拥有

01:52:55.829 --> 01:52:59.760
就像是固定数量的赞，但是如果多个级别都像固定一样

01:52:59.760 --> 01:53:04.860
反对像这样的我不知道继续像这样的频谱

01:53:04.860 --> 01:53:10.260
就像成长，就像在观看时有两种截然不同的方式

01:53:10.260 --> 01:53:14.280
感觉像连续不断增长的DHT基本上是连续的

01:53:14.280 --> 01:53:19.349
只是一个系统，而多级系统就像您故意设计的那样

01:53:19.349 --> 01:53:25.679
因为多层次的做了多层次的事情就像

01:53:25.679 --> 01:53:30.230
离散的，就像你认为那里的优势

01:53:32.040 --> 01:53:39.130
因此，我认为那里的优势在于，我们基本上在您进入时

01:53:39.130 --> 01:53:45.250
为了使您所指向的下一个点可能太远而使该环响了

01:53:45.250 --> 01:53:48.520
远离那些结和诸如此类的东西

01:53:48.520 --> 01:53:56.080
甚至这些都可以很远的地方，所以有时间去那里然后去

01:53:56.080 --> 01:53:59.410
下一个，然后转到下一个，直到您达到了

01:53:59.410 --> 01:54:05.380
您知道的本地节点会收到一条注释，该注释知道您的内容在哪里

01:54:05.380 --> 01:54:13.290
就分辨率而言，您正在查看的内容可能会很长

01:54:13.290 --> 01:54:18.250
我喜欢绕环，然后注意要引导自己的音符

01:54:18.250 --> 01:54:25.960
可能也太远了，那就是内容交付开始正确的时候

01:54:25.960 --> 01:54:32.140
您必须经历一个可能很长的时间，而您可能会从其他途径知道

01:54:32.140 --> 01:54:42.219
大陆，所以如果有一个更小的ADHD概念正在注册

01:54:42.219 --> 01:54:51.900
本地内容，那么您就会知道感兴趣的地方，并且可以

01:54:51.900 --> 01:54:56.440
通过在同一大都市中查找内容来利用您所知道的

01:54:56.440 --> 01:55:02.410
区域，而不必一路前往日本返回并发现

01:55:02.410 --> 01:55:09.870
如果您明白我的意思，这里的内容就在这里，但是您可以像

01:55:09.870 --> 01:55:16.180
就像远跳一样，所以走廊上有延伸部分，而不是

01:55:16.180 --> 01:55:21.910
只需在关键空间中遍及整个网络，您还可以

01:55:21.910 --> 01:55:25.449
喜欢离您更近的人，并且您会破坏网络

01:55:25.449 --> 01:55:29.320
分成两半，四分之一和八分之一，是的，您可以通过延迟来做到这一点，

01:55:29.320 --> 01:55:33.219
像我一样，我要把我的大部分桌子都塞满附近的人，我会

01:55:33.219 --> 01:55:40.390
感觉有人与远方的人没事吧，是的，是的，我是说

01:55:40.390 --> 01:55:43.890
可以做到，我真的必须更仔细地研究

01:55:43.890 --> 01:55:49.500
核心设计，因为自上次注册以来已经有好几年了，我的意思是

01:55:49.500 --> 01:55:58.320
怎么做的细节，但是我从人们那里知道是的，是的，好的，好的

01:55:58.320 --> 01:56:10.110
是的，是的，是的，劳尔拥有机器，是的，其他人我不能

01:56:10.110 --> 01:56:16.530
看到我每个人，我都可以举手，但是我确实很快

01:56:16.530 --> 01:56:27.500
问题似乎就像缓存一样，并且像重做很多网络一样

01:56:27.500 --> 01:56:33.090
命名它，喜欢或喜欢以信息为中心的网络之类的作品似乎

01:56:33.090 --> 01:56:38.970
在某些方面违反最终原则，那么哪个原则

01:56:38.970 --> 01:56:44.790
端到端原则对，是的，这种冲突在讨论中如何体现

01:56:44.790 --> 01:56:52.680
围绕这些项目，例如在IETF内或在大型团体中，

01:56:52.680 --> 01:56:58.290
对互联网有很多控制权好像是这样

01:56:58.290 --> 01:57:02.340
承认就像它可能真的很有趣，就像一个小像

01:57:02.340 --> 01:57:05.160
可能的替代方案以及将来的方式，但我们不会考虑

01:57:05.160 --> 01:57:07.500
人们真的会只是想念这个吗

01:57:07.500 --> 01:57:13.920
努力还是人们普遍同意，这样做会是一件好事，但这确实是一件好事。

01:57:13.920 --> 01:57:21.000
一定有问题，是的，所以最近有讨论说

01:57:21.000 --> 01:57:25.380
你知道互联网服务已经足够整合了，那不是很好

01:57:25.380 --> 01:57:31.800
事情必须改变，那里还没有什么大动作

01:57:31.800 --> 01:57:35.670
就是说有些人我们谈论的是大约10个人

01:57:35.670 --> 01:57:41.190
多年前在IETF或某些会议上，但还没有

01:57:41.190 --> 01:57:51.150
从根本上说，实际上我所做的一切都是如此，是的，我认为他的讨论

01:57:51.150 --> 01:57:56.160
现在开始，我们需要看看这些新协议

01:57:56.160 --> 01:58:03.300
堆栈您如何知道内容可寻址系统对我们有帮助还是无济于事

01:58:03.300 --> 01:58:11.040
在某些情况下，是的，你能说说这段对话的原因吗？

01:58:11.040 --> 01:58:16.200
现在开始是因为他们好像并没有将它与业务联系在一起

01:58:16.200 --> 01:58:21.270
像谁为这类事情付费的类型的应用程序是

01:58:21.270 --> 01:58:24.180
感兴趣，或者有明确的财务激励措施，还是有一些

01:58:24.180 --> 01:58:29.520
我不知道只是人们醒来的另一个原因是隐私问题，这是

01:58:29.520 --> 01:58:35.580
大约是时间了，是的，但是是的，我要说的是

01:58:35.580 --> 01:58:39.870
试图与人们谈论这些事情很多年了，但是那是

01:58:39.870 --> 01:58:43.680
所有人都会来的，你知道次要的事情，并且人们希望改善

01:58:43.680 --> 01:58:48.600
性能以及其他，您知道您最终会获得诸如VPN之类的解决方案

01:58:48.600 --> 01:58:52.860
而且你是说好吧，我不在乎是否有更多的隐私延迟，所以

01:58:52.860 --> 01:58:57.360
扔掉了某人试图去掉的所有表演东西

01:58:57.360 --> 01:59:01.400
因为我不在乎你知道喜欢

01:59:02.600 --> 01:59:08.270
史蒂文·我不是说这有助于改善天线原理，因为

01:59:08.270 --> 01:59:12.330
目前，为了使您想要HTTP的解释杆，我们已经

01:59:12.330 --> 01:59:17.250
必须在HTTP上分层，这是绝对的，它可以防止任何和所有缓存，是的，但是

01:59:17.250 --> 01:59:21.120
这实际上就像端点实际上就像下一个路由器一样，然后

01:59:21.120 --> 01:59:25.020
他们在点上是下一个路由器，所以点对点仍然像您一样

01:59:25.020 --> 01:59:30.060
可能具有加密或安全的连接，但就像您不是一样

01:59:30.060 --> 01:59:34.220
我在乎我是哪个，这是放进去的最好方法

01:59:34.220 --> 01:59:39.210
在隐私方面，您可以获取隐私，这是通过加密实现的，但是

01:59:39.210 --> 01:59:43.200
只有那样，您才能像在这里一样获得一些隐私

01:59:43.200 --> 01:59:47.400
诸如内容路由之类的问题，以及中间人将进入

01:59:47.400 --> 01:59:53.550
知道你在找什么，是的，是的，是的，是的，

01:59:53.550 --> 01:59:56.940
您需要我想说的那些东西，特别是因为有时不需要

01:59:56.940 --> 02:00:01.850
有时您知道您知道这些案件名称必须是唯一且永久的

02:00:01.850 --> 02:00:07.230
这意味着您知道路透社或他是谁

02:00:07.230 --> 02:00:12.930
t确切地知道您要转发的内容，因此在网络方面

02:00:12.930 --> 02:00:17.510
中立性以及您所知道的所有基本信息实际上是不存在的

02:00:17.510 --> 02:00:25.500
您知道您甚至不必进行数据包检查即可

02:00:25.500 --> 02:00:31.650
看那个包里有什么，这是我不知道的另一件事

02:00:31.650 --> 02:00:52.020
我有一点，但是没关系，还有更多的想法和问题，好吧，

02:00:52.020 --> 02:01:08.550
好多人，​​好吧，所以有这份调查表对

02:01:08.550 --> 02:01:18.960
得到一些反馈是的，但是如果没有其他人有任何问题，那么他们可以继续

02:01:18.960 --> 02:01:21.350
那个

02:01:22.280 --> 02:01:26.910
谢谢，我想我们很好，所以谢谢

02:01:26.910 --> 02:01:29.610
非常好吃，这真的很棒，谢谢

02:01:29.610 --> 02:01:34.110
大家都来了，我们真的很在乎反馈，所以希望您知道

02:01:34.110 --> 02:01:38.340
您想使用接下来的两分钟，这是一个简短的表格，这也将

02:01:38.340 --> 02:01:45.239
帮助我们计划B，您知道未来的远程维修人员会亲自参加，是的，我

02:01:45.239 --> 02:01:50.850
意思是周末过得很愉快，谢谢大家的到来，我希望

02:01:50.850 --> 02:01:54.720
您发现它对任何反馈或您认为值得的任何事情都很有用

02:01:54.720 --> 02:02:01.400
不管出于什么原因，只给我打个电话

