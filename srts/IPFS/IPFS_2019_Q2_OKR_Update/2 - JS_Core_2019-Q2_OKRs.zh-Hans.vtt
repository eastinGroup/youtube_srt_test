WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.800 --> 00:00:08.460
您好，这里的朋友是我们最快乐的最开心的四分之一的IPFS用户。

00:00:08.460 --> 00:00:12.719
课程既有趣又有趣，因此我们要做的是创建一个

00:00:12.719 --> 00:00:18.420
即将到来的ipfs训练营的几门课程，我们将做一门核心课程，

00:00:18.420 --> 00:00:23.310
选修课程，我们尚未决定内容，但我们

00:00:23.310 --> 00:00:28.680
要创建这两个，它们将很棒，所以第二步，我们要

00:00:28.680 --> 00:00:36.030
构建一些功能，这些功能将在ipfs营地提供最佳的ipfs体验，因此

00:00:36.030 --> 00:00:40.739
DHT排名第一的是Jess IP FSN，默认情况下，它们将在

00:00:40.739 --> 00:00:44.820
浏览器和Node.js，因此如果没有DHD，我们将受到限制

00:00:44.820 --> 00:00:48.570
能够在p2p网络中查找内容的能力，因此我们节省的任何希望

00:00:48.570 --> 00:00:52.680
从我们附近的同伴那里快速获取内容的带宽是

00:00:52.680 --> 00:00:56.760
受到严重阻碍，因此我们需要将其实施，这对于

00:00:56.760 --> 00:01:02.399
拥有非常好的IVF体验，实现了重要的API缺失

00:01:02.399 --> 00:01:08.610
想要实现repo GC和refs，所以基本上，如果我们要存储数据

00:01:08.610 --> 00:01:12.659
对于包管理器，我们需要能够固定它，以使其不会被删除

00:01:12.659 --> 00:01:19.530
而且我们还需要能够进行垃圾回收，所以当我们大量使用NFS时

00:01:19.530 --> 00:01:24.990
或者您知道获取内容以及最终没有填充的内容

00:01:24.990 --> 00:01:32.340
refs终结点必须存在于典型的FS处的死亡可能是

00:01:32.340 --> 00:01:37.759
预载节点本身，大约一秒钟

00:01:39.590 --> 00:01:45.329
dns协助以NS分辨率进行下一个IP传输以提高速度

00:01:45.329 --> 00:01:48.570
因此IP NS需要快速运行，而软件包管理器必须能够快速运行

00:01:48.570 --> 00:01:53.100
找出最新版本的存储库是IP NS的DNS hack

00:01:53.100 --> 00:01:58.920
分辨率将提供一种快速可靠的集中式方法，

00:01:58.920 --> 00:02:03.780
回退到我们当前使用的去中心化方法，以便

00:02:03.780 --> 00:02:08.080
会很酷，会更快，会很棒

00:02:08.080 --> 00:02:14.620
接下来的基础42个编码的对等ID可以与IP NS一起使用，这很酷，很需要

00:02:14.620 --> 00:02:21.070
允许网关上的两个可变内容都不会出现安全问题

00:02:21.070 --> 00:02:25.450
公共网关而不是共管公寓项目网关，如果我们是

00:02:25.450 --> 00:02:31.630
要从第58页过渡到第50页，以查看我们想要的ID

00:02:31.630 --> 00:02:34.510
发送消息，说明将来一切都将基于该消息进行投票

00:02:34.510 --> 00:02:42.880
因此，让我们以钢琴家开放性解决方案来支持他们，可以解决IP NS rip

00:02:42.880 --> 00:02:46.750
名称，我的意思是我说得通，目前我是ipfs

00:02:46.750 --> 00:02:52.150
解决它当前无法解析钢琴家的名字，这是必需的

00:02:52.150 --> 00:02:56.200
软件包管理器，以便他们可以找出最新版本的注册表

00:02:56.200 --> 00:03:04.350
我已经说过了，是的，因此下一个核心api会受到影响以使用异步

00:03:04.350 --> 00:03:09.190
迭代器和异步正在等待，并且至少有四分之三的收割者在范围内

00:03:09.190 --> 00:03:16.360
有建议或请求，因此这是一项持续不断的工作，

00:03:16.360 --> 00:03:20.410
影响那种性能可维护性的开发人员的经验吧

00:03:20.410 --> 00:03:28.930
涉及整个Jess Jess核心团队，我们最终将成为一个真正的

00:03:28.930 --> 00:03:36.000
不错的JavaScript为ipfs用户提供了不错的开发人员体验

00:03:36.000 --> 00:03:41.890
Jess IVF在生产环境中自我支持，因此这是关于

00:03:41.890 --> 00:03:48.130
Jess IVF为生产做好了准备，过去我们一直在努力实现目标

00:03:48.130 --> 00:03:53.800
将JFS投入生产，但我们逐渐意识到，还有许多其他方面

00:03:53.800 --> 00:03:58.209
在我们真正得到JFS之前，需要对JFS中的内容进行调整和调整

00:03:58.209 --> 00:04:04.900
在那里，这将对希望有所帮助，所以我们有了GC

00:04:04.900 --> 00:04:10.959
存在策略来满足预加载节点的需求，因此目前在

00:04:10.959 --> 00:04:15.160
预载节点每小时大约有G种子的概念，这很好

00:04:15.160 --> 00:04:21.389
但是，如果仅在数量上加上您的数量的ipfs，那将是一个坏消息

00:04:21.389 --> 00:04:27.870
因此，更合适的GC策略可能就是删除see

00:04:27.870 --> 00:04:33.539
可能是一个多小时前添加的较旧的ID，所以这会

00:04:33.539 --> 00:04:38.909
让我们同时为之建立更好的策略

00:04:38.909 --> 00:04:47.430
总体上实施GC下一步是将性能基准测试网站与

00:04:47.430 --> 00:04:52.409
CI，我们已经有了性能基准测试网站

00:04:52.409 --> 00:04:55.889
需要一点点修复，但是如果我们能够测量我们的

00:04:55.889 --> 00:04:59.490
随着时间的流逝，我们需要一些可见性，而实际上我们需要

00:04:59.490 --> 00:05:03.270
挂接到CI，以便我们可以看到何时进行更改

00:05:03.270 --> 00:05:07.439
不管它们是否影响我们的表现，所以这只是一种

00:05:07.439 --> 00:05:15.629
简单的一个，下一个IVF会替换当前的IVFs预载节点，这样

00:05:15.629 --> 00:05:23.009
这是关于JSI PFS狗食本身，就像是

00:05:23.009 --> 00:05:27.629
让JJ的IVF充当网关节点，它应该在

00:05:27.629 --> 00:05:32.189
生产并成为公共预载节点之一，那么它应该是

00:05:32.189 --> 00:05:37.770
使用我们实施的这种新的GC策略，以便我们获得真正好的

00:05:37.770 --> 00:05:44.009
使用预载节点的人们的经验可以，接下来的目标添加和

00:05:44.009 --> 00:05:50.639
更新包监视的数据既简单又方便，所以首先

00:05:50.639 --> 00:05:57.870
结果的第一个关键是要存在ipfs的接收器以进行镜像

00:05:57.870 --> 00:06:05.520
软件包管理器的数据与ipfs一起工作，因此现在可以对软件包进行镜像

00:06:05.520 --> 00:06:11.279
ipfs生成管理器数据是不可能的，不能将文件存储到慢速文件中

00:06:11.279 --> 00:06:16.560
已更新且在J的IVF中不存在，就像Rhian移植的一切一样

00:06:16.560 --> 00:06:20.879
只是花费太长时间，并且需要两倍的磁盘空间

00:06:20.879 --> 00:06:25.469
它在磁盘上以及在您的IP FS存储库中，所以这不好，我们需要一些东西

00:06:25.469 --> 00:06:30.150
我们需要一个要求ipfs的工具或

00:06:30.150 --> 00:06:36.600
或ipfs与它们一起作为文件系统MF挂载，所以这是关键

00:06:36.600 --> 00:06:40.590
结果使工作正常进行，以便包管理人员可以实际添加人员

00:06:40.590 --> 00:06:46.770
并先将其更新为IP，然后再进行实验性的UNIX FS

00:06:46.770 --> 00:06:51.210
 Jes IVF中存在实现以允许将权限或元数据

00:06:51.210 --> 00:07:00.120
与文件一起存储，因此这就像我们需要上次修改的时间和文件

00:07:00.120 --> 00:07:04.740
诸如是否可执行文件之类的权限，在以下情况下将不保留

00:07:04.740 --> 00:07:11.880
我们在包管理器将数据添加到其仓库时添加数据，是的，这仅仅是

00:07:11.880 --> 00:07:17.550
该要求，并且将使用现有的UNIX FS系统，该系统使用

00:07:17.550 --> 00:07:22.260
我知道的元数据已经存在或正在实施或帮助中

00:07:22.260 --> 00:07:31.889
实现这一点，或者至少具有实验性的实现

00:07:31.889 --> 00:07:36.660
添加时，将现有的固定代码重构为不是瓶颈

00:07:36.660 --> 00:07:45.680
文件还可以，所以这是一种必要，我们尚未在ipfs的npm中见过

00:07:45.680 --> 00:07:52.590
实际固定东西的实验需要花费一段时间

00:07:52.590 --> 00:07:57.060
花费的时间太长，这是一个瓶颈，因此在npm上已被禁用

00:07:57.060 --> 00:08:01.080
ipfs没关系，因为GC还不存在

00:08:01.080 --> 00:08:07.949
所以我们需要做的是重构现有的固定代码，使其更快

00:08:07.949 --> 00:08:11.250
在添加文件时使其成为瓶颈，因为我们将要

00:08:11.250 --> 00:08:20.460
接下来，当程序包管理器正在使用JFS时，可以进行很多研究

00:08:20.460 --> 00:08:24.560
并创建一个证明概念以收集改进的网络

00:08:24.560 --> 00:08:29.789
关于规模和活动的内省指标，因此这相当简单

00:08:29.789 --> 00:08:34.650
并且通常是ipfs所需要的，因此

00:08:34.650 --> 00:08:39.330
我们可以弄清楚谁正在使用asana的IP，为什么以及有多少人和

00:08:39.330 --> 00:08:46.830
我们有什么样的覆盖范围，还有大象

00:08:46.830 --> 00:08:50.940
包管理者仍然需要度量是否

00:08:50.940 --> 00:08:54.600
即使已切换到分布式系统，其回购协议仍在使用中

00:08:54.600 --> 00:09:00.630
所以我们需要某种方式来收集信息，这很酷

00:09:00.630 --> 00:09:06.540
在不同环境中量身定制的下一次客观体验可实现最佳

00:09:06.540 --> 00:09:10.410
性能hooray是的，我们这样做还行，所以性能

00:09:10.410 --> 00:09:17.220
桌面浏览器服务器移动版存在配置文件，并且在测试中很酷，所以

00:09:17.220 --> 00:09:23.339
如果我们要在生产中运行Jaz IVF节点，则需要一个服务器配置文件

00:09:23.339 --> 00:09:28.410
将配置JSI PFS以使其像数据中心一样正常运行

00:09:28.410 --> 00:09:32.490
或意识到，如果我们要为此添加配置文件，那么我们可能会

00:09:32.490 --> 00:09:37.560
可能有一些缘故FS的地方有很多配置文件

00:09:37.560 --> 00:09:46.260
接下来可以使用一个回购迁移工具，并且Jase IVF可以

00:09:46.260 --> 00:09:51.330
自动升级旧的自己的存储库很酷，因此这对于获得J的IVF是必要的

00:09:51.330 --> 00:09:57.089
如果投入生产，我们仍然需要能够升级我们的存储库

00:09:57.089 --> 00:10:05.400
他们的布局更改或我们需要能够迁移数据的任何内容，

00:10:05.400 --> 00:10:10.460
在迁移块存储以使用多个哈希和

00:10:10.460 --> 00:10:17.610
而不是像现在那样使用C ID作为密钥，这就是下一个

00:10:17.610 --> 00:10:26.160
端口Robin-Jas，如果现在可用，都使用J的版本，不错

00:10:26.160 --> 00:10:33.000
所以这基本上是目前在Jace IVF中的Robin是一个本机模块

00:10:33.000 --> 00:10:36.150
而且没有等效的浏览器，因此它不包含在其中

00:10:36.150 --> 00:10:41.160
浏览器包，因此您不能在浏览器中使用它，我们应该能够

00:10:41.160 --> 00:10:46.230
如果只是那些高级分块，请在浏览器中使用它

00:10:46.230 --> 00:10:51.250
浏览器中也需要提供功能，以便人们可以

00:10:51.250 --> 00:10:54.790
他们想要在浏览器以及节点或任何地方进行的所有操作

00:10:54.790 --> 00:11:02.410
无论他们在哪里，无论如何，我希望你喜欢他们

00:11:02.410 --> 00:11:06.520
非常令人兴奋的是，还有很多事情要做，所以我现在就离开你，继续前进

00:11:06.520 --> 00:11:10.380
好的，我们再见

