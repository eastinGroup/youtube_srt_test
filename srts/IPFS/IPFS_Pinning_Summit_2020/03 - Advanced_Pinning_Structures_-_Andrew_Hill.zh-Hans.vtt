WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.329 --> 00:00:03.600
很好，谢谢，莫莉，谢谢大家，谢谢有我

00:00:03.600 --> 00:00:08.910
那里的每个人，我想早上好，下午好，晚上好，无论你在哪里

00:00:08.910 --> 00:00:17.369
今天我在这里与您谈谈我在X工作的纺织品

00:00:17.369 --> 00:00:20.520
几年了，现在您可以在纺织染料上找到我们哦

00:00:20.520 --> 00:00:25.800
我们是一家开源公司，致力于使数据成为一流的

00:00:25.800 --> 00:00:32.009
万维网上的公民，您知道我认为确实有一件事情启发了我们

00:00:32.009 --> 00:00:36.300
实际上是胡安的一句老话，我不记得它是从哪里来的，但他说

00:00:36.300 --> 00:00:40.350
很多人专注于创建铁路的不同轨距

00:00:40.350 --> 00:00:45.420
铁路的早期，当人们

00:00:45.420 --> 00:00:49.500
专注于规范量规，这是我贯穿整个过程的过程

00:00:49.500 --> 00:00:54.719
头很重要的一点是，在互联网上，尤其是在Web 3和

00:00:54.719 --> 00:00:58.890
去中心化的网络，是时候真正开始关注标准仪表了

00:00:58.890 --> 00:01:03.890
我们都可以一起构建，并构建出非常出色和令人惊奇的东西，因此

00:01:03.890 --> 00:01:09.900
纺织品确实专注于连接和扩展的少数技术

00:01:09.900 --> 00:01:18.960
p2p ipfs文件以对应用程序构建器有用的方式自发行，并提供服务和

00:01:18.960 --> 00:01:23.820
今天，我真的很想和您谈谈其中两个技术线程

00:01:23.820 --> 00:01:28.950
桶，然后明天我将谈论我们在文件中链接的工作

00:01:28.950 --> 00:01:32.610
通过称为电源门的技术来投币，因此希望您可以加入

00:01:32.610 --> 00:01:37.890
也可以，但我可以直接跳进去，因为我有很多东西

00:01:37.890 --> 00:01:41.939
我想与大家分享我想专注于第一种技术，即

00:01:41.939 --> 00:01:45.450
线程数据库或有时只是短线程

00:01:45.450 --> 00:01:50.490
线程确实是一项源自我们所谓的领域的技术

00:01:50.490 --> 00:01:54.750
研究实际上试图在ipfs网络上构建应用程序，并且

00:01:54.750 --> 00:01:59.460
意识到我们可以在某些领域为其他领域建立有用的技术

00:01:59.460 --> 00:02:02.969
想做同样事情的人，因此威胁数据库是点对点的

00:02:02.969 --> 00:02:09.479
建立在IP FSLIC p2p IP ns IP LD上的数据库，这确实有助于将

00:02:09.479 --> 00:02:13.830
堆叠这些技术，然后在其中创建

00:02:13.830 --> 00:02:18.000
面对四个真正易于使用的开发人员，因此我们专注于

00:02:18.000 --> 00:02:22.440
提供类似于MongoDB的开发人员界面，因此当开发人员

00:02:22.440 --> 00:02:26.130
想要将数据库放到他们不一定想要的应用程序中

00:02:26.130 --> 00:02:30.240
考虑他们如何堆叠并夹住他们真正的所有协议

00:02:30.240 --> 00:02:35.460
只是想开始在一个非常简单的启动界面中使用它们，然后

00:02:35.460 --> 00:02:41.940
它提供了一些模块化组件，例如CL身份CR DTS，开发人员可以

00:02:41.940 --> 00:02:46.890
即插即用，使他们的应用程序运行，然后最终运行

00:02:46.890 --> 00:02:52.020
它有一个加密crip ssin优先设计，可以实现私有

00:02:52.020 --> 00:02:56.790
与第三方服务的共享以及添加，我将更深入

00:02:56.790 --> 00:03:00.870
因为我觉得那对这个观众真的很有用，所以

00:03:00.870 --> 00:03:04.830
只是非常快速地向内线程化线程，我将讨论数据库

00:03:04.830 --> 00:03:10.650
首先在这里，所以每个网络线程都有一个数据库

00:03:10.650 --> 00:03:16.110
是本地组件，这些填充这些术语可能听起来很熟悉

00:03:16.110 --> 00:03:19.709
实际上，我希望他们听起来很熟悉，是当开发人员创建数据库时

00:03:19.709 --> 00:03:23.550
数据库有很多集合集合是定义的模式

00:03:23.550 --> 00:03:28.200
馆藏内的那个数据库中将会发生什么

00:03:28.200 --> 00:03:32.190
实例，因此对象就是您要存储在其中的文档

00:03:32.190 --> 00:03:36.780
满足这些架构的数据库，然后这些实例就可以了

00:03:36.780 --> 00:03:40.440
添加删除和更新，一旦你有你的数据库，等等左我有一些

00:03:40.440 --> 00:03:43.980
此处的代码使用JavaScript库来创建

00:03:43.980 --> 00:03:47.880
有一些领域的宇航员，然后在非常大的范围内更新和查询这些领域

00:03:47.880 --> 00:03:52.739
看起来很熟悉并且试图帮助开发人员的方式不一定

00:03:52.739 --> 00:03:55.590
想着您知道不断变化的内容地址

00:03:55.590 --> 00:04:01.280
以及他们如何管理在IP FS上实际运行的可变数据

00:04:01.280 --> 00:04:07.440
但是那时我们的线程可能真的很强大，那就是网络等等

00:04:07.440 --> 00:04:11.130
我想指出一些有关网络的内容，以便

00:04:11.130 --> 00:04:14.370
您可以开始了解它是如何工作的以及有什么不同

00:04:14.370 --> 00:04:20.489
这里是新的，所以当我们开始制造纺织品时，我们开始尝试制造

00:04:20.489 --> 00:04:25.710
可以在浏览器和移动设备中以及仅在

00:04:25.710 --> 00:04:28.770
实际网络状况以及建立对等网络时

00:04:28.770 --> 00:04:31.800
应用您将要使用的默认方式中的第一种

00:04:31.800 --> 00:04:37.139
架构师说您是纯粹的，并且您有一些数据或更新了您

00:04:37.139 --> 00:04:42.090
想要发送到B码头，您将其推送，这是Lib p2p很棒的地方

00:04:42.090 --> 00:04:46.770
他们可以彼此连接并推送这些更新，但是经常发生的是

00:04:46.770 --> 00:04:51.210
那将是在真实的网络条件下崩溃，其中B是

00:04:51.210 --> 00:04:55.530
脱机或仅在少量时间内在线，尤其是在移动设备中

00:04:55.530 --> 00:04:59.970
您可以想象该应用程序实际上仅连接到的应用程序

00:04:59.970 --> 00:05:03.660
在一天的一小部分时间内上网，因此接下来的事情

00:05:03.660 --> 00:05:08.220
分层允许网络提取更新，因此如果尝试进行

00:05:08.220 --> 00:05:12.510
更改数据，然后B出现，它可以尝试拉出这些更新

00:05:12.510 --> 00:05:15.449
从和烘焙到网络中，因此开发人员没有

00:05:15.449 --> 00:05:20.190
想得太多，但是再一次对此真的很有趣

00:05:20.190 --> 00:05:24.810
我认为观众是允许推拉的第三部分

00:05:24.810 --> 00:05:30.090
架构，因此，如果A尝试进行更新而B不在线，则可以

00:05:30.090 --> 00:05:34.289
实际上假设他们下次将要脱机时将处于脱机状态，

00:05:34.289 --> 00:05:37.530
因此它们实际上不会用于拉取请求，因此

00:05:37.530 --> 00:05:41.460
他们要做的是可以将这些更新推送到第三方服务Z

00:05:41.460 --> 00:05:46.680
然后一些时间可以过去，B可以上网并知道Z

00:05:46.680 --> 00:05:50.250
是可用的，他们实际上可以拉出他们错过的更新，等等

00:05:50.250 --> 00:05:53.910
我们试图在这里做的是

00:05:53.910 --> 00:05:59.190
技术人员通过使网络真正运行良好并实际应用它们而学到了

00:05:59.190 --> 00:06:02.490
到网络的三个空间，所以我的意思是实际上允许

00:06:02.490 --> 00:06:07.560
服务和api以可以构建应用程序的方式站起来

00:06:07.560 --> 00:06:12.539
他们并扩大规模，但他们不必放弃让用户拥有的想法

00:06:12.539 --> 00:06:16.500
他们的数据或创建可互操作的数据集或私钥基础结构

00:06:16.500 --> 00:06:21.330
所以这是做什么的，我将向您展示如何在更多环境中实际工作

00:06:21.330 --> 00:06:26.160
技术级别，使最终用户拥有自己的数据，开发人员可以配置

00:06:26.160 --> 00:06:30.419
网络上的服务，这些最终用户可以在不使用的情况下使用

00:06:30.419 --> 00:06:37.409
放弃放弃所有权和隐私，是的，所以线程数据库

00:06:37.409 --> 00:06:41.039
真正让人们让最终用户做更多的事情

00:06:41.039 --> 00:06:45.930
包含私有数据和即将公开的数据，所以这是一个概览图

00:06:45.930 --> 00:06:50.009
更改本地数据库然后发生的情况

00:06:50.009 --> 00:06:54.629
它如何传播到网络和一些多层加密

00:06:54.629 --> 00:06:59.520
这将发生在左侧的数据是用户的某种东西

00:06:59.520 --> 00:07:03.990
拥有，受控和私有，右侧是线程启用的地方

00:07:03.990 --> 00:07:07.680
第三方服务，如果您要建立固定服务，

00:07:07.680 --> 00:07:11.729
想要建立api的朋友用户，该api用户的服务提供了

00:07:11.729 --> 00:07:15.180
希望右上方使您的耳朵响起来，这可能是

00:07:15.180 --> 00:07:18.539
有趣的机会，您可以在此基础上建立一个快速的过程

00:07:18.539 --> 00:07:22.409
用户首先在左下角创建一些原始数据

00:07:22.409 --> 00:07:29.099
将会发生的是涂药器对不起图书馆要

00:07:29.099 --> 00:07:32.849
为该数据创建一个对称私钥，或者很抱歉，为该数据创建一个对称私钥

00:07:32.849 --> 00:07:37.800
一次性加密使用的数据，而您不必遵循

00:07:37.800 --> 00:07:41.189
这只是为了那些对您有想法的人

00:07:41.189 --> 00:07:44.430
这已经可以了，但下一步将要进行的是共享读取

00:07:44.430 --> 00:07:49.050
读取密钥，以便线程中所有在同一数据上进行协作的参与者

00:07:49.050 --> 00:07:53.309
集可以共享此读取密钥，以便随后将加密的主体加密

00:07:53.309 --> 00:07:57.930
上一步中的正文和密钥，然后您希望将其共享给

00:07:57.930 --> 00:08:01.080
参与者，以便他们可以打开它并查看数据中您已更新的内容

00:08:01.080 --> 00:08:04.080
设置，但接下来要发生的事情实际上是您要包装

00:08:04.080 --> 00:08:08.099
还有一些时间将一些元数据链接到以前的更新

00:08:08.099 --> 00:08:11.969
然后使用所谓的此服务密钥再进行一层加密，

00:08:11.969 --> 00:08:15.719
因此，使用服务密钥，您无法看到数据中的任何内容，但可以看到

00:08:15.719 --> 00:08:20.519
数据如何跨更新链接，以便您可以做一些非常有趣的事情，例如

00:08:20.519 --> 00:08:26.039
表面API允许分页或基于时间的查找，您可以看到一些

00:08:26.039 --> 00:08:29.789
基本元数据，以便您可以确保向用户提供服务

00:08:29.789 --> 00:08:33.810
经过验证可以使用该服务，但您实际上看不到是什么

00:08:33.810 --> 00:08:37.829
发生在内部，因此这就是服务密钥的所在，我可以共享

00:08:37.829 --> 00:08:42.060
我具有信任级别的任何服务的数据集的服务密钥

00:08:42.060 --> 00:08:46.050
我认为他们会为我提供我想要的服务，例如

00:08:46.050 --> 00:08:50.970
存档或使其在ipfs网络上可用，因此由左侧用户拥有

00:08:50.970 --> 00:08:54.690
右侧可用于在真正基础上建立的服务

00:08:54.690 --> 00:08:59.760
这些和线程数据库概念允许的一种有趣的开放方式

00:08:59.760 --> 00:09:02.760
您可以将它们像可互操作的数据集一样考虑，以便一旦成为用户

00:09:02.760 --> 00:09:06.570
如果有人站起来服务或与他们不同，则归他们所有

00:09:06.570 --> 00:09:10.410
使用这些架构的应用程序，用户可以将其撤回

00:09:10.410 --> 00:09:14.220
并将它们放在新的应用程序中，它的作用是允许您构建

00:09:14.220 --> 00:09:18.630
您不必要求用户将自己的节点作为一个节点来运行的应用程序

00:09:18.630 --> 00:09:22.830
第一步，您不必要求用户做实际加入的开销

00:09:22.830 --> 00:09:28.020
除了仅使用您的应用程序以外的其他网络，但您将那扇门保持打开状态，以便

00:09:28.020 --> 00:09:31.170
他们变得更加参与，变得更感兴趣，他们可以找到新的方法

00:09:31.170 --> 00:09:35.220
以确保他们的数据永远存在或确保他们的数据生活在其他地方

00:09:35.220 --> 00:09:39.930
应用程序，他们可以从中获得最大收益，所以我认为真的很有趣

00:09:39.930 --> 00:09:45.510
在固定服务或固定首脑会议上下文中，线程是

00:09:45.510 --> 00:09:50.250
实际上是动态的引脚组，因此我将介绍一些我们的托管服务

00:09:50.250 --> 00:09:54.510
可供开发人员使用，但实际上您可以考虑进行更新

00:09:54.510 --> 00:09:57.930
到数据库中，您想将其从电话中保留下来，或者您想要

00:09:57.930 --> 00:10:01.740
将它们持久保存在您将要在线的一些ipfs节点上的浏览器中

00:10:01.740 --> 00:10:06.300
更长的时间，所以您要做的是可以使用此服务密钥，然后按一下

00:10:06.300 --> 00:10:11.100
您的线程将更新为这些正在运行ipfs节点的第三方服务，并且

00:10:11.100 --> 00:10:17.520
他们可以确保数据在整个线程上固定为zip插入，并且

00:10:17.520 --> 00:10:21.150
我将分享这些幻灯片，但有关我们拥有的线程的一些重要链接

00:10:21.150 --> 00:10:26.220
白皮书，这实际上是一项正在进行的工作，因此，您确实可以挖掘

00:10:26.220 --> 00:10:30.030
讨论有关如何将它们结合在一起的一些技术性内容，然后我们将

00:10:30.030 --> 00:10:34.350
几个使用数据库和网络的实现，以及

00:10:34.350 --> 00:10:41.339
里面的不同部分，使我将我的下一个部分带到我的身边

00:10:41.339 --> 00:10:47.280
想谈谈哪个是水桶水桶真的是第一个

00:10:47.280 --> 00:10:53.130
基于线程TB构建的应用程序，我们开始意识到的是

00:10:53.130 --> 00:10:56.940
一旦有了线程，就拥有了这种真正的快速轻量级工具

00:10:56.940 --> 00:11:01.080
可以与多个使用用户协作移动数据的数据库

00:11:01.080 --> 00:11:05.400
您可能想做的一件事实际上就是动态地移动

00:11:05.400 --> 00:11:11.279
ipfs上的文件夹，所以什么线程基本上是我们的遗憾

00:11:11.279 --> 00:11:16.380
基本上是一个跟踪变化的dag的线程，所以您有一个dag

00:11:16.380 --> 00:11:21.959
它的头部位于in中的实例的元数据中

00:11:21.959 --> 00:11:26.130
数据库，并且随着该实例的更改，线程可以推送那些

00:11:26.130 --> 00:11:30.810
不仅更新到该文件夹​​中正在协作的所有同级

00:11:30.810 --> 00:11:34.890
数据，然后是任何想要复制并使数据可用的服务

00:11:34.890 --> 00:11:41.100
更快或在ipfs上更多的地方，在这里真的很酷，因为这是

00:11:41.100 --> 00:11:44.700
另一个地方，服务密钥变得非常有趣，因为您可以

00:11:44.700 --> 00:11:48.480
实际上让其他服务订阅您的存储桶中的更改，因此我们可以

00:11:48.480 --> 00:11:52.740
建立一个非常推拉式的网络，其中数据在不断变化和移动

00:11:52.740 --> 00:11:56.100
当我们可以建立一些漂亮的

00:11:56.100 --> 00:12:00.540
令人难以置信的事情，这不仅是固定，而且这是重要的

00:12:00.540 --> 00:12:03.990
不仅仅是存档，您还可以想象服务是重要的

00:12:03.990 --> 00:12:08.910
实际上是在转换和翻译数据，因此您可以想象

00:12:08.910 --> 00:12:12.690
例如音频处理或视频处理或重新格式化和图像

00:12:12.690 --> 00:12:16.620
可以在此基础上进行抽样，并且在方法上有些细微差别

00:12:16.620 --> 00:12:21.500
水桶的工作方式，我们现在让一些水桶完全公开

00:12:21.500 --> 00:12:25.350
我们正在努力也要有专用水桶，但是因为

00:12:25.350 --> 00:12:28.920
他们完全是p人，实际上您可以与

00:12:28.920 --> 00:12:33.810
以及服务，这样他们就可以一直深入到线程中，并进行扩展和

00:12:33.810 --> 00:12:38.579
递归地遍历此dag，并在您的数据之上进行工作，并在此过程中

00:12:38.579 --> 00:12:42.149
现在是案例，只是工作正在固定和公开该数据，但是

00:12:42.149 --> 00:12:46.560
可能就像我说的那样对它进行重采样或格式化或其他操作

00:12:46.560 --> 00:12:51.779
您的数据，因此存储桶是基于线程DB构建的，所以这实际上只是

00:12:51.779 --> 00:12:56.040
另一个可互操作的格式线程存储桶实际上只是一个架构，因此

00:12:56.040 --> 00:13:00.149
如果您回想起线程的数据库部分，那就是具有

00:13:00.149 --> 00:13:03.420
数据库内部的数据库或集合内部的集合，或

00:13:03.420 --> 00:13:07.079
实例存储桶实际上是您创建的每个存储桶，这是不同的

00:13:07.079 --> 00:13:10.560
磁盘上的动态文件夹实际上只是一个

00:13:10.560 --> 00:13:15.300
该集合由仅对某些内容进行存储的架构定义

00:13:15.300 --> 00:13:21.510
真的很酷，我认为这里发生的是互操作性，是

00:13:21.510 --> 00:13:25.270
非常强大，并且可以在任何类型的数据库中使用实例

00:13:25.270 --> 00:13:29.560
使用您可能在此实例中具有一些密钥一些实例的唯一ID

00:13:29.560 --> 00:13:35.200
在buckets集合中，我们实际上已将ID设为IP NS

00:13:35.200 --> 00:13:38.740
地址，因此您已经知道实例定义了一个

00:13:38.740 --> 00:13:43.600
存储桶中也有此地址，该地址可在所有ipfs注释中互操作

00:13:43.600 --> 00:13:48.520
公开IP NS地址，因为这个存储桶是公共的，我可以在任何

00:13:48.520 --> 00:13:53.200
网关并与之共享内容，这真的很令人兴奋，

00:13:53.200 --> 00:13:56.860
有很多机会可以做更多的事情，以及不同类型的模式

00:13:56.860 --> 00:14:00.550
我们可以构建超出使用相同属性的存储桶的功能

00:14:00.550 --> 00:14:06.190
添加可互操作的互操作性并公开非常酷的功能，我们拥有一个

00:14:06.190 --> 00:14:09.250
有一个我接下来要谈的客户，它可以让您创建存储桶并推送

00:14:09.250 --> 00:14:13.930
他们将它们快速地发送到远程IP FS对等端，这里我将四个文件的文件夹推送到

00:14:13.930 --> 00:14:18.220
一线的远程IP FS对等方，然后我要转到网关

00:14:18.220 --> 00:14:21.970
首先，我要询问所有链接，您会看到其中一个是IP NS

00:14:21.970 --> 00:14:26.770
链接，我可以抓住它并转到纺织品上的网关，并查看该IPS

00:14:26.770 --> 00:14:30.970
在我的林肯网站上，有我的网页，我可以在其他网关上访问该网页

00:14:30.970 --> 00:14:40.480
同样，我们还有很多工作要做，只是要增加水桶的大小，

00:14:40.480 --> 00:14:44.560
更好，更像我说的，我们正在研究专用水桶，以便

00:14:44.560 --> 00:14:49.270
是加密的内容，我们正在与几个不同的人一起工作，

00:14:49.270 --> 00:14:52.900
支持存储桶，并且在其他服务上具有互操作性

00:14:52.900 --> 00:14:58.210
面临威胁，显然我们正在研究文件硬币，我将进一步讨论

00:14:58.210 --> 00:15:03.070
明天，但这里的想法是线程和存储桶也将

00:15:03.070 --> 00:15:07.420
可以在文件硬币上进行存储和持久化的端点上受支持

00:15:07.420 --> 00:15:11.080
网络，这也真的非常令人兴奋，因为然后我们只需添加

00:15:11.080 --> 00:15:16.270
我们可以与这些数据集互操作的另一种协议，因此

00:15:16.270 --> 00:15:21.400
一些有趣的链接给您，我们有关于码头上水桶的文档

00:15:21.400 --> 00:15:26.590
在纺织码头上，我们有一堆关于

00:15:26.590 --> 00:15:30.070
桶，以及如何使用它们，我们将做更多的事情，

00:15:30.070 --> 00:15:34.030
实际上，我接下来将讨论有关我们刚刚启动的枢纽的那部分，

00:15:34.030 --> 00:15:36.550
所以我们仍然在那里增加很多内容

00:15:36.550 --> 00:15:42.970
而且，但我会与您分享其中的一些早期内容，是的，

00:15:42.970 --> 00:15:47.800
我是第三项技术，集线器和集线器就是我们所处的位置

00:15:47.800 --> 00:15:53.740
尝试做的只是降低开发人员真正投入的成本，

00:15:53.740 --> 00:15:58.839
实验和建造东西，我认为可以降低实验成本

00:15:58.839 --> 00:16:03.580
是开发人员工具和我们建立的最重要的KPI

00:16:03.580 --> 00:16:07.930
网络，我们要做的就是使开发人员更容易

00:16:07.930 --> 00:16:11.860
探索测试并快速失败，以便他们可以测试并构建下一个

00:16:11.860 --> 00:16:15.460
事情，并在这个事情上真正测试他们的想法，因为只有当我们可以

00:16:15.460 --> 00:16:19.750
让一千名开发人员或数万名开发人员来进行测试

00:16:19.750 --> 00:16:23.770
并建立我们可以拥有真正通过社会和社会燃起的火花

00:16:23.770 --> 00:16:29.290
真正弥补了这一点，取得了一些非常大的，有影响力的成功，所以让我们尝试

00:16:29.290 --> 00:16:36.430
降低采用成本和失败成本，因此集线器确实

00:16:36.430 --> 00:16:40.270
做到这一点，就像我说的，该枢纽实际上只是一组开源

00:16:40.270 --> 00:16:46.270
包括线程和存储桶支持的技术以及一些IP FS注释

00:16:46.270 --> 00:16:49.690
所以真的，如果有的话，这里有东西

00:16:49.690 --> 00:16:52.960
运行服务，并且您希望自己运行这些服务，我们很乐意为您提供帮助

00:16:52.960 --> 00:16:58.000
并逐步引导您并与您分享我们在这里所做的事情，但是当您离开时

00:16:58.000 --> 00:17:02.589
并获取集线器的CLI，您可以创建诸如帐户之类的内容

00:17:02.589 --> 00:17:07.030
创建诸如组织之类的东西，以便您可以共享管理工具

00:17:07.030 --> 00:17:11.829
与其他合作者一起，您可以邀请其他人加入这些组织，

00:17:11.829 --> 00:17:15.670
所以在这里，我将创建我的针叶树，并邀请一名宇航员加入我的针叶树

00:17:15.670 --> 00:17:19.600
组织，这意味着我可以创建存储桶，并创建存储桶和团队

00:17:19.600 --> 00:17:24.850
由该团队协同编辑和管理的线程

00:17:24.850 --> 00:17:29.710
开发人员和我早先提到过，我们有这样的想法，开发人员可以

00:17:29.710 --> 00:17:34.210
供应空间，所以这是集线器上的开发人员供应空间

00:17:34.210 --> 00:17:38.380
这将使他们拥有托管的ipfs资源，从而使他们能够访问

00:17:38.380 --> 00:17:43.090
这些网络和协议通过一些持久性节点，但是我们真正

00:17:43.090 --> 00:17:47.080
想要做的就是让他们以某种方式将其传递给用户

00:17:47.080 --> 00:17:50.200
仍在他们的数据上，所以我一会儿再讲

00:17:50.200 --> 00:17:56.109
中心具有OSI ipfs服务线程服务具有G RPC端点

00:17:56.109 --> 00:18:02.639
可以使用一些不同的客户，并且它实际上专注于这种想法

00:18:02.639 --> 00:18:10.210
互操作性，但为最终用户提供了便捷的入门方式，但可能

00:18:10.210 --> 00:18:13.809
这里最有趣的是我们访问这些内容的方式

00:18:13.809 --> 00:18:19.330
资源，因此我刚刚向您展示的预览中的开发人员正在设置

00:18:19.330 --> 00:18:24.639
他们想要使用api的其他开发人员团队的帐户

00:18:24.639 --> 00:18:27.879
他们实际上可以获得所谓的帐户密钥，而该帐户密钥将

00:18:27.879 --> 00:18:31.659
授予他们访问CLI中正在执行的所有操作的权限，以便他们可以

00:18:31.659 --> 00:18:35.980
创建存储桶，他们可以创建完全拥有的新数据库，

00:18:35.980 --> 00:18:39.789
由他们作为开发人员或他们在其中创建的组织控制，但

00:18:39.789 --> 00:18:43.090
他们还可以创建所谓的用户密钥，而用户密钥将授予

00:18:43.090 --> 00:18:49.029
使用该开发人员的资源访问API，但是

00:18:49.029 --> 00:18:54.730
最终用户拥有并控制该数据，因此使用PKI，以便最终用户

00:18:54.730 --> 00:18:58.210
谁在应用程序中创建线程或在

00:18:58.210 --> 00:19:02.200
应用程序实际上是根据API推送数据，但仅此而已

00:19:02.200 --> 00:19:06.700
加密并私有给开发人员和纺织品，所以这些

00:19:06.700 --> 00:19:11.679
用户可以轻松入门，他们可以在持久性ipfs节点上获取数据，但是

00:19:11.679 --> 00:19:14.739
他们实际上可以在那里使用IP FS及其私钥来获取它

00:19:14.739 --> 00:19:18.970
备份和/或在自己的节点上复制，或将来复制到其他节点上

00:19:18.970 --> 00:19:23.679
在线服务可以将其整合到其他服务中，我们认为这真的很酷

00:19:23.679 --> 00:19:29.109
有趣的是，我们也在与身份提供商合作，以确保

00:19:29.109 --> 00:19:33.309
这是可互操作的，并允许用户选择他们想要的身份

00:19:33.309 --> 00:19:36.879
在这里使用，或者如果用户不在乎他们只是想使用该应用程序，或者

00:19:36.879 --> 00:19:45.759
服务，他们只能使用它，所以是的，我们对中心的关注是

00:19:45.759 --> 00:19:50.700
创建动态互操作和非中间服务

00:19:50.700 --> 00:19:54.909
中间数据，我的意思是在这种情况下

00:19:54.909 --> 00:19:59.379
Disintermediated是，开发人员可以来使用枢纽并访问

00:19:59.379 --> 00:20:03.399
这些资源，但是当他们投入

00:20:03.399 --> 00:20:05.700
他们将资源放入他们的应用程序中，因此

00:20:05.700 --> 00:20:10.230
实际上，这不仅仅是最终用户和托管用户之间的关系

00:20:10.230 --> 00:20:15.660
接口，但是使用线程，它是可互操作的数据格式，因此是PKI，因此

00:20:15.660 --> 00:20:18.930
最终用户真正拥有它，他们或多或少地借了一些空间

00:20:18.930 --> 00:20:24.510
由开发人员提供，如果您想使用这些东西，

00:20:24.510 --> 00:20:29.100
您想尝试将它们构建到您的应用中让我们知道我们的渠道比较闲

00:20:29.100 --> 00:20:32.820
宽松的纺织IO总是可用的，以帮助人们

00:20:32.820 --> 00:20:36.390
悬停在较早的位置，所以我们有点像在填写示例

00:20:36.390 --> 00:20:40.710
填写文档，但是如果您有特定的用例，并且只需要帮助

00:20:40.710 --> 00:20:45.000
让我们知道我们正在尽可能快地工作，我们也希望其他服务

00:20:45.000 --> 00:20:48.960
想要采用这些东西并以此为基础，所以请让我们知道您是否站在那一边

00:20:48.960 --> 00:20:54.240
而且我们很乐意提供帮助，所以这些就是那种

00:20:54.240 --> 00:20:57.480
涵盖了这里的三种技术，就像我明天要说的那样

00:20:57.480 --> 00:21:02.850
电动门，但有点让我的演讲不在这里，我想喜欢

00:21:02.850 --> 00:21:07.440
退后一步，只谈大局，因为我真的很兴奋

00:21:07.440 --> 00:21:10.890
出席了在Pinney和意见峰会上的演讲，但我想到了何时

00:21:10.890 --> 00:21:15.240
我把这些幻灯片放在一起是因为我刚出生在一个完全

00:21:15.240 --> 00:21:19.950
在您认识的不同时间，我们显然专注于帮助人们工作

00:21:19.950 --> 00:21:23.460
通过分散协议，我们真正专注于将数据制作成某种东西

00:21:23.460 --> 00:21:29.220
人们可以拥有并可以长期在线上保留的内容，但是

00:21:29.220 --> 00:21:32.700
确实情况正在发生变化，而发生变化的情况可能永远不会发生

00:21:32.700 --> 00:21:36.540
回到他们平时的状态，我们想找到

00:21:36.540 --> 00:21:40.950
试图为那个新世界建立技术重要的是试图

00:21:40.950 --> 00:21:44.880
建立可以为新世界带来积极影响的技术，因此，如果

00:21:44.880 --> 00:21:48.360
您是在构建将人们聚集在一起的技术，还是

00:21:48.360 --> 00:21:51.870
建立可以确保人员安全的技术，或者您正在建立可以保护人们安全的技术

00:21:51.870 --> 00:21:56.130
通过获得医疗保健和教育机会，创造了更加光明的未来

00:21:56.130 --> 00:22:00.780
更好地获取我们现在真正想为您提供支持的信息，所以不要

00:22:00.780 --> 00:22:06.390
请随时与我们联系，我们会在这里提供资源，您会知道时间和

00:22:06.390 --> 00:22:09.900
以及使这些应用程序变得美丽和光泽所需的一切

00:22:09.900 --> 00:22:13.860
现在，整个新世界即将来临，我们正在看到

00:22:13.860 --> 00:22:17.700
过渡也是一个巨大的机会，因此我们想帮助您到达那里，以便

00:22:17.700 --> 00:22:26.940
只是让我们知道，非常感谢您，非常感谢

00:22:26.940 --> 00:22:31.730
安德鲁这真是不可思议嗯，你们有什么问题吗？

00:22:31.730 --> 00:22:40.200
弗雷达·斯蒂克曼（Freda Stickman）的问答环节或聊天线程和聊天桶都很棒，我当时

00:22:40.200 --> 00:22:44.580
昨晚刚刚读了重读线程论文，所以超级超酷的工作

00:22:44.580 --> 00:22:48.360
在那里，谢谢大家在ipfs上构建ur的惊人工具，

00:22:48.360 --> 00:22:53.309
太棒了，谢谢，我的意思是，它是如此之多的协议实验室和

00:22:53.309 --> 00:22:57.630
我们所做的事情真的不包含某些事情，零五零零启动是

00:22:57.630 --> 00:23:02.370
令人难以置信的是，我们很高兴看到一切都在2020年达成

00:23:02.370 --> 00:23:07.649
将会是一个如此令人敬畏的一年，是来自Pooja的一年

00:23:07.649 --> 00:23:12.059
也可以将存储桶集成到其他服务中吗？

00:23:12.059 --> 00:23:16.110
绝对是这样，其中有些概念在桶中进行

00:23:16.110 --> 00:23:20.639
最主要的是，它实际上只是线程Stevie中的模式，因此线程数据库

00:23:20.639 --> 00:23:25.950
只是一组协议和一些有关

00:23:25.950 --> 00:23:31.110
加密层应该如何工作，然后如何共享这些密钥等等

00:23:31.110 --> 00:23:35.730
其他支持存储桶的服务将需要什么

00:23:35.730 --> 00:23:40.260
是要支持线程，然后就它们所代表的某些模式达成一致

00:23:40.260 --> 00:23:44.039
他们会打电话给水桶，所以水桶确实是我们的第一个版本

00:23:44.039 --> 00:23:48.870
好吧，我们一定会发布一些有关外观的文档

00:23:48.870 --> 00:23:53.039
以及水桶的规格是什么，但现在非常简单，

00:23:53.039 --> 00:23:57.450
只是具有文件夹头CID的基本文档，然后它

00:23:57.450 --> 00:24:01.529
在幕后有一些UNIX FS类型，以确保该文件夹位于

00:24:01.529 --> 00:24:04.620
持久的，但是很简单，因此，如果您正在构建事物

00:24:04.620 --> 00:24:09.360
像固定服务一样，不应该也不应该离开公园

00:24:09.360 --> 00:24:14.909
服务的运行方式实际上是将它们烘焙到参考中

00:24:14.909 --> 00:24:18.299
实现argo线程实现，因此您已经可以

00:24:18.299 --> 00:24:22.590
都可以使用该库来维护您自己的服务并接受事物

00:24:22.590 --> 00:24:26.909
像其他线程一样，所以就在那里，实际上是二进制

00:24:26.909 --> 00:24:30.629
也有它，所以您可以运行二进制文件并构建线程

00:24:30.629 --> 00:24:33.930
关于它的服务记录不足，有点像

00:24:33.930 --> 00:24:36.930
接下来的事情是让人们使用这些东西之后我们需要一个文档，但是

00:24:36.930 --> 00:24:40.440
它会来，就在那里，所以如果您有任何疑问，请跳入我们的github

00:24:40.440 --> 00:24:45.960
回购并开除一些门票，似乎您对科迪有疑问

00:24:45.960 --> 00:24:51.150
在问答环节中，公众如何通过八种方式知道如何阅读和呈现存储桶

00:24:51.150 --> 00:24:57.140
文件夹代表我们我们的UNIX，是的，文件夹是UNIX FS和

00:24:57.140 --> 00:25:03.150
现在我已经提到过，水桶只是敞开的，因为它们是敞开的

00:25:03.150 --> 00:25:08.550
存储桶的作者并不真正在乎rete键，因此他们实际上

00:25:08.550 --> 00:25:12.480
只需在我们有开放线程时共享密钥即可，但是您不需要这样做，但是

00:25:12.480 --> 00:25:17.850
现在线程仅被加密，所以它们只是存储桶

00:25:17.850 --> 00:25:22.320
在这种情况下，所有者将只与中心共享一个读密钥。

00:25:22.320 --> 00:25:25.770
枢纽就是您可以像网关一样思考它，因此

00:25:25.770 --> 00:25:29.520
网关知道如何将线程作为线程服务查看，但是随后

00:25:29.520 --> 00:25:33.090
也可以看到该CID，因为它具有读取密钥，然后它将

00:25:33.090 --> 00:25:37.050
只需固定一下即可知道UNIX FS文件夹，我们可以进行很多改进

00:25:37.050 --> 00:25:41.190
在那里做，我们正在做很多事情，所以它确实在做

00:25:41.190 --> 00:25:43.670
现在好

00:25:43.680 --> 00:25:48.090
所以我很快了解到，默认情况下，每个用户的线程现在都是加密的

00:25:48.090 --> 00:25:50.310
并且您将支持以后不加密自己，即不加密

00:25:50.310 --> 00:25:56.310
已经是可能的，因此可以涉及到一些非常深入的技术方面的内容，因此

00:25:56.310 --> 00:25:58.830
在线程周围真正新颖且有趣的是

00:25:58.830 --> 00:26:05.400
实际上，一个线程是单个编写器日志的集合，然后有一个

00:26:05.400 --> 00:26:10.770
模块化crc rdt，将其转换为数据库，每个日志都是私有的

00:26:10.770 --> 00:26:16.740
由每个用户私人拥有，然后通过

00:26:16.740 --> 00:26:20.580
每次更新使用对称密钥，因此每次有一个

00:26:20.580 --> 00:26:24.420
更新，然后在某些情况下使用读取密钥将其加密

00:26:24.420 --> 00:26:27.750
与所有人共享所有推送到该数据库的不同日志

00:26:27.750 --> 00:26:31.890
共享该读取密钥，并且所有这些都是默认值，因此所有加密都是

00:26:31.890 --> 00:26:36.120
发生了，我们正在寻找解锁方法，以便您可以完全

00:26:36.120 --> 00:26:41.160
人们可以阅读但威胁也可以支持的开放线程

00:26:41.160 --> 00:26:46.490
单身作家，许多读者，以及许多作家的场景

00:26:46.490 --> 00:26:49.610
谢谢你

