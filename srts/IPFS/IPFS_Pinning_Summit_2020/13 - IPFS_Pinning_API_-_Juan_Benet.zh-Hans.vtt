WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.939 --> 00:00:07.870
这是我一直在努力的绘画API的预览，这是一种

00:00:07.870 --> 00:00:11.470
从事很多工作，这些工作是由许多人在

00:00:11.470 --> 00:00:18.160
最近几个月，这实际上是种土地的目标

00:00:18.160 --> 00:00:21.039
在我们的大多数用例上都可以正常工作的API上解决它

00:00:21.039 --> 00:00:27.039
现在就发货了，有四个不同的机会

00:00:27.039 --> 00:00:30.939
ffs领域的产品来利用这种钉扎API，所以我

00:00:30.939 --> 00:00:34.899
想要使用此演讲来给一些动机

00:00:34.899 --> 00:00:40.510
自旋API来自演练，它是实物之前完成的工作的一部分

00:00:40.510 --> 00:00:43.660
充实一下，讨论一下问题的范围

00:00:43.660 --> 00:00:51.550
是一个非常棘手和棘手的问题，也许可以谈一些

00:00:51.550 --> 00:00:55.629
界面希望我一直从许多人那里收集

00:00:55.629 --> 00:01:01.120
遍及iPhone的生态系统，然后讨论前进的路线图

00:01:01.120 --> 00:01:07.359
根据钉扎API的建议API更改类型进行转发

00:01:07.359 --> 00:01:11.709
所以这可能会是很有意义的长期影响，但是

00:01:11.709 --> 00:01:14.920
这项更改将花费一些时间，它将上演并面对

00:01:14.920 --> 00:01:18.729
所以你一开始就知道没有什么是重要的

00:01:18.729 --> 00:01:22.689
会有所改变，但希望您今天所看到的将会成为

00:01:22.689 --> 00:01:28.810
有趣，它将为所有固定服务提供有趣的方式

00:01:28.810 --> 00:01:33.490
可能喜欢写更少的代码并且能够使用

00:01:33.490 --> 00:01:40.539
好了，让我们来谈谈动机，这有点像

00:01:40.539 --> 00:01:45.099
长期存在的问题很多纺纱服务对此都非常熟悉

00:01:45.099 --> 00:01:49.689
哪里可以使用相同的目标

00:01:49.689 --> 00:01:55.989
API，因为部分用户和应用程序必须基于一个API构建

00:01:55.989 --> 00:02:00.249
发现很难以另一种方式有区别地切换到更好的服务，因此

00:02:00.249 --> 00:02:05.049
那里有点像API锁定

00:02:05.049 --> 00:02:08.709
使一个政党受益，但这肯定会伤害其他人

00:02:08.709 --> 00:02:12.790
生态系统，还有其他好处，那里有很多工具

00:02:12.790 --> 00:02:15.790
最终不得不为一项待处理的服务和另一项服务编写

00:02:15.790 --> 00:02:20.140
固定服务想使用它们，但是现在由于IP不是

00:02:20.140 --> 00:02:24.790
然后，事情就会变得不太正常，所以很明显，这是在这种情况下

00:02:24.790 --> 00:02:28.659
标准化的通用API将是理想的，特别是对于任何类型的工具

00:02:28.659 --> 00:02:33.849
围绕引脚集，那是完全开源的，所以我就是这样

00:02:33.849 --> 00:02:37.150
与涉及针组的服务无关的人希望能够

00:02:37.150 --> 00:02:41.170
使用某种标准的标准工具，ipfs也是如此

00:02:41.170 --> 00:02:46.090
集群需要这样的东西，这就是集群团队想出的

00:02:46.090 --> 00:02:51.910
这个固定API的一个版本，它将描述实际上他们做了

00:02:51.910 --> 00:02:56.890
在这里遇到的大部分工作，所以这主要是试图关闭一些

00:02:56.890 --> 00:03:02.290
这些对话，然后转到下一步我要标记

00:03:02.290 --> 00:03:06.190
诸如桌面和伴侣之类的应用程序需要这种东西

00:03:06.190 --> 00:03:10.750
稍后从Molly听到更多有关如何在以下环境中使用这种API的信息：

00:03:10.750 --> 00:03:17.470
产品可以使用户的体验更好得多，并创造出

00:03:17.470 --> 00:03:21.660
固定以前不存在的服务的大量机会

00:03:22.349 --> 00:03:28.060
所以在github上有很多问题，您可以去看看并阅读

00:03:28.060 --> 00:03:32.349
这个API的大部分工作都在这里完成，并且确实非常好

00:03:32.349 --> 00:03:37.290
通过整个对话，您会知道不同的一组

00:03:37.290 --> 00:03:41.469
围绕API设置了一组不同的类似约束，而这恰好可以解决

00:03:41.469 --> 00:03:48.280
从那里的大部分工作到向Adrienne大喊大叫的艾德里安（Adrienne）

00:03:48.280 --> 00:03:55.030
这个以及其他许多人，您可以在这里看到他们的用户名，以及

00:03:55.030 --> 00:03:58.419
还有我认为不是问题的赫克托（Hector），但最终提供了很多

00:03:58.419 --> 00:04:05.139
一直在为该API做出贡献的想法，因此其中存在一个链接

00:04:05.139 --> 00:04:12.909
这个Steiger API也有问题，这具有

00:04:12.909 --> 00:04:17.889
我今天要提出的建议之一，您可以检查一下

00:04:17.889 --> 00:04:22.199
有点像面向休息

00:04:22.740 --> 00:04:28.810
只是解决能够在某些服务中更改引脚的方法，其想法是

00:04:28.810 --> 00:04:33.039
它就像一个独立的东西，非常薄，只是一个

00:04:33.039 --> 00:04:36.909
虽然很容易绑定到本期中的部分讨论

00:04:36.909 --> 00:04:40.030
谈到能够拥有它会是多么的好和非常有用

00:04:40.030 --> 00:04:45.250
该API具有不同的风格，这意味着它会不稳定或已在您的PC中

00:04:45.250 --> 00:04:51.430
或可能将其包含在shell脚本或类似的内容中，所以其中之一

00:04:51.430 --> 00:04:55.810
对于我来说，要点是定义数据结构真的很关键

00:04:55.810 --> 00:05:00.400
和语义，然后提出两种或三种不同的风味

00:05:00.400 --> 00:05:05.139
人们最想要的最普通的东西，然后永远都不会得到

00:05:05.139 --> 00:05:09.099
不幸的是，鉴于所有不同的方式，

00:05:09.099 --> 00:05:12.820
人们使用api的这些帐篷，我们不太可能找到

00:05:12.820 --> 00:05:17.800
恰好一个，所以我认为搭配几种口味是正确的，正确的

00:05:17.800 --> 00:05:24.789
正如我之前提到的，您稍后会更正式地了解

00:05:24.789 --> 00:05:28.630
可以用于许多产品上，依此类推，因此所有

00:05:28.630 --> 00:05:32.370
他们我想看一下有关集群用例的一点，那就是

00:05:32.370 --> 00:05:35.409
集群管理引脚集的方式是

00:05:35.409 --> 00:05:42.249
一直说惩罚日志并使用分布式共识来达成共识

00:05:42.249 --> 00:05:46.479
什么是固定的或没有固定的，所以有集群运行

00:05:46.479 --> 00:05:50.319
第二句话的过程，它需要包装，所以现在它使用一个我认为所有

00:05:50.319 --> 00:05:55.629
默克尔在此有义务就添加和移除的销钉达成一致

00:05:55.629 --> 00:06:00.519
铅笔，因此您可以将这些条目中的每一个视为扩展日志

00:06:00.519 --> 00:06:06.939
并添加或移除图钉，然后将图钉固定为您所知道的

00:06:06.939 --> 00:06:14.409
CID就像整个大图一样，这个模型最终变得极端

00:06:14.409 --> 00:06:19.269
对很多事情有用，所以这不像我们刚刚看到的API，而是

00:06:19.269 --> 00:06:22.959
但是可以在这种线程中描述数据结构

00:06:22.959 --> 00:06:28.139
定向的方式非常有用，因为它意味着各方可以遵循

00:06:28.139 --> 00:06:32.649
跟进内部，然后获取变化的反馈，然后进行调整

00:06:32.649 --> 00:06:37.689
因此，这也意味着您可以序列化所有这些

00:06:37.689 --> 00:06:42.639
更新，然后稍后对其进行推理，因此API并非如此，因此该API

00:06:42.639 --> 00:06:47.409
想到这可能会使用一种结构，而um会提供

00:06:47.409 --> 00:06:50.319
查看事件的整个历史的能力，这是一个

00:06:50.319 --> 00:06:54.490
很多政党在别针上关心的事情使一些政党

00:06:54.490 --> 00:06:58.209
只在乎知道事情已经被钉住了，其他各方都在乎

00:06:58.209 --> 00:07:02.379
确切知道谁在什么时间点固定东西，以及是否固定

00:07:02.379 --> 00:07:07.329
拥有，当它固定在销钉上时，在任何类型的销钉中特别有用

00:07:07.329 --> 00:07:12.849
协作环境，一群不同的聚会在一起

00:07:12.849 --> 00:07:19.489
备份一些重要的数据集，让我们根据APR来解决问题的范围

00:07:19.489 --> 00:07:24.649
今天既是本地的又是远程的，有一个本地固定命令，然后

00:07:24.649 --> 00:07:28.969
当然有远程固定服务固定，我们如何做到这一点

00:07:28.969 --> 00:07:32.749
一堆含义和应用程序，因为应用程序必须告诉ipfs

00:07:32.749 --> 00:07:37.999
保留东西或应用程序必须知道的希望

00:07:37.999 --> 00:07:41.869
他们需要的是那里也有应用程序和服务

00:07:41.869 --> 00:07:47.209
因为该API在定义许多基础架构的过程中是如何定义的，

00:07:47.209 --> 00:07:52.519
服务正确，因此该API的工作方式最终会影响很多人

00:07:52.519 --> 00:07:56.149
运行中的基础架构最终必须要进行构建，因此在一天结束时

00:07:56.149 --> 00:08:00.289
固定是非常关键的体系结构组件，如今，本地固定

00:08:00.289 --> 00:08:05.059
有一些问题，例如，如果您

00:08:05.059 --> 00:08:11.209
如果两个不同的应用程序将相同的CID引脚固定为相同，您会打电话

00:08:11.209 --> 00:08:14.629
发生的是，第一个成功了，第二个成功了，因为

00:08:14.629 --> 00:08:19.610
已经被钉住了，但是如果其中一个被钉住了，它就会被钉住

00:08:19.610 --> 00:08:23.689
都将其删除，所以这是一个仅需解决的问题

00:08:23.689 --> 00:08:27.619
固定在不同用户或不同用户应该有可能的地方

00:08:27.619 --> 00:08:32.329
独立固定相同CID的应用程序

00:08:32.329 --> 00:08:38.419
这类棘手的问题，但这是最棘手的问题

00:08:38.419 --> 00:08:42.949
具体示例最有用的具体示例有两件事

00:08:42.949 --> 00:08:49.939
这使得固定很难，这不仅考虑了访问控制，还考虑了访问控制。

00:08:49.939 --> 00:08:54.410
谁会固定某些东西，尤其是在那种设置中

00:08:54.410 --> 00:08:59.449
各方或许多应用程序可能具有控制权，或者可能具有某些控制权

00:08:59.449 --> 00:09:04.970
可以访问情节，但也可以在需要固定内容的情况下使用

00:09:04.970 --> 00:09:08.660
但这并不意味着您想将其提供给其他人或想要固定

00:09:08.660 --> 00:09:13.730
某些东西，但是您只想将其提供给部分用户，因此可以访问

00:09:13.730 --> 00:09:18.529
控制与人们所要求的数据的性质紧密相关

00:09:18.529 --> 00:09:23.899
固定，因此有一些与内容相关的政策与

00:09:23.899 --> 00:09:27.439
与固定直接相关，但它们彼此相邻，因此

00:09:27.439 --> 00:09:31.130
最终解决的任何解决方案都会很棒

00:09:31.130 --> 00:09:37.670
形成类似的内容访问控制

00:09:37.670 --> 00:09:43.790
对内容路由公告的影响，因此今天ITF estes只是一个公告

00:09:43.790 --> 00:09:47.270
您添加的大部分内容，除非您将其关闭

00:09:47.270 --> 00:09:52.850
但是内容撰写的公告有点像是全有或全无

00:09:52.850 --> 00:09:55.280
任您播报的播音员都不会播报

00:09:55.280 --> 00:10:01.370
名词然后你从一开始就宣布一切，你知道那是一个目标

00:10:01.370 --> 00:10:05.660
最终制定政策，以便您能够描述自己想要的

00:10:05.660 --> 00:10:11.390
宣布以及现在如何更加谨慎地执行此操作以及边缘的种类

00:10:11.390 --> 00:10:14.930
这个问题的问题也很复杂，所以甚至不是现在

00:10:14.930 --> 00:10:18.470
不太清楚您到底想怎么做，有一些想法

00:10:18.470 --> 00:10:23.570
漂浮在社区周围，但我们所处的地方没有出现任何具体的东西

00:10:23.570 --> 00:10:28.250
显然，您知道我们有一个很好的API，可用于如何思考

00:10:28.250 --> 00:10:33.170
公告，但又与固定有关，与相邻的依赖关系和

00:10:33.170 --> 00:10:37.160
我们使用固定所做的一切最终都会影响到这一点，因此它很有用

00:10:37.160 --> 00:10:41.810
考虑一下它的一部分，所以这是一个很大的范围，并且

00:10:41.810 --> 00:10:44.810
这里的问题是找到解决所有这些问题的正确解决方案

00:10:44.810 --> 00:10:49.760
一切顺利，然后我们才有时间尝试一下

00:10:49.760 --> 00:10:53.960
一堆应用程序并使用它来解决速率问题

00:10:53.960 --> 00:10:57.620
产生可能是错误的其他东西，因此关键的是要认识到

00:10:57.620 --> 00:11:01.940
这实际上是将其分解为不同的问题并将其分阶段实施

00:11:01.940 --> 00:11:05.930
这样，但也记住这些东西是非常相关的意思，

00:11:05.930 --> 00:11:11.240
我们最终为固定所做的一切都会对应用程序产生影响

00:11:11.240 --> 00:11:19.910
服务等等等等，尽管这样，我会

00:11:19.910 --> 00:11:25.280
经历一些希望，对于此API，这不是

00:11:25.280 --> 00:11:29.720
我只是介意这是从许多笔记中收集的

00:11:29.720 --> 00:11:34.700
在整个社区中，因此首先要配置的针脚应该是

00:11:34.700 --> 00:11:39.410
一流的对象，所以今天的销钉有点像这种大销钉套装，但是您

00:11:39.410 --> 00:11:44.089
不能真正以相同的方式引用销钉，就像您可以说的一样。

00:11:44.089 --> 00:11:48.680
分支或标签并获得，因此很明显

00:11:48.680 --> 00:11:52.310
很多接口都希望将pin设为一流的对象，而我喜欢

00:11:52.310 --> 00:11:55.370
固定服务可以做到这一点，因此今天的便士服务将固定销视为

00:11:55.370 --> 00:11:58.910
一级对象具有一堆与图钉和和相关联的元数据

00:11:58.910 --> 00:12:03.140
有这样的情况，引脚也应该具有唯一性

00:12:03.140 --> 00:12:07.730
解决我们之前在应用程序中描述的问题的方法

00:12:07.730 --> 00:12:11.150
旋转相同的东西，然后只有其中之一将其删除并删除

00:12:11.150 --> 00:12:15.200
对于另一方来说，痛苦有一个独特的处理方式，然后您知道两个

00:12:15.200 --> 00:12:19.190
对象将被创建，每个应用程序将能够删除该对象

00:12:19.190 --> 00:12:22.750
然后相应地

00:12:24.290 --> 00:12:27.259
我们还应该能够保留引脚变化的历史，因此

00:12:27.259 --> 00:12:33.589
今天ipfs并没有做这个集群，但是在

00:12:33.589 --> 00:12:37.250
能够理解引脚尺寸如何变化的适当想法

00:12:37.250 --> 00:12:40.790
历史记录可能需要随着时间的推移进行垃圾收集，因此这可能在

00:12:40.790 --> 00:12:45.350
ref日志样式的东西或直接在数据结构中

00:12:45.350 --> 00:12:50.449
针设置，工具探索和跟随笔设置也应该很容易，因此

00:12:50.449 --> 00:12:56.060
这意味着像集群之类的东西以及其他类似工具应该能够看到

00:12:56.060 --> 00:13:00.889
引脚设置的变化和订阅两种事件的类型

00:13:00.889 --> 00:13:08.389
发生，这将使这将大大简化工具

00:13:08.389 --> 00:13:12.800
围绕这些事情建立需求的原因是因为拥有一个

00:13:12.800 --> 00:13:17.600
应该是实时的，并且应该捕捉到更多的事件

00:13:17.600 --> 00:13:23.290
易碎且容易出错，如果您始终可以引用所有日志

00:13:23.290 --> 00:13:27.529
更改，并且您知道自己已经赶上了这些更改，并且您知道自己

00:13:27.529 --> 00:13:33.350
两侧都具有一致性，因此很容易有效地弄乱固定

00:13:33.350 --> 00:13:40.490
如果某个事件丢失或/或成功而没有其他事件则为固定API

00:13:40.490 --> 00:13:46.579
知道聚会或类似的事情非常有用，这是

00:13:46.579 --> 00:13:50.000
引脚的范围也应视每个应用程序实例而定，因此

00:13:50.000 --> 00:13:58.610
现在，工具中的钉扎API最终创建了一个很大的范围

00:13:58.610 --> 00:14:04.760
在您未按顺序排列的地方，您会知道成千上万的图钉，依此类推

00:14:04.760 --> 00:14:07.970
现实中，他们通常只是想保持他们认为自己在乎的一切

00:14:07.970 --> 00:14:12.260
本地文件，例如EMF或宫殿树文件，因此可能只是其中之一

00:14:12.260 --> 00:14:16.850
固定这是一个变化很大的固定，但我也许可以是一个

00:14:16.850 --> 00:14:21.709
固定或其他一些可能想要的其他应用程序

00:14:21.709 --> 00:14:26.630
也许一起跟踪数据集，但不想让您知道

00:14:26.630 --> 00:14:31.819
分别有数百个引脚，我们只想有一个引脚，所以如果

00:14:31.819 --> 00:14:37.220
这些接口支持者现在这种事情

00:14:37.220 --> 00:14:42.410
另一件事是，这对于旋转对象将非常有用

00:14:42.410 --> 00:14:48.380
在创建销钉的用户创建销钉时跟踪销钉上的一些元数据

00:14:48.380 --> 00:14:53.360
或应用程序创建了自旋和种类，因此适用于集群或其他用例

00:14:53.360 --> 00:14:57.380
这意味着什么样的复制因素和复制因素

00:14:57.380 --> 00:15:00.980
可能意味着您知道创建独立的副本可能意味着Razr编码

00:15:00.980 --> 00:15:06.230
那里有很多潜在的东西，所以理想情况下，如果我们获得

00:15:06.230 --> 00:15:10.040
可以只在十个字节上分配一些元数据的能力，那么那应该是

00:15:10.040 --> 00:15:15.470
现在应该足够用于远程api了，我们也希望

00:15:15.470 --> 00:15:20.360
别针别针是一个一流的对象，我们应该能够单独绘制

00:15:20.360 --> 00:15:25.010
在基坑物体上，我们应该能够将其固定在大头针组的大头针上

00:15:25.010 --> 00:15:28.010
集群用例，我们现在应该能够遵循图钉设置，值得注意的是

00:15:28.010 --> 00:15:31.190
不同的服务想要做不同的事情有些服务是

00:15:31.190 --> 00:15:35.960
今天建立在个别引脚操作的基础上，我们希望

00:15:35.960 --> 00:15:40.640
继续执行此操作，其他服务将需要遵循该引脚设置

00:15:40.640 --> 00:15:44.630
方法的类型，所以这确实表明确实存在

00:15:44.630 --> 00:15:51.860
应该是将两种不同的瓷器放在相同的基础api上

00:15:51.860 --> 00:15:55.640
还应注意的是，不同的服务对其限制有限制。

00:15:55.640 --> 00:16:00.470
身份验证，因此尽管许多团体都希望能够到达

00:16:00.470 --> 00:16:06.500
在单一的验证系统上，这实际上是根本不可能的，

00:16:06.500 --> 00:16:10.340
不同的服务将需要不同种类的身份验证系统

00:16:10.340 --> 00:16:15.740
因此，无论该API做什么，都应该在它周围停顿一下，或者应该

00:16:15.740 --> 00:16:20.750
通过不透明的身份验证令牌，这在以下方面也很重要

00:16:20.750 --> 00:16:24.890
付款，因此您考虑通过这些身份验证进行付款

00:16:24.890 --> 00:16:32.690
系统不只是呃，不只是说出令牌来标识您可能想要的一方

00:16:32.690 --> 00:16:36.830
通过不透明的付款，因为这可能是条纹的事情，这可能是

00:16:36.830 --> 00:16:44.060
加密货币，这可能是各种各样事物的所有宿主，因此

00:16:44.060 --> 00:16:48.080
无论我们在API中做什么，它都应该与所有不同的版本兼容

00:16:48.080 --> 00:16:51.140
人们使用各种不同类型的支付系统的高度

00:16:51.140 --> 00:16:55.730
您应该有一种做事的方式，我们也应该能够

00:16:55.730 --> 00:17:01.010
明确区分钉扎与推拉还是推拉

00:17:01.010 --> 00:17:06.290
是将您知道的整个图推给另一方的过程，或者

00:17:06.290 --> 00:17:11.030
为另一方绘制整个图，该操作可能会很昂贵，并且

00:17:11.030 --> 00:17:14.809
这与Hey的意图完全不同，我希望您继续

00:17:14.809 --> 00:17:18.470
周围的东西，所以有一个API可以真正区分那些

00:17:18.470 --> 00:17:22.939
三是一件有用且重要的事情，这是在

00:17:22.939 --> 00:17:29.240
在线程对话和github中，我们希望能够

00:17:29.240 --> 00:17:32.929
保持与固定服务的联系，因此会有很多应用程序

00:17:32.929 --> 00:17:37.130
喜欢快速地将事情推向依赖服务，或者我们希望获取

00:17:37.130 --> 00:17:41.120
来自与该应用程序关联的固定服务的信息，以及

00:17:41.120 --> 00:17:45.350
最终导致当前的Liberty连接管理可能

00:17:45.350 --> 00:17:48.260
最终关闭与固定服务的连接，这是其正常状态的一部分

00:17:48.260 --> 00:17:52.429
一种连接垃圾收集，所以这是一件有用的事情，因为它

00:17:52.429 --> 00:17:57.440
保持较低的连接数，但理想情况下，我们喜欢强制那些

00:17:57.440 --> 00:18:01.130
连接保持打开状态，并且由于某种原因而关闭时，请尝试重新打开

00:18:01.130 --> 00:18:06.679
它们与if的其他需求类似，在这种情况下，对它们进行分类真的很有用

00:18:06.679 --> 00:18:11.330
维护群集节点之间的连接或能够维护连接

00:18:11.330 --> 00:18:15.620
之间的类似对等对等系统之间，需要能够

00:18:15.620 --> 00:18:19.400
有流量在流，因此绘画服务和钉扎API会

00:18:19.400 --> 00:18:23.450
得益于液体的使用，我们将从中受益匪浅

00:18:23.450 --> 00:18:29.590
建立类似于持久性长期连接的连接，然后

00:18:29.590 --> 00:18:34.549
应该可以使用相同的固定API固定到多个服务

00:18:34.549 --> 00:18:39.440
因此理想情况下，可以针对可能具有以下特征的一个API构建应用程序和工具

00:18:39.440 --> 00:18:42.530
多种口味，但语义上是相同的，数据结构是

00:18:42.530 --> 00:18:45.620
同样的事情，但后来被很多人消耗和使用

00:18:45.620 --> 00:18:51.230
不同的服务，所以这的另一部分是

00:18:51.230 --> 00:18:55.370
区分我们在谈论的经济交易，因此当我们交谈时

00:18:55.370 --> 00:19:00.050
关于固定，我们明确地说，嘿，请存储此数据，但我们

00:19:00.050 --> 00:19:04.580
隐含地还说，嘿，请从潜在的地方获取数据

00:19:04.580 --> 00:19:07.429
我嘿，也请把数据送回

00:19:07.429 --> 00:19:11.659
在某些时候我可能还会将数据提供给其他人

00:19:11.659 --> 00:19:15.710
许多具有截然不同成本的经济安排都嵌入其中

00:19:15.710 --> 00:19:18.919
一个，因此这使得固定服务提供商很难

00:19:18.919 --> 00:19:22.610
区分这些不同功能的成本，因此

00:19:22.610 --> 00:19:26.510
这里的目标是能够区分这些目标，以便固定

00:19:26.510 --> 00:19:31.460
服务运营商可以为所有这些运营分配不同的成本，也可以不分配

00:19:31.460 --> 00:19:36.860
但至少有足够的灵活性能够做到这一点，所以无论我们在做什么

00:19:36.860 --> 00:19:41.360
在这些api中，我们应该能够使这些东西与众不同

00:19:41.360 --> 00:19:46.340
有点缩小了想法，嘿，我们有某种

00:19:46.340 --> 00:19:50.210
推动将图形明确地传输到可能是免费的或可能不是免费的远程

00:19:50.210 --> 00:19:55.309
我们要明确表达的操作意图来存储和备份一些

00:19:55.309 --> 00:20:00.950
可能是或不是自由操作的数据，我们想表达我们

00:20:00.950 --> 00:20:05.870
希望能够从特定的遥控器中提取和下载图形

00:20:05.870 --> 00:20:09.740
或可能不是免费的操作，可能是我的图表，也可能是某人

00:20:09.740 --> 00:20:14.150
其他图，因此此请求项需要进行某种身份验证

00:20:14.150 --> 00:20:19.429
可能是因为那个交易，所以它不只是一个图钉

00:20:19.429 --> 00:20:23.299
需要进行身份验证的操作是拉交易

00:20:23.299 --> 00:20:27.740
以及需要进行身份验证的内容，

00:20:27.740 --> 00:20:32.480
固定对象可能表达一些发布意图，所以该怎么办？

00:20:32.480 --> 00:20:37.760
这意味着我应该能够同意固定服务

00:20:37.760 --> 00:20:41.210
那个-请存储并服务

00:20:41.210 --> 00:20:45.980
免费向他人收费并向我收取费用，以便这种意图

00:20:45.980 --> 00:20:49.220
可以用图钉的元数据或其他一些形式表达

00:20:49.220 --> 00:20:56.179
NE的设施还可以，所以有很多希望

00:20:56.179 --> 00:21:01.159
人们可能会希望从该API中获得许多不同的东西，这又是什么？

00:21:01.159 --> 00:21:03.860
最终有意义的是分解问题

00:21:03.860 --> 00:21:07.010
分成这些不同的部分，您开始看到某种形状

00:21:07.010 --> 00:21:11.630
它的出现，然后看看我们可以采取什么样的路线图

00:21:11.630 --> 00:21:15.409
尽快满足最重要的需求，并进一步了解

00:21:15.409 --> 00:21:18.800
设计是我可靠的，然后一种

00:21:18.800 --> 00:21:24.320
以后再推一些方向，所以我有点缩小到建议的六个范围

00:21:24.320 --> 00:21:29.330
更改等，这些都是我将在集线器上编写并放上的

00:21:29.330 --> 00:21:36.050
现在是它主要是在笔记中，依此类推，所以必须变得很好

00:21:36.050 --> 00:21:40.190
结构化为RFC样式的提案，但我会给出

00:21:40.190 --> 00:21:42.740
这里是简短的摘要，因为我以后对人们的反馈非常感兴趣

00:21:42.740 --> 00:21:48.410
今天在敬拜的时间，所以改变一个是最终

00:21:48.410 --> 00:21:54.170
输入本地调整API，引入待处理对象以吸引元数据，因此我们

00:21:54.170 --> 00:21:59.420
前面已经提到过了，所以不再赘述，别针设置了

00:21:59.420 --> 00:22:02.420
应该演变为可以跟踪这些对象，而不仅仅是C ID

00:22:02.420 --> 00:22:06.740
他们也应该直接解决我们强调的那种问题

00:22:06.740 --> 00:22:13.580
在此之前，应该可以为服务或工具创建Pin API

00:22:13.580 --> 00:22:18.710
来处理最简单的情况，所以今天的大多数服务都只是像

00:22:18.710 --> 00:22:24.230
能够创建读取更新和删除图钉的原始样式API，因此

00:22:24.230 --> 00:22:29.540
那种基本的简单事情应该只适用于简单的API，并且

00:22:29.540 --> 00:22:32.390
可能在IP第一节点周围，也可能这样，所以它可能会错过

00:22:32.390 --> 00:22:36.500
流量第一个节点，也可能是其他一些服务器，所以这是

00:22:36.500 --> 00:22:41.360
值得庆幸的是，大多数事情已经完成了，所以我们可以做到这一点，这是

00:22:41.360 --> 00:22:45.050
最紧迫的事情，所以大多数社区真的需要这个

00:22:45.050 --> 00:22:50.390
事情更容易发生，对未来也有好处，我们还需要一个

00:22:50.390 --> 00:22:54.980
销螺纹API，因此这对于种类丰富的API极为有用

00:22:54.980 --> 00:22:58.760
这些前瞻性案例，例如集群和许多应用程序

00:22:58.760 --> 00:23:04.910
才能拥有一个API，该API可以为我们提供整个数据结构

00:23:04.910 --> 00:23:08.750
随着事物的添加和移除，销钉设置发生了什么变化的历史等

00:23:08.750 --> 00:23:13.910
并让各方能够实时并理想地跟随

00:23:13.910 --> 00:23:18.230
复制整个内容，以便此类线程对象和pin对象

00:23:18.230 --> 00:23:22.759
应该是我科迪的股权草吗

00:23:22.759 --> 00:23:26.899
值得注意的是，这些不是连续的，所以这些不同的建议

00:23:26.899 --> 00:23:30.349
更改可能会以相同的销钉最终以任何顺序发生

00:23:30.349 --> 00:23:35.269
数据结构，但我们可以按照不同的顺序进行构建

00:23:35.269 --> 00:23:39.649
顺序，因此我建议我们经历为创建简单API的知识p0

00:23:39.649 --> 00:23:44.509
服务需求，然后再进行其他三个更改，

00:23:44.509 --> 00:23:49.190
这些与钉扎并不完全相关，但它们是相邻的，所以一个

00:23:49.190 --> 00:23:52.969
其中的一个是添加推挽API，所以值得庆幸的是，这已经是

00:23:52.969 --> 00:23:57.799
由于图形和集成，部分原因是在飞行中

00:23:57.799 --> 00:24:03.829
数据传输组件，我们中的一些人一直在努力

00:24:03.829 --> 00:24:07.929
使推入和拉出整个IP LD图变得容易，并且

00:24:07.929 --> 00:24:13.969
通过它来关联身份验证或付款，因此这是一个

00:24:13.969 --> 00:24:17.959
实际上是需要的，以便能够四处移动我觉得D图和

00:24:17.959 --> 00:24:22.789
能够与他们建立支付渠道，但在BFS中也需要

00:24:22.789 --> 00:24:27.169
能够对说“嘿”的内容进行身份验证，我真的只希望能够

00:24:27.169 --> 00:24:32.209
提供该特定方并能够对其进行身份验证

00:24:32.209 --> 00:24:36.799
聚会成为有用的功能，因此大多数代码是这样编写的

00:24:36.799 --> 00:24:41.289
它已经必须进入BFS

00:24:41.289 --> 00:24:46.819
我们也想要一种持久的个人管理对等体的方法，所以这是

00:24:46.819 --> 00:24:50.719
围绕这个问题，我们只是需要某种形式的正式化

00:24:50.719 --> 00:24:54.229
然后推动它，这对于所有固定都是一件有价值的事情

00:24:54.229 --> 00:24:58.459
服务，我们应该以在某个时候做到这一点为目标，

00:24:58.459 --> 00:25:01.849
最后一个是以前没有提到过的东西

00:25:01.849 --> 00:25:08.809
令我震惊的是，许多此类api确实可以解决

00:25:08.809 --> 00:25:13.069
我现在宣称的事实还没有一种轻松委派API的方式

00:25:13.069 --> 00:25:17.989
呼叫其他IP节日，因此IP FS节点无法引起远程呼叫

00:25:17.989 --> 00:25:21.919
当然，由于信任的原因，另一个IP fest节点也可以

00:25:21.919 --> 00:25:25.879
以经过验证的方式进行操作，因此需要经过验证的远程操作

00:25:25.879 --> 00:25:31.159
API可以解决很多此类问题，但这是一个巨大的问题

00:25:31.159 --> 00:25:35.149
任务，并且需要仔细考虑哪种API

00:25:35.149 --> 00:25:38.779
是您可能想这样做，但这可能对外部有用

00:25:38.779 --> 00:25:41.750
清洁服务，因为它可能不只是手，可能是一大堆

00:25:41.750 --> 00:25:45.320
突然变得容易使用的其他操作的一部分

00:25:45.320 --> 00:25:54.250
必须写很多代码，所以最后一部分是当我有

00:25:54.250 --> 00:26:01.279
提到了，但是APS看起来像我早跑的样子，所以我会

00:26:01.279 --> 00:26:06.559
嗯，我现在给你看片子，而不是那种经历

00:26:06.559 --> 00:26:11.059
我将只介绍今天的研讨会固定服务API

00:26:11.059 --> 00:26:14.299
这就是我们将要讨论的真正着陆于

00:26:14.299 --> 00:26:19.909
人群操作，然后为线程提及

00:26:19.909 --> 00:26:24.020
这里有很多要求，我不会因为他们而入狱

00:26:24.020 --> 00:26:29.330
您熟悉集群用例，但您会知道

00:26:29.330 --> 00:26:32.090
非常仔细地思考这个问题，并思考它的整体形状

00:26:32.090 --> 00:26:39.130
ACL的问题和重要性等等，我着眼于以下事实：

00:26:39.130 --> 00:26:45.049
纺织线程是正确的数据结构，它几乎覆盖了所有

00:26:45.049 --> 00:26:48.830
用例（如果不是所有用例）这些我们曾担心过的用例

00:26:48.830 --> 00:26:55.730
关于它是一个IP LD图，它允许创建很多更新的事件日志

00:26:55.730 --> 00:26:59.840
as和delete等，它内置了所有类型的加密

00:26:59.840 --> 00:27:04.880
能够读取或写入其不同部分的工具

00:27:04.880 --> 00:27:09.830
和/或能够复制所有内容而又无法读取它，这是一个

00:27:09.830 --> 00:27:13.880
用于复制集群的访问控制的重担

00:27:13.880 --> 00:27:20.120
所以这样的事情很可能整个固定

00:27:20.120 --> 00:27:24.710
线程API将变成纺织线程，我们仍然必须

00:27:24.710 --> 00:27:28.220
进行一堆针对使用该类型的尝试的实验，依此类推，然后执行

00:27:28.220 --> 00:27:30.860
繁重的举重，但首先要感谢的是这种风格

00:27:30.860 --> 00:27:35.029
创建所有这些并基本实现它，您就会知道所有

00:27:35.029 --> 00:27:40.460
围绕这复杂的逻辑，很可能将一个家伙固定在一个

00:27:40.460 --> 00:27:44.860
显然最终会朝着这个方向发展

00:27:45.200 --> 00:27:48.200
如果您绝对还没有读过这篇文章，那就去做吧

00:27:48.200 --> 00:27:55.850
将会改变您编写许多应用程序的方式，因此

00:27:55.850 --> 00:27:58.610
简短的路线图，今天晚些时候我们将进行崇拜，我们将讨论一些

00:27:58.610 --> 00:28:05.179
接下来，我们将对这些更改和建议进行形式化，

00:28:05.179 --> 00:28:10.190
提交它们，然后希望尽快使用简单的pin服务API

00:28:10.190 --> 00:28:14.240
因为这是人们最需要的，然后在后面的部分中

00:28:14.240 --> 00:28:19.250
到2020年，我们可以朝着在引脚线程API上做出决策的方向迈进，

00:28:19.250 --> 00:28:22.789
所有这些东西，我们可以根据

00:28:22.789 --> 00:28:30.470
人们渴望实现的欲望我知道ffs团队拥有所有

00:28:30.470 --> 00:28:34.580
举手之劳，所以我认为Pin Service API有点像关键部分

00:28:34.580 --> 00:28:38.600
我们可能很快就会做，其他所有事情都会有所收获

00:28:38.600 --> 00:28:42.460
随着时间的流逝好吗谢谢

