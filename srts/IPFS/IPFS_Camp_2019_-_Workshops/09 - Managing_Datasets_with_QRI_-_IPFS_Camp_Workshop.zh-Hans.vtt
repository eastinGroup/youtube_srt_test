WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.619 --> 00:00:04.560
让我们看看现在几点了12点我想我们可以开始了

00:00:04.560 --> 00:00:09.810
非常感谢大家的光临，我要谈谈，我们会

00:00:09.810 --> 00:00:14.130
经历了这一点，但绝对可以，我认为这绝对是我的忠实粉丝

00:00:14.130 --> 00:00:17.429
像学习Python那样的困难方式，就像您键入很多

00:00:17.429 --> 00:00:20.640
时，它会像您喜欢的那样进入您的脑海

00:00:20.640 --> 00:00:23.699
所以今天，如果您有兴趣与我一起做的话

00:00:23.699 --> 00:00:31.169
否则，谢谢您参加有关该项目的查询会议

00:00:31.169 --> 00:00:37.399
我所做的工作让我们确定一下让我们进行演示

00:00:37.399 --> 00:00:41.010
所以这是选修课G希望你在合适的房间里，如果你不在

00:00:41.010 --> 00:00:45.480
我们今天要讨论D Web上的数据集，我想我们会做一些

00:00:45.480 --> 00:00:48.839
混合了这里有多少人喜欢数据科学，他们会自称

00:00:48.839 --> 00:00:54.929
数据科学家，我们得到了两种我所期待的惊人的发现

00:00:54.929 --> 00:00:58.170
在一个做网络的事情上，所以今天我要做两件事，我们要做的是

00:00:58.170 --> 00:01:01.949
向您展示数据科学可能会有所帮助，或者至少会进行数据版本化

00:01:01.949 --> 00:01:05.190
控制可能是高流量曲线，您作为开发人员，我们要谈一谈

00:01:05.190 --> 00:01:10.260
有关查询如何使用ipfs的信息，主要集中在这些方面

00:01:10.260 --> 00:01:14.310
如果您在任何时候都基于IP FS构建并且想要

00:01:14.310 --> 00:01:17.220
阻止我，了解我们的工作方式或获取有关以下内容的更多详细信息

00:01:17.220 --> 00:01:20.640
我们所有的代码都是开源的，我可以直接将您链接到我们的地方

00:01:20.640 --> 00:01:25.860
可以很好地阅读我们代码的代码库

00:01:25.860 --> 00:01:31.950
不会道歉的，但是我很喜欢

00:01:31.950 --> 00:01:35.700
因此，我认为我们会尽力而为，迅速爆炸

00:01:35.700 --> 00:01:38.460
通过像什么查询的快速概述，但再次采取这些

00:01:38.460 --> 00:01:43.020
走弯路进入ipfs，这样我在互联网上就成为b5 Brendan

00:01:43.020 --> 00:01:48.690
我在github上看到我为b5，我从事查询工作，我们查询拼写发音为query spark

00:01:48.690 --> 00:01:56.370
 URI我为此表示歉意，是的，当时看来这是个好主意

00:01:56.370 --> 00:01:59.850
就像续集查询一样，它是关于问题的，

00:01:59.850 --> 00:02:04.440
有点气氛，但在一天结束时查询有关数据集的问题是

00:02:04.440 --> 00:02:07.500
关于ipfs版本集的版本控制是我们的一种

00:02:07.500 --> 00:02:12.490
粒度模型这是一个文档，我们希望考虑我们所需要的一切

00:02:12.490 --> 00:02:14.800
今天要谈论的是关于共享版本控制移动数据集

00:02:14.800 --> 00:02:22.330
周围的人都可以进来，是的，所以我们只想给您一个概述

00:02:22.330 --> 00:02:25.270
心智模型GRU是一种新事物，但它也是所有事物的组合

00:02:25.270 --> 00:02:29.740
我们看到的东西，因为这三样东西最终是一个版本

00:02:29.740 --> 00:02:33.550
控制系统是一个数据库，它出现在网络上

00:02:33.550 --> 00:02:37.720
同时再次在数据集的上下文中考虑所有这些问题

00:02:37.720 --> 00:02:41.500
作为您的文档模型，因此就像您

00:02:41.500 --> 00:02:45.040
使用查询时，您只考虑资产，因此实际上不喜欢担心

00:02:45.040 --> 00:02:51.580
关于这些事情，是的，这是一个非常重要的技术图

00:02:51.580 --> 00:02:57.190
查询工作，我们将Blob放在IP FS之上，这就是

00:02:57.190 --> 00:03:00.940
是的，我们将深入探讨，并将确切探讨这种关系是如何的

00:03:00.940 --> 00:03:06.640
经过谈判，但这就是我所拥有的查询外观网络

00:03:06.640 --> 00:03:11.500
像这样，这就是查询是如何在覆盖网络上进行覆盖网络的

00:03:11.500 --> 00:03:15.370
这很有趣，我认为如果您

00:03:15.370 --> 00:03:19.209
有人用嘴唇p2p，所以如果您有任何疑问，我们可以

00:03:19.209 --> 00:03:23.950
查询是注册为Lib p2p复用处理程序的协议，因此我们可以

00:03:23.950 --> 00:03:28.810
也要详细讨论，但是如果您还没有看到

00:03:28.810 --> 00:03:33.850
分组二进制，您正在家里玩，让我们再次快速

00:03:33.850 --> 00:03:36.790
提醒任何迟到的人，如果我们

00:03:36.790 --> 00:03:39.489
可以跳过一些东西，因为我们有这些

00:03:39.489 --> 00:03:42.790
概述事情，以便我们回避一些问题，您可以在这里回来

00:03:42.790 --> 00:03:46.780
就像检查完成一样，他们稍后会有一个教程，所以如果我们过一段时间的话

00:03:46.780 --> 00:03:49.870
随着时间的推移，我不认识其他人，但我们可以解决所有这些问题，但是我

00:03:49.870 --> 00:03:53.230
基本上要讲这四个步骤，所以第一件事

00:03:53.230 --> 00:03:57.970
我们要做的实际上就是像我们的数据集世界一样

00:03:57.970 --> 00:04:01.060
今天我们要从命令行执行所有这些操作，我们有一个前端

00:04:01.060 --> 00:04:05.980
但我认为喜欢这很有趣，因为我们特别喜欢因为我们要

00:04:05.980 --> 00:04:08.709
在查询中的ipfs之间进行很多交互，这样比较好

00:04:08.709 --> 00:04:11.950
全部来自命令行，所以我要尝试让这个更大的人大吼大叫

00:04:11.950 --> 00:04:16.120
如果这是一个足够大的尺寸或更大的尺寸，请问我

00:04:16.120 --> 00:04:21.010
好的，好的，很酷，所以如果您正在家里玩，并且还没有运行查询

00:04:21.010 --> 00:04:25.210
设置，但是这是要运行的一件事，显然，我会选择

00:04:25.210 --> 00:04:26.530
出现错误，因为我已经设置好了

00:04:26.530 --> 00:04:30.460
会要求您选择您的纯名，即我们可以识别的易读名称

00:04:30.460 --> 00:04:34.630
使用集中式名称注册中心进行注册，但这与您的注册中心非常相似

00:04:34.630 --> 00:04:40.690
github用户名，所以明智地选择任何人，使其成为您的查询设置

00:04:40.690 --> 00:04:45.430
酷，我们赞叹不已，所以我们要做的第一件事就是

00:04:45.430 --> 00:04:51.310
一个新的目录和CD，所以我今天要在桌面上工作

00:04:51.310 --> 00:04:55.830
会去做他们的工作坊，因为我想我会说我称之为工作坊

00:04:56.070 --> 00:05:00.000
酷，然后我还要打开一个文本编辑器，如果您是

00:05:00.000 --> 00:05:05.530
某种代码忍者，无论您喜欢什么，我都会关闭它，这非常有用

00:05:05.530 --> 00:05:10.000
首先，这很酷，我要在这里做什么

00:05:10.000 --> 00:05:23.770
做这个研讨会很酷，对不起，研讨会变成了一个新的新鲜事物，所以我

00:05:23.770 --> 00:05:27.190
没有文件，离开后，我将文本编辑器设置为白色，这确实是

00:05:27.190 --> 00:05:30.639
把我扔掉，但是最好看看，所以我要做的第一件事就是

00:05:30.639 --> 00:05:35.470
要回到该教程，然后将其随机复制并粘贴

00:05:35.470 --> 00:05:44.229
东西，我将这个叫点CSV很酷，所以您已经做到了

00:05:44.229 --> 00:05:47.530
会立即注意到他们就像这个数据有点混乱

00:05:47.530 --> 00:05:51.639
这里是一个多余的逗号，这是故意的，因此也要复制并粘贴，

00:05:51.639 --> 00:05:57.220
我们将转到第一个命令，我们将查询保存文件或便盆

00:05:57.220 --> 00:06:02.410
抱歉，基本上只键入一次，我会在稍后解释，但这是

00:06:02.410 --> 00:06:07.830
Home dot CSV然后我要输入我斜线你好

00:06:08.400 --> 00:06:14.370
那没找到我在哪里，演示手，男人

00:06:14.370 --> 00:06:25.770
我不会保存身体的问候，所以今天标签将成为我的朋友，所以

00:06:25.770 --> 00:06:36.750
好的，我必须恢复正常，现在必须重新设置此引线，这很酷

00:06:36.750 --> 00:06:41.430
这是您运行此程序时应该看到的内容，如果每个人都已经看到了

00:06:41.430 --> 00:06:46.260
在后台，这是刚刚创建的数据集版本，因此我们

00:06:46.260 --> 00:06:50.970
在我的PFS土地上看到一些熟悉的东西，这看起来应该很熟悉

00:06:50.970 --> 00:06:56.820
我要把它做大一些，但是在引擎盖下，您会注意到我们已经

00:06:56.820 --> 00:06:59.669
已经收到验证错误，我们没有提供架构或其他任何内容

00:06:59.669 --> 00:07:04.229
查询这只是一个CSV文件查询，在后台进行了很多工作

00:07:04.229 --> 00:07:08.430
有点像试图帮助我们使这些数据可解释的整个问题是

00:07:08.430 --> 00:07:11.970
您可以将非常混乱的数据放入查询中，我们认为您可以开始

00:07:11.970 --> 00:07:15.270
只要能够解析，就可以从几乎是无效的东西开始

00:07:15.270 --> 00:07:18.930
它应该采用您可以用来查询我们的文件格式的类型

00:07:18.930 --> 00:07:26.460
JSON CSV SLX xlsx我永远也不能和Seaborg这么大声说出来，以便您养活

00:07:26.460 --> 00:07:29.370
那些在您进行转换的人中，您可以与任何这些人之间进行转换的任何人

00:07:29.370 --> 00:07:32.430
这些转换中的一些比其他高转换c有点时髦

00:07:32.430 --> 00:07:37.440
对excel文件的战争不是世界上最伟大的事情，但它发生得如此之多

00:07:37.440 --> 00:07:40.139
只是为了解决这里的其他一些争论

00:07:40.139 --> 00:07:44.340
这是一个称为body的参数，我们称为实际数据，我对它进行了设置

00:07:44.340 --> 00:07:47.400
因此，我们将其像HTML HTML页面一样思考，因此我们有了头脑

00:07:47.400 --> 00:07:50.099
这些都是所有其他组件，我们将在稍后介绍它们

00:07:50.099 --> 00:07:53.940
实际数据称为正文只是为了帮助我们区分，因为

00:07:53.940 --> 00:07:57.389
我们将要写很多东西，但是数据集中的其他所有内容

00:07:57.389 --> 00:08:01.530
关于身体，如果您正在思考，身体通常是主要主题

00:08:01.530 --> 00:08:05.160
在表格数据中，大多数数据科学都发生在表格数据中，但完全可以查询

00:08:05.160 --> 00:08:07.979
支持高维数据，JSON大量，无论您想放入什么

00:08:07.979 --> 00:08:14.340
肯定只有结构化的数据，这才是使身体凉爽的东西

00:08:14.340 --> 00:08:19.150
我/你好是数据集名称，所以这是

00:08:19.150 --> 00:08:24.250
无论我的纯名是什么，我都有一个特殊的关键字，所以如果我

00:08:24.250 --> 00:08:28.000
键入我，我一直在指代我目前的名字，我想我的纯名是Fuu，所以

00:08:28.000 --> 00:08:33.190
表示我创建了Fuu斜杠打招呼，如果我结婚只是为了喜欢在

00:08:33.190 --> 00:08:37.780
这个存在，我可以查询日志我斜杠你好，我看到一个日志，嘿，酷我

00:08:37.780 --> 00:08:41.530
制作了一个数据集，看起来应该与获取类似，但是如果您是这里工作的人

00:08:41.530 --> 00:08:48.040
有了很棒的了解您的听众，让我们切入正题

00:08:48.040 --> 00:08:54.910
查询有一些差异，没有暂存区域，没有分支，一切都和

00:08:54.910 --> 00:08:58.360
仓库的概念非常不同，我们将在

00:08:58.360 --> 00:09:02.470
有点，但是要记住的是，当我点击保存时

00:09:02.470 --> 00:09:05.800
直接从您好CSV它现在已经存储了版本，我可以吹走

00:09:05.800 --> 00:09:10.450
CSV文件存储在此哈希中的我的PFS中，我们将对此进行介绍

00:09:10.450 --> 00:09:13.300
但是我接下来要做的是因为我可以吹走我

00:09:13.300 --> 00:09:18.970
要去掉那个错误并在此处添加绿色，再次保存该文件，我

00:09:18.970 --> 00:09:23.860
只是要运行完全相同的命令查询，保存您好，您好，这一次

00:09:23.860 --> 00:09:29.080
数据集错误消失了，如果我创建了正确的锁，如果我查询日志

00:09:29.080 --> 00:09:35.170
我们看到的方式然后我们现在得到数据集提交的所有其他差异

00:09:35.170 --> 00:09:39.460
消息是可选的，我们会自动为您生成一种文本消息

00:09:39.460 --> 00:09:42.070
当前设置的说明中有一个使它看起来有点像的错误

00:09:42.070 --> 00:09:46.870
像GAC在本次演讲中一样，但这是有效的东西，我们实际上

00:09:46.870 --> 00:09:50.380
只是看看数据集内部发生了什么变化，并为您提供了一个很好的

00:09:50.380 --> 00:09:53.800
description有一个提交描述，您可以完全覆盖

00:09:53.800 --> 00:09:57.400
当您要做非常细致的工作时

00:09:57.400 --> 00:10:00.760
留下一个非常真实的审核记录，您想直接覆盖这些消息

00:10:00.760 --> 00:10:03.910
想要发送标题，并且想要留下关于您如何做的事情的踪迹

00:10:03.910 --> 00:10:07.120
您正在做的事情，但在某些情况下您实际上可以

00:10:07.120 --> 00:10:10.630
自动化数据集的更新，我们将在以后介绍，因此有这些

00:10:10.630 --> 00:10:13.420
自动提交消息生成意味着我们不必费力

00:10:13.420 --> 00:10:19.360
如果不需要的话，进入到该循环的中间，这是一个不错的开始

00:10:19.360 --> 00:10:22.420
我们现在知道我们可以快速探索的身体，就像我要回顾的一样

00:10:22.420 --> 00:10:25.570
我们还有另一件事要查询，那就是我们得到某种东西的方式

00:10:25.570 --> 00:10:30.280
是的，如果我只是打招呼，这将告诉您实际上有

00:10:30.280 --> 00:10:33.560
当您使用CSV文件进行PMS时，会有很多事情发生

00:10:33.560 --> 00:10:37.730
我们推断出一个模式，然后我们发现有一个标题行

00:10:37.730 --> 00:10:41.300
确认格式为CSV，我们可以算出其中有多少个条目

00:10:41.300 --> 00:10:44.360
为您计算了一个校验和，我们找出了图的深度

00:10:44.360 --> 00:10:48.170
您的数据，所以我们知道这是一个二维数组，我们知道

00:10:48.170 --> 00:10:52.580
它以字节为单位，我们知道我们并且我们试图推断该数字是整数类型

00:10:52.580 --> 00:10:54.890
因为其中没有浮点值

00:10:54.890 --> 00:10:58.970
我们还为您推断了一个基本的可视化脚本，并将其添加到两个

00:10:58.970 --> 00:11:03.050
ipfs，所有这些都已智能地进行了版本控制，以便您

00:11:03.050 --> 00:11:05.060
更改此数据集中的不同组件，我们将介绍其中一些

00:11:05.060 --> 00:11:08.630
组件这是为您创建的结构组件

00:11:08.630 --> 00:11:12.260
总会有一个提交组件，它是所有实际的版本控制信息

00:11:12.260 --> 00:11:15.589
其中的一部分分别存储在您的IP FS存储库中，我们已经

00:11:15.589 --> 00:11:18.320
在创建新内容时要非常谨慎

00:11:18.320 --> 00:11:20.750
如果您不更改自己的身体数据的版本，则表示我正在复制

00:11:20.750 --> 00:11:24.230
身体，以便思考正在创建的奇迹标签图

00:11:24.230 --> 00:11:27.410
通过这种方式，如果我们不改变车身挡块，我们就会不断地制造新的车身。

00:11:27.410 --> 00:11:30.380
遇到引用相同数据的提交，所以我们有一个非常好的

00:11:30.380 --> 00:11:35.600
如果我们确实更改数据，那么我们所有版本中的重复数据删除因子

00:11:35.600 --> 00:11:40.640
无论如何都会得到新的方块是的，所以就像我可以做的一样

00:11:40.640 --> 00:11:43.760
查询列表，现在我看到我有应该删除的数据集

00:11:43.760 --> 00:11:48.980
以前，但是我在那里有foo你好，大家都好打招呼，所以

00:11:48.980 --> 00:11:52.490
到目前为止，我们关注该部分的任何问题，就像超级基础

00:11:52.490 --> 00:11:56.180
这就是我们创建数据集的方式这基本上是到此为止我们已经清理了

00:11:56.180 --> 00:12:00.320
数据集的quote-unquote，我们已经删除了一个验证错误，但这有点

00:12:00.320 --> 00:12:03.380
就我而言，我们需要从实际的角度出发，例如手动数据创建

00:12:03.380 --> 00:12:07.240
从今天开始的问题

00:12:10.330 --> 00:12:23.860
是是是哦，我们完全破坏了你是个怪胎哦，是的，我在

00:12:23.860 --> 00:12:27.280
这句话的开头，在我们再次将所有刻录副本修剪到我的

00:12:27.280 --> 00:12:33.790
PFS，这个我应该大声说出来，但是我可以帮助您，但是

00:12:33.790 --> 00:12:37.780
我们实际上可以在下一章中讨论有关查询对您IP所做的一切

00:12:37.780 --> 00:12:41.950
最好的仓库，所以如果我们可以清楚地看到正在发生的事情，那么这就是事情的所在

00:12:41.950 --> 00:12:45.490
实际上变得有点适度，所以在本节中，我只是

00:12:45.490 --> 00:12:47.470
在这里打孔，我要输入查询连接

00:12:47.470 --> 00:12:54.640
查询Connect是我们的ipfs守护进程，我们喜欢单词connect more deal，但我们会

00:12:54.640 --> 00:12:57.640
马上注意到，我觉得很有趣，喜欢看我们有

00:12:57.640 --> 00:13:03.730
我发生得太快了，好吧，演示会很有趣，但是我

00:13:03.730 --> 00:13:07.390
要打开网络应用程序，如果我们可以在这里看到它被托管在

00:13:07.390 --> 00:13:14.920
本地主机2505（如果我执行了2505，然后按Enter，这是我们的GUI，因此我们发货）

00:13:14.920 --> 00:13:20.650
通过IP FS，我们拥有一个IP NS，直到遇到DNS记录为止

00:13:20.650 --> 00:13:24.250
不断更新，查询会在每次启动时检查是否看到

00:13:24.250 --> 00:13:27.250
它会尝试获取新的哈希，并将其固定，将其拉到

00:13:27.250 --> 00:13:31.210
查看Evan钉住它，这就是我们在这里看到的内容，特别说“嘿”

00:13:31.210 --> 00:13:34.540
网络应用程序，这一切都是根植于网络，当您首次启动查询时，它实际上只是

00:13:34.540 --> 00:13:36.790
就像将您放入此加载屏幕一样嘿，我们正在尝试找到您的应用

00:13:36.790 --> 00:13:41.350
给我们一点时间，想一想它一旦得到，那么它将永远是

00:13:41.350 --> 00:13:44.380
能够将网络应用还原到至少一个版本，并且它将不断进行排序

00:13:44.380 --> 00:13:47.740
跳到下一版本时，它将取消固定上一个版本

00:13:47.740 --> 00:13:51.520
并固定最新的信息，只是让您的Web应用程序保持最新状态，我认为

00:13:51.520 --> 00:13:55.060
这就像是开始解释我的技术图表的好点

00:13:55.060 --> 00:14:00.750
在IP FS回购之上的查询Blob，这是怎么回事，我们有一个go ipfs副本

00:14:00.750 --> 00:14:06.130
0.4点21作为依赖项导入到查询二进制文件中，依此类推

00:14:06.130 --> 00:14:08.830
这就是为什么我们要计算回购锁定的原因，如果您用光了

00:14:08.830 --> 00:14:12.310
声明是其他您无法拥有该锁的东西

00:14:12.310 --> 00:14:17.740
可以查询还尊重有关ipfs守护程序或BFS goai BFS的所有信息

00:14:17.740 --> 00:14:20.760
如此一来，我的配置就全部

00:14:20.760 --> 00:14:24.329
如果您设置ipfs path，则环境变量就在其中

00:14:24.329 --> 00:14:28.740
查询受到尊重，因此目标只是让查询真正在做什么

00:14:28.740 --> 00:14:33.180
只是在伪造您的存储库来做它认为是做的事情

00:14:33.180 --> 00:14:37.410
特殊且有价值，因此当我们执行查询保存时，会创建一个

00:14:37.410 --> 00:14:41.040
数据集为您固定，并在我查询时将根哈希保留在本地

00:14:41.040 --> 00:14:44.730
删除所有不固定的内容，使其不为您运行垃圾回收

00:14:44.730 --> 00:14:49.230
对于以后要清除这些障碍的任何人都应该注意，但是

00:14:49.230 --> 00:14:54.089
您有关数据集的所有内容都存储在s队列中

00:14:54.089 --> 00:14:59.699
完全独立的东西，就像数据集实际上可以完全起作用

00:14:59.699 --> 00:15:05.279
像实际数据结果一样从查询本身带外

00:15:05.279 --> 00:15:08.880
您可以在网关中查看原始数据，我们将在稍后介绍

00:15:08.880 --> 00:15:12.029
当查询Connect正在运行时，我将打开另一个Turnable，然后显示一些

00:15:12.029 --> 00:15:16.230
类似的，我们有一些内置的东西可以让我们检查查询

00:15:16.230 --> 00:15:19.910
我认为这对这个人群也很有价值，所以如果我查询同行

00:15:19.910 --> 00:15:27.690
清单，我发现与正常情况有所不同，因此我们决定覆盖

00:15:27.690 --> 00:15:33.779
您的纯ID之外的第二个个人资料身份，原因是，如果我

00:15:33.779 --> 00:15:37.350
想要移动我的配置文件或拥有不同的多个IP FS存储库

00:15:37.350 --> 00:15:42.029
我能够做到这一点，所以现在我有了实际的纯名称与

00:15:42.029 --> 00:15:46.649
与我的IP FS存储库的密钥对分开的配置文件ID，我们使用您的

00:15:46.649 --> 00:15:50.940
个人资料ID来签署提交，因此您进行的每一次提交都被签名

00:15:50.940 --> 00:15:55.260
与该密钥对一起存储，并与IP FS f一起存储，并分别进行查询，并且

00:15:55.260 --> 00:15:59.370
因此，每个提交都归因于一个人，这是您审核的一部分

00:15:59.370 --> 00:16:03.449
日志，没有人显然要感谢密码学，除非您做某事

00:16:03.449 --> 00:16:06.660
那个密钥对或那个密钥对的私有端是愚蠢的，没人能做

00:16:06.660 --> 00:16:11.459
提交看起来像您的查询，因此这与获取非常相似

00:16:11.459 --> 00:16:14.310
获取经过验证的提交，这就是我们帮助所有提交的起点

00:16:14.310 --> 00:16:20.310
总是在查询中得到验证，因此我可以列出我的职业对，也可以列出我的ipfs

00:16:20.310 --> 00:16:23.790
通过充其量做网络的啤酒，我看到一个非常不同的数字

00:16:23.790 --> 00:16:29.400
现在在95播放，由于油的原因，我们调试很久了

00:16:29.400 --> 00:16:32.130
列出了连接管理器中的内容，我们应该考虑一下

00:16:32.130 --> 00:16:36.120
出来，但是在那里，我们实际上也有一个很好的例子，说明了我们在什么时候做的事情

00:16:36.120 --> 00:16:40.170
我们找到支持支持查询的Zeus出现的位置，并与连接管理器对话

00:16:40.170 --> 00:16:43.680
我们说嘿，这个对等点支持查询，我们将这个数字加上一点

00:16:43.680 --> 00:16:46.890
现在是任意的，但它是一百，基本上说嘿，请挂起

00:16:46.890 --> 00:16:49.200
尽可能长时间地保持该连接

00:16:49.200 --> 00:16:52.230
并且根据我们的经验，随着时间的推移，这种情况越来越好

00:16:52.230 --> 00:16:59.550
谢谢ipfs团队，是的，所以我认为这有点像

00:16:59.550 --> 00:17:03.270
如您所见，查询幕后发生的事情

00:17:03.270 --> 00:17:06.600
就像在IP FS上分层一些技术一样，但是我们也随时随地

00:17:06.600 --> 00:17:11.250
可能会加入我们也喜欢的常规ipfs通信中，但我们

00:17:11.250 --> 00:17:15.180
有一些好处，我可以在这里查询

00:17:15.180 --> 00:17:21.600
列出第一件衬衫蓝色这里是连接蓝色我可以给一个同伴的名字

00:17:21.600 --> 00:17:27.089
它将自动进入查询从地址中拉出的链接

00:17:27.089 --> 00:17:30.720
通讯录中查找最新的场景配置文件ID是什么，然后尝试

00:17:30.720 --> 00:17:35.100
与他们建立联系有时并不能一直有效

00:17:35.100 --> 00:17:37.500
取决于您最近看到那个同龄人的原因，因为我们实际上一直在坚持

00:17:37.500 --> 00:17:41.610
其中一些数据，并且我们知道变化很大，但是如果您能弄清楚的话

00:17:41.610 --> 00:17:44.400
一种连接方式，您可以将其命名，然后再连接，但是您

00:17:44.400 --> 00:17:48.810
也可以在这里传递经典的多地址，你也可以像p4一样

00:17:48.810 --> 00:17:52.530
等等等等，这也只会将其委托给ipfs

00:17:52.530 --> 00:17:58.950
连接也可以在查询运行时进行，因为go ipfs是核心湿HTTP

00:17:58.950 --> 00:18:05.640
暴露了api，我们可以执行所有常用的ipfs命令，因此ipfs--api IP

00:18:05.640 --> 00:18:18.120
默认为127点0点0点1点斜杠2 CP / 5001

00:18:18.120 --> 00:18:24.740
是的，它的确感谢您，所以您仍然可以与API进行交流

00:18:24.740 --> 00:18:29.990
包括我们也会从您的正常生活中浮出水面，就像我们尝试像约翰尼一样

00:18:29.990 --> 00:18:34.490
当我们必须锁定时，您的观点使其尽可能无缝

00:18:34.490 --> 00:18:38.900
不想成为ipfs生态系统的不良公民，因此我们仍然运行网络

00:18:38.900 --> 00:18:41.900
用户界面有关网关的所有内容仍在您可以运行的情况下运行

00:18:41.900 --> 00:18:45.350
配置pub / sub并向下传递，就像两个参数一样

00:18:45.350 --> 00:18:48.890
go ipfs守护进程命令行的特殊命令，您可以设置该查询

00:18:48.890 --> 00:18:53.240
配置，以便将其传递下去，我们有些人正在使用pub / sub

00:18:53.240 --> 00:18:57.040
听一个查询是否创建了资产，然后协调谁

00:18:57.040 --> 00:19:00.470
复制这些引脚，使它们远超我们

00:19:00.470 --> 00:19:05.750
他们正在飞机监视中，这很有趣，但是很酷，这很不错

00:19:05.750 --> 00:19:08.630
关于这种相互作用如何工作的任何问题，我的意思是我认为这是

00:19:08.630 --> 00:19:11.440
可能是这个人群可能对这个东西更感兴趣的部分

00:19:11.440 --> 00:19:14.440
任何事物

00:19:26.550 --> 00:19:31.770
对对对，所以目标是

00:19:31.770 --> 00:19:35.310
标准是人类可能做到的，所以我们显然将其保留在最后

00:19:35.310 --> 00:19:40.110
我们不得不打入我正在研究的API事情，我认为我们可以

00:19:40.110 --> 00:19:45.720
也差不多，但是如果有的话，它应该表现出完全相同的范围

00:19:45.720 --> 00:19:50.400
与我们眼中的偏离是一本书，但显然我们还有其他

00:19:50.400 --> 00:20:02.190
可以叠加在上面，是的，所以目前有点

00:20:02.190 --> 00:20:05.970
我们的设计（例如I PMS守护程序和查询）的局限性

00:20:05.970 --> 00:20:16.140
彼此冲突，因为他们试图拥有回购锁定，但是是的，并且

00:20:16.140 --> 00:20:19.350
我认为我们可以通过多种方式开始编程，例如

00:20:19.350 --> 00:20:23.730
关于工作的核心API的好处是，我们将能够

00:20:23.730 --> 00:20:28.830
核心API的HTTP API版本，现在就谈谈吧，唯一的限制是

00:20:28.830 --> 00:20:31.410
就像我们实际上向不注册主机的流处理程序注册

00:20:31.410 --> 00:20:34.950
通过Cori API向我们公开的信息，因此我们需要谨慎对待我们的方式

00:20:34.950 --> 00:20:37.860
这样做，但我认为从长远来看这是可行的，我只需要弄清楚

00:20:37.860 --> 00:20:42.990
解决方案，我们只是在炫耀

00:20:42.990 --> 00:20:48.330
这让我们继续进行第三课，在不到三课的时间内我们要做什么？

00:20:48.330 --> 00:20:53.010
我们实际上会变得很酷，所以我觉得喜欢

00:20:53.010 --> 00:20:55.710
看一些数据，所以这是不同的

00:20:55.710 --> 00:21:00.300
我的意思是我要杀死左边的查询Connect，在这种情况下，我只是

00:21:00.300 --> 00:21:07.650
打孔哦，是的，让我们先做这个，所以另一件事是不同的，我们正在尝试

00:21:07.650 --> 00:21:14.220
运行对两个互联网都可见的服务，因此当您发布时，这是一个

00:21:14.220 --> 00:21:19.680
peccary io / vv / p2p请注意我们的领先优势，这就是您所看到的

00:21:19.680 --> 00:21:23.820
这里没有软件，这是网站或网页，这是我们为最终做出的反应

00:21:23.820 --> 00:21:27.000
但以只读模式运行，因此我们积极尝试让您

00:21:27.000 --> 00:21:31.570
是的，下载现有的应用程序，但这允许其他

00:21:31.570 --> 00:21:34.960
看到这种情况的人会看到您正在发布的数据，包括哪些

00:21:34.960 --> 00:21:39.010
我们计划在下个季度使用该工具，这是一个

00:21:39.010 --> 00:21:42.760
react应用程序，我们将呈现此服务器端并将所有内容

00:21:42.760 --> 00:21:46.630
谷歌数据集搜索，因此您实际上将与发布查询时一样

00:21:46.630 --> 00:21:50.590
将显示在Google的数据集搜索中，我们认为这非常重要，因此

00:21:50.590 --> 00:21:54.670
跨兼容性的东西，我们故意偏向于

00:21:54.670 --> 00:21:58.390
分布式Web的重点是向不了解这些信息的人显示信息

00:21:58.390 --> 00:22:02.920
对网络发行一无所知，但您会在网络应用中注意到这一点

00:22:02.920 --> 00:22:08.020
事情的一面我该如何连接到您的任何听到的连接，抱歉在网络上

00:22:08.020 --> 00:22:14.440
应用程序方面，我们拥有可视化功能，我们也拥有身体数据，因此

00:22:14.440 --> 00:22:18.070
我实际上可以在这里看到实际的身体信息，这很好

00:22:18.070 --> 00:22:21.880
因为我正在为本地ipfs节点获取此信息，所以这是我们的

00:22:21.880 --> 00:22:25.090
丰富的信息，我在本地操作，还是在非本地操作

00:22:25.090 --> 00:22:28.710
分布式Web，这里没有任何集中式服务的负载

00:22:28.710 --> 00:22:34.090
但是当您进行查询时，我们将能够为您提供实际的信息服务

00:22:34.090 --> 00:22:38.980
运行查询发布您正在发布到我们的固定服务

00:22:38.980 --> 00:22:42.760
该数据集适合您，我们保留的只是棒形块

00:22:42.760 --> 00:22:46.540
您，这意味着它也可以在网关上使用，因为我们可以

00:22:46.540 --> 00:22:50.620
现在关闭灰色的连接器，我是否曾经说过我要削减这个

00:22:50.620 --> 00:23:00.280
东西，我们会看到一些与众不同的东西，所以也查询

00:23:00.280 --> 00:23:03.370
包括一个称为可视化的组件，因此可视化

00:23:03.370 --> 00:23:06.970
允许我们提供HTML文档，该文档以数据集中的任何内容为模板

00:23:06.970 --> 00:23:10.710
您想要的，因此在这种情况下，我们在模板中计算节点数和字数

00:23:10.710 --> 00:23:15.700
HTTP网关足够聪明，可以在您知道UNIX fSV的系统中看到一个文件

00:23:15.700 --> 00:23:19.720
叫做index.html，如果我们有可视化工具，我们会想好

00:23:19.720 --> 00:23:23.680
有数据，为什么我们不只是向您展示事物的可视化效果，所以这

00:23:23.680 --> 00:23:28.810
我们正在查看具有本体JSON的引擎盖下的原始ipfs哈希

00:23:28.810 --> 00:23:36.280
数据在那里查看哦，天哪，我们将在一分钟内深入探讨，但

00:23:36.280 --> 00:23:39.580
我们也可以对此进行分类，我认为这确实是重要的一点

00:23:39.580 --> 00:23:42.259
了解一切查询牙医，这是一个文档

00:23:42.259 --> 00:23:46.789
并不是历史，我们只是在一个单一的事物中看到一个事物的一个单一版本

00:23:46.789 --> 00:23:50.330
时间点是完全独立的，这给了我们

00:23:50.330 --> 00:23:54.109
就像我们可以向人力资源部门展示的东西或其他正确的东西

00:23:54.109 --> 00:23:58.009
比较可口，但这是一个完全独立的可审核数据

00:23:58.009 --> 00:24:01.999
设置您需要了解此数据集的所有要素

00:24:01.999 --> 00:24:06.229
默克尔包，我们已经精心安排了它，以便每一个出色的数据集

00:24:06.229 --> 00:24:10.399
设置方式完全相同，这意味着每个单独的箱子都可以

00:24:10.399 --> 00:24:14.179
如果我可以转换任何查询数据集的主体，则以相同的方式解释

00:24:14.179 --> 00:24:18.829
到JSON，因为它总是以完全相同的方式进行比较

00:24:18.829 --> 00:24:22.549
每一个都可以查询数据集，因为它们始终是我可以使用的相同方法

00:24:22.549 --> 00:24:25.820
从所有内容中提取元标题，因为查询只会让您输入

00:24:25.820 --> 00:24:29.719
右侧的meta部分中的元数据，因此我们在

00:24:29.719 --> 00:24:35.029
顶层非常松散的文档模型用于实际数据集，所以这仅仅是

00:24:35.029 --> 00:24:40.070
像基本HTML这样的高级图表，但这实际上是最近的原因

00:24:40.070 --> 00:24:43.609
节点总数即节点总数的这种波动形式是

00:24:43.609 --> 00:24:50.029
喜欢一件有趣的事情，所以我们将深入探讨这一点，为什么不

00:24:50.029 --> 00:24:55.369
我们得到了这个数据集，所以我喜欢进入这里，然后说嘿，这是

00:24:55.369 --> 00:24:59.509
我想要的东西我只是要复制粘贴到此的结尾，我要这样

00:24:59.509 --> 00:25:02.809
我是你们，将您的查询与我们联系起来，哦，天哪，这使所有

00:25:02.809 --> 00:25:08.209
时间我要输入查询添加，我要打这个，所以我不是我的笔记不是

00:25:08.209 --> 00:25:12.950
现在发生的事情是因为我没有连接

00:25:12.950 --> 00:25:14.839
我们必须认为我们正在考虑数据科学家，而不是在考虑

00:25:14.839 --> 00:25:19.309
关于像清教主义那样的，因为你从那里获取

00:25:19.309 --> 00:25:21.499
当时没有连接，只是说嘿，我们要去那里

00:25:21.499 --> 00:25:24.409
注册表，所以我们昨天演示的不同步的事情是

00:25:24.409 --> 00:25:32.059
我们如何从HTTP查询网关提取20个数据块并放入

00:25:32.059 --> 00:25:36.979
当我们发送对话时，本地同步

00:25:36.979 --> 00:25:39.709
嘿，我们想要这个，因为我们对此一无所知，它发送了所有信息

00:25:39.709 --> 00:25:43.969
对我们来说，如果我们对此更加聪明，或者我们说这是我们实际上会产生的开斋节

00:25:43.969 --> 00:25:47.570
清单并将其发送回去，这只会将我们发送回

00:25:47.570 --> 00:25:50.870
我们需要，但是现在我在本地有这个，所以我可以做

00:25:50.870 --> 00:25:55.910
酷儿LS，我在本地拥有所有这些数据，如果执行Prairie Connect，

00:25:55.910 --> 00:26:04.190
并在本地主机上将其加载到我的计算机上，哦，我们做了什么来击败

00:26:04.190 --> 00:26:08.990
每天或每小时，这很酷，我现在可以正确获取身体数据，

00:26:08.990 --> 00:26:12.410
我认为这就是我们真正想要推动人们前进的东西

00:26:12.410 --> 00:26:16.010
例如，如果我们使用分布式技术，那么整个交换就是

00:26:16.010 --> 00:26:19.880
像这样的罚款权利可以免费使用，因为它是分布式网络，因此

00:26:19.880 --> 00:26:25.420
花费这笔费用的成本您为什么不看一下演示神呢？

00:26:25.420 --> 00:26:31.940
我们走了两次很不错，我认为这真的很重要，就像

00:26:31.940 --> 00:26:35.420
像在此可视化中一样，表面占总数的一部分

00:26:35.420 --> 00:26:39.290
节点，而这正是数据科学中的常见现象，例如

00:26:39.290 --> 00:26:43.730
所有这些数据都像我们这个指标集一样

00:26:43.730 --> 00:26:48.620
正在发布该网络上每个已注册的版本，因此

00:26:48.620 --> 00:26:51.680
这是我们看到的每个节点版本，就像这样，我们拥有

00:26:51.680 --> 00:26:55.940
像这样的数据时间戳比显示的要有趣得多

00:26:55.940 --> 00:27:00.620
您所看到的那个单图可视化，所以当它也非常

00:27:00.620 --> 00:27:03.740
重要的是要注意，当我们对查询广告进行排名时，我们只会得到一个版本的

00:27:03.740 --> 00:27:07.490
该数据集我们没有获取整个历史记录，这与get write不同

00:27:07.490 --> 00:27:12.740
让您知道是否要克隆有最近才克隆的标志是什么

00:27:12.740 --> 00:27:18.050
谢谢你克隆浅钉，这是有效踢克隆

00:27:18.050 --> 00:27:21.740
浅层特征将在接下来的一段时间内出现

00:27:21.740 --> 00:27:25.730
看到您目前没有的东西的方式我们没有

00:27:25.730 --> 00:27:30.770
所以有了这样的数据，我们现在可以将其弹出来，我将其关闭

00:27:30.770 --> 00:27:35.300
再次是因为我不断地关闭和打开它，但是我还是要查询

00:27:35.300 --> 00:27:40.160
我要通过一个过滤器，要说的就是给我这个身体

00:27:40.160 --> 00:27:44.570
时间，因为当我执行查询时，我会得到实时的b2b节点数

00:27:44.570 --> 00:27:51.159
每小时，我爱我们每天都在做，是的

00:27:54.270 --> 00:27:59.250
坚持玛丽的

00:27:59.250 --> 00:28:08.030
没错，是的，因为我还不到55岁，哦，天哪

00:28:09.640 --> 00:28:17.320
很酷，让我们每小时进行一次报告，因为如果我们看到这实际上是

00:28:17.320 --> 00:28:21.910
只是向我们展示了数据集的实际的头内容，所以我们

00:28:21.910 --> 00:28:24.730
看到我想要得到身体的东西的类似描述词，所以我

00:28:24.730 --> 00:28:30.730
会做非常猫的身体，这一次我要复制粘贴，因为我不

00:28:30.730 --> 00:28:34.120
想再次犯错，这很酷，这实际上是要展示身体

00:28:34.120 --> 00:28:40.540
数据整洁，不是超级有用，让我们将其转换为CSV并通过管道传输

00:28:40.540 --> 00:28:48.160
到不是管道的主要CSV文件中，但是您知道我的意思，然后再看

00:28:48.160 --> 00:28:53.919
在我们的主要CSV文件中，我们现在可以在其他程序中打开它，这是什么

00:28:53.919 --> 00:28:57.490
这里很重要，就像正在做数据标志的人真的需要高

00:28:57.490 --> 00:29:02.080
互操作性的程度，因此您可以在其中使用Python包

00:29:02.080 --> 00:29:05.559
该查询使您可以直接从超级笔记本对此进行交谈，因此您

00:29:05.559 --> 00:29:09.640
可以，好吧，请给我这个版本的数据集，并将其作为

00:29:09.640 --> 00:29:13.660
将熊猫的数据框放入超级笔记本中，以便在需要时进行超级处理

00:29:13.660 --> 00:29:17.080
我们的核心数据科学，但在此示例中，我们想做一些基准

00:29:17.080 --> 00:29:20.980
分析，所以我只想单击此列，如果我们在这里向下看，我们

00:29:20.980 --> 00:29:26.950
得到一些像基本分析这样的消息，平均连接的节点数是96

00:29:26.950 --> 00:29:31.720
一千八百二十二哦，我的天哪，这是一个很高的数字，我们可以

00:29:31.720 --> 00:29:34.270
开始开始分析这些日期戳，并仔细研究一下

00:29:34.270 --> 00:29:36.760
我们需要的格式，所以我认为这真的是我想指出的

00:29:36.760 --> 00:29:43.090
因此，我们的目标是使用灰色工具，以便尽可能地互操作，并且

00:29:43.090 --> 00:29:48.070
能够像程序员一样在尽可能多的上下文中使用它

00:29:48.070 --> 00:29:51.220
或主要从事开发工作的人我使用正方形的地方

00:29:51.220 --> 00:29:54.549
在我的日常开发工作中，最重要的是每当我想做某事时

00:29:54.549 --> 00:29:58.210
周围像金色的文件试图理解像我们的东西的输出

00:29:58.210 --> 00:30:01.299
可以使用查询差异工具来处理高度结构化的JSON

00:30:01.299 --> 00:30:04.120
有点像了解几个版本之间的变化

00:30:04.120 --> 00:30:07.870
经常，我们就像拿我们的测试套件API输出一样，猛烈抨击

00:30:07.870 --> 00:30:12.010
将其放入数据集并说很酷，就好比看看外观如何，我们将进行检查

00:30:12.010 --> 00:30:14.740
我会每隔一两个月检查一次

00:30:14.740 --> 00:30:18.550
然后蘸一下就可以了，事情发生了多大变化，这并不是我们真正的一部分

00:30:18.550 --> 00:30:22.179
测试套件，但是我们经常做很多像基本分析一样的东西

00:30:22.179 --> 00:30:26.200
数据是我们花了一个PI来了解她的私下生活是什么样子

00:30:26.200 --> 00:30:31.090
这只是一种分析事物的好方法，然后保持这一点

00:30:31.090 --> 00:30:33.970
一个人的本机格式JSON，但我认为值得指出的是

00:30:33.970 --> 00:30:37.270
这也与现有工具很好地结合在一起，所以我们可以开始使用Jake

00:30:37.270 --> 00:30:40.179
您像疯子一样陷入困境，并从切片中得到我们想要的一切，

00:30:40.179 --> 00:30:44.830
划片有几种方法可以同时获取多个数据

00:30:44.830 --> 00:30:52.570
连锁在一起，我们今天不会太酷了，那就是我

00:30:52.570 --> 00:30:56.890
想想为什么我们要在那儿停一秒钟，有人对此有任何疑问

00:30:56.890 --> 00:31:09.700
到目前为止，在可视化中展示是的，让我们检查一下，以了解更多内容。

00:31:09.700 --> 00:31:12.940
关于自动化的第四节希望能给您适当的帮助

00:31:12.940 --> 00:31:16.440
答案我会在第二次回顾

00:31:18.480 --> 00:31:26.050
mm-hmm，所以注册表可以，是的，因此每个查询配置默认为

00:31:26.050 --> 00:31:31.780
注册表查询作为注册表，您可以将其关闭，可以说我想要

00:31:31.780 --> 00:31:34.900
进入困难模式，我想完全去中心化，我不想提交

00:31:34.900 --> 00:31:39.370
对于任何注册表，注册表相对于您的行为都会有所不同，但仅仅是

00:31:39.370 --> 00:31:44.890
注册表，这意味着当您尝试进行查询添加时，您现在需要

00:31:44.890 --> 00:31:49.150
运行迅速的连接，它将从D Web中拉出它，相反，我们发现

00:31:49.150 --> 00:31:54.040
在办公室里，你经常会发狂，主要是因为我们有五个

00:31:54.040 --> 00:31:57.730
经常运行笔记的计算机，它们倾向于获取

00:31:57.730 --> 00:32:00.880
彼此之间的距离比实际速度快，我们基本上只是将

00:32:00.880 --> 00:32:04.390
每次您运行查询广告时，D Web中的注册表都会争分夺秒，这就像

00:32:04.390 --> 00:32:07.720
看到什么时候赢了，真的很有趣，但是数据集是否在我们的内部

00:32:07.720 --> 00:32:19.180
办公室，它几乎总是从HTTP击败它，这很有趣，您如何处理

00:32:19.180 --> 00:32:22.930
具有事物的动态性质，因此查询协议实际上具有一种

00:32:22.930 --> 00:32:29.200
与头部同步，因此您可以获取实时p2p请求的参考，因此

00:32:29.200 --> 00:32:32.290
在引擎盖下，灰色将为您解决这个问题，因此，如果我运行良好的连接，我会运行

00:32:32.290 --> 00:32:37.360
查询广告，并且注册表已关闭或关闭，它将执行操作，并发送一条消息

00:32:37.360 --> 00:32:40.480
到任何对的查询都可以连接到的任何对

00:32:40.480 --> 00:32:44.440
反弹，如果有人有最新消息，您会得到一个

00:32:44.440 --> 00:32:47.440
几则关于最新消息，然后查询将决定什么

00:32:47.440 --> 00:32:51.700
最聪明的要约是，如果对等方的纯ID与

00:32:51.700 --> 00:32:54.040
您正在寻找的东西会给您一个答案，那么它就被认为

00:32:54.040 --> 00:32:59.460
权威，所以那里就像一场整个谈话

00:33:08.070 --> 00:33:12.249
因此，如果您想与我们一起处理该RFC，我想

00:33:12.249 --> 00:33:16.299
很高兴看到私有数据以及对加密数据和访问控制的访问

00:33:16.299 --> 00:33:20.950
我们对今年年底的目标可以说，嘿，这是一个数据集，

00:33:20.950 --> 00:33:23.679
加密，我只希望此人能够读取此人可以读取的身体

00:33:23.679 --> 00:33:29.440
如果路线图可以回答您的问题，请编辑路线图上非常多的meta

00:33:29.440 --> 00:33:35.979
可悲的是现在不是现在，现在唯一关心的是

00:33:35.979 --> 00:33:48.970
是的，很酷，是的，所以是的，对不起逻辑，哦，存储在其中的内容

00:33:48.970 --> 00:33:51.479
默克尔·达格

00:33:59.550 --> 00:34:06.430
完全完全可以，因此查询的架构设计基于JSON架构

00:34:06.430 --> 00:34:09.820
它支持所谓的注解集合注解，因此

00:34:09.820 --> 00:34:13.780
通常我们在大部分数据字典注释工作中

00:34:13.780 --> 00:34:17.050
显然对人类来说不是语义映射或本体论

00:34:17.050 --> 00:34:20.320
如果我有两个数据集，我认为您基本上指的是映射

00:34:20.320 --> 00:34:23.800
这是人均，这是个人可以查询

00:34:23.800 --> 00:34:28.290
自动不，乘以一千就是您要问的

00:34:36.730 --> 00:34:42.220
我是不是在付钱给你，是因为我们走吧，也许我可以回答

00:34:42.220 --> 00:34:48.010
现在的问题是的，所以让我们谈谈自动化吧，这是

00:34:48.010 --> 00:34:52.119
实际上，下一个我认为是我们的魔力酱，所以我们嵌入了一个

00:34:52.119 --> 00:34:58.630
将语法编程到查询中，这就像是在完整沙箱中巡视的Python

00:34:58.630 --> 00:35:02.560
一种语言，可让您自动将数据集的一种版本转换为

00:35:02.560 --> 00:35:09.160
另一个，我很酷，我们会看到谢谢你，我期待着

00:35:09.160 --> 00:35:12.880
对此进行了改进，所以今天我们要做的是真正降低

00:35:12.880 --> 00:35:17.140
如此简单，我们将理想地回答约翰尼紧缩问题并得到

00:35:17.140 --> 00:35:22.330
同时关闭ish，所以我要制作一个新文件，这将是

00:35:22.330 --> 00:35:28.960
称为下载点星，以便该星代表星云雀星云雀仅代表

00:35:28.960 --> 00:35:33.280
一些历史来自谷歌的罗勒构建系统，这就是他们用来

00:35:33.280 --> 00:35:37.900
有意使构建自动化，他们希望它能够巡回演出并完成，

00:35:37.900 --> 00:35:41.590
 Google内部的每个人都非常喜欢Python数据科学家们真的很喜欢

00:35:41.590 --> 00:35:44.920
Python，这是我们遇到的很多问题，为什么不进行网络汇编

00:35:44.920 --> 00:35:52.000
数据科学是为什么，但因此我们在这里拥有的功能将是

00:35:52.000 --> 00:35:57.850
当我们去保存这个数据集时，将会调用一个严重的地穴

00:35:57.850 --> 00:36:01.420
有两个魔术函数，当您定义它们时，查询便会调用它们

00:36:01.420 --> 00:36:06.430
您第一个称为下载，第二个称为transform in

00:36:06.430 --> 00:36:09.160
下载您会得到一个称为上下文的东西，如果您想通过它

00:36:09.160 --> 00:36:12.790
配置到转换或API机密，您可以传递这些机密

00:36:12.790 --> 00:36:17.800
在这里，但最重要的是您实际上并没有传递数据集

00:36:17.800 --> 00:36:22.660
这是数据集，是您编辑以使自己与众不同的东西

00:36:22.660 --> 00:36:26.470
可以将相同的手动和自动转换混合在一起

00:36:26.470 --> 00:36:29.950
提交查询，确保这些电线不

00:36:29.950 --> 00:36:34.960
作为具体示例，您可以进行提交以更新元数据

00:36:34.960 --> 00:36:40.330
手动操作，但是使用脚本来更改主体，我们发现了这一点

00:36:40.330 --> 00:36:44.170
当您喜欢进行深度学习时，这对您真的很有帮助

00:36:44.170 --> 00:36:47.170
清理工作真的很好，因为我们有这些黄色文件

00:36:47.170 --> 00:36:49.210
好的，这是我的提交信息，我非常

00:36:49.210 --> 00:36:52.420
准备做这个，我要设置这个元数据，然后我要运行一堆

00:36:52.420 --> 00:36:56.020
代码，因此在这种情况下，我们要做的事情非常非常简单，

00:36:56.020 --> 00:36:59.050
构造一个例子主要是为了展示这方面的自动化方面

00:36:59.050 --> 00:37:02.470
只是检查最新版本的JSF BFS的一个例子

00:37:02.470 --> 00:37:06.970
只是说我们要去检查github API并要求它的数据集

00:37:06.970 --> 00:37:10.510
发布，我们将获取该响应的JSON，然后我们将获取

00:37:10.510 --> 00:37:14.800
该响应的第一件事，我们将祈祷Jes ipfs至少

00:37:14.800 --> 00:37:19.650
一个版本，否则此代码将中断，但我认为我们会没事的

00:37:19.650 --> 00:37:23.770
我们要做的下一件事是当该函数返回时，将其放置在

00:37:23.770 --> 00:37:28.960
在转换和下载之前，总是先调用它现在下载的特殊位置

00:37:28.960 --> 00:37:34.330
无论您返回什么，下载功能的结果都会传递到

00:37:34.330 --> 00:37:38.080
CTX作为此点下载值，因此您可以放置​​任何可以传递的内容

00:37:38.080 --> 00:37:41.260
返回两个民意调查，您可以根据需要在此处传递两个对象，然后

00:37:41.260 --> 00:37:46.570
这将在转换步骤中传递，您的HTTP访问权限仅处于打开状态

00:37:46.570 --> 00:37:50.830
在树桩期间进行下载通话，因此您只能访问Internet

00:37:50.830 --> 00:37:54.820
在这里，您只能在下载步骤中访问D网站，因此您必须完成所有操作

00:37:54.820 --> 00:37:59.020
首先收集您的数据，然后当您完成操作后，我们将所有

00:37:59.020 --> 00:38:02.860
网络访问权限，然后我们打开您对本地数据集的访问权限，并为

00:38:02.860 --> 00:38:06.040
这最终将使我们为加密数据做好准备，因此，如果您

00:38:06.040 --> 00:38:09.760
接触私人数据集查询会自动确保您

00:38:09.760 --> 00:38:13.510
不能写一些有点恶意的东西，因为我们

00:38:13.510 --> 00:38:18.370
不想像这里一样在我们的数据中向某些服务器进行HTTP发布

00:38:18.370 --> 00:38:22.720
像安全预防措施一样，我们特意采取了一些措施

00:38:22.720 --> 00:38:29.490
比javascript或其他类似的沙盒环境更严格的方法

00:38:29.490 --> 00:38:32.830
主要是因为我们不知道这将如何工作，但是我们已经有很多

00:38:32.830 --> 00:38:36.550
内部辩论，所以我要说这是下载星号，而

00:38:36.550 --> 00:38:40.030
我们正要包括一个可视化图像，主要是为了回答约翰尼

00:38:40.030 --> 00:38:44.200
卡森（Carson）的问题，所以这实际上是一种可视化

00:38:44.200 --> 00:38:49.900
HTML模板，但在这种情况下，我们这里有一个特殊的东西，称为all body

00:38:49.900 --> 00:38:53.470
我们故意将其放入此条目，因为您要对此小心

00:38:53.470 --> 00:38:58.090
这会将所有数据集数据模板化为可以迭代的数据集

00:38:58.090 --> 00:39:01.000
而不是这样做会更聪明

00:39:01.000 --> 00:39:04.150
所以您必须使用Jeff，我们相信您会以正确的方式做到这一点

00:39:04.150 --> 00:39:08.200
但是嘿，这是你自己的事，是你自己的脚枪把自己踢了出去

00:39:08.200 --> 00:39:14.050
但是在这种情况下，我们制作模板HTML并保存，然后我将继续

00:39:14.050 --> 00:39:18.580
在这里，我要确保是很酷，我要查询保存并

00:39:18.580 --> 00:39:23.620
这个家伙将通过快速下载文件中的两个文件下载星号和文件

00:39:23.620 --> 00:39:35.770
模板点HTML，我会做的，我会是最好的最新版本，所以

00:39:35.770 --> 00:39:38.680
现在，科里这次要采取行动，做一些不同的事情

00:39:38.680 --> 00:39:41.470
为此下载脚本选择了转换步骤

00:39:41.470 --> 00:39:45.640
Starlog转换脚本并依序为我调用函数

00:39:45.640 --> 00:39:48.010
没有定义下载功能，您不会看到任何精彩

00:39:48.010 --> 00:39:52.600
卫星表情符号，如果您在Windows上运行，则只会看到白色的X

00:39:52.600 --> 00:39:57.550
这令人沮丧，但是是的，所以它运行了转换并生成了新数据

00:39:57.550 --> 00:40:05.530
如果我们查询此数据获取正文，是的，我们可以看到它实际上是

00:40:05.530 --> 00:40:16.240
github响应很酷，所以我们还可以执行查询动力学并检查它

00:40:16.240 --> 00:40:21.370
再次，我还没有发布这个，所以这只是本地的，但是如果我做本地主机的话

00:40:21.370 --> 00:40:29.880
什么5001这个东西我以为是的，它总是把我吹

00:40:29.880 --> 00:40:35.820
介意，让我们尝试一下

00:40:35.820 --> 00:40:41.849
所以当前的版本很酷，所以现在我们要迈出的重要一步

00:40:41.849 --> 00:40:46.380
实际上，在那里面，如果我们确实要查询这一点，我们就可以

00:40:46.380 --> 00:40:53.790
屏幕显示正确，不，不，不粘贴，所以我们有一个叫做查询的工具，但是

00:40:53.790 --> 00:40:57.230
我们正在考虑将其取出，但是我基本上可以做到这一点，我可以进行查询使用

00:40:57.230 --> 00:41:03.840
这样，我就不再需要复制并粘贴非常好的mm-hmm

00:41:03.840 --> 00:41:09.330
它是有状态的，我不知道，但是正如我们在这里看到的那样，我们没有

00:41:09.330 --> 00:41:13.170
转换嵌入到其中，脚本实际上与它一起保存

00:41:13.170 --> 00:41:18.630
所以我们现在要做的是绑定一个脚本，该脚本教查询如何更新

00:41:18.630 --> 00:41:24.630
本身到数据集，所以在任何给定的点我都可以做，我可以做困难的事情，

00:41:24.630 --> 00:41:30.210
如果我想返回转换脚本，我可以做查询来保存召回TF。

00:41:30.210 --> 00:41:36.770
可以做到，但我要这么做，你我是的，我有最新版本

00:41:36.770 --> 00:41:42.599
这将运行它，它会保持凉爽，所以它只是重写

00:41:42.599 --> 00:41:45.990
一切，并检查保存的唯一原因是因为有一个错误

00:41:45.990 --> 00:41:50.580
如果您不再提供可视化效果，则删除可视化效果，这就是我自己，我只是

00:41:50.580 --> 00:41:57.839
要真的很快地做到这一点，忽略它，这很好，很酷，所以现在

00:41:57.839 --> 00:42:02.040
查询知道如何为我们更新我们的数据集，这很有帮助，并且

00:42:02.040 --> 00:42:05.040
这里要注意的另一件事是因为我们已将脚本绑定到数据集

00:42:05.040 --> 00:42:08.820
本身作为审核跟踪的一部分，所以如果有人想检查我的代码

00:42:08.820 --> 00:42:11.460
并想知道嘿，您是将该列乘以一千还是

00:42:11.460 --> 00:42:14.640
改变这个，这是你忘了你被一些怪异的事物分开吗？

00:42:14.640 --> 00:42:19.770
浮点数是数据集的一部分，对

00:42:19.770 --> 00:42:23.820
正确执行数据审核的人，我们有一个非常非常非常

00:42:23.820 --> 00:42:27.839
对发生的事情有明确的了解，我们今天不打算讨论它，但是

00:42:27.839 --> 00:42:32.070
查询数据集可以依赖于其他数据集，这意味着您可以构建

00:42:32.070 --> 00:42:36.450
您可以在其中加载数据集的依赖树获取其数据并将

00:42:36.450 --> 00:42:39.110
在引擎盖下很好地产生新事物查询

00:42:39.110 --> 00:42:43.550
记录您运行所有脚本应用程序并知道的确切版本

00:42:43.550 --> 00:42:47.360
当这些数据集更改其历史记录并可以告诉您重新运行

00:42:47.360 --> 00:42:53.750
下游数据集，也适合从事数据科学和聚合的人员

00:42:53.750 --> 00:42:59.330
就像一件有价值的事情，我们有一个我们不知道的最后一个问题

00:42:59.330 --> 00:43:05.390
当JSI BFS会提出一个新版本时，我们处于这种情况下，

00:43:05.390 --> 00:43:09.800
可以向后弯腰，像设置一个网钩，我们想得到

00:43:09.800 --> 00:43:13.790
真的很像某种针对该问题的定制解决方案，或者我们

00:43:13.790 --> 00:43:18.230
可以以分散方式完成分散的重量

00:43:18.230 --> 00:43:22.010
它是从我的机器上获取的，因此查询还有最后一个窍门，今天我想向您展示

00:43:22.010 --> 00:43:28.610
创建更新查询更新基本上是一个正在运行的cron守护程序

00:43:28.610 --> 00:43:33.260
在您的计算机上，您可以说去检查此更新是否重新运行

00:43:33.260 --> 00:43:37.610
以一定的间隔转换脚本，所以我要运行此命令

00:43:37.610 --> 00:43:43.130
更新服务启动，所以我必须打开我们希望您执行的服务

00:43:43.130 --> 00:43:46.760
现在，请注意，我们不会在后台用完两个FS

00:43:46.760 --> 00:43:50.900
当发生这种情况时，这只是一个循环，正在检查嘿我们有没有

00:43:50.900 --> 00:43:56.060
更新不会运行，就是这样，所以这东西吃起来就像

00:43:56.060 --> 00:44:02.330
我的机器上大约有6 Meg的内存，不是很安静，所以这是

00:44:02.330 --> 00:44:06.170
向您的操作系统注册我很抱歉，这仅适用于OS X Linux

00:44:06.170 --> 00:44:13.670
即将在一周内到来，但现在我可以查询更新服务状态了

00:44:13.670 --> 00:44:17.150
正在运行，这又回来了，我们可以将其配置为资源

00:44:17.150 --> 00:44:19.670
受限制，所以如果我们要确保自己不炸毁自己

00:44:19.670 --> 00:44:29.300
计算机，我们可以做到这一点，但现在我可以执行查询更新，将我的J安排在BFS上

00:44:29.300 --> 00:44:38.600
哦上帝最新版本，然后我要选择一个周期，这可能是你

00:44:38.600 --> 00:44:43.880
以前没有见过这种语法，但是重复了一段时间

00:44:43.880 --> 00:44:49.010
一分钟的时间戳，如果您使用用户界面执行此操作，则不是最大的时间戳

00:44:49.010 --> 00:44:56.030
这样就不那么痛苦了，但是没有3ls跑起来就很难记住他自己的

00:44:56.030 --> 00:45:07.640
现在的事情很棒，更新时间表安排了这个rt1酷酷，所以如果我们现在这样做

00:45:07.640 --> 00:45:14.630
在两分钟内查询更新列表，它将运行，因此它将位于

00:45:14.630 --> 00:45:18.950
我的机器的背景，只是挂出关于版本控制的好处

00:45:18.950 --> 00:45:22.940
系统现在我们知道世界的当前状态，所以我们知道

00:45:22.940 --> 00:45:29.600
JSF EFS当前为0.36点一，运行此转换时

00:45:29.600 --> 00:45:33.290
每次行程都将执行，并且如果body的值为或

00:45:33.290 --> 00:45:38.090
该数据集是相同的查询，将不会创建新版本，而是

00:45:38.090 --> 00:45:44.000
记录它检查并为我保留该终端的输出以及什么

00:45:44.000 --> 00:45:47.150
允许您做的是，如果没有新东西，我不会得到新东西

00:45:47.150 --> 00:45:51.010
如果有新东西，它将为我捕获，并在发现后立即告诉我

00:45:51.010 --> 00:45:55.550
这将在我的计算机上本地运行，并产生一个不可变的哈希，我可以

00:45:55.550 --> 00:46:01.790
分布在任何地方，所以我称其为雾服务，我们将查看

00:46:01.790 --> 00:46:05.390
坚持，但我认为这是一项雾霾服务，我认为，如果我们所有

00:46:05.390 --> 00:46:09.320
机器正在被动地进行一些数据集挖掘工作，而我们

00:46:09.320 --> 00:46:14.540
然后发布，我们有一些模糊的数据，这真的很好，我就像所有人一样

00:46:14.540 --> 00:46:20.330
关于它的原因是因为我目前管理的计算机大约有50个数据集

00:46:20.330 --> 00:46:25.640
这样，就像每天我醒来啊，你知道我们是否可以

00:46:25.640 --> 00:46:31.550
我每一个有礼貌的查询更新视频博客，就像我们在做CI一样，

00:46:31.550 --> 00:46:35.870
每次读取某项内容时，只需追加一个递增的整数

00:46:35.870 --> 00:46:39.299
变成灰色，不保存更改，然后

00:46:39.299 --> 00:46:43.469
绿色，因为实际上我想在任何时候看到一个新版本

00:46:43.469 --> 00:46:48.660
我的终端输出，我可以做的就是非常更新博客羔羊，这就是

00:46:48.660 --> 00:46:53.279
这是该更新权发生时发生的事情的终端记录，因此

00:46:53.279 --> 00:46:57.869
如果您可以在这里做的另一件事是您不能只是安排查询数据

00:46:57.869 --> 00:47:00.599
自行设置，仅允许您启动我们的转换

00:47:00.599 --> 00:47:04.890
您可以安排shell脚本，从而可以集成各种

00:47:04.890 --> 00:47:09.690
您可以说其他类似的东西，就像Libby一样，请注意我们

00:47:09.690 --> 00:47:14.969
看看这个shell脚本看起来像这样，让我们​​向您展示

00:47:14.969 --> 00:47:26.579
这就是我的屏幕，比这里很难看到的要小得多，所以让我们

00:47:26.579 --> 00:47:32.640
每天记一下此笔记吗，是的，这是执行此操作的shell脚本，因此

00:47:32.640 --> 00:47:36.450
这实际上是一个进入kubernetes的shell脚本，它执行了一个端口

00:47:36.450 --> 00:47:40.349
转发给我9090，以便我可以看到一个本地的prometheus实例

00:47:40.349 --> 00:47:44.069
然后允许我运行一个巨大的转换脚本，该脚本将数据从Prometheus中提取出来

00:47:44.069 --> 00:47:48.029
将其转换为表格形式将其放入查询中并提供最新数据

00:47:48.029 --> 00:47:52.410
这样就可以每天在我的计算机上运行并每天发布

00:47:52.410 --> 00:47:57.299
我会奇怪地认为这些数据会带来一些后果

00:47:57.299 --> 00:48:00.359
无法执行更新的原因是因为我的笔记本电脑已关闭，

00:48:00.359 --> 00:48:04.369
那么您知道您将获得比原定时间表少六个小时的更新

00:48:04.369 --> 00:48:09.089
但是它可以工作并且可以运行，您会得到好处，因为我们拥有此shell脚本

00:48:09.089 --> 00:48:12.960
集成，您可以做很多非常有趣的事情，在这种情况下，我们只是

00:48:12.960 --> 00:48:16.710
调用查询保存在这里一次，然后我们终止代理并关闭

00:48:16.710 --> 00:48:18.930
这样您就可以想象可以在此处集成的所有内容

00:48:18.930 --> 00:48:22.680
将您的数据库翻转东西连接到某种类型的输出gem进行查询

00:48:22.680 --> 00:48:26.369
版本，它将关闭所有内容，如果您非常擅长于此，就完成了

00:48:26.369 --> 00:48:29.759
管理退出代码查询可以为您提供正确的错误消息

00:48:29.759 --> 00:48:33.089
告诉你想当某件事没有破裂时就破裂了，是的

00:48:33.089 --> 00:48:38.440
所以这只是向您展示可能会是什么样子

00:48:38.440 --> 00:48:43.210
没有转储抱歉更新列表，所以这是我目前仅做四件事

00:48:43.210 --> 00:48:47.260
但是在恢复工作的机器上，我得到的清单很长，很高兴

00:48:47.260 --> 00:48:53.440
看到某种在后台运行的关于我们的问题

00:48:53.440 --> 00:49:10.869
显然要像diff一样吃午饭，好吧，让我们进入这个非常

00:49:10.869 --> 00:49:21.099
diff是算法完成的网格可视化是可怕的，但我

00:49:21.099 --> 00:49:25.630
认为我可以做到，我认为我对这个东西还不太习惯，是的，是的

00:49:25.630 --> 00:49:32.589
因此查询是否默认情况下将数据集顶部与我们的数据进行比较

00:49:32.589 --> 00:49:36.940
比较最新版本与最新版本，因为我正在运行查询

00:49:36.940 --> 00:49:42.339
只是在这种情况下执行JSF BFS，这是一个非常不同的光环

00:49:42.339 --> 00:49:46.720
时间什么都没改变，这是一件非常有价值的事情，这是不同的

00:49:46.720 --> 00:49:51.970
来自UNIX diff UNIX diff比较文本行并为

00:49:51.970 --> 00:49:57.400
行查询中最长的公共子字符串正在比较结构化数据，因此如果

00:49:57.400 --> 00:50:02.170
您有非常复杂的高维数据，这是我们有一个

00:50:02.170 --> 00:50:05.650
我会告诉你的事情是，我认为看着你很平静很有趣

00:50:05.650 --> 00:50:11.890
喊出深深的差异，这是你可以做的是线性比较

00:50:11.890 --> 00:50:17.380
时间高度结构化的东西，因此这在geo JSON中非常有效

00:50:17.380 --> 00:50:22.119
那就是我们就像裂痕一样的东西，但这很好，因为如果你喜欢潜艇

00:50:22.119 --> 00:50:25.660
树是相似的，您将显示为匹配，我们将使用它来做

00:50:25.660 --> 00:50:29.319
我们需要做的不同的工作实际上是我们希望变得更好

00:50:29.319 --> 00:50:32.440
在实际的可视化过程中，我们很难下定决心

00:50:32.440 --> 00:50:36.690
事实上，如果您愿意，您可以可视化移动，从而可以实际显示

00:50:36.690 --> 00:50:39.640
东西的运动，然后我们还试图弄清楚如何可视化

00:50:39.640 --> 00:50:43.109
列开关比数学更有趣

00:50:43.109 --> 00:50:48.930
但是，是的，这就是路线图上的希望能够回答您的问题

00:50:48.930 --> 00:51:03.630
问题好吧，为什么我们不这样做，是的，我很紧张，我不是，我没有打字

00:51:03.630 --> 00:51:09.569
今天很好，他不去，但是是的，我会完全表明是的，所以这

00:51:09.569 --> 00:51:12.539
理想情况下有点像加起来，希望您可以看到

00:51:12.539 --> 00:51:18.480
我们在这里制定了长期目标，在这种情况下，我们将目标定为

00:51:18.480 --> 00:51:21.359
像小时便笺计数现在将可供您使用

00:51:21.359 --> 00:51:28.470
我们还可以准备另一个我认为很有趣的数据集b5，如果您

00:51:28.470 --> 00:51:43.230
知道GI Joe IP是希望这是对的，对不起一秒钟Ellis怎么样

00:51:43.230 --> 00:51:48.440
对不起

00:51:49.390 --> 00:51:54.360
ohmygosh careerconnect让我们开始吧

00:52:01.200 --> 00:52:07.940
让p2p节点按国家/地区分类，这是对伟大开源的证明

00:52:07.940 --> 00:52:17.039
在那里，这就是我们可以看到的内容，这是对所有可公开阅览的出版物的扫描

00:52:17.039 --> 00:52:22.349
在过去的六个月中，我们在DHT上看到过我们的刮板机的地址

00:52:22.349 --> 00:52:26.640
您是否重复建议独特性，以便我们可以看到我们公开能够

00:52:26.640 --> 00:52:31.440
拨号，所以这实际上是我可以正确地给您的信息，如果我们这样做的话

00:52:31.440 --> 00:52:35.819
应用装饰有I / O，应该发布，让我们确保它很酷

00:52:35.819 --> 00:52:40.109
在那里，但是如果我们进入这里就像我们可以看到一些有趣的东西，例如这种传统的

00:52:40.109 --> 00:52:43.109
从这个意义上讲，电台的加权很有趣，所以我们有九个

00:52:43.109 --> 00:52:46.529
在美国提供了1,512个独特的IPS，然后有5个

00:52:46.529 --> 00:52:49.440
在中国一万二千二百六十，似乎没有人在连接，但

00:52:49.440 --> 00:52:53.760
如果您将鼠标悬停在上面，就像有七百个容易和一千二百个

00:52:53.760 --> 00:52:57.240
就像可视化调整一样，这是一种艺术形式，但是我很明显我没有在做

00:52:57.240 --> 00:53:00.569
耳朵看着澳大利亚，就像三百八十二

00:53:00.569 --> 00:53:05.369
独特之处，但像其中一些会变得非常有趣，就像是，从20世纪90年代开始

00:53:05.369 --> 00:53:10.740
阿根廷巴西155值得注意的是，这绝对不是您在哪里

00:53:10.740 --> 00:53:14.130
正确了解您的数据绝不是拥有这些数据的人的全部

00:53:14.130 --> 00:53:18.779
连接的ipfs，这只是可公共拨打的IP地址，就像

00:53:18.779 --> 00:53:27.539
知道的好东西是的，百分之一的欠我，因为这是ipfs

00:53:27.539 --> 00:53:34.799
做了一个geoip b-tree，这是Ollie，然后在我将它运到

00:53:34.799 --> 00:53:37.829
实际上对这些进行地理编码，我的贡献将是

00:53:37.829 --> 00:53:42.269
更新该内容-但是，是的，我们完全可以在其中完全拥有它

00:53:42.269 --> 00:53:46.670
您可以立即运行查询广告，这将转到您的计算机上

00:53:46.670 --> 00:53:52.250
是的，这是离线问题

00:53:55.530 --> 00:54:00.790
是的，如果他们真的很糟糕，但是嘿，那就是我们要做的事情

00:54:00.790 --> 00:54:08.250
可以帮助您在顶部放置一个命名系统，但是要调查此数据

00:54:12.750 --> 00:54:16.750
哈珀儿子，我认为我们要做的事情是我们意识到hTML也是

00:54:16.750 --> 00:54:19.600
大量的工作，因此我们将像标准的可视化库一样进行构建

00:54:19.600 --> 00:54:23.980
而且我认为这是即将到来的，所以如果有人对

00:54:23.980 --> 00:54:28.000
可视化库的标准再次使我们像rfcs一样完成了所有工作，因此

00:54:28.000 --> 00:54:31.930
查询的所有内容都是RS，我要去做这个，然后无耻地推广这个

00:54:31.930 --> 00:54:35.350
回购是我们在这里进行所有技术路线图查询的地方，因此您

00:54:35.350 --> 00:54:38.140
可以看到我们在如何工作中将要做的事情，可以看到所有工作

00:54:38.140 --> 00:54:41.270
我们已经交付了，而且一直在增长

00:54:41.270 --> 00:54:45.670
[音乐]是的，我们基于锈RFC

00:54:45.670 --> 00:54:50.860
系统是我的忠实支持者，您可以看到，是的，所以它位于地理位置

00:54:50.860 --> 00:54:54.220
这基本上是现成的ipfs项目，所以这是

00:54:54.220 --> 00:54:59.230
使用与webview内部相同的系统是地理编码器，但这是

00:54:59.230 --> 00:55:04.930
已应用于我可以找到的51000个唯一地址，是的

00:55:04.930 --> 00:55:09.160
看到他们有点有趣，但是随着时间的流逝，对我们的研究真的很有趣

00:55:09.160 --> 00:55:13.420
随着时间的流逝开始相交，但是这里的重点就像我已经做到了

00:55:13.420 --> 00:55:17.860
只要您有信任我的审核记录，只要您信任我，就可以为您工作

00:55:17.860 --> 00:55:22.230
如果我做对了，就不必信任我，并且我可以对这些数据进行注释

00:55:22.230 --> 00:55:26.950
艰苦的工作已经完成，这意味着您有更多的时间进行分析，这意味着

00:55:26.950 --> 00:55:30.310
您有更多时间将很酷的东西发布回去，这就是

00:55:30.310 --> 00:55:34.330
这是唯一的问题，就像你是否有一天能给你一套东西

00:55:34.330 --> 00:55:39.490
知道这就像一个不错的业力骑自行车的人，也许不一对一，我不知道

00:55:39.490 --> 00:55:45.340
让我们去10:00到1:00之类的东西，但是是的，涵盖了整个色域

00:55:45.340 --> 00:55:49.030
但是我们有很多需要改进的地方，我们将把它变成

00:55:49.030 --> 00:55:53.620
github上的数据，所以您的拉取请求到了这里，我们必须弄清楚如何

00:55:53.620 --> 00:55:57.280
我们将使工作分散到最终难以解决的问题

00:55:57.280 --> 00:56:08.860
但是，是的，任何重大问题都存在地理编码保留或您确实有

00:56:08.860 --> 00:56:16.570
您实际上是在某个时候从挪威公开的，她的数据是

00:56:16.570 --> 00:56:32.230
对心脏的射击不准确是的，所以让我们看一下音符计数

00:56:32.230 --> 00:56:40.060
总的来说，如果我们看的话，就像是，这是每小时一次，是的，这是我们的租约，所以

00:56:40.060 --> 00:56:43.960
像9.6万个音符，所以目前连接的音符比我们更多

00:56:43.960 --> 00:56:48.850
拥有公共地址，所以像以前一样令人困惑

00:56:48.850 --> 00:56:52.330
这个geoip是最后六个的五万一千个地址

00:56:52.330 --> 00:57:01.450
看着网络几个月，这是肯定的，它始终知道这一点吗？

00:57:01.450 --> 00:57:04.630
相对而言，实际上我认为这是因为它将加载JavaScript

00:57:04.630 --> 00:57:10.770
在我自己的时区，但日期戳本身存储在GMT中

00:57:14.970 --> 00:57:17.840
毫米-毫米

00:57:21.950 --> 00:57:31.500
嗯，对不起，这个项目叫什么名字哦哦，是的，对不起

00:57:31.500 --> 00:57:36.420
我有我的口音，是的，是的。Kangol是的，我想我就像是“充满了，我认为这是

00:57:36.420 --> 00:57:39.530
集中，它让我发疯

00:57:49.740 --> 00:57:53.660
实际的损坏数据模式

00:58:01.460 --> 00:58:08.550
完全是100％的目标，就像嘿，这是错误的，我知道为什么，我

00:58:08.550 --> 00:58:20.400
专家，因为您希望现在多快成为现在好吗，是的，我们会得到一些

00:58:20.400 --> 00:58:25.170
团队中有更多的人可以做到这一点，这绝对是我们要做大事的地方

00:58:25.170 --> 00:58:28.830
我认为挑战对我们来说就像我们想要正确处理原始数据一样

00:58:28.830 --> 00:58:32.820
真的很像我们花了三年时间才能建立起可以在

00:58:32.820 --> 00:58:36.210
对我们而言具有性能特征的分布式上下文

00:58:36.210 --> 00:58:40.050
认为很重要，我没有为它发布而奔波，而是喜欢将其发布回来

00:58:40.050 --> 00:58:46.680
是相对简单的ALS再次对不起，是的，我不是

00:58:46.680 --> 00:58:54.359
如果有人让我们发布它，就像这样，这就是我们的git版本

00:58:54.359 --> 00:58:59.820
推送演示，现场直播总是很有趣，哦，还有另一个节点正在运行

00:58:59.820 --> 00:59:04.619
背景，这样它就不会覆盖不起作用的内容，从而推动了

00:59:04.619 --> 00:59:09.540
通过铰链连接，现在将数据放在HTTP上，因为

00:59:09.540 --> 00:59:12.990
这回落了，但我们希望一切都能持续工作，我们

00:59:12.990 --> 00:59:19.200
想要的一切都需要git和github级的好IP FS是正确的

00:59:19.200 --> 00:59:24.450
在ipfs上执行此操作的原始操作不会占用您的数据，因此操作起来非常有趣

00:59:24.450 --> 00:59:28.800
在本地，我无法告诉您工作的乐趣是什么，所以我会做很多事情

00:59:28.800 --> 00:59:33.180
与此相关的项目，我将致力于合并13种不同的数据

00:59:33.180 --> 00:59:37.020
将资源汇总到一个汇总中，并将所有这些汇总到我的本地IP FS存储库中

00:59:37.020 --> 00:59:40.740
表现得足够快，我真的像在做选择

00:59:40.740 --> 00:59:44.460
10个数据集s-用管道传输到JQ然后将其分散到某些查询中

00:59:44.460 --> 00:59:48.990
写回是将数据集全部集中在一个命令中，就像真正干净一样

00:59:48.990 --> 00:59:53.460
工作充满乐趣和兴奋，让我心情舒畅，真是太好了

00:59:53.460 --> 00:59:58.230
我的数据是经过整理的，并且放置在易于推送给他人的地方

00:59:58.230 --> 01:00:00.990
是的，我们真的很希望这种情况，如果您在实验室里

01:00:00.990 --> 01:00:04.270
环境和在同一个房间里，我不想去

01:00:04.270 --> 01:00:09.010
意思是我在这里宣讲合唱团，但我不想去我，我想去

01:00:09.010 --> 01:00:13.450
马上见到你，这就是我所拥有的，我认为非常好

01:00:13.450 --> 01:00:17.290
现在我们要进入事物的社会方面，就像我认为

01:00:17.290 --> 01:00:22.420
我们需要在UX上进行最多的工作，并试图了解如何开始

01:00:22.420 --> 01:00:29.440
解决拉取请求E的这种提交样式特征，以便在需要的地方进行

01:00:29.440 --> 01:00:40.540
去吧，我们真的很希望能尝试一下

01:00:40.540 --> 01:00:44.080
面向社区的项目，非常真实

01:00:44.080 --> 01:00:48.070
我们已经学到了很多与不同领域的数据科学家交流的经验

01:00:48.070 --> 01:00:51.310
一直在与地理空间领域的金融领域的人们交谈，

01:00:51.310 --> 01:00:54.700
环境空间通常是我们谈论的大问题，因此，如果您

01:00:54.700 --> 01:01:02.380
还有您正在使用的其他类型的数据对不起，是的时候错了

01:01:02.380 --> 01:01:06.640
问这个问题，但是是的，我认为有大量的

01:01:06.640 --> 01:01:09.190
在这里，我们已经消除了向网络添加数据的成本

01:01:09.190 --> 01:01:12.310
您用硬盘付款，我认为这是一件非常令人兴奋的事情

01:01:12.310 --> 01:01:16.210
查询中有一些相似之处，例如如果您尝试推动

01:01:16.210 --> 01:01:19.900
超过500 MB的数据集Chicago AG强度，例如我们不接受

01:01:19.900 --> 01:01:23.620
如果您尝试将其推送到多个演出数据集以进行查询，我们将

01:01:23.620 --> 01:01:27.610
说我们不接受这个，你应该写一个正确的笔记，那是不同的

01:01:27.610 --> 01:01:31.660
声明，这意味着我可以托管任何我想托管的Landsat（如果我愿意）

01:01:31.660 --> 01:01:36.280
想要，那是一件令人兴奋的事情，我认为那是我们将其保留下来的副本

01:01:36.280 --> 01:01:39.340
在注册表中，我们仍将在I / O上显示应用程序套词上的元数据，因此

01:01:39.340 --> 01:01:43.180
有人可以看到灰烬并获得最新版本，然后他们可以使用

01:01:43.180 --> 01:01:47.350
您的外观有点废话，无数的数据，令我感到兴奋的是

01:01:47.350 --> 01:01:54.150
现在存在了，我认为这很有趣，但是是的，我认为有点

01:01:55.490 --> 01:01:58.590
没有这样的事情你是什么你的资金是怎么做的

01:01:58.590 --> 01:02:01.670
我们赚钱是的

01:02:07.710 --> 01:02:15.150
是的，是的，我知道你很欣赏你，但就像在结尾处一样

01:02:15.150 --> 01:02:18.920
那天人们必须为此工作，我们曾经冒险重新创业

01:02:18.920 --> 01:02:23.340
我们将待了很多年，我不会告诉你有多少，因为

01:02:23.340 --> 01:02:31.980
越来越长，像是最少四个最少四个

01:02:31.980 --> 01:02:36.720
这周之后，我们发生了一些很棒的事情，所以我不担心

01:02:36.720 --> 01:02:40.020
但是，我们以计划的方式来满足您的要求，我会告诉您我们计划的方式

01:02:40.020 --> 01:02:44.490
最终赚钱是我们要旋转查询云，您可以在其中放

01:02:44.490 --> 01:02:47.970
您在我们服务器上的加密数据，每月给我们五美元或其他费用

01:02:47.970 --> 01:02:53.010
一些数字没有在五块钱上引用我，但是一些数字然后是主要

01:02:53.010 --> 01:02:55.230
你打算赚钱的地方是白色的，让整个东西都变成

01:02:55.230 --> 01:02:59.790
企业，因此将为需要的大型公司运行专用网络

01:02:59.790 --> 01:03:06.200
所有这些内部的想法，这样我们就可以许可其中的一些GPL和

01:03:06.200 --> 01:03:12.120
意思是说我们所有其他子包或MIT的主要意思是

01:03:12.120 --> 01:03:14.970
其他人想要使用它，就没有副本可以阻止您

01:03:14.970 --> 01:03:21.270
那是的，是的，我们是说我们什么都不会去，但是我们确实想做

01:03:21.270 --> 01:03:27.950
以正确的方式进行开放可以解决任何其他问题

01:03:28.549 --> 01:03:32.059
谢谢你

01:03:38.630 --> 01:03:42.890
有点像发展

01:03:44.950 --> 01:03:54.170
嗯，是的，所以我们实际上可以

01:03:54.170 --> 01:04:00.740
还没有发货，但是我们很抱歉有一秒钟的查询清单

01:04:00.740 --> 01:04:08.660
现在有一个木箱dag按住它是一个隐藏的命令，我们可以浸入

01:04:08.660 --> 01:04:11.930
块，所以我们可以取两个清单，然后说，嘿，块是什么

01:04:11.930 --> 01:04:14.960
这两个版本之间在大小上存在差异，因此我们

01:04:14.960 --> 01:04:18.109
计划最终将其提供给我们嘿，这是您的重复数据删除因素

01:04:18.109 --> 01:04:21.680
在这些版本中，我们应该删除该版本，这样的事情是

01:04:21.680 --> 01:04:25.609
当您管理大量的

01:04:25.609 --> 01:04:29.630
块存储中的数据，您需要知道这是什么，所以这是一个

01:04:29.630 --> 01:04:32.540
与实际数据不同的diff类型，

01:04:32.540 --> 01:04:35.740
持久层不是

01:04:41.790 --> 01:04:49.800
嗯，是的，那会毁了你的整棵树，因为

01:04:49.800 --> 01:04:52.020
每个提交都引用之前的提交

01:04:52.020 --> 01:04:56.490
是的，我们基于的是我们不喜欢变得特别的东西

01:04:56.490 --> 01:04:59.160
因为您将转换脚本中的内容放入其中，

01:04:59.160 --> 01:05:02.520
哦，不，当他们去基地改建时，我们做了一个长期的噩梦，因为

01:05:02.520 --> 01:05:06.180
我们必须弄清楚如何在出现类似情况时重播转换脚本

01:05:06.180 --> 01:05:10.020
可能是源HTTP更改了，所以我们想考虑存档

01:05:10.020 --> 01:05:16.140
现在访问我们在管理大量数据时要做的事情

01:05:16.140 --> 01:05:20.790
只是真正地管理版本，就像基本上得到提交修改一样

01:05:20.790 --> 01:05:23.700
最终我们想进入一个星期，您确实喜欢一盏灯

01:05:23.700 --> 01:05:28.590
提交您仅保留散列结果的位置，然后放入

01:05:28.590 --> 01:05:33.420
身体，然后基本上只是对最近一次提交执行该操作，

01:05:33.420 --> 01:05:36.300
然后将主体添加到第二个最近提交的第一个中，然后移出

01:05:36.300 --> 01:05:39.720
身体的全部数据，因此您始终拥有完整的数据集

01:05:39.720 --> 01:05:44.940
在您只想简单地引用历史背后的内容的时候，

01:05:44.940 --> 01:05:48.410
正在进行中的RFC

01:05:51.670 --> 01:05:57.160
嗯，不，我真的很想和彼得·布朗谈一谈

01:05:57.160 --> 01:06:00.730
关于这一点，我认为我们要做一些令人兴奋的事情

01:06:00.730 --> 01:06:04.990
在引擎盖上与Raiden碎块机一起玩过，我的意思是无论你拥有什么

01:06:04.990 --> 01:06:08.950
当前的Chucky策略对我们来说是一个理想的起点

01:06:08.950 --> 01:06:12.430
首先开发块浸渍的东西，然后开始调整我们的分块

01:06:12.430 --> 01:06:16.630
和他们在一起，我想做一段时间的语义运输，现在我已经

01:06:16.630 --> 01:06:20.020
说服这个周末不要这样做，所以我们会看看情况如何

01:06:20.020 --> 01:06:24.340
但我认为，真正的下一个是去壳，就像想如何

01:06:24.340 --> 01:06:29.440
这些模式变成了某种AI PLD，我们现在数据集已经意识到了

01:06:29.440 --> 01:06:35.110
他们如何相交重叠是这里的两个令人兴奋的事情，但这是

01:06:35.110 --> 01:06:38.830
至少要进行大量对话，我们将尝试设置

01:06:38.830 --> 01:06:42.550
这样的架构，就像我们知道的那样，该架构的熵是其中的一个子集

01:06:42.550 --> 01:06:46.810
模式，所以我们可以告诉您，嘿，我们可以将这些东西粉碎在一起，我们不知道

01:06:46.810 --> 01:06:49.120
如果它在语义上有意义，那么您现在就可以这样做

01:06:49.120 --> 01:06:52.930
但是像是的，如果我们想最终喜欢自然和自然的关节

01:06:52.930 --> 01:07:00.010
容易，但一次很酷，对所有人都非常有帮助，谢谢

01:07:00.010 --> 01:07:07.360
你真的坐过[掌声]

