WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:05.460
这是一个欢迎课程的人，很高兴看到你的脸，我希望你不要

00:00:05.460 --> 00:00:11.610
太宿醉或疲倦或其他原因，我是艾伦（Alan），这是迈克尔（Michael）和他们的

00:00:11.610 --> 00:00:17.779
斯蒂芬实际上是，我们可以和您谈谈我的PFS如何处理油脂

00:00:17.779 --> 00:00:24.600
五个部分之一，就在那里，令人兴奋，我认为那是

00:00:24.600 --> 00:00:33.059
到目前为止的反馈意见还可以吧，谁能告诉我这是什么意思

00:00:33.059 --> 00:00:39.750
不可变这个词好极了，无法更改，而不是

00:00:39.750 --> 00:00:44.969
易变，易于更改，因此我们将讨论为什么ipfs具有

00:00:44.969 --> 00:00:49.770
高度重视对等网络中的不变性和可变数据

00:00:49.770 --> 00:00:55.890
右边的那个没有权威的中心，没有人可以隐含

00:00:55.890 --> 00:01:01.379
信任，但在今天的网络中，我们暗中信任诸如此类的事情

00:01:01.379 --> 00:01:06.930
机构，所以证书颁发机构社交媒体政府，但信任

00:01:06.930 --> 00:01:12.810
容易被颠覆，我们不一定要依赖收到的数据

00:01:12.810 --> 00:01:20.009
即使我们经常进行资源完整性，也可以将其作为我们要求的数据。

00:01:20.009 --> 00:01:24.630
确保您要的数据是您知道的数据的一种方法是

00:01:24.630 --> 00:01:30.960
从数据本身计算数据的标识符，标识符是

00:01:30.960 --> 00:01:36.180
称为哈希，我们在计算哈希时使用加密来确保

00:01:36.180 --> 00:01:41.070
某些属性（例如唯一性和确定性），但我们要谈一谈

00:01:41.070 --> 00:01:46.079
在下一个会话中会更多地讨论这一点，所以一旦我们获得了该哈希值，

00:01:46.079 --> 00:01:51.320
我们可以与世界其他地方分享这两个人以为

00:01:51.320 --> 00:01:57.149
当有人掌握了这些数据时，他们还计算了哈希值，然后他们

00:01:57.149 --> 00:02:02.070
检查它们是否匹配，如果匹配，则可以，您已经获得了什么数据

00:02:02.070 --> 00:02:09.000
如果有人掌握了数据并且哈希值不匹配，则表示胜利

00:02:09.000 --> 00:02:15.360
哦，有人篡改了您的数据，所以保证了解释检查

00:02:15.360 --> 00:02:19.800
完整性检查是，如果数据更改为哈希，则内容是不可变的

00:02:19.800 --> 00:02:26.459
我不再产生比赛，因此可验证性是主要原因之一

00:02:26.459 --> 00:02:33.080
在今天的网络中使用不变的数据，我可以将贵宾犬的图片放起来

00:02:33.080 --> 00:02:41.370
abc.com将贵宾犬jpg切成斜线，然后24小时后我可以在贵宾犬上涂鸦，让我们

00:02:41.370 --> 00:02:47.220
说我加了些眼镜使他看起来更加老练，所以

00:02:47.220 --> 00:02:52.200
问题是内容不是天生就与地址相关联

00:02:52.200 --> 00:02:57.900
内容可以更改，但URL不会更改，这取决于我何时访问此内容

00:02:57.900 --> 00:03:02.090
贵宾犬可能会完全不同

00:03:02.629 --> 00:03:07.290
因此，我们今天在网络上所拥有的地址就是地址，它告诉我们在哪里

00:03:07.290 --> 00:03:11.489
数据已存储，但另一方面，没有多少有趣的内容是

00:03:11.489 --> 00:03:15.810
在这里我们使用哈希访问内容，并允许我们验证

00:03:15.810 --> 00:03:20.150
我们收到的内容就是我们要求的内容

00:03:20.480 --> 00:03:26.129
好的缓存和D duping不可变的内容完全解决了缓存

00:03:26.129 --> 00:03:29.099
这样的问题，因为数据永远不会更改缓存规则

00:03:29.099 --> 00:03:32.510
我们永远缓存

00:03:32.700 --> 00:03:38.580
回到我们的示例中，如果我们使用内容寻址可爱的贵宾犬，

00:03:38.580 --> 00:03:43.920
从其内容派生出来的特定地址hack，如果我更改了该地址

00:03:43.920 --> 00:03:49.769
那只贵宾犬24小时后，地址也改变了，但是没关系

00:03:49.769 --> 00:03:55.439
任何人都可以验证它是否已缓存和获取，如果我想同时保留两者

00:03:55.439 --> 00:04:01.140
文件很好，因为内容是不可变的ID FS，任何读取实际上都需要

00:04:01.140 --> 00:04:07.019
将所做的更改存储在我们实际看到的两个文件之间的差异中

00:04:07.019 --> 00:04:12.360
许多相同的字节，所以如果我拥有这些文件之一，那么我拥有的数据量

00:04:12.360 --> 00:04:15.760
转移以获取另一个确实很小

00:04:15.760 --> 00:04:20.450
当前，如果要存储这两张非常相似的图片，我需要

00:04:20.450 --> 00:04:24.260
将它们全部存储在我的磁盘上，如果我想与某人共享它们

00:04:24.260 --> 00:04:27.920
而且您想要两者，我希望他们看到这两张图片，我必须

00:04:27.920 --> 00:04:33.980
将它们全部转移，我们将了解有关ipfs如何实现该神奇DG的更多信息

00:04:33.980 --> 00:04:39.740
ping东西以后可以从任何人那里获得好的效果，如果内容

00:04:39.740 --> 00:04:44.480
是一成不变的，我可以验证其完整性，我应该能够

00:04:44.480 --> 00:04:50.840
从任何人那里得到的，这真的非常适合p2p，但是事实并非如此。

00:04:50.840 --> 00:04:56.720
今天的网络，所以我在网上有两个托管相同内容的网站怎么办

00:04:56.720 --> 00:05:03.260
我知道这些贵宾犬中哪一个是正确的贵宾犬，所以答案

00:05:03.260 --> 00:05:06.980
是我们不能相信这些贵宾犬中的任何一个都是正确的

00:05:06.980 --> 00:05:12.890
可爱的贵宾犬，但我们只是无法从需要它的人那里得到它

00:05:12.890 --> 00:05:21.410
来自一个受信任的来源，因为我无法很好地验证其完整性，因此

00:05:21.410 --> 00:05:28.160
我们在ipfs中使用内容寻址，并使用称为CID CID的特殊哈希

00:05:28.160 --> 00:05:33.230
代表内容标识符，第二部分我们将详细介绍

00:05:33.230 --> 00:05:39.490
的五分之一好吧，这一切都始于加密散列a

00:05:39.490 --> 00:05:46.040
评论者一个伪造的哈希函数将任意大小的输入映射到固定的输出

00:05:46.040 --> 00:05:51.200
大小，并且我们希望从该哈希中获得一些属性，因此相同的数据应始终

00:05:51.200 --> 00:05:55.940
产生相同的哈希值，因此它是确定性的，应该不可能

00:05:55.940 --> 00:06:02.450
像我们那样反转我们不应该能够从散列中重建数据

00:06:02.450 --> 00:06:09.910
也应该是唯一的，因此没有两个不同的文件应该产生相同的

00:06:10.039 --> 00:06:15.659
ipfs使用char来存在许多不同的哈希算法

00:06:15.659 --> 00:06:20.479
默认情况下为256，这只是ITS中可用的一些

00:06:20.479 --> 00:06:26.579
我们可以使用像sha-1这样的较旧的农业算法被证明已被破坏，

00:06:26.579 --> 00:06:32.329
不是没有冲突的，如果和问题是算法是否可以破解

00:06:32.329 --> 00:06:39.629
我们将要在以后的默认情况下切换我们默认使用的哈希

00:06:39.629 --> 00:06:44.849
切换算法的问题是给定的哈希只是一个序列

00:06:44.849 --> 00:06:51.569
位，我们使用了什么算法来生成该哈希，我们需要一个

00:06:51.569 --> 00:06:57.300
将用于生成散列的散列函数标识为

00:06:57.300 --> 00:07:05.849
以及哈希名称向多重哈希打招呼，它将解决您的所有问题，因此

00:07:05.849 --> 00:07:10.979
多重哈希是仅位于末尾的哈希，但它也是一个前缀

00:07:10.979 --> 00:07:18.839
该前缀是一个数字，现在是go算法，它标识哈希

00:07:18.839 --> 00:07:23.939
用来生成骇客的算法和另一个数字

00:07:23.939 --> 00:07:30.089
哈希长度这两个数字都是变体，Virant只是紧凑的

00:07:30.089 --> 00:07:36.899
对整数进行编码，算法编号是多编解码器，因为a是Savarin但b

00:07:36.899 --> 00:07:41.969
是它的值是我们同意的预定义值，它在内部

00:07:41.969 --> 00:07:46.829
Internet上的表格，字符2的多涂层标识符

00:07:46.829 --> 00:07:53.429
二五六是数字十八，我们的哈希长度是二五六

00:07:53.429 --> 00:07:58.679
二进制，看起来像这样，您会看到哈希长度实际上是2

00:07:58.679 --> 00:08:03.869
字节长，这是因为长度超过一二七，并且在

00:08:03.869 --> 00:08:09.839
大于1到7的编码数字被编码为2个字节，因此您可以

00:08:09.839 --> 00:08:14.909
认为这就像两次一二八是二五六，但这不是

00:08:14.909 --> 00:08:20.819
真的是在工作多远，这只是巧合，是的，两口

00:08:20.819 --> 00:08:28.469
因为它超过了1到7，所以我们要支持多种编码危险

00:08:28.469 --> 00:08:33.779
所以你有一个哈希，当你拿回数据时，我正在整理你的数据

00:08:33.779 --> 00:08:38.969
你知道它的编码方式吗，我们可能会用C Bohr简洁的方式对其进行编码

00:08:38.969 --> 00:08:43.169
二进制对象表示形式，可能在协议缓冲区中进行了编码，可能是

00:08:43.169 --> 00:08:48.420
编码为仅播放JSON，为什么我们想要这个呢？

00:08:48.420 --> 00:08:52.410
特别紧凑的二进制编码，因此对于存储确实非常有效，但是它

00:08:52.410 --> 00:08:56.009
可能是为了方便起见，可能只是很简单，可能很快

00:08:56.009 --> 00:09:00.360
但是我们又遇到了同样的问题，例如当我们查看一些编码数据时

00:09:00.360 --> 00:09:09.300
我们怎么知道如何解码它相同的解决方案更多元数据前缀，所以这是

00:09:09.300 --> 00:09:15.899
IP LD编解码器和ipfs现在添加的任何内容

00:09:15.899 --> 00:09:25.740
gets是用于对数据进行编码的编解码器，标记为da g PB，它为P

00:09:25.740 --> 00:09:32.130
 B代表协议缓冲区，所以它只是编码的协议缓冲区

00:09:32.130 --> 00:09:36.930
我说过，这是对数据的紧凑编码，我们有一些元数据可以

00:09:36.930 --> 00:09:47.160
在哈希之后开始，是的，您可以使用许多IP LD格式，并且

00:09:47.160 --> 00:09:56.880
太多了，所以有两个不同的CID版本，

00:09:56.880 --> 00:10:03.300
如今或未来，他们经常会感到沮丧

00:10:03.300 --> 00:10:08.189
版本1是我们使用的主要版本，其中包含版本0和版本1

00:10:08.189 --> 00:10:13.559
这只是一个数字前缀，我们添加到前面，所以你们所有人，如果您

00:10:13.559 --> 00:10:18.600
使用ipfs之前，您可能会习惯于看到类似此版本的c ID 0是一个

00:10:18.600 --> 00:10:24.839
这个最高的版本和版本1是最低的版本，因此版本0是

00:10:24.839 --> 00:10:30.269
以qm的种类开始，通常版本0从qm的版本1开始

00:10:30.269 --> 00:10:38.699
开头是baffi或浴盒，有时还可以，所以事情就是看ID

00:10:38.699 --> 00:10:44.190
二进制数据的零和一在打印时会形成很长的字符串

00:10:44.190 --> 00:10:49.050
甚至不适合幻灯片上的锯，所以我们要做的是使用

00:10:49.050 --> 00:10:53.610
较高的数字基编码，并使它们更短且更易于打印

00:10:53.610 --> 00:11:01.500
识别出即使是字符串形式，我们又遇到了另一个问题

00:11:01.500 --> 00:11:07.699
我们是否解释创建此字符串所创建的数字基础编码

00:11:07.699 --> 00:11:12.779
一种编码中的字符在另一种编码中有效，因此我们不能只看

00:11:12.779 --> 00:11:21.329
在字符串上，就像那也是一个基本的伙伴，所以我们如何解决这个问题

00:11:21.329 --> 00:11:27.839
好吧，您猜到了它更多的元前缀，这是多基础的，多基础的帮助

00:11:27.839 --> 00:11:33.060
我们知道内容以第一个符号编码的数字是

00:11:33.060 --> 00:11:46.069
编码B的标识符是基数52 Z或Z是基数58 BTC而M是基数64

00:11:46.069 --> 00:11:52.350
版本零的C ID（如您在上一张幻灯片中看到的QM）也以58为基础

00:11:52.350 --> 00:11:57.300
编码，我刚刚告诉过您，基数58应该以Z为前缀，但是它们是

00:11:57.300 --> 00:12:02.279
如果您对此感到疑惑，请不要担心，我们将在

00:12:02.279 --> 00:12:07.889
分钟就可以了，所以第一个第一个符号之后的字符串的其余部分就是其余部分

00:12:07.889 --> 00:12:12.899
该特定基础中编码的CID的数量，因此所有

00:12:12.899 --> 00:12:18.420
对于CID，这就是二进制形式的CID版本

00:12:18.420 --> 00:12:22.829
是IP LD格式的多编解码器，它是将多哈希拆分的多操作

00:12:22.829 --> 00:12:27.510
如您所知，因为我们发现它是通过使用

00:12:27.510 --> 00:12:33.399
哈希长度作为流，我们有多重基础

00:12:33.399 --> 00:12:43.800
编码，并且该编码应用于其余CID的效果很好，因此

00:12:43.800 --> 00:12:49.060
如果启动浏览器并转到

00:12:49.060 --> 00:12:54.910
CID des ipfs IO，如果您正在发生CID，他们将碰巧有一个

00:12:54.910 --> 00:13:00.370
躺在那里，然后您可以将其粘贴到该工具中，它将挑选出这些

00:13:00.370 --> 00:13:05.680
我们刚刚讨论过的CID的属性，并向您显示

00:13:05.680 --> 00:13:08.920
ipfs中的一个工具（如果已在命令行上安装了该工具）

00:13:08.920 --> 00:13:13.720
 ipfs CID，这样您就可以更改八分位数或

00:13:13.720 --> 00:13:19.330
CID的版本号（如果您键入IP CID）-帮助它告诉您如何使用

00:13:19.330 --> 00:13:23.260
它，所以如果您想要一个b0c的想法并想将其转换

00:13:23.260 --> 00:13:27.370
成为一个，把它放进去，或者其他任何东西，但是我要打开它

00:13:27.370 --> 00:13:38.170
现在，向您展示一些我先前准备的一些C ID，我可以算出

00:13:38.170 --> 00:13:42.360
怎么打开它当然不会连接

00:13:42.360 --> 00:13:45.360
守护程序

00:13:50.290 --> 00:13:58.169
很快，我将有第一个开斋节

00:13:59.579 --> 00:14:06.189
以字符串开头，这是Buffy CID，这是低音32编码的CID

00:14:06.189 --> 00:14:14.850
哦，一旦ID用称为dag PB的IPO D格式编码，锤子杜松子酒

00:14:14.850 --> 00:14:19.359
我们在末尾有多重哈希，这是山的名字

00:14:19.359 --> 00:14:23.739
hash哈希算法的名称是喊2 2 5 6的长度2 5 6和

00:14:23.739 --> 00:14:33.689
这是实际的哈希值，就像我说的那样是多库，它的代码是

00:14:33.689 --> 00:14:40.779
从字符串开始是B，这很适合-谢谢B的多重哈希-

00:14:40.779 --> 00:14:46.089
像在幻灯片上看到的那样，char的字符2 2 5 6的编码是18

00:14:46.089 --> 00:14:52.859
那就是我已经将base64编码的代码，如果我将其粘贴到这里

00:14:52.859 --> 00:14:59.799
记得我在CID以M开头之前说过基本的，他们是按照这个做的

00:14:59.799 --> 00:15:05.289
没关系，所以这是另一个CID V 1是的基础知识T 4

00:15:05.289 --> 00:15:10.919
我在这里也有一个带有不同IPL变形器的

00:15:12.940 --> 00:15:22.940
所以这是一个以base 58 BTC编码的v1c ID，这很有趣，因为它是

00:15:22.940 --> 00:15:27.830
使用dag请参阅bor IP LD格式，而不是向量V的dag PB是

00:15:27.830 --> 00:15:32.540
添加文件的默认设置没有得到，但是您可以使用ipfs dag API来

00:15:32.540 --> 00:15:42.529
创建具有不同编码的结构，这很好

00:15:42.529 --> 00:15:46.750
最后，你们可能一直在等待的那个

00:15:46.750 --> 00:15:54.830
这里发生了什么好吧，这是一个V 0 CID，您可以在这里看到um

00:15:54.830 --> 00:16:02.180
从QM开始，它是对人脸58进行编码，但是如果我们在这里使用基于多语言的代码怎么办

00:16:02.180 --> 00:16:13.339
隐式多编解码器代码隐式我们应该谈论什么

00:16:13.339 --> 00:16:23.839
哦，很酷，一开始好多了

00:16:23.839 --> 00:16:33.410
哈希，它们被编码为以58 BTC为基础的所有版本零，请参见ID否

00:16:33.410 --> 00:16:40.339
多库，所以这就是为什么他们不以Z开头的原因，为什么我以QM开头的原因

00:16:40.339 --> 00:16:47.240
虽然很好，它们只是多重哈希和MA，它们只是多重哈希

00:16:47.240 --> 00:16:53.089
对面部58进行了编码，因此，如果您还记得关于多重哈希的幻灯片，

00:16:53.089 --> 00:16:57.320
多重散列是散列函数加上一半长度加上散列和

00:16:57.320 --> 00:17:04.459
多重哈希开头的那两件事通常是固定的

00:17:04.459 --> 00:17:08.390
在ipfs中，所以这就是为什么您会看到很多这些的原因，而这正是它的原因

00:17:08.390 --> 00:17:16.160
这些是您这个qm只是那些以基数58编码的两个数字

00:17:16.160 --> 00:17:22.040
基地永远是基地58 BTC，就像它说的那样，那么如果这些还没有，

00:17:22.040 --> 00:17:29.860
版本零，请参阅ID只是多哈希值，它们除了没有什么外没有什么

00:17:29.860 --> 00:17:43.510
拥有正确的人，他们没有格式，没有CID版本，所以

00:17:43.510 --> 00:17:48.070
总共对于V零，这是更简单的，因为它们只是多个

00:17:48.070 --> 00:17:52.360
演员和他们的酒是他们的基础58编码的多个散列，这就是为什么他们

00:17:52.360 --> 00:18:00.220
从cue em开始，您可以像这样思考它们，因此，多基础是

00:18:00.220 --> 00:18:08.320
总是基于58英尺，简单的PTC是Z，这是隐式的，不是书面的CID版本

00:18:08.320 --> 00:18:14.710
始终为0，这是隐式的，它不是写的IP LD格式始终是dag PB，它是

00:18:14.710 --> 00:18:20.529
隐式的，它没有写，哈希函数总是char为256

00:18:20.529 --> 00:18:31.299
它是显式的而不是隐式的这是一个技巧问题，它在多重哈希中，所以

00:18:31.299 --> 00:18:37.330
哈希函数在多脂肪补丁中，是否在哈希中

00:18:37.330 --> 00:18:43.690
长度也是明确的，它在多重哈希中，如果有任何这些变量

00:18:43.690 --> 00:18:52.390
更改，那么您就不再有V零CID了，很酷，所以现在您知道了

00:18:52.390 --> 00:18:59.770
我如何使用C ID和哈希值来TFS处理内容，我们现在可以学习

00:18:59.770 --> 00:19:05.140
关于ipfs实际处理的数据结构的介绍，非常酷

00:19:05.140 --> 00:19:10.500
迈克尔大家

00:19:12.100 --> 00:19:20.049
我们已经做了三遍了，所以我确定你是个傻瓜

00:19:20.049 --> 00:19:23.350
大概在这一点上听到了一点

00:19:23.350 --> 00:19:29.140
dag只是直接丙烯酸RAF的花哨缩写，这是一个非常花哨的词

00:19:29.140 --> 00:19:33.220
对于这个概念，如果您考虑普通的树状结构，则有一个根

00:19:33.220 --> 00:19:36.400
然后是一些分支，最后是一些叶子，通常在

00:19:36.400 --> 00:19:40.660
一棵树的结构，一片叶子会有一个父母，而一棵树则是一棵树，但是在

00:19:40.660 --> 00:19:44.440
至少它可以有多个父母，没有循环引用，我们会得到

00:19:44.440 --> 00:19:54.010
在一分钟内这是不可能的，这就是我的全部意思，所以让我们

00:19:54.010 --> 00:19:58.659
建立一个dag，所以关于构建基于散列的数据的一件有趣的事

00:19:58.659 --> 00:20:02.500
结构是您必须向后构建它们，以便习惯于编写

00:20:02.500 --> 00:20:08.440
递归函数，希望您喜欢它，所以我们将从这里开始

00:20:08.440 --> 00:20:13.030
你好世界只是我们的小对象，这是我们将获得一半的叶子节点

00:20:13.030 --> 00:20:18.850
其中的哈希是cume哈希，现在我们建立到该叶节点的第一个分支

00:20:18.850 --> 00:20:23.980
那就是你要知道食物的客观属性

00:20:23.980 --> 00:20:29.140
警察将得到两个多维数据集哈希，然后我们可以创建另一个叶节点

00:20:29.140 --> 00:20:33.330
都指向父母

00:20:35.570 --> 00:20:41.149
你知道另一个属性只是一个任意的元数据，而这两个都是

00:20:41.149 --> 00:20:45.259
指在屋顶上，因此它们都被打上了补丁，然后用作属性

00:20:45.259 --> 00:20:50.629
在根政府中，您最终得到的是一个完整的数据结构，

00:20:50.629 --> 00:20:55.700
现在看起来像这样，在这个你不能说这些是

00:20:55.700 --> 00:20:58.279
基本相同，但从语义上讲这是一个大数据

00:20:58.279 --> 00:21:01.909
得到的结构，然后可以将其分解成这样的块

00:21:01.909 --> 00:21:04.609
显然，这是一个非常小的数据结构，因此我们通常不会破坏

00:21:04.609 --> 00:21:07.940
这变成一堆数据块，但是当您有非常大的数据时

00:21:07.940 --> 00:21:11.239
结构，您想将它们分解成较小的Samantha块，这就是

00:21:11.239 --> 00:21:16.039
您做到了，您做的一切以及链接最终可以在任何API中工作的方式，

00:21:16.039 --> 00:21:20.599
 IPL de或IPSS是他们得到趋势，他们基本上得到遍历

00:21:20.599 --> 00:21:27.229
透明地，所以你知道如果你在这里取qm4的一半，然后你跟随

00:21:27.229 --> 00:21:30.679
通过你知道你遍历整个世界的人

00:21:30.679 --> 00:21:34.519
结构，直到您只是问好了，这将抓住所有

00:21:34.519 --> 00:21:40.879
这些块可以透明地遍历您，但您也可以知道

00:21:40.879 --> 00:21:52.729
抓住其中一个的哈希值，这样就知道您是否已经拥有任何哈希值

00:21:52.729 --> 00:21:56.660
在这些分支中，您可以更高效地遍历

00:21:56.660 --> 00:22:02.690
嗯，我们开始吧，所以如果我们现在以自上而下的方式看树，

00:22:02.690 --> 00:22:07.400
链接指向下方，我们可以谈谈

00:22:07.400 --> 00:22:12.800
造天，所以我们在这里看到我们有两个分支指向同一个叶子

00:22:12.800 --> 00:22:17.360
但是，如果我们尝试创建对父级的引用，会发生什么情况

00:22:17.360 --> 00:22:20.770
基本上尝试创建一个循环引用，实际上是不可能的

00:22:20.770 --> 00:22:25.280
因为如果您修改此设置，您将要修改图案填充，并且因为

00:22:25.280 --> 00:22:30.680
柴刀，这是这些叶子里面所含之物的一部分

00:22:30.680 --> 00:22:34.430
扎根-那么这将改变所有事物的一半，因此

00:22:34.430 --> 00:22:38.990
这就是知道根本无法对根节点进行黑客攻击

00:22:38.990 --> 00:22:43.460
事先知道，除非您在票据中有一个哈希泵，否则，如果您不知道

00:22:43.460 --> 00:22:50.300
使用shell一件不好的事情会变得如此，所以在我们进入那种问题之前，有任何疑问

00:22:50.300 --> 00:22:57.800
讨论中关于块大小的问题，一点问题都没有，块

00:22:57.800 --> 00:23:06.350
大小，所以是块大小就像您知道要加热的三只熊

00:23:06.350 --> 00:23:13.250
寒冷只是这样写，所以很多东西可能太大了，当你开始做的时候有一些

00:23:13.250 --> 00:23:17.810
块越来越大，您会遇到一系列不同的问题，一个大问题是

00:23:17.810 --> 00:23:22.040
您无法从多个同伴下载单个块的问题是

00:23:22.040 --> 00:23:26.990
在不受信任的网络中，任何人都只能通过以下方式为您提供不良数据：

00:23:26.990 --> 00:23:30.740
您必须验证数据是否正确，是整个数据的哈希值

00:23:30.740 --> 00:23:34.790
阻止，所以如果您从两个人那里提取同一块的数据，然后

00:23:34.790 --> 00:23:38.270
不验证谁向您发送了错误的数据，不知道

00:23:38.270 --> 00:23:41.300
就像BitTorrent从事这项工作的时间比任何人都长，

00:23:41.300 --> 00:23:46.190
如果看起来太慢，他们就不再尝试这样做了，他们决定

00:23:46.190 --> 00:23:49.810
从新时期开始

00:23:50.480 --> 00:23:55.020
当您拥有这些大的不可变结构，然后您进行突变时，

00:23:55.020 --> 00:23:59.730
他们你得到一条新路线，我们进入了一点点，最终你创造了什么

00:23:59.730 --> 00:24:02.880
被称为孤立块，如果您曾经建立数据库或处理过

00:24:02.880 --> 00:24:07.799
就像磁盘上的可变数据结构一样，您遇到了同样的问题

00:24:07.799 --> 00:24:10.919
我们就像在您更改事物时最终会得到像垃圾一样的数据

00:24:10.919 --> 00:24:15.480
然后必须在某个时间点将其收集起来，这样当您真正拥有

00:24:15.480 --> 00:24:18.960
大块积木会留下很大的孤儿积木，然后

00:24:18.960 --> 00:24:23.490
大量孤儿产生了更大的GC问题，不同的运输方式可能会有

00:24:23.490 --> 00:24:26.850
不同的限制位交换存在超过2 MB的块的问题

00:24:26.850 --> 00:24:30.990
现在，该问题可能会得到解决，但您仍应尝试将其保留在

00:24:30.990 --> 00:24:35.309
记住并记住其他交通工具也会有一些你

00:24:35.309 --> 00:24:39.120
最终，重复数据删除的数量就少得多，而您制作的块越大，

00:24:39.120 --> 00:24:43.799
因为我们唯一用于重复数据删除的方法是哈希本身，所以

00:24:43.799 --> 00:24:47.700
如果你把所有这些小颗粒都当作是相同的数据

00:24:47.700 --> 00:24:51.150
跨许多不同的节点，但它们不是链接，它们只是嵌入在

00:24:51.150 --> 00:24:58.559
块，那么那些将永远不会让你复制你的小，所以你也最终

00:24:58.559 --> 00:25:03.270
问题，当您制造一堆微小的微小块时，您就变成了大块

00:25:03.270 --> 00:25:05.880
如果您愿意的话，您最终将获得更多块的更多请求

00:25:05.880 --> 00:25:08.130
得到的数据量很少，最终却得到许多不同的数据

00:25:08.130 --> 00:25:11.700
可能不在网络中的块，可能不在磁盘上，但它是

00:25:11.700 --> 00:25:15.510
除非您已经做过，否则通常会导致I / O往返

00:25:15.510 --> 00:25:21.440
经历了很多的内存缓存日，您最终也得到了更多的编码时间

00:25:21.440 --> 00:25:25.409
当您编写不同的块编码器时，可以使它们更高效

00:25:25.409 --> 00:25:28.920
通常一次您会有更多，所以如果您有的话

00:25:28.920 --> 00:25:31.860
少得多的数据集，则可能会导致编码效率降低

00:25:31.860 --> 00:25:37.080
虽然最大的一次是散列散列散列函数通常具有

00:25:37.080 --> 00:25:40.230
有保证他们将花费多长时间来处理任何数量的数据，因此

00:25:40.230 --> 00:25:42.420
如果最终有很多较小的块，那么最终将像

00:25:42.420 --> 00:25:45.780
更多的哈希实际上将花费更多的计算时间

00:25:45.780 --> 00:25:50.400
关于那个魔术，然后与阻止请求类似，您最终得到的只是

00:25:50.400 --> 00:25:54.600
对给定的数据有更多的跃点，因此无论何时您想看一些东西

00:25:54.600 --> 00:25:58.590
通过一个深图，您最终会像从一件事转到另一件事，然后

00:25:58.590 --> 00:26:02.190
您创建的团队越多，创建的链接越多

00:26:02.190 --> 00:26:07.530
是的，所以潜在的表现是正确的

00:26:07.530 --> 00:26:12.990
很大程度上取决于您的用例，没有一种真正的方法可以做到这一点

00:26:12.990 --> 00:26:16.710
不幸的是，这就是为什么我们创建了这么多灵活的结构以及您如何

00:26:16.710 --> 00:26:20.730
创建块以及如何创建DAG是不同的用例

00:26:20.730 --> 00:26:24.360
会要求非常不同的dag结构，因此如果您要优化

00:26:24.360 --> 00:26:28.710
如果您可以预先花费很多性能成本，则可以进行读写操作

00:26:28.710 --> 00:26:34.380
正确的时间使读取速度非常快，如果您有的话，可以这样做

00:26:34.380 --> 00:26:38.640
通常，当您具有可变结构时，您实际上不会突变

00:26:38.640 --> 00:26:43.350
图的特定部分，但是每次

00:26:43.350 --> 00:26:47.190
例如，当ipfs创建文件并将其分块时，我们

00:26:47.190 --> 00:26:50.700
总是将整个文件从磁盘中拉出，然后通过分块器运行它

00:26:50.700 --> 00:26:54.090
不喜欢看现有的分块文件，然后走，哦，我看到了

00:26:54.090 --> 00:26:57.630
我可以像你所知道的那样贴在这里

00:26:57.630 --> 00:27:01.350
如果它们匹配，我们每次都会对其重新编码，因此您将使用

00:27:01.350 --> 00:27:06.450
不同的算法来创建该dag并基本平衡，那么您将

00:27:06.450 --> 00:27:10.380
如果你只是想随着时间的推移改变一个dag，就像一个真正的

00:27:10.380 --> 00:27:14.010
一个很好的例子，就像你经常做的事情，所以

00:27:14.010 --> 00:27:16.150
有一个算法和一个火腿

00:27:16.150 --> 00:27:20.840
保证一定的平衡和固定的宽度

00:27:20.840 --> 00:27:25.550
抱歉，那棵树会变大的时代深度，这些就像您知道的一样

00:27:25.550 --> 00:27:29.270
在决定日期和方式时可以进行的各种权衡

00:27:29.270 --> 00:27:33.710
您想要多大和多大的一款，您还具有运输性能

00:27:33.710 --> 00:27:37.580
如果您拉出所有障碍物，问题就正确了，您知道这就像一个

00:27:37.580 --> 00:27:40.820
HTTP Duke与一台主机的连接将会有很大的不同

00:27:40.820 --> 00:27:44.120
性能配置文件，而不是将其从对等网络中拉出来，所以您

00:27:44.120 --> 00:27:47.480
当您处于

00:27:47.480 --> 00:27:52.940
您正在创建那些块结构，否则将等待任何

00:27:52.940 --> 00:28:27.350
在我们打破之前提出问题，所以事实证明，

00:28:27.350 --> 00:28:33.350
文件大小写取决于文件类型，并且有不同的分块器

00:28:33.350 --> 00:28:36.860
您可能会在其他文件类型上获得更好的重复数据删除功能

00:28:36.860 --> 00:28:41.090
所以我们实际上将在稍后再讨论，我想我们聊了

00:28:41.090 --> 00:28:44.810
是关于兔子的，对吧，好吧，就像文本有如算法一样疯狂

00:28:44.810 --> 00:28:47.509
以一种非常好的方式将其分解

00:28:47.509 --> 00:28:52.379
是的，将在下一节中答应，是的，还有其他任何问题

00:28:52.379 --> 00:28:59.450
关于DAG和纸箱尺寸是的，您是否认为它们非常有效？

00:28:59.450 --> 00:29:06.830
哪种算法可以像一天中制作广告一样处理广告中的任何内容

00:29:06.830 --> 00:29:12.389
嗯，我认为我们有一些不错的选择，所以现在的问题是

00:29:12.389 --> 00:29:15.899
我们尚未针对不同的数据类型进行预配置，以使用不同的请求

00:29:15.899 --> 00:29:19.169
必须告诉它我认为哪个吸盘有一些非常好的选择

00:29:19.169 --> 00:29:24.330
我认为哪个使用的chunker和chunker中相当不错的默认值

00:29:24.330 --> 00:29:27.830
我们目前还不是很高效，而您所需要的是

00:29:27.830 --> 00:29:33.419
dag指向文件，因此文件中的目录正确，例如

00:29:33.419 --> 00:29:36.539
您有一个非常小的文件，我们没有办法喜欢内联

00:29:36.539 --> 00:29:39.720
将二进制文件放入文件中，我知道该文件很小，您可以将其放到一个文件中

00:29:39.720 --> 00:29:42.990
正确的目录，就像您有五个文件的目录和整个目录一样

00:29:42.990 --> 00:29:48.960
设置就像一个兆字节的十分之一只是一个块谢谢卡里斯

00:29:48.960 --> 00:29:54.119
嗯，但我们目前还没有办法在dag PB中做到这一点，所以在

00:29:54.119 --> 00:29:59.070
今天晚些时候，联合国儿童基金会（UNICEF）的v2深入探讨，我将探讨如何解决这个问题，所以我

00:29:59.070 --> 00:30:02.789
认为我们没有一种非常有效的方法来创建文件，但是

00:30:02.789 --> 00:30:07.669
一旦进入文件分块，我们就在那里完成了一些相当不错的工作

00:30:12.649 --> 00:30:21.409
关联是是，但在用户中击败了您

00:30:29.330 --> 00:30:32.330
只是

00:30:36.650 --> 00:30:44.420
很好，嗯，嗯，现在有很多街区了

00:30:44.420 --> 00:30:50.090
现在正在使用c1，它将成为文件元数据的一个块，然后

00:30:50.090 --> 00:30:55.340
对于泄漏的实际文件数据至少一个块-然后

00:30:55.340 --> 00:31:02.300
周围的目录将互锁，因此将来他们会认为

00:31:02.300 --> 00:31:05.750
例如，如果您只是想像一下dag，

00:31:05.750 --> 00:31:09.620
整个堆栈中完成的事情是一个块可以包含一个

00:31:09.620 --> 00:31:13.190
我们称之为节点的任意数量，所以没有像任何地图或任何

00:31:13.190 --> 00:31:19.160
我们在其中没有新的编解码器（例如XE Boren卡座JSON）中没有的值

00:31:19.160 --> 00:31:23.390
是的，没有任何限制。

00:31:23.390 --> 00:31:28.400
您可以使用的类型，以便将来我会说是的，一个块可以

00:31:28.400 --> 00:31:35.690
包含许多文件现在有一些是的

00:31:35.690 --> 00:31:40.790
是的，倾向于您的问题，您不应该想到一对一的映射

00:31:40.790 --> 00:31:56.750
在区块或实际上任何数据结构上的文件与区块之间

00:31:56.750 --> 00:32:03.640
是一个深潜，是的，就像被开发了，这是你的休息时间

00:32:03.640 --> 00:32:08.360
我们在中间部分流血就像我们如何在FS中获取文件并

00:32:08.360 --> 00:32:12.080
该文件中发生了什么以及它创建的结构是的，我们将做一些

00:32:12.080 --> 00:32:20.300
例子，如果您喜欢um，是否还有其他问题，是的，对吧

00:32:20.300 --> 00:32:24.700
现在，因为你说如果你回来，我们现在要做五分钟

00:32:24.700 --> 00:32:32.560
然后你又回到了四分之一，那是反对吧，让我们进入一些

00:32:32.560 --> 00:32:39.430
深入探讨文件给我带来的重要性

00:32:39.430 --> 00:32:45.550
人们在这里，但我确定他们会穿梭，让我们开始吧

00:32:45.550 --> 00:32:55.180
当我使用ipfs添加文件时，实际上会发生这种情况

00:32:55.180 --> 00:33:00.070
实际发生的是，这些位被分为几块一块

00:33:00.070 --> 00:33:05.380
两个免费的块，稍后我将参考它们，就像您看到C 1 C 2 C一样

00:33:05.380 --> 00:33:09.790
3这是文件的各个部分，文件的各个部分被分块

00:33:09.790 --> 00:33:16.660
向上，所以这些块被排列成一个dag的树结构，所以

00:33:16.660 --> 00:33:20.470
我们已经讨论过图形节点中的类似项目，并非每个节点都需要

00:33:20.470 --> 00:33:24.490
包含文件的一部分这些节点中的一些是中间节点

00:33:24.490 --> 00:33:29.080
可能包含大块文件，但在此示例中并非总是如此

00:33:29.080 --> 00:33:33.910
是的，我们已经有了，我们已经在这三个树干中找到了大块

00:33:33.910 --> 00:33:41.260
在建立图表时已经创建了这种饮食的叶子

00:33:41.260 --> 00:33:45.340
谈到了一点，但我们计算了每个节点的CID

00:33:45.340 --> 00:33:50.050
自下而上发生，之所以发生，是因为我们无法计算

00:33:50.050 --> 00:33:54.760
父母的CID，直到我们注意到孩子的IDS，因为CID为

00:33:54.760 --> 00:34:00.190
根据数据以及它具有的任何链接计算得出的，因此我们没有链接

00:34:00.190 --> 00:34:05.200
要查看链接的ID，我们无法计算该节点的CID，因此我们

00:34:05.200 --> 00:34:10.120
我们必须从这里的底部开始，然后返回并添加一个我们不能

00:34:10.120 --> 00:34:13.720
进行排名靠前的一项，因为我们没有排名靠前的一项，因此我们必须遍历所有

00:34:13.720 --> 00:34:18.670
一直到树叶，然后慢慢地回到我们的路上，我们

00:34:18.670 --> 00:34:25.540
最终到达根CID cqm哈希六，因此对于单个文件，这就是CID

00:34:25.540 --> 00:34:29.700
退还给您，您可以想到此CID

00:34:29.700 --> 00:34:37.079
作为文件的CID，但实际上它是节点顶部的节点的CID

00:34:37.079 --> 00:34:44.879
可以组成您文件的树，让我们来看看它的实际效果，您可以尝试一下

00:34:44.879 --> 00:34:49.530
在您的浏览器中以及Dagda ipf esta IO的位置上放一个小文件

00:34:49.530 --> 00:34:54.720
不到100 K，人们像五名Meg飞行员一样掉落在上面

00:34:54.720 --> 00:34:59.069
并且我将块大小设置得非常慢很低

00:34:59.069 --> 00:35:03.690
就像他们的浏览器开始变化一样，因为它试图

00:35:03.690 --> 00:35:07.140
渲染哦，废话，所以它的作用是为您渲染dag，它正在尝试

00:35:07.140 --> 00:35:15.030
将图形渲染成一百万个笔记，因此只需删除一个小文件，就可以在这里

00:35:15.030 --> 00:35:19.109
我们走了，如果你走的太小，那么你只会得到一个单一的音符说

00:35:19.109 --> 00:35:24.420
那里是一个甜蜜的地方，所以我们去吧，你应该并且你应该看到

00:35:24.420 --> 00:35:27.319
看起来像这样的东西

00:35:34.420 --> 00:35:45.400
哦，是的，如果我有我的文件夹，好吧，所以你应该看看

00:35:45.400 --> 00:35:55.240
有点像这样好吧，这是什么，这是一个可以运行的工具

00:35:55.240 --> 00:36:01.990
浏览器中的JSI PFS如果将文件拖放到该文件上，则会显示以下内容：

00:36:01.990 --> 00:36:09.390
被创建，所以我们可以做的是将文件放到

00:36:18.840 --> 00:36:24.390
好的，我们可以放下一个火灾报警器，这是从我的PFF回购中读取我的信息，

00:36:24.390 --> 00:36:28.890
会替我丢下我的狗，我可以将鼠标悬停在鼻子上，然后我会看到

00:36:28.890 --> 00:36:32.370
在这里的底部，我们有一个酒吧，告诉我们有关每个节点的信息

00:36:32.370 --> 00:36:37.020
它已经在包中创建了，每个都可以看到，现在每个都有

00:36:37.020 --> 00:36:44.190
它们放在这里的另一个CID现在显示在这里，然后

00:36:44.190 --> 00:36:48.870
我可以改变我可以改变诸如块大小之类的东西

00:36:48.870 --> 00:36:55.650
创建512字节的块，但我可以将其更改为102 4，然后得到一个图

00:36:55.650 --> 00:37:02.300
节点少得多，因为每个块都可以在其中包含更多数据

00:37:02.300 --> 00:37:08.540
可以将其推高以获得更小的胸罩，现在就消失了

00:37:08.540 --> 00:37:14.790
这是ipfs中的默认块大小，我只是得到了一个小节点

00:37:14.790 --> 00:37:26.220
文件，所以回到它的灯光，好了，我们已经讨论了一些

00:37:26.220 --> 00:37:31.920
但是为什么要更改块大小，所以目前ipfs中的默认值是

00:37:31.920 --> 00:37:38.850
每当您添加文件以将其固定为固定的块大小时，我们都会

00:37:38.850 --> 00:37:43.320
的默认设置，我们只是做了一些更改，例如

00:37:43.320 --> 00:37:47.310
较小的块可能是因为它们中的字节较少

00:37:47.310 --> 00:37:52.740
获得DG Pingdom的机会更大，但就像迈克尔的伍迪所说的那样

00:37:52.740 --> 00:37:56.910
前期工作以创建您必须创建的所有这些块

00:37:56.910 --> 00:38:01.920
散列过去的数据和每个单独的块以及更多块的CID

00:38:01.920 --> 00:38:07.770
如果我们有大块文件，那么前期的工作就更多了。

00:38:07.770 --> 00:38:11.580
先行工作，但更容易喜欢的节点越少越好

00:38:11.580 --> 00:38:19.380
如果您的笔记转移了，则传输数据，是的，事实并非如此

00:38:19.380 --> 00:38:25.349
另一方面，在DGP和智能块大小上肯定是如此出色

00:38:25.349 --> 00:38:30.279
现在这很有趣，例如，也许您有一个大块的

00:38:30.279 --> 00:38:35.710
关键帧，这样您可以更好地寻找视频，现在与该人或其他人在一起的视频很酷

00:38:35.710 --> 00:38:42.039
它可能是一个分块器，确实非常喜欢将文件分块，因此

00:38:42.039 --> 00:38:46.240
这样一来，如果您在中间添加数据，则不会让所有人失望

00:38:46.240 --> 00:38:50.829
所以我们喜欢固定块大小的问题是，如果您添加一点数据

00:38:50.829 --> 00:38:55.059
在中间，然后所有类似的东西都冻结了

00:38:55.059 --> 00:38:59.980
那些，所以这些块现在是不同的，因此deegeu ping不是

00:38:59.980 --> 00:39:04.390
如果您使用智能分块器，那么它一定会很好

00:39:04.390 --> 00:39:07.210
帐户可能会为您提供更大的数据块

00:39:07.210 --> 00:39:10.809
那么您可以保留与其余部分相同的大块

00:39:10.809 --> 00:39:16.450
文件，是的，所以我们已经有了一个智能分块器

00:39:16.450 --> 00:39:23.349
这称为抢劫，您可以在浏览器的J s中使用它，它是全新的

00:39:23.349 --> 00:39:29.619
就像一个小原子的东西，这是超酷的，并且在那个标签中，

00:39:29.619 --> 00:39:36.130
还标记了视觉效果，因此您可以检查出来，所以是的，智能块大小是

00:39:36.130 --> 00:39:39.579
真的很有趣，但再次要做更多的前期工作

00:39:39.579 --> 00:39:47.440
弄清楚合适的边界在哪里，假设罗宾不知道

00:39:47.440 --> 00:39:53.470
好的，Robin只是获取了一个字节流，并弄清楚了，这非常非常

00:39:53.470 --> 00:40:04.779
聪明已经有很长一段时间了不是不是我的TFS专用的，是的

00:40:04.779 --> 00:40:08.799
因此，目前我们已经修复了这两个分块器，而罗宾就像我们一样

00:40:08.799 --> 00:40:13.210
对于许多不同的文件类型，可能有许多不同的分块器用于

00:40:13.210 --> 00:40:17.150
根据文件将做正确的事情

00:40:17.150 --> 00:40:24.039
而且您知道我们还是可以有一些非常好的DG东西

00:40:24.039 --> 00:40:30.890
好了，回到示例，让我们来看一下可视化器中的D duping

00:40:30.890 --> 00:40:35.299
我在这里得到的是一份我已复制的自述文件，而我所做的是

00:40:35.299 --> 00:40:39.650
在它的末尾添加了一些数据，所以我可以做的稍微大一点

00:40:39.650 --> 00:40:44.690
我可以将其拖放到此处吗，可视化工具的作用是

00:40:44.690 --> 00:40:48.710
将这两个文件的目录直接添加到这两个节点

00:40:48.710 --> 00:40:53.869
从目录降序的是位于根目录下的两个文件

00:40:53.869 --> 00:40:57.770
我基本上添加了两个文件，您可以从该图中的行中看到

00:40:57.770 --> 00:41:04.819
他们实际上共享几乎所有节点，从头到尾都在这里

00:41:04.819 --> 00:41:08.420
所以我们可以将它们拾起并拖动它们，您会看到有两个小

00:41:08.420 --> 00:41:14.450
这里和这里的块，这些块不共享的只有两个块

00:41:14.450 --> 00:41:19.069
有点酷的文件，如果您看一下，可以看到这个大块

00:41:19.069 --> 00:41:27.529
咬到一口大小是因为这个树干的字节数比这个多

00:41:27.529 --> 00:41:32.029
而这里发生的是我们没有设法得到它，以至于它

00:41:32.029 --> 00:41:37.760
就像是完整的边界，所以在这两个区域中将有一些共享数据

00:41:37.760 --> 00:41:42.109
这两个块，但是其中一个具有我添加的额外数据

00:41:42.109 --> 00:41:46.970
到文件，所以这是d joopa，这就是两者的方式-非常

00:41:46.970 --> 00:41:53.599
磁盘上的类似文件实际上并不会占用我们密钥中的时间存储空间

00:41:53.599 --> 00:41:55.839
罪行

00:41:58.540 --> 00:42:07.730
好的，所以实际上并没有告诉您有关该节点的全部真相

00:42:07.730 --> 00:42:16.130
图不只是由文件的文件数据块组成，每个数据块都是

00:42:16.130 --> 00:42:22.040
包装在我们称为UNIX FS包装器的东西中，而UNIX FS包装器是

00:42:22.040 --> 00:42:26.480
他们可以有三个文件，可以是目录，也有其他类型，但是

00:42:26.480 --> 00:42:29.660
这两个是主要的两个，它允许我们

00:42:29.660 --> 00:42:37.220
区分什么是文件数据和什么是目录，所以它有点

00:42:37.220 --> 00:42:41.540
梦想中的梦想不仅仅是数据，还有

00:42:41.540 --> 00:42:47.120
包装器，那就是它成为数据，所以实际上它是做什么的

00:42:47.120 --> 00:42:52.520
由于我们拥有UNIX FS，因此为每个节点增加了大约几个字节的开销

00:42:52.520 --> 00:43:00.040
每个包装器都需要一些数据，因此让我们快速了解一下

00:43:00.040 --> 00:43:03.040
这里

00:43:03.970 --> 00:43:10.600
好吧，如果您将鼠标悬停在某个知识上，我们可以在左下角看到

00:43:10.600 --> 00:43:15.850
该模式具有的UNIX FS类型，正如我所说的，此类型位于顶部

00:43:15.850 --> 00:43:19.450
他们会认为该工具的作用是因为目录中有两个文件，所以

00:43:19.450 --> 00:43:26.160
这是一个UNIX FS目录，这些其他节点都是UNIX FS文件类型

00:43:26.160 --> 00:43:34.630
这样就知道构成此注释的总字节数和该数据中的数据字节数

00:43:34.630 --> 00:43:41.080
节点稍有不同，这是因为存在此UNIX FS包装器

00:43:41.080 --> 00:43:48.670
在每个节点中都有几个字节的机架数据

00:43:48.670 --> 00:43:57.610
要做的就是我们可以改变我们可以改变叶子来使用规则缓解作用

00:43:57.610 --> 00:44:04.000
而不是将UNIX FS包装器添加到叶子上，它不会那样做

00:44:04.000 --> 00:44:10.000
只是它将添加一个数据行缓冲区作为叶子，您可以看到

00:44:10.000 --> 00:44:14.470
这些节点的总字节数与数据的字节数完全相同，因此我们

00:44:14.470 --> 00:44:17.380
不再有这个Raptor，这意味着我们节省了一些空间

00:44:17.380 --> 00:44:21.820
在我们创建的每个节点上，因为我们不使用任何包装

00:44:21.820 --> 00:44:30.190
信息，这也意味着我们获得了v1 CID，因此您可以在这里看到

00:44:30.190 --> 00:44:35.530
是一个v1 CID，所以这些就像以QM开始，而这些都是以v-0开始

00:44:35.530 --> 00:44:40.770
在这种情况下用K

00:44:43.510 --> 00:44:49.300
使用CID是否有所不同，因为我知道哈希在哪里不同，但是为什么

00:44:49.300 --> 00:44:56.320
正如我们之前谈到的CITV零值有何不同

00:44:56.320 --> 00:45:00.970
关于他们的事情其中之一是隐性的，没有写成

00:45:00.970 --> 00:45:07.210
这意味着它的V 0 CID是IPL D格式，而IP的格式是

00:45:07.210 --> 00:45:15.640
这些节点是原始节点的dab PB，因为如果您使用IP，则我们的D格式

00:45:15.640 --> 00:45:22.450
请记住告诉我们如何解码数据，以便我们知道该数据是什么

00:45:22.450 --> 00:45:31.380
这是一个原始buff编码的数据块，并使用对其进行解码

00:45:31.380 --> 00:45:39.400
就像它是一个原始协议一样，所以这只是原始字节，因此具有IP

00:45:39.400 --> 00:45:43.650
 LD格式我告诉D卷

00:45:49.390 --> 00:45:58.030
所以这些肺部是个好问题，我想答案是

00:45:58.030 --> 00:46:02.800
很快，我们就是

00:46:02.800 --> 00:46:08.500
如果您ipfs添加内容并指定此CID版本，则此刻正在过渡

00:46:08.500 --> 00:46:13.300
一个人然后您的客人v1 CID，这仅仅是因为这就是人们

00:46:13.300 --> 00:46:17.290
期望现在，切换到V 1是一个重大突破，因为

00:46:17.290 --> 00:46:22.240
突然看到，您回来的看到ID并没有完全不同

00:46:22.240 --> 00:46:29.740
并拥有你以前会回来的东西，就像我说的，现在就是这个

00:46:29.740 --> 00:46:35.560
现在是v1 CID，因为它使用的是其他格式，我们真的无法

00:46:35.560 --> 00:46:43.900
签证是早期的，因为它不是PBC ER的死者，并且编码数据很酷，所以

00:46:43.900 --> 00:46:52.870
没关系，还有不同的图形布局具有不同的

00:46:52.870 --> 00:46:56.890
性能特征平衡布局是您获得默认设置

00:46:56.890 --> 00:47:03.940
ipfs广告，它很容易构建并且非常容易遍历，但这有点

00:47:03.940 --> 00:47:07.330
如果要在中间进行更改，则很难进行编辑，您必须做很多事情

00:47:07.330 --> 00:47:13.000
重新平衡以再次平衡它，就像我们trick流一样

00:47:13.000 --> 00:47:17.890
好是一个选择，它很难构建，但是对于

00:47:17.890 --> 00:47:22.510
例如流式传输，因为到第一个字节的时间要少得多

00:47:22.510 --> 00:47:27.120
想象一下，如果我有

00:47:31.589 --> 00:47:36.089
下雪了，我需要掌握这个节点，然后我才能开始流式传输

00:47:36.089 --> 00:47:41.039
像想象中的一样，我有一个大文件，就像一个大电影文件，而且它变得很大

00:47:41.039 --> 00:47:45.420
平衡台，如果我想开始播放它，那我就得

00:47:45.420 --> 00:47:49.529
在我可以之前，此节点可能此节点不在此节点中

00:47:49.529 --> 00:47:53.369
开始流媒体播放时，说到第一个字节的时间会更好

00:47:53.369 --> 00:48:00.390
爸爸trick细流的风格，所以让我们看一下两者的不同

00:48:00.390 --> 00:48:16.859
我们可以使用不同类型的DAG布局，所以这是

00:48:16.859 --> 00:48:19.890
平衡层，因为到目前为止我一直在研究，但是如果我们可以使用它

00:48:19.890 --> 00:48:23.789
放到这里，我们可以切换到细流dag，您可以看到

00:48:23.789 --> 00:48:30.029
布局完全改变了这种情况，这真的很有趣

00:48:30.029 --> 00:48:38.400
结构，如果您在其上添加一个更大，更大的文件，但要注意一件事

00:48:38.400 --> 00:48:43.200
注意，如果我们检查出它是QM的话，这种提示就在这里

00:48:43.200 --> 00:48:54.839
CW ESU如果我更改了余额标签，则QM的开始不会开始结束

00:48:54.839 --> 00:49:03.089
具有相同的字符，这是相同的数据，我们没有更改

00:49:03.089 --> 00:49:06.869
我们已经完成的所有数据实际上是在此处更改选项（如果您更改了任何选项）

00:49:06.869 --> 00:49:11.099
这些选项中的任何一个都会得到一个不同的CID，所以这有一些

00:49:11.099 --> 00:49:17.430
知道那里或采取注意或至少你确实得到

00:49:17.430 --> 00:49:24.839
如果您更改不同的选项，则使用不同的C ID，原因是

00:49:24.839 --> 00:49:28.549
它可能有更多或更少的孩子，

00:49:28.549 --> 00:49:32.420
那些孩子会有不同的看到ID，因为他们有

00:49:32.420 --> 00:49:36.319
或多或少的孩子，所以它基本上一直传播到顶部，

00:49:36.319 --> 00:49:38.839
你只是得到了相同数据的想法

00:49:38.839 --> 00:49:45.619
现在，如果您使用了相同的分块算法，那么您的叶子可能会

00:49:45.619 --> 00:49:50.299
仍然有相同的数据可以被重复，但是那只是

00:49:50.299 --> 00:49:55.960
具有不同见解的中间节点，我认为不同的想法说还可以

00:49:55.960 --> 00:50:04.430
问题所有的块都包含我认为您提到的链接，这些链接会导致

00:50:04.430 --> 00:50:12.319
哈希值更改是的，是的，是的，所以我说这是相同的数据，因为

00:50:12.319 --> 00:50:16.609
与添加到卡座的文件数据相同，但它们是中间节点

00:50:16.609 --> 00:50:20.390
其他人认为这是他们正在引起改变的事物，

00:50:20.390 --> 00:50:24.609
根CID已更改是的，您是对的

00:50:27.589 --> 00:50:30.519
因为它刚刚改变

00:50:32.080 --> 00:50:38.000
根据您父亲的选择，您将获得更少的收益，例如，将同一文件

00:50:38.000 --> 00:50:43.410
两种不同的诊断方法不会有太多

00:50:43.410 --> 00:50:48.630
是的，如果您改变了，如果您更换了垃圾桶，那么它就这样

00:50:48.630 --> 00:51:13.170
不一定会一样好，是的，这就是这一切

00:51:13.170 --> 00:51:18.120
可作为类似选项使用，但您知道99％的时间人们将只是一个

00:51:18.120 --> 00:51:22.410
BFS添加，它将做正确的事，我认为我们

00:51:22.410 --> 00:51:26.640
需要变得更好地为您已经创建的文件实际构建适当的dag

00:51:26.640 --> 00:51:33.480
添加并选择它，因为这个城市正确，您知道很好的分块器

00:51:33.480 --> 00:51:37.620
实际的块将保持不变，所以您会选择很多欺骗选项

00:51:37.620 --> 00:51:41.610
是的，所以您可以想象如果您只是改变块的大小就不会

00:51:41.610 --> 00:51:45.300
是的，要改变饮食习惯，所以您可以想像一下一项服务需要的数据

00:51:45.300 --> 00:51:49.290
被添加使用均衡的饮食结构调整是黄色的尖叫剂量

00:51:49.290 --> 00:51:56.840
是的，哦，是的，是的，是的，是的，是的，这很有趣

00:51:56.840 --> 00:52:06.060
好的，很酷，让我们继续前进吧，

00:52:06.060 --> 00:52:11.490
案例，我们还有很多时间，所以我们要等待

00:52:11.490 --> 00:52:15.130
本届会议在哪里让我们快速冷却

00:52:15.130 --> 00:52:21.029
好吧，可变文件系统好吧，这是什么

00:52:21.029 --> 00:52:27.940
好吧，让我解释一下好音乐，可变文件系统是NFS

00:52:27.940 --> 00:52:34.029
 ipfs中的抽象，可让您像处理文件一样处理ipfs中的文件

00:52:34.029 --> 00:52:39.609
是一个可变的unix风格的文件系统，它负责所涉及的繁忙工作

00:52:39.609 --> 00:52:44.529
在更改文件时创建新的dag结构时，从高层次上讲，

00:52:44.529 --> 00:52:48.940
可以将其想像成一条跟踪路线，该路线可以映射地图的路径以查看ID和

00:52:48.940 --> 00:52:53.979
就像常规的UNIX样式文件系统一样，您需要使用路径，并且必须

00:52:53.979 --> 00:52:59.380
您可以使用的熟悉的基本命令（例如移动复制）使您知道

00:52:59.380 --> 00:53:04.180
当您处理猫的gif时的东西

00:53:04.180 --> 00:53:11.140
使用这样的不可变哈希而不是MSS，您便拥有了整个ipfs

00:53:11.140 --> 00:53:15.999
网络可供您使用，因此，如果在本地找不到它，那么它将被交付

00:53:15.999 --> 00:53:21.969
从网络上的另一个对等点（假设您在

00:53:21.969 --> 00:53:28.059
使用类似我的重要业务文档路径的IP FS路径

00:53:28.059 --> 00:53:34.450
仅向您的节点询问该文件，如果在您的节点上找不到该文件，则该文件

00:53:34.450 --> 00:53:38.559
将会失败，所以我想在这里说明的是，没有

00:53:38.559 --> 00:53:44.170
全局路由NFS命名空间没有我们可以使用的全局Dropbox

00:53:44.170 --> 00:53:50.469
都是这样写的，但是您可以做的是将MF的路径转换为

00:53:50.469 --> 00:53:57.009
CID您可以使用ipfs文件人员，它会给您比cid更多的东西

00:53:57.009 --> 00:54:01.269
但是它给了你，所以我可以捕捉我的业务文档文本，然后我得到一个

00:54:01.269 --> 00:54:08.229
CI dqm点txt，然后我们可以与某人共享该CID，他们就可以

00:54:08.229 --> 00:54:13.319
就像被问到的那样或从对等网络中获取该内容

00:54:13.319 --> 00:54:19.660
但是在共享从您的CID获得的CID时，您应该格外小心

00:54:19.660 --> 00:54:25.600
NFS为什么很好，让我们看看

00:54:25.600 --> 00:54:29.760
您在em FS中编辑文件以回答该问题时会发生

00:54:29.760 --> 00:54:36.940
好吧，所以将内容添加到文件中假设我将所有笔记存储在青蛙中

00:54:36.940 --> 00:54:43.720
EM FS中的文件/注释实验室青蛙点txt可以，所以当我想要

00:54:43.720 --> 00:54:49.390
用neuf更新我的笔记，就像我看到了一只新的稀有青蛙一样，我想将其添加到

00:54:49.390 --> 00:54:55.660
文件的末尾就像您可以想象的那样，青蛙将文本点到的路径/注释

00:54:55.660 --> 00:55:02.410
在dag中是这样的，所以在UNIX FS目录中使用斜杠

00:55:02.410 --> 00:55:07.980
在顶部，这是当前的EMF路线，而ipfs会跟踪此路线

00:55:07.980 --> 00:55:12.850
MF路由中挂起的所有内容都可以安全地进行垃圾回收

00:55:12.850 --> 00:55:17.830
不会被收集，这样很好，所以当我们想要

00:55:17.830 --> 00:55:23.650
将一些数据添加到该文件中，我们有了一个新的免费QM块，

00:55:23.650 --> 00:55:30.850
我在其中看到的关于这只新青蛙的所有笔记，我们需要一个新节点

00:55:30.850 --> 00:55:35.320
我们需要更新的说明，指出之前的代码块以及

00:55:35.320 --> 00:55:41.710
新的块，所以我们有了一个新的块，您知道frogs文件的新cid和

00:55:41.710 --> 00:55:45.940
因为我们为frogs文件有了一个新的cid，所以我们得到了一个新的cid和一个新的

00:55:45.940 --> 00:55:50.740
注释目录的节点，因为正如我所说的，已知CID已创建

00:55:50.740 --> 00:55:55.420
从数据以及链接中删除，因为我的链接更改了我的目录

00:55:55.420 --> 00:56:00.550
已经改变，并且一直传播到根，所以qm / d RR

00:56:00.550 --> 00:56:05.980
为m FS根获得了新的cid，IP FS跟踪了该ID，所以现在是新的

00:56:05.980 --> 00:56:11.230
m FS根目录是该目录，请注意，我在此处和现在都已变灰

00:56:11.230 --> 00:56:14.860
有资格进行垃圾收集，因此可以根据

00:56:14.860 --> 00:56:20.300
ipfs的设置请注意，您可能会在任何时候收集它们

00:56:20.300 --> 00:56:27.950
现在，当您添加了更多内容或根本没有内容时，您永远不会知道，是的，好的

00:56:27.950 --> 00:56:34.970
回到共享内容上，我们已经学到了很多东西，如果您共享一个

00:56:34.970 --> 00:56:39.440
文件的CID（如果有人从您的em FS事物的文件统计信息中获取）

00:56:39.440 --> 00:56:47.960
然后编辑文件，任何人都猜对了，这可能很好，所以

00:56:47.960 --> 00:56:52.850
该文件的CID会更改，收件人不会收到通知

00:56:52.850 --> 00:56:56.600
发生了变化，通过CID的方式没有自动化的方式

00:56:56.600 --> 00:56:59.390
像这样改变了，但是ipfs永远不知道，因为它不知道

00:56:59.390 --> 00:57:04.490
您与其他人共享该CID，也不像

00:57:04.490 --> 00:57:09.290
不能保证收件人能够访问像他们一样保留的内容

00:57:09.290 --> 00:57:13.510
可能能够，因为它可能还不是垃圾，但是他们可能

00:57:13.510 --> 00:57:25.250
不能，是的，是的，但是没有任何一种

00:57:25.250 --> 00:57:29.710
目前是自动执行的

00:57:33.940 --> 00:57:45.320
是的，所以你可以，很酷，是的，谈论它，是的，我很高兴你们都

00:57:45.320 --> 00:57:49.310
听很酷，所以这是

00:57:49.310 --> 00:57:53.359
代码名称和地址以及MF的区别是内容名称

00:57:53.359 --> 00:57:57.500
但这并没有说明他们的礼服，他们的大陆装扮就像

00:57:57.500 --> 00:58:01.730
这种约束的内容是不可变的，但是我们有这个可变性层

00:58:01.730 --> 00:58:06.290
最重要的是，位置寻址也很有趣，因为我们可以

00:58:06.290 --> 00:58:10.280
更改内容并仍然将其保存在该URL上，但是我们已经讨论过了

00:58:10.280 --> 00:58:15.560
关于我们在ipfs中存在的那种父母问题

00:58:15.560 --> 00:58:22.869
称为IP NS的东西，它是解决可变内容的一种手段，

00:58:22.869 --> 00:58:27.950
因此，ip NS会将名称映射为地址，例如dns将名称映射为IP

00:58:27.950 --> 00:58:32.960
地址，但在p2p系统中，它需要某种法定人数

00:58:32.960 --> 00:58:36.170
关于事物的最新版本，因此有时可能需要一些时间

00:58:36.170 --> 00:58:40.310
在获得它之前先弄清楚最新版本是什么

00:58:40.310 --> 00:58:44.900
有一些问题，但是是的，我是一种您可以使用的方式

00:58:44.900 --> 00:58:51.290
可以解决可变内容，因此您必须以某种方式统计NFS路由

00:58:51.290 --> 00:58:58.040
每次更改并更新您的IP NS记录以指向该新记录时，我

00:58:58.040 --> 00:59:03.320
在会话中不打算再进入DNS，但是其余的

00:59:03.320 --> 00:59:09.970
现在大约是两分钟的时间，因为有人得到了女儿

00:59:12.780 --> 00:59:20.200
好的，很酷，我们还没有多少时间，但我会指出这一点

00:59:20.200 --> 00:59:23.950
新的英国全新教程，我​​们已经将此站点称为proto dot

00:59:23.950 --> 00:59:28.000
这所学校向人们传授ipfs概念，我们拥有一个品牌

00:59:28.000 --> 00:59:34.599
适用于训练营的EM FS新教程，如果您继续学习

00:59:34.599 --> 00:59:39.400
原始学校，您应该在主页上看到一个指向em FS的em FS链接

00:59:39.400 --> 00:59:43.599
本教程将涵盖我刚才谈到的一堆东西，但

00:59:43.599 --> 00:59:48.730
以及各种编码练习和各种类似的练习

00:59:48.730 --> 00:59:52.710
让您忙碌，并帮助您了解更多有关

