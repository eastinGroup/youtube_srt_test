WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.120 --> 00:00:06.720
因此从高级的角度来看，这是一个动态的信息管理协议

00:00:06.720 --> 00:00:12.799
对于开放的网络，当我们设计陶瓷时，我们真的以为

00:00:12.799 --> 00:00:16.800
大概你知道为什么

00:00:16.800 --> 00:00:20.000
您知道文件或内容管理系统是

00:00:20.000 --> 00:00:23.600
今天坏了，那是因为它们托管在电视或服务器上

00:00:23.600 --> 00:00:27.359
或分散在分散网络上某处的静态文件的种类

00:00:27.359 --> 00:00:31.760
所以嗯，我们基本上想创建一个新模型

00:00:31.760 --> 00:00:36.000
呃，我们称之为智能文档的内容，它们都是完全内置的

00:00:36.000 --> 00:00:40.239
点对点，因此智能文档的作用是

00:00:40.239 --> 00:00:43.680
真正将内容移动到数据库和静态文件之外

00:00:43.680 --> 00:00:48.160
因此您基本上可以将文件转换为动态对象

00:00:48.160 --> 00:00:51.440
得到一个永不变的永久链接

00:00:51.440 --> 00:00:55.600
可验证的版本，因此您可以更新这些文件

00:00:55.600 --> 00:00:58.879
完全未经许可，您可以给他们每个人

00:00:58.879 --> 00:01:01.920
每个文件都有自己的功能集和逻辑

00:01:01.920 --> 00:01:06.000
这样您就可以做一些很酷的事情，就像您知道定义规则一样

00:01:06.000 --> 00:01:09.360
什么构成对该内容的有效更新um

00:01:09.360 --> 00:01:12.400
以一种真正充满活力和有趣的方式，我会跳进去

00:01:12.400 --> 00:01:16.159
嗯，这也带来了无限的合作

00:01:16.159 --> 00:01:19.680
以及我们的某种不可组合性

00:01:19.680 --> 00:01:23.040
曾经与web3中的区块链有关

00:01:23.040 --> 00:01:26.080
但您可以在其中访问可互操作信息的全球网络

00:01:26.080 --> 00:01:29.439
公开发现查询并共享文档

00:01:29.439 --> 00:01:35.119
应用程序和上下文，最后您将获得更高的安全性，

00:01:35.119 --> 00:01:38.560
信任，这样您就可以真正向其他人保证文档的状态

00:01:38.560 --> 00:01:43.040
完全透明和分散的方式等等

00:01:43.040 --> 00:01:45.280
管理是真的

00:01:45.280 --> 00:01:48.880
我们一直试图了解智能文档的概念

00:01:48.880 --> 00:01:53.200
为内容建立状态管理系统或版本控制系统

00:01:53.200 --> 00:02:00.159
生活完全分散的um，但是可以自定义

00:02:00.159 --> 00:02:04.240
因此，智能文档的某些功能

00:02:04.240 --> 00:02:08.160
其中一些我已经涵盖了较高的水平，但基本上

00:02:08.160 --> 00:02:12.319
每个文档都由固定链接标识，并且永不更改

00:02:12.319 --> 00:02:15.760
um每个文档都会得到可明确显示的可验证版本

00:02:15.760 --> 00:02:19.040
已引用，因此您可以引用您知道的文档ID

00:02:19.040 --> 00:02:21.520
然后您获得文档的最新状态

00:02:21.520 --> 00:02:27.200
或者您可以使用带有查询版本参数的来引用文档ID

00:02:27.200 --> 00:02:32.000
而且您只能获得当时的显式版本，并且

00:02:32.000 --> 00:02:35.120
每个文档都可以通过模式定义，因此协议实际上可以

00:02:35.120 --> 00:02:38.879
如果将模式设置为某些json，则强制执行

00:02:38.879 --> 00:02:41.840
模式，例如写入该模式的所有内容

00:02:41.840 --> 00:02:46.480
文档必须符合模式，否则协议将拒绝它

00:02:46.480 --> 00:02:50.720
您可以配置每个文档，使内容的每个单独部分

00:02:50.720 --> 00:02:54.080
您可以选择将内容保留在何处

00:02:54.080 --> 00:03:00.400
嗯，例如像filecoin或sql server，您可以选择

00:03:00.400 --> 00:03:03.920
用于您的时间戳的区块链和时间戳实际上是我们使用的

00:03:03.920 --> 00:03:07.200
显式地形成版本，因此您可以

00:03:07.200 --> 00:03:09.599
选择将这些更新锚定在以太坊上

00:03:09.599 --> 00:03:15.200
um bitcoin任何其他区块链平台um，您可以配置隐私

00:03:15.200 --> 00:03:19.200
设置，这样您就可以基本上加密文档，而整个加密过程仅一部分

00:03:19.200 --> 00:03:22.959
记录您想要的种类，并且您可以管理该种类的共享

00:03:22.959 --> 00:03:28.319
如果是私有逻辑，最后是逻辑逻辑，那么您基本上可以定义

00:03:28.319 --> 00:03:34.480
一组用于强制更新行为的规则

00:03:34.480 --> 00:03:38.640
您可能会说我的文档只有在以下情况下才能更新

00:03:38.640 --> 00:03:42.879
所有者更新它，或者所有所有者更新它，或者其中一个所有者更新

00:03:42.879 --> 00:03:46.159
它，或者你甚至可以写脚本说

00:03:46.159 --> 00:03:50.720
如果文档b的状态发生更改并且自动更新此文档，

00:03:50.720 --> 00:03:55.439
更新本文档以反映该内容，以便您可以真正开始编写内容代码

00:03:55.439 --> 00:03:59.040
并以全新的方式对内容um进行编程

00:03:59.040 --> 00:04:02.159
未经许可，文件也可能发出事件，

00:04:02.159 --> 00:04:05.920
导致其他事情发生，例如您知道固定节点的节点

00:04:05.920 --> 00:04:09.360
图像内容或保留在文件点

00:04:09.360 --> 00:04:13.120
嗯，我们谈到了可组合性

00:04:13.120 --> 00:04:18.560
嗯，您真正了解的是可验证的可编程信息网络

00:04:18.560 --> 00:04:21.600
允许，嗯，您知道所有这些信息都可以

00:04:21.600 --> 00:04:26.160
受信任的内容状态是可审核的和透明的，因此

00:04:26.160 --> 00:04:29.840
任何人都可以使用网络上的任何文档和内容

00:04:29.840 --> 00:04:34.639
特别是如果它是公共的，只需查询节点就可以知道

00:04:34.639 --> 00:04:37.120
文档可以链接其他文档来创建

00:04:37.120 --> 00:04:41.840
链接内容的链接或映射，以便您可以形成文档图

00:04:41.840 --> 00:04:45.919
并且每个文档在某种程度上已经做到了这一点，因为例如一个架构

00:04:45.919 --> 00:04:50.000
被定义为陶瓷文档，然后在其中引用该架构

00:04:50.000 --> 00:04:53.360
您正在创建的文档说该文档将符合

00:04:53.360 --> 00:04:55.840
模式，因此每个文档已经只是一个

00:04:55.840 --> 00:05:00.000
映射两个模式和一个文档，但是您可以然后映射实际文档

00:05:00.000 --> 00:05:04.960
我将一起进入um和聚合

00:05:04.960 --> 00:05:08.720
例如，您知道您是否要建立一个分散的um

00:05:08.720 --> 00:05:14.400
陶瓷上的测井平台或评论系统，您基本上可以拥有每个

00:05:14.400 --> 00:05:18.000
用户单独发表自己的意见，将自己的评论发布到

00:05:18.000 --> 00:05:21.360
他们自己的文档，还有另一个可以运行的文档

00:05:21.360 --> 00:05:24.960
侦听带有特定标签的所有文档的脚本，或者

00:05:24.960 --> 00:05:27.280
东西，它会聚合成

00:05:27.280 --> 00:05:31.840
一个脚本，最后和集成

00:05:31.840 --> 00:05:35.120
所以这种陶瓷真的是这个规则

00:05:35.120 --> 00:05:37.919
和内容管理引擎

00:05:37.919 --> 00:05:42.160
技术，以便识别陶瓷上的每个文档

00:05:42.160 --> 00:05:46.960
由did和dids撰写的内容可能是关键的，并且与网络无关

00:05:46.960 --> 00:05:50.160
所以你做了一个分散的标识符

00:05:50.160 --> 00:05:53.280
它可以由任何区块链中的密钥控制

00:05:53.280 --> 00:05:56.720
呃或多个区块链的多个密钥，所以你知道你可以

00:05:56.720 --> 00:05:59.199
用以太坊键控制你的操作

00:05:59.199 --> 00:06:03.280
您的文件硬币钥匙您的比特币钥匙您的宇宙钥匙等等

00:06:03.280 --> 00:06:06.400
真正使内容具有互操作性，因为

00:06:06.400 --> 00:06:09.680
现在您可以查找那个比特币密钥或那个以太坊密钥

00:06:09.680 --> 00:06:13.680
文件硬币密钥解决做，然后解决其内容

00:06:13.680 --> 00:06:17.520
因此您实际上并没有将内容锁定在任何特定的网络中

00:06:17.520 --> 00:06:22.880
因为陶瓷以某种形式形成了这种元文档基础架构

00:06:22.880 --> 00:06:27.039
嗯，是的，就像我提到的存储您的现有系统一样

00:06:27.039 --> 00:06:30.240
只需在一个陶瓷节点中，您就可以插入一个持久性提供程序

00:06:30.240 --> 00:06:34.880
那可以是filecoin嗯，您知道我们从filecoin获得了一笔赠款，

00:06:34.880 --> 00:06:38.400
两者都将filecoin密钥与did身份进行了集成

00:06:38.400 --> 00:06:43.120
并将uh文件币持久性集成为陶瓷节点的选项

00:06:43.120 --> 00:06:46.960
因此您实际上可以以分散的方式保存内容，或者

00:06:46.960 --> 00:06:49.520
已经使用集中式服务器，您也可以这样做

00:06:49.520 --> 00:06:53.199
显然，对于以下文件，它们提供了不同的保证：

00:06:53.199 --> 00:06:57.440
以这种方式持久，但是协议与持久性无关

00:06:57.440 --> 00:07:01.440
um computing如果您有运行脚本的文档，则可以调用以下代码

00:07:01.440 --> 00:07:04.800
住在服务器上的其他任何地方

00:07:04.800 --> 00:07:07.840
最后，您可以插入任何区块链进行锚定

00:07:07.840 --> 00:07:11.919
我只是介绍了很多，但我只专注于

00:07:11.919 --> 00:07:18.080
一些ipfs件，所以与文件硬币持久性分开了

00:07:18.080 --> 00:07:21.919
我们实际使用ipfs堆栈的方式是

00:07:21.919 --> 00:07:24.960
文档，因此文档由一系列记录组成，它们都是ipld

00:07:24.960 --> 00:07:29.120
对象um，我们使用lib p2p同步更新

00:07:29.120 --> 00:07:33.039
围绕网络中的节点，所以它是一个八卦网络

00:07:33.039 --> 00:07:36.800
您知道一个节点可以管理文档的状态，而其他节点可以

00:07:36.800 --> 00:07:40.080
可以八卦，也可以根据需要复制

00:07:40.080 --> 00:07:45.360
um网络与陶瓷有关的有趣之处与区块链不同

00:07:45.360 --> 00:07:49.280
没有全球性的国家，所以我们选择了

00:07:49.280 --> 00:07:54.080
doc状态，因此每个文档只有状态，它们形成doc链

00:07:54.080 --> 00:07:57.120
因为您有一系列固定的记录，但是没有

00:07:57.120 --> 00:08:00.800
文档之间的全局状态，因此您可以通过与

00:08:00.800 --> 00:08:04.639
如果您不坚持将内容提交硬币，那么ipfs会起作用

00:08:04.639 --> 00:08:07.919
或者您是运行该文档的唯一节点，而您

00:08:07.919 --> 00:08:11.280
关闭计算机，或者删除该内容，因为它可能消失了

00:08:11.280 --> 00:08:14.000
因为文档状态仅在网络范围内保持

00:08:14.000 --> 00:08:16.720
维护它，这提供了规模um，因为

00:08:16.720 --> 00:08:19.360
满足世界上会有如此之多的内容

00:08:19.360 --> 00:08:23.039
您无法在其上运行全局状态机，因此

00:08:23.039 --> 00:08:27.599
这样可以运行陶瓷，并且资源确实受环境限制

00:08:27.599 --> 00:08:31.199
例如浏览器和其他没有构建其他层的东西

00:08:31.199 --> 00:08:34.959
顶部，我介绍了很多这样的东西

00:08:34.959 --> 00:08:37.680
已经，但有趣的是，如果您查看如下图

00:08:37.680 --> 00:08:41.839
不同的三角形节点可以运行不同的配置，所以一个

00:08:41.839 --> 00:08:45.279
正在运行比特币和以太坊锚定，呃

00:08:45.279 --> 00:08:48.800
盖子p2p和ipld以及其他仅运行比特币锚定的

00:08:48.800 --> 00:08:52.160
其他一些只是运行以太坊锚定，并且有一个重叠

00:08:52.160 --> 00:08:57.680
在那种情况下，但是没有全局状态，文档如何真正快速地工作，所以您

00:08:57.680 --> 00:09:00.720
嗯，你知道一系列记录吗？

00:09:00.720 --> 00:09:03.839
创始记录，然后将其锚定在区块链上

00:09:03.839 --> 00:09:07.680
然后您提交一个或多个签名记录，然后将其锚定在

00:09:07.680 --> 00:09:09.760
区块链，您将获得一个明确的新版本

00:09:09.760 --> 00:09:13.200
然后再发生几条更新记录，然后您得到一个新的锚点

00:09:13.200 --> 00:09:17.760
形成一个新版本um，因为我们使用区块链

00:09:17.760 --> 00:09:21.040
锚定我们可以做的事情我们可以保证状态

00:09:21.040 --> 00:09:24.160
版本，所以这对于去中心化非常重要

00:09:24.160 --> 00:09:27.200
密钥管理呃和受信任的内容在哪里

00:09:27.200 --> 00:09:30.959
您知道我是否从文档中删除所有者，但我不希望该所有者成为

00:09:30.959 --> 00:09:33.360
能够更新该文档，并且数量不多

00:09:33.360 --> 00:09:37.200
在这种情况下，允许主观性和共识

00:09:37.200 --> 00:09:42.800
所以我们对区块链有严格的要求，最早的锚赢了

00:09:42.800 --> 00:09:46.880
和doctype实际上是创建文档时每个文档的规则引擎

00:09:46.880 --> 00:09:50.959
您指定文档类型的文档三种文档类型开箱即用

00:09:50.959 --> 00:09:54.959
该节点，你也可以只写自己的人已经在做，但是

00:09:54.959 --> 00:09:58.800
磁贴只是json存储，您可以在其中存储任意json内容

00:09:58.800 --> 00:10:02.480
非常适合架构之类的东西，例如博客文章之类的配置文件

00:10:02.480 --> 00:10:08.560
消息um三个id是一个dod sys是陶瓷固有的一个dod方法，所以一个

00:10:08.560 --> 00:10:12.959
带有安全密钥轮换账户的分散式身份系统

00:10:12.959 --> 00:10:15.519
链接是链接到您的文档的文档

00:10:15.519 --> 00:10:19.839
链上的加密帐户或其他地方的网络帐户

00:10:19.839 --> 00:10:22.480
并编写您自己的，我们已经在社区中有人写作

00:10:22.480 --> 00:10:27.600
可验证的声明文档类型，因此您可以根据以下内容创建和验证声明

00:10:27.600 --> 00:10:31.519
那些人以及正在编写脚本的w3c标准

00:10:31.519 --> 00:10:34.800
doctype作为hack fs的一部分，实际上这两个都是hack的一部分

00:10:34.800 --> 00:10:38.079
fs um和脚本doctype正在执行

00:10:38.079 --> 00:10:41.680
我之前谈到的聚合，因此您可以构建评论系统

00:10:41.680 --> 00:10:46.160
一个文档正在汇总一堆文件的所有内容

00:10:46.160 --> 00:10:52.320
用户自己拥有的文档，嗯，它可以作为完整的javascript使用

00:10:52.320 --> 00:10:54.880
客户端，或者您可以通过HTTP API使用它

00:10:54.880 --> 00:11:01.680
嗯，两个api完全一样，所以像ipfs一样有效

00:11:01.680 --> 00:11:06.320
还有一些东西是建立在最上面的，所以我们最近一直在做一堆

00:11:06.320 --> 00:11:10.720
标准围绕陶瓷的标识工作，因为陶瓷确实

00:11:10.720 --> 00:11:15.519
一个很好的平台，不仅可以管理分散的标识符，还可以管理

00:11:15.519 --> 00:11:18.160
当您考虑身份以及身份中需要包含的内容时

00:11:18.160 --> 00:11:22.640
分散式Web身份确实是您所有人的索引

00:11:22.640 --> 00:11:25.120
资源，无论这些是您的个人资料

00:11:25.120 --> 00:11:28.959
或服务器上的对等数据库

00:11:28.959 --> 00:11:32.480
诸如纺织数据库或轨道数据库之类的地方

00:11:32.480 --> 00:11:38.880
或存储在filecoin上的文件或可能存在的社交图谱

00:11:38.880 --> 00:11:42.000
某个地方或其他各种事情，所以现在在分散

00:11:42.000 --> 00:11:45.839
网络上没有一个查询和发现的地方

00:11:45.839 --> 00:11:49.839
与给定身份相关联的所有资源，并且这些资源存在

00:11:49.839 --> 00:11:54.000
跨各种平台，因此idx致力于解决这一问题

00:11:54.000 --> 00:11:58.160
就像我说的那样，它可以与任何区块链完全互操作，

00:11:58.160 --> 00:12:03.279
 um的任何存储系统，但它形成了这种可发现性的机制

00:12:03.279 --> 00:12:06.720
嗯，这就是它的外观架构

00:12:06.720 --> 00:12:10.480
每个盒子都是陶瓷文件，所以你做了

00:12:10.480 --> 00:12:15.040
它可以做任何事情，它指向仅包含以下内容的根索引文档

00:12:15.040 --> 00:12:19.519
从相似的配置文件到其自身的配置文件索引的映射

00:12:19.519 --> 00:12:22.480
文档和配置文件索引中，您可能会发现

00:12:22.480 --> 00:12:26.639
从基本位置到呃位置的映射，这可能是一个陶瓷基座ID

00:12:26.639 --> 00:12:30.160
因为它的基本配置有趣

00:12:30.160 --> 00:12:34.079
集合中的某种形式是您对用户数据的汇总

00:12:34.079 --> 00:12:38.000
通常由应用程序创建，因此它们是由

00:12:38.000 --> 00:12:43.760
一个定义，该定义由一组具有显式架构的数据存储组成，

00:12:43.760 --> 00:12:47.040
说我正在使用纺织线，并且它使用此模式，而我正在使用轨道

00:12:47.040 --> 00:12:50.079
存储并使用架构和使用

00:12:50.079 --> 00:12:54.160
模式，假设您的应用包含这三个数据源

00:12:54.160 --> 00:12:57.839
您可以在定义中定义该定义，该定义将存储在collections索引中，

00:12:57.839 --> 00:13:01.040
映射到包含特定于用户的参考

00:13:01.040 --> 00:13:06.240
有关该定义的信息，所以我的纺织线程ID就是这个

00:13:06.240 --> 00:13:10.240
住在这个托管服务端点，我的访问控制器是这个

00:13:10.240 --> 00:13:14.800
所以真的，如果您查找一个，就可以找到它的根索引，也可以找到它的根索引。

00:13:14.800 --> 00:13:17.920
集合，然后您可以找到与给定数据相关的所有数据

00:13:17.920 --> 00:13:21.200
用户仍然能够管理的应用程序

00:13:21.200 --> 00:13:24.560
它的同意和右边的项目已经

00:13:24.560 --> 00:13:28.560
致力于与idx um so Textile的集成，以实现其枢纽和

00:13:28.560 --> 00:13:32.240
他们的线程db fleek正在构建新产品，

00:13:32.240 --> 00:13:35.680
他们需要以分散的方式进行身份管理，并且他们正在使用

00:13:35.680 --> 00:13:39.839
idx也适用于馆藏以及诸如团队组成之类的各种事情

00:13:39.839 --> 00:13:43.920
用户名和猫头鹰在做类似的事情，但是

00:13:43.920 --> 00:13:46.880
几乎没有什么不同，所以一堆很棒的ipfs项目和

00:13:46.880 --> 00:13:51.279
生态系统已经建立在这个基础上，我不会涉及所有这些，因为我

00:13:51.279 --> 00:13:56.079
知道我时间不多了，但显然内容和信息

00:13:56.079 --> 00:14:00.000
需要被信任和可编程或遵守一套

00:14:00.000 --> 00:14:02.720
规则实际上对什么几乎没有限制

00:14:02.720 --> 00:14:07.920
您可以在此基础上构建，因此这里有几个示例

00:14:07.920 --> 00:14:12.720
时间轴alpha devnet现已发布，您可以开始使用陶瓷了

00:14:12.720 --> 00:14:17.680
已经黏土会在一个月内出来，它有一些改进

00:14:17.680 --> 00:14:22.959
包括使用dag jose，这是用于签名和加密的新标​​准

00:14:22.959 --> 00:14:29.760
对于我们从ipfs和以太坊获得拨款的json网站，我们

00:14:29.760 --> 00:14:33.360
与纺织一起执行该操作或js实现已经

00:14:33.360 --> 00:14:36.800
准备好了，我们正在寻找可以构建go实施的人，所以

00:14:36.800 --> 00:14:40.320
如果您对此感兴趣，请与我们联系

00:14:40.320 --> 00:14:43.519
雇人去写那个go版本

00:14:43.519 --> 00:14:50.800
主网将问世，第四季度中期这是一些我们不和谐的资源

00:14:50.800 --> 00:14:53.120
在那里，我还将在其中放置一个类似的链接

00:14:53.120 --> 00:14:55.279
聊天，因为我知道这不是人类可读的

00:14:55.279 --> 00:14:58.959
嗯，在Twitter上找到我们，我们在github上的陶瓷网络上

00:14:58.959 --> 00:15:02.639
我谈论的很多标准都包括doctypes

00:15:02.639 --> 00:15:06.240
模式IDX和各种各样的事情正在

00:15:06.240 --> 00:15:10.240
以cip的形式写出，以便社区可以重复使用和共享

00:15:10.240 --> 00:15:13.680
以一种协作的方式，所以如果您对此感兴趣的话

00:15:13.680 --> 00:15:27.839
环顾四周并做出贡献

