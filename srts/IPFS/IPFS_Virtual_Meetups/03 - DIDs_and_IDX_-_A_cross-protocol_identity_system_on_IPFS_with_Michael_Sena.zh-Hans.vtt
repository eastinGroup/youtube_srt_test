WEBVTT
Kind: captions
Language: zh-Hans

00:00:09.519 --> 00:00:13.599
所以idx是跨协议身份标准

00:00:13.599 --> 00:00:18.480
与丹尼尔（Daniel）和乔尔·艾德克斯（Joel IDX）的先前谈话相关

00:00:18.480 --> 00:00:23.439
确实是一种管理整个用户范围的方法

00:00:23.439 --> 00:00:26.000
信息或仅是有关以下内容的一般信息

00:00:26.000 --> 00:00:29.920
以分散的方式进行，并且建立在

00:00:29.920 --> 00:00:32.960
陶瓷的顶部，因此它具有所有特性

00:00:32.960 --> 00:00:36.320
乔尔刚刚描述并使用瓷砖

00:00:36.320 --> 00:00:44.879
和其他流处理数据类型基本创建了系统

00:00:44.879 --> 00:00:51.039
好吧，因为这里怕重复

00:00:51.039 --> 00:00:54.320
我不会详细介绍所有这些内容，而是在什么基础上进行构建

00:00:54.320 --> 00:00:58.000
丹尼尔（丹尼尔）说，嗯，身份确实是

00:00:58.000 --> 00:01:00.960
有关主题的信息，因此您所有事物的整个宇宙

00:01:00.960 --> 00:01:05.040
说您在网上吗

00:01:05.040 --> 00:01:09.920
在网络2中，显然我们有特定于应用的标识符，需要

00:01:09.920 --> 00:01:14.720
您知道服务器端身份验证um，传统上您知道关系型

00:01:14.720 --> 00:01:17.840
数据库模型（如果使用的是dynamodb或其他工具）

00:01:17.840 --> 00:01:21.360
您可能会知道建立一个用户表um，除了这些只是

00:01:21.360 --> 00:01:26.720
分散在应用程序孤岛中，因此它们实际上只能映射到其他数据资源

00:01:26.720 --> 00:01:31.040
由用户在与单个应用程序交互时产生

00:01:31.040 --> 00:01:33.680
而且它们不是为互操作性而设计的，所以您知道

00:01:33.680 --> 00:01:36.960
它们与该应用程序的一个技术堆栈实现相关联

00:01:36.960 --> 00:01:39.520
选择，他们积极劝阻

00:01:39.520 --> 00:01:42.880
外来者发现此信息的可能性得到保护

00:01:42.880 --> 00:01:46.960
因为那是他们的事，但在网络3中

00:01:46.960 --> 00:01:51.360
旨在将模型从应用程序孤岛转换为用户孤岛

00:01:51.360 --> 00:01:55.520
并且这些都是开放标识符，所以

00:01:55.520 --> 00:01:58.640
像Daniel和Joel这样的人

00:01:58.640 --> 00:02:02.079
您知道客户端身份验证可能是服务器端的，但是

00:02:02.079 --> 00:02:07.520
客户端作为权力下放的起点

00:02:07.520 --> 00:02:12.160
呃，理想情况下，您有这个统一的以实践为中心

00:02:12.160 --> 00:02:15.840
与之相关的信息和资源索引

00:02:15.840 --> 00:02:21.440
用户或该身份，最好是您知道的该索引映射到的用户

00:02:21.440 --> 00:02:24.879
资源，因为您知道有不同的数据

00:02:24.879 --> 00:02:27.520
生产者和消费者，以便用户与应用交互

00:02:27.520 --> 00:02:31.360
一个应用程序a可能直接在文件硬币中存储数据

00:02:31.360 --> 00:02:35.360
或应用b可能以文本样式存储数据，而应用c可能在a上存储数据

00:02:35.360 --> 00:02:39.920
集中数据存储在某个地方，目的是

00:02:39.920 --> 00:02:44.400
使所有数据可互操作和可发现

00:02:44.400 --> 00:02:49.840
将单个位置放置在不受任何技术影响的统一位置

00:02:49.840 --> 00:02:53.280
单个应用程序实现

00:02:53.680 --> 00:02:57.840
而且我不必经历这个，所以谢谢丹尼尔，但是最重要的是

00:02:57.840 --> 00:03:00.400
确实对理解这一点至关重要

00:03:00.400 --> 00:03:03.920
这些是在以下位置注册的分散标识符

00:03:03.920 --> 00:03:09.280
一些分散的，您知道的分类帐或数据平台

00:03:09.280 --> 00:03:12.879
这些数据独立于任何第三方的地方

00:03:12.879 --> 00:03:16.080
这些标识符及其结果

00:03:16.080 --> 00:03:21.120
代表um的文档确实是去中心化的，因为

00:03:21.120 --> 00:03:27.120
一切都会从中构建，因此，如果我们考虑到您，您会知道

00:03:27.120 --> 00:03:31.360
设计时真正要达到的设计目标

00:03:31.360 --> 00:03:37.440
一个分散的身份标准，我们可以在这里的列表中看到它们，等等

00:03:37.440 --> 00:03:40.879
第一个实际上就是灵活性

00:03:40.879 --> 00:03:45.040
使标准不可知

00:03:45.040 --> 00:03:50.159
给定的应用程序开发人员可能选择的任何特定技术堆栈

00:03:50.159 --> 00:03:54.080
部署在um上，因此理想的情况是该标准

00:03:54.080 --> 00:03:57.840
可以用任何方法知道是否是离子

00:03:57.840 --> 00:04:01.439
你知道由微软运行或元素的另一种实现

00:04:01.439 --> 00:04:06.159
一棵树或三棵id做过，其他一些则是陶瓷原生的

00:04:06.159 --> 00:04:08.799
嗯，不要紧，因为这些事会来的

00:04:08.799 --> 00:04:12.400
从整个地方开始，它应该与所有人一起工作

00:04:12.400 --> 00:04:16.880
身份验证方法和密钥对，因此您知道能够

00:04:16.880 --> 00:04:20.799
从n个数字中控制一个身份

00:04:20.799 --> 00:04:23.840
登录方法是否是客户端中的区块链密钥对

00:04:23.840 --> 00:04:27.360
服务管理的钱包或社交登录名

00:04:27.360 --> 00:04:31.440
在服务器上，他们应该都能控制

00:04:31.440 --> 00:04:34.240
从中生成的根标识符

00:04:34.240 --> 00:04:37.919
您知道签名和加密可以归因于

00:04:37.919 --> 00:04:42.160
信息的内容和控制

00:04:42.160 --> 00:04:45.360
应该与所有数据存储技术格式和位置一起使用，因此

00:04:45.360 --> 00:04:48.639
无论您要在任何地方部署的基础上构建的任何内容，都不应

00:04:48.639 --> 00:04:53.120
嗯，可发现性很重要，所以这真的是

00:04:53.120 --> 00:04:57.199
建立此类数据的关键要素

00:04:57.199 --> 00:05:01.120
索引位置，而不是应用程序实体模型

00:05:01.120 --> 00:05:04.880
今天我们有你知道的走向用户孤岛的地方

00:05:04.880 --> 00:05:08.800
或以用户为中心的模型，重要的是我们开始描述

00:05:08.800 --> 00:05:13.039
语义上的数据与像描述数据一样

00:05:13.039 --> 00:05:15.919
哦，是来自应用程序a的数据还是来自应用程序b的数据

00:05:15.919 --> 00:05:20.479
因为应用c可能不喜欢护理或知道您知道

00:05:20.479 --> 00:05:24.880
应用程序a和b都是博客平台，所以我需要

00:05:24.880 --> 00:05:28.160
当我查询时，知道用户使用了哪些其他应用程序

00:05:28.160 --> 00:05:32.800
此信息应通过数据本身来描述，例如

00:05:32.800 --> 00:05:36.080
数据，架构，一些元数据和描述，以便

00:05:36.080 --> 00:05:39.600
它更具有互操作性，它不受限制，您不需要了解其他所有知识

00:05:39.600 --> 00:05:41.919
也使用该标准的应用程序

00:05:41.919 --> 00:05:45.440
消耗不是由您的应用程序创建的数据

00:05:45.440 --> 00:05:48.800
并且所有这些都应该在一个逻辑上集中的位置进行组织，并且

00:05:48.800 --> 00:05:53.520
逻辑上是集中的，因为它存在于一个地方，但是它位于一个地方

00:05:53.520 --> 00:05:56.639
去中心化的网络，所以您知道某种程度上是去中心化的，但是

00:05:56.639 --> 00:06:01.440
逻辑上集中的um，并且应该保留隐私

00:06:01.440 --> 00:06:04.880
因此该系统应该能够支持公共和私人信息

00:06:04.880 --> 00:06:09.680
正如丹尼尔（丹尼尔）所提到的um，实际上是假名和

00:06:09.680 --> 00:06:12.800
设计时，渐进式身份必须普遍存在

00:06:12.800 --> 00:06:16.800
建立一个有满足要求的身份标准

00:06:16.800 --> 00:06:22.080
空间ID或类似政府颁发的合法身份，可以在船上使用和使用，但

00:06:22.080 --> 00:06:24.479
而是所有身份开始

00:06:24.479 --> 00:06:28.080
假名和空的，取决于哪种类型

00:06:28.080 --> 00:06:31.120
用户在与应用程序交互时向他们添加的信息

00:06:31.120 --> 00:06:34.160
这种身份再次开始获得

00:06:34.160 --> 00:06:38.160
的含义是随着时间的流逝，取决于用户决定哪种

00:06:38.160 --> 00:06:40.880
他们想要添加到此身份的信息um

00:06:40.880 --> 00:06:44.479
其中一些人最终可能会以法律身份的形式出现，

00:06:44.479 --> 00:06:48.400
同一用户具有不同的身份，他们开始形成一个身份

00:06:48.400 --> 00:06:52.160
另一种不同的角色，您知道我们并没有限制一个用户

00:06:52.160 --> 00:06:55.919
到一个idx um，而是某种程度地保持打开状态

00:06:55.919 --> 00:07:00.160
它可以按需要的多种方式使用，

00:07:00.160 --> 00:07:03.599
重要的是它们必须具有标准接口

00:07:03.599 --> 00:07:07.680
您知道从中读取和写入信息的通用方法

00:07:07.680 --> 00:07:12.400
索引um使您无需集成一次性api即可实现互操作

00:07:12.400 --> 00:07:15.599
每个单独的数据源um，因为那太麻烦了

00:07:15.599 --> 00:07:18.400
真正实现我们的互操作性目标

00:07:18.400 --> 00:07:22.479
而且您知道它是不可信且可扩展的，因此可以部署在分散式，无权限的环境中

00:07:22.479 --> 00:07:26.319
丹尼尔（Daniel）说的dos本身应该是

00:07:26.319 --> 00:07:30.000
这个索引idx数据结构也很好

00:07:30.000 --> 00:07:33.440
应该是第一原则

00:07:33.440 --> 00:07:37.280
因为它实际上是由用户而不是第三方控制的

00:07:37.280 --> 00:07:41.199
或一台服务器，如果它掉线了，您的所有数据和路由信息现在

00:07:41.199 --> 00:07:45.280
嗯，即使持续了几分钟

00:07:45.280 --> 00:07:48.720
和可扩展性，因此基础架构是分散式基础架构

00:07:48.720 --> 00:07:51.680
建立在需要能够扩展以能够支持它的基础上

00:07:51.680 --> 00:07:55.280
嗯，这就是为什么我们在陶瓷上部署idx的原因

00:07:55.280 --> 00:08:00.720
以及如何实际工作的快速介绍，这是一个分散的数据结构

00:08:00.720 --> 00:08:06.000
使用陶瓷流关联任何类型的数据

00:08:06.000 --> 00:08:10.000
到一个迪迪，所以在这里你看到一个碰巧是一个

00:08:10.000 --> 00:08:13.120
三个id是陶瓷固有的一种方法

00:08:13.120 --> 00:08:16.960
像乔尔所说的那样使用瓷砖，在下面您会看到两个

00:08:16.960 --> 00:08:20.800
这是一个离子，所以你知道它锚定在比特币上

00:08:20.800 --> 00:08:25.599
离子协议和网络，它们都有

00:08:25.599 --> 00:08:30.400
相应的索引，即使

00:08:30.400 --> 00:08:34.320
丹尼尔（daniel）谈到他展示了他们具有用于签名的公钥

00:08:34.320 --> 00:08:37.680
验证加密以及其他服务端点

00:08:37.680 --> 00:08:41.919
关于Ceramic和IDX的好处是您实际上不必注册

00:08:41.919 --> 00:08:46.240
做过的文档即服务中的索引

00:08:46.240 --> 00:08:51.600
您可以冗余，但是陶瓷具有这种确定性

00:08:51.600 --> 00:08:54.640
财产，如果你知道做过的事，而你知道你在哪里

00:08:54.640 --> 00:08:57.519
寻找它的索引，您可以确定地

00:08:57.519 --> 00:09:02.160
查询该索引，陶瓷协议将解析并返回

00:09:02.160 --> 00:09:05.440
用户的索引，而无需实际建立链接

00:09:05.440 --> 00:09:08.640
这很关键，因为有很多不同的方法

00:09:08.640 --> 00:09:12.959
插入它们的常用方法可能并不总是可行的，因此给定一个

00:09:12.959 --> 00:09:16.800
您是否总是可以确定性地生成其索引并返回

00:09:16.800 --> 00:09:20.560
当前状态，在这里您看到两个用户，所以接下来

00:09:20.560 --> 00:09:25.440
开发人员将创建一个模式，将其发布到瓷砖中，然后

00:09:25.440 --> 00:09:31.040
我们将获取该陶瓷流ID，并将其插入定义中，然后

00:09:31.040 --> 00:09:34.880
将该定义部署到瓷砖上，定义基本上是

00:09:34.880 --> 00:09:38.720
资源的语义描述，所以在这里您可以看到一些

00:09:38.720 --> 00:09:42.880
元数据让我们假设它是一个基本配置文件，它具有一些

00:09:42.880 --> 00:09:46.320
描述一个通用配置文件，它具有一个模式

00:09:46.320 --> 00:09:51.360
因此，这将提供此定义的流ID

00:09:51.360 --> 00:09:55.279
作为索引中的键，并且作为开发人员，我只需要创建一个

00:09:55.279 --> 00:09:58.880
一次定义，我可以将其用于n个用户

00:09:58.880 --> 00:10:02.480
因此，在顶部的用户之一，在底部的用户是两个

00:10:02.480 --> 00:10:05.839
相同的流ID

00:10:06.800 --> 00:10:12.720
他们的两个索引，现在作为用户用户进入我的应用程序，他们插入了

00:10:12.720 --> 00:10:16.160
一些个人资料信息恰好是satoshi他们有一个

00:10:16.160 --> 00:10:21.200
ipfs图片，并有描述和

00:10:21.200 --> 00:10:25.200
在创建此记录时使用idx api

00:10:25.200 --> 00:10:28.959
 idx库自动发布定义

00:10:28.959 --> 00:10:32.320
流ID和作为单独流的记录流ID

00:10:32.320 --> 00:10:36.160
进入索引，所以现在您有了这张地图

00:10:36.160 --> 00:10:39.839
定义的流ID到记录的流ID

00:10:39.839 --> 00:10:42.959
这样您就可以在语义上组织信息存储

00:10:42.959 --> 00:10:47.680
现在，当用户2到达相同的定义流ID时，

00:10:47.680 --> 00:10:51.040
是他们索引中的关键，他们创建了一个单独的记录，这是它自己的

00:10:51.040 --> 00:10:54.399
流，其中包含他们的个人资料，所以现在您

00:10:54.399 --> 00:10:57.279
他们都有成千上万的用户

00:10:57.279 --> 00:11:01.680
建立在一个通用数据定义和每个对应数据的基础上

00:11:01.680 --> 00:11:06.959
记录分别存储在流中，并且

00:11:06.959 --> 00:11:10.959
在这些记录中，我认为重要的是

00:11:10.959 --> 00:11:14.240
它们可以直接包含数据，例如我刚刚展示的示例

00:11:14.240 --> 00:11:18.000
基本配置文件，您可以将json数据转储到记录中

00:11:18.000 --> 00:11:21.279
这是自成体系的，或者您可以使用

00:11:21.279 --> 00:11:25.680
记录为跳点或路由机制

00:11:25.680 --> 00:11:31.040
外部存储，因此在这种情况下的记录将只包含您知道的uri

00:11:31.040 --> 00:11:35.040
以及其他一些元数据，这些元数据在解决后将使您能够

00:11:35.040 --> 00:11:38.399
路由到IDX源的一些外部

00:11:38.399 --> 00:11:40.959
信息，这可能是其他陶瓷

00:11:40.959 --> 00:11:46.160
像想象中的文档，您有一个IDx记录，上面写着博客文章和

00:11:46.160 --> 00:11:49.680
所以里面只有一系列陶瓷

00:11:49.680 --> 00:11:53.360
停靠ID和每个陶瓷或流ID

00:11:53.360 --> 00:11:57.360
并且这些流中的每一个都是独立的博客文章，因此，

00:11:57.360 --> 00:12:00.800
被认为是外部存储，而您正在使用idx作为一种

00:12:00.800 --> 00:12:06.480
所有这些指针的聚集机制都可以做同样的事情

00:12:06.480 --> 00:12:09.920
用filecoin文件或存储在任何文件中的文件来想象

00:12:09.920 --> 00:12:13.600
其他类型的分散式持久存储网络

00:12:13.600 --> 00:12:17.440
您可以指向纺织数据存储或轨道数据存储或其他集中式

00:12:17.440 --> 00:12:21.760
版本，甚至是链上合同，等等

00:12:21.760 --> 00:12:24.480
与技术无关的方式，您可以将记录用作

00:12:24.480 --> 00:12:28.000
数据存储或指向其他数据存储的指针，所有这些都可用于

00:12:28.000 --> 00:12:33.760
组织信息，而IDX则更多

00:12:33.760 --> 00:12:37.760
丹尼尔和乔尔都说过，

00:12:37.760 --> 00:12:41.360
如果可以用a表示，它可以有一个idx，所以

00:12:41.360 --> 00:12:44.480
你知道对于人来说这是不言而喻的

00:12:44.480 --> 00:12:48.720
呃，有乔尔在说的规范的组织

00:12:48.720 --> 00:12:50.720
他们选择代表或左右

00:12:50.720 --> 00:12:56.480
本身满足nft did方法允许的nfts是

00:12:56.480 --> 00:13:00.880
数字内容现在具有身份并拥有其组织的所有信息

00:13:00.880 --> 00:13:04.240
以IDX进行组织，从而使他们能够建立

00:13:04.240 --> 00:13:08.720
整个元内容世界是可移植的，并随其而来

00:13:08.720 --> 00:13:17.120
nft甚至设备嗯，并采用um Ceramicsville和testnet

00:13:17.120 --> 00:13:20.639
但已签署了100多个elp项目

00:13:20.639 --> 00:13:26.399
陶瓷um的早期发布计划在这里有很多知名人士

00:13:26.399 --> 00:13:29.200
我们期待成功的发布

00:13:29.200 --> 00:13:34.000
嗯，我想我注意到我很快就离开了一张幻灯片，但我可以说

00:13:34.000 --> 00:13:40.639
通过它，你会知道一些常见的记录用例，其中

00:13:40.639 --> 00:13:44.160
我们已经看到并且正在使用记录

00:13:44.160 --> 00:13:49.440
实际上是做某事的身份验证钥匙串，因此您可以将做事

00:13:49.440 --> 00:13:53.839
种子，您可以使用一些区块链帐户对其进行加密

00:13:53.839 --> 00:13:57.279
并将其存储在记录中，您将存储有效的数组

00:13:57.279 --> 00:14:01.120
加密的种子材料，所以作为用户您知道

00:14:01.120 --> 00:14:06.800
使用其元掩码登录到应用，该应用可以解密解密的种子

00:14:06.800 --> 00:14:11.920
在安全且受保护的iframe中，我们正在构建一个称为3d连接的

00:14:11.920 --> 00:14:16.399
这使用户可以从他们的所有身份中对他们的行为进行身份验证

00:14:16.399 --> 00:14:20.079
人们正在使用区块链钱包进行配置文件和

00:14:20.079 --> 00:14:23.680
社交图um用户生成的内容（例如博客文章）

00:14:23.680 --> 00:14:27.920
以及照片和用户设置，所以您可能知道

00:14:27.920 --> 00:14:32.959
用户说我想将我的所有文件持久保存到该特定Powergate实例

00:14:32.959 --> 00:14:37.600
这正在运行Filecoin um，因此不是应用程序本身

00:14:37.600 --> 00:14:41.440
您知道为其所有用户数据运行Powergate实例

00:14:41.440 --> 00:14:44.639
用户可以指定自己的文件，这样就可以携带自己的文件

00:14:44.639 --> 00:14:48.079
以及他们在各个平台上的坚持不懈，因此他们可以

00:14:48.079 --> 00:14:51.279
一栋通用建筑，您知道那里可能正在向他们收费

00:14:51.279 --> 00:14:54.079
他们订阅了这个特定的备份提供商

00:14:54.079 --> 00:14:57.199
现在可以在所有这些接口上移植

00:14:57.199 --> 00:15:01.120
um替代idx的方法我认为值得一提

00:15:01.120 --> 00:15:05.760
他们来，这样你就可以看到你喜欢的差异

00:15:05.760 --> 00:15:08.880
知道人们说您为什么不将所有内容存储在已完成的文档中

00:15:08.880 --> 00:15:12.160
嗯，那真的很难，因为

00:15:12.160 --> 00:15:15.920
同意所有数据格式的所有标准以及如何解释

00:15:15.920 --> 00:15:19.040
处理过的文档中的数据似乎非常困难

00:15:19.040 --> 00:15:23.440
嗯，所以对于这些标准将无法实现

00:15:23.440 --> 00:15:26.639
数字世界所代表的全部数据

00:15:26.639 --> 00:15:30.399
因此有一些描述定义和语义组织的方法

00:15:30.399 --> 00:15:33.199
它超出了文档的范围

00:15:33.199 --> 00:15:37.120
重要的是，文件是否需要超级保存

00:15:37.120 --> 00:15:39.759
轻便的，因为它们可能是最轻巧的之一

00:15:39.759 --> 00:15:43.120
同步事物，例如每次您访问应用程序时，他们都需要同步您所做的事情

00:15:43.120 --> 00:15:45.199
文档，如果该文档只是保留

00:15:45.199 --> 00:15:49.440
随着同步时间的增加，呃，它增加了，并且使该文档过时了

00:15:49.440 --> 00:15:52.800
远离实际上只是签名的关键信息

00:15:52.800 --> 00:15:56.639
像您的公用密钥之类的um密钥，用于加密签名

00:15:56.639 --> 00:15:59.759
有人说您使用智能合约做得很好

00:15:59.759 --> 00:16:04.480
那种将您所做的事情与您的索引联系起来并将其包装成一件事

00:16:04.480 --> 00:16:08.240
嗯，并与特定的区块链网络联系在一起

00:16:08.240 --> 00:16:10.639
跨链互操作性真的很难

00:16:10.639 --> 00:16:15.279
以及围绕数据描述的各种灵活性

00:16:15.279 --> 00:16:19.519
或者我想丹尼尔说的是你知道有一项服务

00:16:19.519 --> 00:16:24.079
完工文档中的端点，该端点可以指向安全的数据存储或个人

00:16:24.079 --> 00:16:26.160
数据存储，您的许多信息都在其中

00:16:26.160 --> 00:16:29.120
在某个地方运行的服务器实例上进行管理

00:16:29.120 --> 00:16:34.800
um和所有应用程序都进行读写操作，以便对该单个实例进行读写操作

00:16:34.800 --> 00:16:38.560
理论上由您管理，但在所有实践中均由

00:16:38.560 --> 00:16:44.399
云提供商um，但这似乎不是一种有效的方法

00:16:44.399 --> 00:16:48.320
分散的um，因为如果那种服务器

00:16:48.320 --> 00:16:52.480
是找到所有数据的第一个起点

00:16:52.480 --> 00:16:56.240
即使复制单个服务器，也要承担很大的责任

00:16:56.240 --> 00:16:59.839
所以首先要依靠分散的基础设施

00:16:59.839 --> 00:17:03.040
跳点，然后如果您选择前往

00:17:03.040 --> 00:17:06.400
从idx到存储子集的安全数据存储

00:17:06.400 --> 00:17:09.839
您希望对信息进行超级加密和保密的信息

00:17:09.839 --> 00:17:12.319
服务器似乎是一种更好的方法，所以它

00:17:12.319 --> 00:17:16.799
应该像dids idx一样，那么无论您托管什么数据源

00:17:16.799 --> 00:17:19.280
想要而不是直接从做

00:17:19.280 --> 00:17:23.520
到托管数据存储区um，是的，您今天就可以开始使用

00:17:23.520 --> 00:17:27.919
因此Ceramic具有一个javascript完整节点，可以在浏览器或客户端中运行

00:17:27.919 --> 00:17:33.360
或http api并进行身份验证，您可以

00:17:33.360 --> 00:17:36.400
使用用户的各种区块链钱包对您的工作进行身份验证

00:17:36.400 --> 00:17:39.360
已经通过ID Connect使用，或者您可以

00:17:39.360 --> 00:17:42.160
如果您想做更多事情，则可以自然地整合一个提供服务的提供者

00:17:42.160 --> 00:17:47.360
复数，一个idx是一个javascript sdk，因此

00:17:47.360 --> 00:17:50.640
您可以将其直接放到您的应用客户端中，并且可以正常工作

00:17:50.640 --> 00:17:55.919
嗯，是的，您可以查看docs developers.idx.xyz

00:17:55.919 --> 00:18:01.120
我们在Ceramic Network上的博客有很多很好的内容和教程

00:18:01.120 --> 00:18:05.280
如果您正在玩耍，并且有兴趣尝试这些

00:18:05.280 --> 00:18:09.200
陶瓷上的东西在测试网上，您可以继续进行并开始构建

00:18:09.200 --> 00:18:12.960
但是如果您想将您的应用程序移至这些系统上的正式版中，我会

00:18:12.960 --> 00:18:15.360
鼓励您注册早期启动计划

00:18:15.360 --> 00:18:19.360
嗯，这将是我们目前正在接受的申请，并将

00:18:19.360 --> 00:18:23.520
正式上线了一个多月

00:18:23.520 --> 00:18:29.840
所以这一切都给我

00:18:30.960 --> 00:18:33.039
你

