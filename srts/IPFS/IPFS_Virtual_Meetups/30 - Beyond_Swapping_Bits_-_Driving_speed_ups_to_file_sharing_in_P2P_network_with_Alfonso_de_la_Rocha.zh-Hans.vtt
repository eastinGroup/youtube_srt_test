WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.040 --> 00:00:05.920
大家好，我是阿方索·拉罗特，我正在研究

00:00:05.920 --> 00:00:10.240
工程师在Resnet实验室的协议实验室担任工程师，今天我只是

00:00:10.240 --> 00:00:13.360
想分享我们正在运行的令人兴奋的项目

00:00:13.360 --> 00:00:17.039
在我们试图驱动的resnet实验室中

00:00:17.039 --> 00:00:19.920
加快速度以加快文件共享

00:00:19.920 --> 00:00:25.359
对等网络，当然我们试图找到这些加速

00:00:25.359 --> 00:00:30.080
使用ipfs um，所以当我们开始时

00:00:30.080 --> 00:00:33.280
我们要做的第一件事就是像任何其他方式一样进行最先进的评估

00:00:33.280 --> 00:00:37.200
其他研究人员试图找到改进文件的方法

00:00:37.200 --> 00:00:42.239
分享，但我们意识到我们没有办法测试我们的

00:00:42.239 --> 00:00:44.800
的想法，所以我们当然有一个基础设施

00:00:44.800 --> 00:00:48.480
很多ipfs节点，我们可以在本地尝试，但是我们没有

00:00:48.480 --> 00:00:52.960
将基线与我们曾经的想法进行比较的方式

00:00:52.960 --> 00:00:58.320
生成并且我们正在制作原型，所以我们要做的第一件事是

00:00:58.320 --> 00:01:05.600
建立一个测试平台来尝试文件共享，

00:01:05.600 --> 00:01:10.080
轻松实现文件共享协议的新原型

00:01:10.080 --> 00:01:16.560
并评估其性能，因此，如果您想尝试一下，就在这里

00:01:16.560 --> 00:01:20.479
回购你会发现像一个探针和一个测试床

00:01:20.479 --> 00:01:24.080
是实际的测试回合吗，我不知道你是否

00:01:24.080 --> 00:01:30.000
知道特斯拉，但这是原始协议实验室中的一个很棒的um项目，

00:01:30.000 --> 00:01:33.119
以一种非常简单的方式测试对等协议

00:01:33.119 --> 00:01:36.720
在这里您将找到我们正在使用的所有计划

00:01:36.720 --> 00:01:43.439
评估我们所有的原型，您还将看到一个python笔记本仪表板

00:01:43.439 --> 00:01:49.680
其实认为我在这里，以便您可以运行不同的版本

00:01:49.680 --> 00:01:52.880
在测试场地测试台上进行测试并开始

00:01:52.880 --> 00:01:59.119
通过ipfs玩共享um实现的文件

00:01:59.119 --> 00:02:03.119
在项目中，我们如何专注于方法论

00:02:03.119 --> 00:02:08.879
首先，如果我们想出了一个首先写的想法，

00:02:08.879 --> 00:02:12.720
一个rfc，这样我们就可以开始讨论这个想法了，

00:02:12.720 --> 00:02:15.840
我们可以和其他人聊天

00:02:15.840 --> 00:02:20.080
人们看看这个想法是否有意义，一旦我们对此感到满意

00:02:20.080 --> 00:02:24.879
知道我们感觉是一个原型，然后进行适当的测试

00:02:24.879 --> 00:02:27.760
在我们的测试平台上进行评估，今天我想要什么

00:02:27.760 --> 00:02:31.680
分享是我们一直在制作原型的一些东西，因此

00:02:31.680 --> 00:02:36.000
到目前为止，以及如果这项工作仍在进行中，我们所取得的结果以及

00:02:36.000 --> 00:02:38.959
我今天在这里讲话的原因是邀请大家

00:02:38.959 --> 00:02:42.879
以任何方式分享您的反馈或合作

00:02:42.879 --> 00:02:48.640
我的意思是，如果您像这里一样加入，您可以找到我们所有的贡献，

00:02:48.640 --> 00:02:53.200
除了bitwap项目外，我们围绕此所做的所有工作都可以找到

00:02:53.200 --> 00:02:57.200
为什么我们称之为超越

00:02:57.200 --> 00:03:01.120
在这里您会看到RFCS，如果您想进入讨论，则可以

00:03:01.120 --> 00:03:05.599
想提出任何建议或想提出合作建议去这些

00:03:05.599 --> 00:03:09.920
问题，并提出一个问题，我们可以开始讨论，看看我们如何

00:03:09.920 --> 00:03:13.920
将您带入项目um

00:03:13.920 --> 00:03:18.159
但让我们跳入到目前为止已原型化的rfcs

00:03:18.159 --> 00:03:21.519
嗯，就像我说过的那样，我的意思是我们的目标是尝试

00:03:21.519 --> 00:03:25.680
总体上改善对等网络中的文件共享，但是我们已经开始

00:03:25.680 --> 00:03:30.799
当然使用ipfs，并通过apfs开始，我们开始尝试改进

00:03:30.799 --> 00:03:35.920
改善bitstrap，它是ipfs中的交换超级模型

00:03:35.920 --> 00:03:40.239
我们意识到的第一件事是，只要您想要满足

00:03:40.239 --> 00:03:44.239
嗯，您想从网络中获取一些内容

00:03:44.239 --> 00:03:48.159
您的笔记所做的是保存自己，嘿，我想找到这个身份证

00:03:48.159 --> 00:03:52.000
它向您连接的同伴发送了一条我请求的消息

00:03:52.000 --> 00:03:56.000
说我想要这个特定的内容，如果您的同龄人您的连接的同龄人

00:03:56.000 --> 00:03:59.439
没有它，您求助于DHT尝试查找

00:03:59.439 --> 00:04:04.000
存储那个阻止或那个内容的那个家伙的家伙

00:04:04.000 --> 00:04:06.239
所以我们意识到位陷阱没有使用

00:04:06.239 --> 00:04:12.560
收集来自周围环境的信息，以尝试提高其效率

00:04:12.560 --> 00:04:14.959
查找，所以我们所做的是我们的第一个原型

00:04:14.959 --> 00:04:19.440
我们做了一些位交换节点

00:04:19.440 --> 00:04:22.720
听取了来自其连接的对等方和

00:04:22.720 --> 00:04:26.160
网络并保留注册表，以便下一个

00:04:26.160 --> 00:04:30.400
他们想找到一个特定的CID的时间，他们会去的，我是说他们

00:04:30.400 --> 00:04:33.759
会检查之前是否有人要求提供该CID

00:04:33.759 --> 00:04:35.520
在我们周围的环境中，因为可能

00:04:35.520 --> 00:04:39.759
他们将拥有内容，我们将直接向他们索取内容

00:04:39.759 --> 00:04:44.960
以这种方式um加快了流行内容的发现，因为如果有人

00:04:44.960 --> 00:04:48.720
我周围的人要求提供这些内容，而我不需要使用

00:04:48.720 --> 00:04:52.320
嘿家伙的要求，我想要这个内容，我可以直接去找我认识的家伙

00:04:52.320 --> 00:04:56.080
在我们使用测试平台之前已经要求过

00:04:56.080 --> 00:05:00.560
初步测试，以了解其工作方式以及我们设计的任务测试计划

00:05:00.560 --> 00:05:06.320
因为这是软波，所以我们有一个播种机和一个ipfs节点

00:05:06.320 --> 00:05:09.440
为内容提供特定的内容，然后

00:05:09.440 --> 00:05:13.280
水手们大声疾呼，要求提供这些内容

00:05:13.280 --> 00:05:15.440
您在左侧看到的基准位陷阱

00:05:15.440 --> 00:05:19.120
您会发现随后的浪潮越多

00:05:19.120 --> 00:05:22.880
成为海浪的后继水手变成雪松，所以这就是为什么

00:05:22.880 --> 00:05:26.320
我们看到随后的浪潮已经

00:05:26.320 --> 00:05:29.600
取回时间较短，因为它们更容易

00:05:29.600 --> 00:05:33.280
查找内容的简便方法，但很有趣

00:05:33.280 --> 00:05:38.880
当我们使用受欢迎的内容并检查一条消息时的方式

00:05:38.880 --> 00:05:42.960
我们可以减少很多时间发现儿童

00:05:42.960 --> 00:05:47.120
并发现谁拥有内容，从而减少了发现时间

00:05:47.120 --> 00:05:51.600
位陷阱，所以这是我们原型化的第一个射频控制器，并得出结论

00:05:51.600 --> 00:05:54.479
当然，这不是一个完美的实现，可能需要很多

00:05:54.479 --> 00:05:56.800
迭代，但是我们从这里得出的结论是

00:05:56.800 --> 00:06:01.440
我们可以通过获取信息来改善呃文件共享

00:06:01.440 --> 00:06:04.880
从我们现在不使用的其他协议的协议

00:06:04.880 --> 00:06:11.600
发现内容，然后我们说http使用压缩原因

00:06:11.600 --> 00:06:15.759
我们不能使用压缩来使文件共享到

00:06:15.759 --> 00:06:19.919
在未来的纯网络中进行交流，因此在

00:06:19.919 --> 00:06:24.639
在bitswap范围内，我们尝试了不同的策略来查看哪种

00:06:24.639 --> 00:06:28.400
导致更好的结果，我们尝试了

00:06:28.400 --> 00:06:32.319
引导程序压缩每个块以尝试的块压缩策略

00:06:32.319 --> 00:06:36.319
并加速一些不是很好，然后我们尝试了一个完整的

00:06:36.319 --> 00:06:39.199
每一位交换消息的压缩策略

00:06:39.199 --> 00:06:43.360
被压缩了也不是很好

00:06:43.360 --> 00:06:46.400
然后我们尝试了条带压缩，然后说为什么

00:06:46.400 --> 00:06:51.440
尝试压缩消息以便通过跳跃发送

00:06:51.440 --> 00:06:57.280
点对点传输，我们需要事先知道大小，然后包装

00:06:57.280 --> 00:07:00.800
利勃海尔流进入压缩机

00:07:00.800 --> 00:07:07.599
与我们在http和uh jcp处理程序中进行的操作相同

00:07:07.599 --> 00:07:10.960
这样，每个离开bitswap流的字节

00:07:10.960 --> 00:07:14.319
被压缩，这是我们发现的地方

00:07:14.319 --> 00:07:18.000
实际上我们意识到的是，这种实现不是

00:07:18.000 --> 00:07:22.720
协议级别压缩但传输级别

00:07:22.720 --> 00:07:27.120
压缩，在测试床上进行了一些测试之后，我们说嘿

00:07:27.120 --> 00:07:31.520
那是我们的aha时刻，我们意识到，也许如果我们增加压缩以实现跨越式发展

00:07:31.520 --> 00:07:34.639
youtube peer不仅比萨饼可以从中受益，而且

00:07:34.639 --> 00:07:39.759
在ipfs之上构建的每个协议应用程序都可以

00:07:39.759 --> 00:07:43.599
可能会受益于使用uh压缩，因此我们

00:07:43.599 --> 00:07:47.120
花了一些时间试图弄清楚哪里有意义

00:07:47.120 --> 00:07:50.400
给脂质三重压缩

00:07:50.400 --> 00:07:52.960
堆栈，我们做了第一个原型，最后完成了

00:07:52.960 --> 00:07:57.280
嗯，我们在混频器之后增加了压缩，以便

00:07:57.280 --> 00:08:02.000
来自每个单个字节的每个字节流

00:08:02.000 --> 00:08:06.160
协议流可以被压缩，可能被压缩并发送

00:08:06.160 --> 00:08:10.400
通过传输，我们现在正在运行测试中的测试

00:08:10.400 --> 00:08:14.560
不同的数据集，并希望在几天之内我们将能够给出

00:08:14.560 --> 00:08:18.639
一些令人信服的呃结果，但是

00:08:18.639 --> 00:08:22.400
如果您想开始使用压缩功能，甚至想要

00:08:22.400 --> 00:08:27.280
实施您自己的压缩机，这是一个不间断的变化，因为我们

00:08:27.280 --> 00:08:30.960
在运输升级程序中还实施了压缩，并且

00:08:30.960 --> 00:08:33.599
如果您想开始，可以进入这里

00:08:33.599 --> 00:08:36.560
再次与压缩液体一起玩这是一个原型

00:08:36.560 --> 00:08:39.200
可能需要很多直觉和反馈

00:08:39.200 --> 00:08:41.919
但这就是为什么我们正在做这个演讲来邀请大家

00:08:41.919 --> 00:08:45.279
给我们所有反馈，最后

00:08:45.279 --> 00:08:48.480
我们目前正在实施的另一项任务只是为了让您了解

00:08:48.480 --> 00:08:54.640
烤箱里现在有什么东西，所以我们意识到我们还需要更多

00:08:54.640 --> 00:08:57.760
信息，以便更有效地发现

00:08:57.760 --> 00:09:01.120
通过添加内容，例如一条消息

00:09:01.120 --> 00:09:04.720
但我们也可以尝试改善现有范围

00:09:04.720 --> 00:09:06.800
现在找到内容，因为现在

00:09:06.800 --> 00:09:10.320
bitswap仅直接发送监视消息

00:09:10.320 --> 00:09:13.920
与其连接的对等方并通过将ttls添加到

00:09:13.920 --> 00:09:17.440
对内容的要求，我们可能会跳

00:09:17.440 --> 00:09:22.959
进一步注意一个和一个音符，而不必求助于cid

00:09:22.959 --> 00:09:26.959
到dht，所以这就是我们现在正在尝试的

00:09:26.959 --> 00:09:30.160
我们有第一个实施方案

00:09:30.160 --> 00:09:34.320
可以改善，但是我们在初始测试中已经看到了类似的行为

00:09:34.320 --> 00:09:39.040
到我们看到的带有想要的消息rfc的那些，但是再次

00:09:39.040 --> 00:09:43.360
非常欢迎为我们提供帮助并尝试使用文件

00:09:43.360 --> 00:09:47.279
在ipfs中共享，我不想花费更多的时间，因为

00:09:47.279 --> 00:09:50.000
我们有令人兴奋的谈话，非常感谢您让我

00:09:50.000 --> 00:09:59.519
然后再与我联系，以获取一些反馈，讨论或您需要的任何内容

