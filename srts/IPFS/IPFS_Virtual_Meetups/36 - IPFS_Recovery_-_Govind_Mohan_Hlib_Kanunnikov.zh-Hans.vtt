WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.040 --> 00:00:06.080
这是ipfs恢复，我们内置了

00:00:06.080 --> 00:00:08.880
在类似的过程中发生的hackafest 2020

00:00:08.880 --> 00:00:14.080
恩两个月前恩持续30天，所以这有点像

00:00:14.080 --> 00:00:18.560
我们对自己所做的事情的喜好，以及大量的技术

00:00:18.560 --> 00:00:22.160
详细信息，所以进入这次黑客马拉松，我有一个

00:00:22.160 --> 00:00:27.039
有很多使用uh分布式uh纠错的经验

00:00:27.039 --> 00:00:29.439
在分布式系统的上下文中的错误纠正，所以我认为这会

00:00:29.439 --> 00:00:32.640
将其带到ipfs是一个很酷的主意

00:00:32.640 --> 00:00:38.559
嗯，像现有的那样，我能解决的问题是什么

00:00:38.559 --> 00:00:43.920
我想解决的问题是数据损坏会导致呃的损失

00:00:43.920 --> 00:00:47.520
重要信息，因为当您拥有分布式数据时

00:00:47.520 --> 00:00:51.520
系统中，您有存储中的数据和传输中的数据，并且您想确保

00:00:51.520 --> 00:00:56.480
这两种数据模式都具有完整性，因此

00:00:56.480 --> 00:00:59.680
诸如此类的数据可能会破坏静态数据

00:00:59.680 --> 00:01:03.120
咖啡倒在您的笔记本电脑上或像大功率握把故障

00:01:03.120 --> 00:01:08.640
呃，如果是，则是否提供潜在的重要内容

00:01:08.640 --> 00:01:12.560
正在从您的设备向网络中其他设备提供服务

00:01:12.560 --> 00:01:16.400
希望这种情况发生，您要确保有不同的方法

00:01:16.400 --> 00:01:18.560
在您的内部访问相同的信息

00:01:18.560 --> 00:01:21.920
分布式系统，所以您也有没有问题

00:01:21.920 --> 00:01:25.119
搅动设备无论出于何种原因都可以离线的地方

00:01:25.119 --> 00:01:28.320
决定我要关闭我的电脑

00:01:28.320 --> 00:01:32.000
还有如果有人积极参与审查制度

00:01:32.000 --> 00:01:34.640
定位是网络上某些数据类型的数据

00:01:34.640 --> 00:01:38.159
他们可以转到任何链接以确保它不存在

00:01:38.159 --> 00:01:42.799
最后是短暂的连接，可能会发生互联网连接不畅的情况

00:01:42.799 --> 00:01:46.240
出于各种原因，在分布式系统中

00:01:46.240 --> 00:01:48.560
考虑到这一点很重要

00:01:48.560 --> 00:01:52.799
嗯，我也想补充一下，网络安全有三个组成部分，那就是

00:01:52.799 --> 00:01:56.000
机密性完整性和可用性

00:01:56.000 --> 00:02:00.399
机密性可能是最受关注的一种

00:02:00.399 --> 00:02:04.479
嗯，所以完整性和可用性也很重要，所以我认为

00:02:04.479 --> 00:02:09.360
擦除编码才是真正的解决方案，它使我们能够

00:02:09.360 --> 00:02:12.879
保证分布式系统的适当网络安全

00:02:12.879 --> 00:02:16.560
那是什么比例编码呢？这是一种数据保护的方法，其中数据

00:02:16.560 --> 00:02:20.080
被分解成碎片，并用冗余数据块进行编码，并且

00:02:20.080 --> 00:02:23.040
存储在一组不同的位置或存储介质中

00:02:23.040 --> 00:02:27.200
嗯，这个行话实际上是指

00:02:27.200 --> 00:02:30.319
擦除编码类型的数据变得像九头蛇

00:02:30.319 --> 00:02:34.000
多头，如果你砍掉一些头

00:02:34.000 --> 00:02:36.160
你可以喜欢它不断恢复

00:02:36.160 --> 00:02:39.200
一遍又一遍，直到你砍大部分或如果不是

00:02:39.200 --> 00:02:43.680
所有的头脑，所以，值得花一些额外的存储空间来获得

00:02:43.680 --> 00:02:46.239
更好的数据弹性承保表现

00:02:46.239 --> 00:02:51.760
而且数据可以在整个地理区域内分布

00:02:51.760 --> 00:02:56.000
它甚至可以提供更好的性能和交付保证

00:02:56.000 --> 00:03:00.800
嗯，为什么这对ipfs特别重要

00:03:00.800 --> 00:03:06.000
嗯，我想以无限的方式来分发数据

00:03:06.000 --> 00:03:09.440
这是ipfs的核心，它需要强大的完整性保证

00:03:09.440 --> 00:03:12.959
但是我们要确保无论任何情况都要不惜一切代价获得数据

00:03:12.959 --> 00:03:16.159
我们想要确保它是可用的那种数据

00:03:16.159 --> 00:03:20.159
试图摆脱谁或什么情况都没有关系

00:03:20.159 --> 00:03:23.040
我们要确保这些数据仍然存在

00:03:23.040 --> 00:03:25.920
嗯，这是一个长期要求的功能

00:03:25.920 --> 00:03:30.000
像2016年那样的github问题等问题仍未解决

00:03:30.000 --> 00:03:35.280
嗯，解决了这个问题，而且没有具体的解决方案

00:03:35.280 --> 00:03:38.640
对于ipld层，这是我们实际构建的地方

00:03:38.640 --> 00:03:42.799
正如您很快就会看到的，最后我们将其保留在精神中

00:03:42.799 --> 00:03:46.799
ipfs嗯，这只是使其保持模块化

00:03:46.799 --> 00:03:49.599
并且可以通过许多不同的方式插入，因此我们实际上有一些不同的方式

00:03:49.599 --> 00:03:53.280
我们已经建立的橡皮擦代码，所以我会说一些

00:03:53.280 --> 00:04:01.840
我们的hack以及我们实际构建的内容

00:04:02.879 --> 00:04:06.080
哦，我想你是个哑巴

00:04:07.120 --> 00:04:12.879
在那里，你好，嘿，我会讲一些更多的技术细节

00:04:12.879 --> 00:04:17.759
那么所有的工作方式都是

00:04:17.759 --> 00:04:24.479
我最初的目标是创建一个用于

00:04:24.479 --> 00:04:31.280
恢复将遵循大多数最佳实践最佳实践

00:04:31.280 --> 00:04:35.360
在ipfs中可以看到，以及如何进行模块化操作

00:04:35.360 --> 00:04:41.600
嗯，您如何分割所有内容，因此本模块还将介绍

00:04:41.600 --> 00:04:48.720
喜欢尝试的界面喜欢有用的界面

00:04:48.720 --> 00:04:56.479
抽象，就像嗯，最初使用um时很方便，我们开始嗯

00:04:56.479 --> 00:05:03.120
像是在想，呃，我们，我们，我们需要，我们ipfs需要一个

00:05:03.120 --> 00:05:08.240
护林员编码我们做了一些研究，发现实际上有很多

00:05:08.240 --> 00:05:11.440
诸如此类的想法

00:05:11.440 --> 00:05:15.919
实施呃，但是像

00:05:15.919 --> 00:05:19.280
我决定使用uh将其集成到ipld中

00:05:19.280 --> 00:05:23.280
和ipfs当前可与ipld的第一个版本一起使用，因此

00:05:23.280 --> 00:05:27.840
apfs恢复集成在那儿

00:05:27.840 --> 00:05:34.000
嗯，为了那个东西的拥抱示范

00:05:34.400 --> 00:05:40.800
由于要在黑客节上展示一些东西，我们还添加了

00:05:40.800 --> 00:05:47.520
对ipfs的新注释，主要是在允许以下内容的代码中

00:05:47.520 --> 00:05:53.680
你编码任何呃甲板

00:05:53.680 --> 00:05:59.680
重新恢复到可恢复的甲板上，所以您只需一次放置一个ID，就可以得到另一个

00:05:59.680 --> 00:06:04.400
一个呃，有趣的是，我们需要

00:06:04.400 --> 00:06:09.520
uipfast get uh或使用其他获得的哈希值，您将

00:06:09.520 --> 00:06:15.120
仍然看到原始文件，所以实际上您只是交换呃

00:06:15.120 --> 00:06:19.840
一个一个哈希到另一个哈希，您仍然能够

00:06:19.840 --> 00:06:23.520
通过此新生成的内容获取原始内容

00:06:23.520 --> 00:06:32.560
哈希还具有恢复功能um也有类似的功能

00:06:32.560 --> 00:06:39.120
可以添加到您的ipf sli中的可扩展性的不同想法

00:06:39.120 --> 00:06:44.479
带有新功能的ipfs

00:06:44.479 --> 00:06:50.479
就像这样有助于管理某些情况下的回收率

00:06:50.479 --> 00:06:53.520
这样您就可以进行手动恢复，或者

00:06:53.520 --> 00:06:57.599
可以看一下吗

00:06:57.599 --> 00:07:04.800
就像某些国家在ipfs恢复模型中

00:07:05.199 --> 00:07:09.199
这对于查看错误会话很有用

00:07:09.199 --> 00:07:16.479
嗯，我们的主要实现方式，就像我们是rit萨拉曼一样

00:07:16.479 --> 00:07:20.400
这是一种非常流行的擦除编码，它是

00:07:20.400 --> 00:07:26.639
简单易懂，嗯，我不会描述它的工作原理，嗯，我

00:07:26.639 --> 00:07:33.280
想像一些数学上的细节，但是

00:07:33.280 --> 00:07:41.120
嗯，简单地说，它只是让您去恢复呃

00:07:41.120 --> 00:07:47.599
首先，我将为您现有的块生成一些额外的块

00:07:47.599 --> 00:07:53.680
例如，您有七个街区，但您决定再生成三个街区

00:07:53.680 --> 00:07:58.000
阻止呃，那将是那样，那么我们将有

00:07:58.000 --> 00:08:02.960
总共有10个街区，但如果您输掉其中的三个街区

00:08:02.960 --> 00:08:07.360
没关系，您仍然可以获取原始文件

00:08:07.360 --> 00:08:14.960
嗯，所以您仍然可以重新生成那些代表

00:08:14.960 --> 00:08:18.720
实际的用户数据，即使您丢失了它们

00:08:18.720 --> 00:08:23.280
嗯关于实施嗯

00:08:23.919 --> 00:08:30.479
我们为此需要

00:08:31.680 --> 00:08:38.399
为了一个仪式，为了这个能力整合的呃，我们需要

00:08:38.399 --> 00:08:45.600
嗯，就像找到一种方法来整合它，而ipld，我们归零

00:08:45.600 --> 00:08:52.720
有呃节点呃接口可以通过以下方式解决

00:08:52.720 --> 00:08:57.600
一个cid和那个id定义了内容

00:08:57.600 --> 00:09:04.399
像实际的uh节点实现一样被连接起来，我们添加了

00:09:04.399 --> 00:09:11.519
一个新的CD编解码器（如自定义），以解决新问题，新问题

00:09:11.519 --> 00:09:18.959
新节点，呃，正在包装的新恢复节点

00:09:19.200 --> 00:09:26.640
质子化uh，用作链接到uh到网络和uh上的块的链接

00:09:26.640 --> 00:09:29.920
这个呃恢复节点还做什么

00:09:29.920 --> 00:09:37.920
向uh和um恢复说明添加其他免费链接

00:09:37.920 --> 00:09:44.560
链接到该节点的链接，所以这个

00:09:44.560 --> 00:09:51.279
允许um在整个ipfs网络上进行恢复，这意味着

00:09:51.279 --> 00:09:56.000
如果你有一种，你有一个

00:09:56.000 --> 00:10:03.279
恢复节点，但您可以获得所需的块，可以回退到

00:10:03.279 --> 00:10:06.079
得到块

00:10:07.519 --> 00:10:12.160
获取恢复记录，这将帮助您恢复

00:10:12.160 --> 00:10:19.120
您最初需要的障碍物以及可以正常工作的好处

00:10:19.120 --> 00:10:25.440
不只是在您当地的音符上，而是在您想散布您的

00:10:25.440 --> 00:10:30.839
内容并在ipfs上与他人共享，可能要求很高

00:10:30.839 --> 00:10:37.920
它在ipfs网络中四处流动，因此确实有助于

00:10:37.920 --> 00:10:44.959
恢复并提高存储在其上的数据的可用性

00:10:44.959 --> 00:10:49.279
ipfs有点像，让我们继续

00:10:49.279 --> 00:10:52.880
嗯实施，所以

00:10:52.880 --> 00:10:59.920
这个id hack嗯这个id是嗯没错吧

00:10:59.920 --> 00:11:06.959
实际上是一个hack，因为根据我的理解，嗯，我们需要

00:11:06.959 --> 00:11:10.720
分开的东西

00:11:10.720 --> 00:11:16.399
这是一种新的免费插件模型，我们可以在其中添加其他插件

00:11:16.399 --> 00:11:21.279
插件或一些额外的呃代表

00:11:21.279 --> 00:11:24.800
字母或其他要说的内容

00:11:24.800 --> 00:11:32.320
额外的自定义数据，以解决一些额外的问题

00:11:32.320 --> 00:11:39.760
您要处理的数据的功能uh，因为uh恢复不是

00:11:39.760 --> 00:11:43.200
实际上是一个编解码器，您可以说，嗯

00:11:43.200 --> 00:11:49.200
嗯，没有任何节点是一个总结，就像你可以告诉你的那样

00:11:49.200 --> 00:11:54.560
恢复是编码编码还是

00:11:55.519 --> 00:11:58.560
因为法典通常只是说好，我用

00:11:58.560 --> 00:12:02.079
呃json编码，我在上面使用Darkroad

00:12:02.079 --> 00:12:10.800
呃其他任何编解码器，以了解如何

00:12:10.800 --> 00:12:16.560
获取有关编码的块到内存

00:12:16.560 --> 00:12:21.200
实施，所以嗯，有一个重要的嗯

00:12:21.200 --> 00:12:26.000
读取salaman的质量表示所有块都应具有

00:12:26.000 --> 00:12:32.399
大小相同，这是我们要解决的问题

00:12:32.399 --> 00:12:38.800
因为呃ipfs块的大小并不总是相同，而是所罗门群岛丰富

00:12:38.800 --> 00:12:44.800
需要它们是相同的，所以我决定使用

00:12:44.800 --> 00:12:52.880
um并编码为实际块的大小

00:12:52.880 --> 00:12:57.040
在冗余节点内

00:12:57.600 --> 00:13:05.440
这样，当我们尝试恢复一些块时，我们

00:13:05.440 --> 00:13:10.480
将我们拥有的块复制到图表中，这是一种特殊的数据结构

00:13:10.480 --> 00:13:15.600
它管理着，呃，我们有足够的吗

00:13:15.600 --> 00:13:21.839
所需的方块数量，它可以帮助您

00:13:21.839 --> 00:13:27.200
实际恢复原始大小的块并获得

00:13:27.200 --> 00:13:32.240
原始大小呃，我们在那里使用可变整数

00:13:32.240 --> 00:13:37.920
获取原始数据，以便在像插件这样的ipfs中工作

00:13:37.920 --> 00:13:42.959
玩，因为呃，如果你有一个

00:13:42.959 --> 00:13:46.800
有一个已经创建好的牌组，您需要

00:13:46.800 --> 00:13:53.279
对其进行编码，但不进行大幅度更改，以使数据保持静止

00:13:53.279 --> 00:14:02.959
以ipfs方式可读我希望你嗯，我希望我能解释一下

00:14:02.959 --> 00:14:07.440
嗯，我想告诉你的下一件事是自定义码头

00:14:07.440 --> 00:14:11.120
会议如此

00:14:13.199 --> 00:14:19.600
对于ipld，我们零ipf使用了深色服务

00:14:19.600 --> 00:14:27.120
嗯，它允许您通过CID获得ipfs节点

00:14:27.120 --> 00:14:30.800
会议的概念将一些

00:14:30.800 --> 00:14:37.279
嗯逻辑就像一些笔记嗯

00:14:37.279 --> 00:14:40.959
让您从互联网上获取或获取

00:14:40.959 --> 00:14:49.519
它在本地，因此在自定义鸭子会话中，um管理um的密钥对

00:14:49.519 --> 00:14:54.800
你已经恢复了像你的花园街区一样的花园街区

00:14:54.800 --> 00:14:59.680
检索并将其保存为下一个参考

00:14:59.680 --> 00:15:06.880
遍历图的迭代以了解节点是否为um

00:15:06.880 --> 00:15:15.519
我没办法从网络上得到它的父母

00:15:15.519 --> 00:15:20.639
这有点像当前实施的软链接，嗯

00:15:20.639 --> 00:15:28.160
只是在记忆中，你了解谁可以康复

00:15:28.160 --> 00:15:31.360
我现在有不需要的便笺

00:15:31.360 --> 00:15:34.880
在当前会话中，显然它们被保存在

00:15:34.880 --> 00:15:37.920
记忆，但我认为应该有一个特殊的

00:15:37.920 --> 00:15:44.880
就像是代表数据存储区的特殊组件一样

00:15:44.880 --> 00:15:51.759
嗯，这只是说本地的关于某些内容的少量元数据

00:15:51.759 --> 00:15:55.839
节点可以从什么恢复

00:15:57.360 --> 00:16:04.480
这不会增加很多额外的存储空间，但它仍然很有用

00:16:04.480 --> 00:16:09.279
它仅在本地工作，因此您是节点节点

00:16:09.279 --> 00:16:13.279
知道，嗯，我可以用什么来恢复

00:16:13.279 --> 00:16:20.639
一些我需要的东西，一些用户问的第四件事

00:16:20.639 --> 00:16:24.560
嗯恢复这实际上是一个接口

00:16:24.560 --> 00:16:28.800
呃，它有一个红色的所罗门实现

00:16:28.800 --> 00:16:35.759
嗯，它管理状态以进行恢复，因为例如，如果我们想象一个ipfs，

00:16:35.759 --> 00:16:39.040
网关，很多人试图得到一些

00:16:39.040 --> 00:16:42.800
嗯...

00:16:43.680 --> 00:16:51.360
可能会导致在同一时间，同一时间

00:16:51.360 --> 00:16:57.600
对于我们想要的相同数据，将有一个恢复过程

00:16:57.600 --> 00:17:01.519
避免，所以有一个恢复单身

00:17:01.519 --> 00:17:09.120
管理不同的恢复会话以及它允许​​什么

00:17:09.120 --> 00:17:16.000
对于ipfs的任何用户

00:17:16.000 --> 00:17:22.400
指向嗯，对不起，我

00:17:22.400 --> 00:17:30.160
我的耳机掉了，让您指向可能处于恢复状态的恢复会话

00:17:30.160 --> 00:17:36.400
同时进行，这可能与实施有关

00:17:36.400 --> 00:17:39.840
里德所罗门我认为有

00:17:41.600 --> 00:17:46.080
这就是我要说的所有这一切，第四件事

00:17:46.080 --> 00:17:52.000
是用于新颖的alpha纠缠实现的草稿，所以um eric solomon

00:17:52.000 --> 00:17:58.000
是用于擦除编码的行业标准，但是嗯，

00:17:58.000 --> 00:18:03.280
关于编码的正在进行中的研究，还有

00:18:03.280 --> 00:18:09.440
有趣的贵族阿尔法娱乐呃纸和

00:18:09.440 --> 00:18:16.400
呃，甚至有机会联系他们的创造者

00:18:16.400 --> 00:18:20.080
嗯，这篇论文，他们也为

00:18:20.080 --> 00:18:26.240
以太坊，他们以某种方式整合了那些高贵的阿尔法纠缠

00:18:26.240 --> 00:18:30.000
但是我们决定将其排除在范围之外

00:18:30.000 --> 00:18:33.520
像Ritzleman一样易于理解和实施

00:18:33.520 --> 00:18:36.559
但是我们有一个用于身份验证的实施草案

00:18:36.559 --> 00:18:40.160
是的，对不起，我想说几件事，首先，我

00:18:40.160 --> 00:18:42.880
被卡在彼此上最长的时间，所以我不能说

00:18:42.880 --> 00:18:46.720
任何事情，是的，所以Alpha权利是一种

00:18:46.720 --> 00:18:49.919
数据分布在您所拥有的网络中

00:18:49.919 --> 00:18:53.679
嗯实际数据嗯当你有数据上传到

00:18:53.679 --> 00:18:56.880
嗯，网络可能是多个不同的文件，所以

00:18:56.880 --> 00:18:59.760
您可以上传文件，其他人可以上传文件，呃

00:18:59.760 --> 00:19:02.240
这两个文件形成的冗余

00:19:02.240 --> 00:19:06.640
嗯，这样您的文件可能会帮助别人的

00:19:06.640 --> 00:19:10.880
恢复由于某些原因可能损坏或降级的其他人的文件

00:19:10.880 --> 00:19:14.799
我在呃之前提到过，所以这是一种非常新的形式

00:19:14.799 --> 00:19:17.360
一直有很多实验在进行

00:19:17.360 --> 00:19:21.440
以及其他分布式系统，例如以太坊群

00:19:21.440 --> 00:19:25.600
所以我只想把它带到ipfs世界，所以你知道

00:19:25.600 --> 00:19:29.120
我认为，模块化是我们拥有的高度模块化

00:19:29.120 --> 00:19:32.240
使用ipfs recovery还可以帮助我们插入

00:19:32.240 --> 00:19:37.200
任何擦除代码，将来可能会更加疯狂吧

00:19:37.200 --> 00:19:41.280
我们想要实现的目标就像信息理论的平衡

00:19:41.280 --> 00:19:46.000
我们可以从降级的数据中恢复多少

00:19:46.000 --> 00:19:49.280
最后一点是测试场

00:19:49.280 --> 00:19:53.039
当然，ipfs的好伙伴们创造了试验场

00:19:53.039 --> 00:19:57.280
这是我们想要进行战斗测试的过程，我们执行恢复的过程

00:19:57.280 --> 00:20:00.160
都与所罗门阿尔法纠缠在一起

00:20:00.160 --> 00:20:05.039
看看如何获​​得关于我们能够降解多少的精确指标

00:20:05.039 --> 00:20:08.720
数据以及我们网络上节点的性能下降

00:20:08.720 --> 00:20:12.000
抵抗，那将是关键

00:20:12.000 --> 00:20:16.480
确定如何将其与核心整合的因素

00:20:16.480 --> 00:20:18.840
然后您知道可能部署在

00:20:18.840 --> 00:20:23.679
主网嗯，我想是的，关于

00:20:23.679 --> 00:20:26.880
袖子还想使之具有可恢复性

00:20:26.880 --> 00:20:33.760
嗯，所以有一些类似的概念可以在线使用

00:20:33.760 --> 00:20:36.960
这是我们的界面级别

00:20:36.960 --> 00:20:44.640
嗯，这里应该涵盖，嗯，首先是可恢复性，所以嗯

00:20:44.640 --> 00:20:51.200
这是一种让您喜欢的东西，因为它是

00:20:51.200 --> 00:20:55.280
该编码器数据的数据定义如下

00:20:55.280 --> 00:20:59.280
您想要的数据百分比

00:20:59.280 --> 00:21:06.320
安全丢失的外观如果丢失了所投入的百分比，这是可恢复的

00:21:06.320 --> 00:21:09.919
数据的常规功能，您仍然可以

00:21:09.919 --> 00:21:16.080
从网络上检索它，所以说我想要可恢复性

00:21:16.080 --> 00:21:22.559
我已经在网络中有一个dac，并且可以在上面进行编码

00:21:22.559 --> 00:21:30.480
将常规能力设置为25，它的作用是产生25％

00:21:30.480 --> 00:21:34.559
像在整个卡座中添加更多音符

00:21:34.559 --> 00:21:41.760
嗯，如果您实际上从这个套牌中损失25

00:21:41.760 --> 00:21:44.480
在网络上，您仍然可以阅读全部内容

00:21:44.480 --> 00:21:49.919
来自它的数据，但是就像我们真的可以告诉我们

00:21:49.919 --> 00:21:56.000
只需添加更多的数据，而添加更多的25个数据，但就分布式而言

00:21:56.000 --> 00:22:01.520
我认为这是开销的系统

00:22:01.520 --> 00:22:07.440
是有帮助的，它将允许

00:22:08.080 --> 00:22:11.120
或内容是

00:22:11.679 --> 00:22:17.679
更好的可回收性

00:22:17.679 --> 00:22:24.240
所罗门，这个可恢复性行得通，但是行不通

00:22:24.240 --> 00:22:28.240
就像我们有一个参数

00:22:28.559 --> 00:22:35.360
定义要为其生成的节点的节点数量

00:22:35.360 --> 00:22:41.840
如果您可以在图片上看到所有的狗层，那么我们在这里，如果我们

00:22:41.840 --> 00:22:47.039
对于我们拥有的根块具有可恢复性2

00:22:47.039 --> 00:22:54.080
嗯，有两个um节点，我们恢复了生成的能力

00:22:54.080 --> 00:23:01.120
还有两个或更多，以防丢失第二个和第三个

00:23:01.120 --> 00:23:04.720
嗯，这也很可能发生，如果您输了

00:23:04.720 --> 00:23:11.360
无损失，您将无法呃得到呃的内容

00:23:11.360 --> 00:23:16.159
六，嗯，所有免费的东西

00:23:16.159 --> 00:23:21.360
好吧，所以在您拥有的每个父节点的每个级别上，呃

00:23:21.360 --> 00:23:24.799
您的可恢复性所指定的数量是很多冗余

00:23:24.799 --> 00:23:27.200
被创建，因此在此级别上您可以看到

00:23:27.200 --> 00:23:31.039
创建a和b并以如下方式将其连接到一次

00:23:31.039 --> 00:23:34.720
如果您丢失了这四个节点中的任何两个，则可以使用其余节点恢复所有

00:23:34.720 --> 00:23:37.679
他们嗯，同样适用于两个和所有

00:23:37.679 --> 00:23:40.159
它的五个孩子，所有的孩子都是父母

00:23:40.159 --> 00:23:43.919
知道有所有的孩子，所以这又是里德所罗门

00:23:43.919 --> 00:23:48.159
在我们的github中，您在其中之一中有uh纠缠度uh

00:23:48.159 --> 00:23:51.120
问题，您实际上可以看到一个更指定的图表

00:23:51.120 --> 00:23:54.559
那种用例，所以这里有

00:23:54.559 --> 00:23:57.600
有很多不同的方法可以处理dag结构，谢谢

00:23:57.600 --> 00:24:02.000
你知道吗ipld api允许做这种事情

00:24:02.000 --> 00:24:07.679
真的很好，关于策略的一些知识

00:24:07.679 --> 00:24:12.640
好吧，恩，所以这是恩

00:24:12.640 --> 00:24:16.080
当你嗯

00:24:16.799 --> 00:24:20.640
从uh获取网络从ipfs获取数据

00:24:20.640 --> 00:24:29.360
嗯，你嗯，你回过头去恢复吧，这可能吧

00:24:29.360 --> 00:24:36.240
会导致您未要求的节点上的其他数据

00:24:36.240 --> 00:24:40.080
我的意思是，如果我需要一些内容

00:24:40.080 --> 00:24:44.880
并获得该内容ii需要其他内容

00:24:44.880 --> 00:24:49.039
而这另一种内容是可以在网络上获得的

00:24:49.039 --> 00:24:57.279
我帮助我恢复了我需要的数据，但是

00:24:57.279 --> 00:25:02.960
我没有要求恢复数据，所以这种策略是这样的

00:25:02.960 --> 00:25:07.360
最好是放些东西

00:25:07.360 --> 00:25:14.320
ipfs config会帮你的忙，就像帮助你决定要做什么

00:25:14.320 --> 00:25:18.000
与数据，你需要这些额外的数据

00:25:18.000 --> 00:25:22.320
为了恢复，是的，像呃

00:25:22.320 --> 00:25:25.120
首先是全部

00:25:25.440 --> 00:25:28.799
这意味着您将帮助网络

00:25:28.799 --> 00:25:32.799
您将存储所有内容，只是数据意味着

00:25:32.799 --> 00:25:37.360
您将只存储数据

00:25:37.679 --> 00:25:43.679
数据意味着仅数据意味着您将能够在恢复时

00:25:43.679 --> 00:25:50.000
您可以在文件中找到这个文件，而您可能只得到文件的一部分

00:25:50.000 --> 00:25:55.360
您不需要整个文件，但是文件的这一部分

00:25:55.360 --> 00:26:02.320
嗯，有些像失落的积木，你需要做什么，然后退回到

00:26:02.320 --> 00:26:06.640
其他日期和区块供您恢复原始

00:26:06.640 --> 00:26:11.919
博客，但如果有，用户是否没有要求

00:26:11.919 --> 00:26:18.480
例如在第三次拍卖中不会存储此商品的情况下

00:26:18.480 --> 00:26:22.640
那些块不会被存储，但是如果您只选择数据

00:26:22.640 --> 00:26:29.039
嗯，在这种情况下，我向您描述了您没有要求的数据，但是

00:26:29.039 --> 00:26:32.559
嗯，您仍然可以从网络上获取它，或者您也可以

00:26:32.559 --> 00:26:38.720
可能会在您只需要数据的情况下与您要求的其他博客重新生成它

00:26:38.720 --> 00:26:43.039
会在本地保存它们，也许您需要将来，否则您将

00:26:43.039 --> 00:26:46.799
帮助网络，你实际上

00:26:46.799 --> 00:26:50.159
如果您要求将其提供给网络

00:26:50.159 --> 00:26:56.320
您将只做您将要保存的事情，而不需要帮助的事情

00:26:56.320 --> 00:26:59.919
你为了时间而得到你需要的东西，因为我

00:26:59.919 --> 00:27:03.919
认为我们有点低，有些情况下

00:27:03.919 --> 00:27:06.480
知道我认为可能更重要的用例

00:27:06.480 --> 00:27:10.400
存储数据和裁员很重要，即使这意味着要支付一定的费用也是如此。

00:27:10.400 --> 00:27:13.679
多一点，你知道有更多的成本和

00:27:13.679 --> 00:27:16.960
然后有一些情况，例如可能更平均的情况

00:27:16.960 --> 00:27:20.159
您只想获取数据并保存数据的地方

00:27:20.159 --> 00:27:23.840
我们也想拥有这些不同类型的策略

00:27:23.840 --> 00:27:28.960
我认为这对任何社区来说都是真正的未来

00:27:28.960 --> 00:27:33.039
我们希望能够与社区进行讨论的讨论，看看我的意思是我们

00:27:33.039 --> 00:27:35.760
有很多想法很明确，我们想看看是什么样的

00:27:35.760 --> 00:27:38.960
大家有什么想法，以及我们如何实施

00:27:38.960 --> 00:27:43.360
两者都适用于javascript和go ipfs

00:27:44.720 --> 00:27:50.399
关于第二版ipld，我没有足够的时间进行实际潜水

00:27:50.399 --> 00:27:54.880
变成新的规格，呃，他们喜欢

00:27:54.880 --> 00:27:59.440
协议实验室的工作原理，我知道有很多

00:27:59.440 --> 00:28:06.080
新的很酷的功能也可以用于恢复，但我不确定

00:28:06.080 --> 00:28:12.480
我们可以将其用于什么但可以恢复的确切功能

00:28:12.480 --> 00:28:20.080
正如我已经说过的CID部分，恢复是一种

00:28:20.080 --> 00:28:24.159
这是此内容的功能，不是实际的

00:28:24.159 --> 00:28:32.640
表示此内容的方式，所以像其他额外内容一样增加

00:28:32.880 --> 00:28:38.960
到CD的东西也将放在ipld中，我认为这有点

00:28:38.960 --> 00:28:43.120
与此有关的事物也是第二点

00:28:43.120 --> 00:28:47.120
定义恢复注释，说明将要进行的操作

00:28:47.120 --> 00:28:50.399
关于阿尔法纠缠

00:28:50.399 --> 00:28:58.399
但嗯，还有一个有趣的主意，我向您描述了软链接

00:28:58.399 --> 00:29:04.799
用于您的呃可以在本地找到

00:29:04.799 --> 00:29:09.039
恢复所需数据需要注意什么

00:29:09.039 --> 00:29:14.640
嗯，您将清楚地将其存储在该数据存储中，但是

00:29:14.640 --> 00:29:19.760
如果我们将其放在dht上，那会允许

00:29:19.760 --> 00:29:23.120
我们在网络上创建一种软链接

00:29:23.120 --> 00:29:26.559
这将是您恢复的一种最后手段

00:29:26.559 --> 00:29:31.600
嗯，当您尝试恢复数据um像实际的ipfs当前

00:29:31.600 --> 00:29:35.600
得到一些东西，嗯，它会无休止地等待着

00:29:35.600 --> 00:29:39.520
对于数据，它可以找到如果我们

00:29:39.520 --> 00:29:47.919
可以异步做其他事情

00:29:47.919 --> 00:29:51.279
在网络上找到其他东西

00:29:51.279 --> 00:29:56.000
以及软链接的种类，这样您就可以匹配它，从而可以恢复

00:29:56.000 --> 00:30:01.600
因为他们呃有人联系了他们，并且有一个

00:30:01.600 --> 00:30:07.200
um为用户服务的动机

00:30:07.200 --> 00:30:13.679
做互连的恢复节点，例如

00:30:13.679 --> 00:30:20.720
您想要您的数据来帮助其他人恢复其他数据

00:30:20.720 --> 00:30:23.919
这样您就可以建立联系并做出类似帮助的笔记

00:30:23.919 --> 00:30:27.520
它将连接不同甲板的不同部分

00:30:27.520 --> 00:30:32.880
并从这两个平台中获得帮助，您将创建一些多余的音符

00:30:32.880 --> 00:30:39.440
更多，如果您能帮助他们，他们会以这种方式

00:30:39.440 --> 00:30:44.880
不同的数据互相帮助

00:30:45.679 --> 00:30:51.200
即使我可以恢复它们，当呃时也有一个有趣的例子

00:30:51.200 --> 00:30:54.880
您希望您的内容在网络上更加分散

00:30:54.880 --> 00:30:57.919
您可以将其与苛刻的内容联系起来

00:30:57.919 --> 00:31:02.000
您可以帮助您要求恢复内容

00:31:02.000 --> 00:31:06.480
这样您的内容将会更多

00:31:06.480 --> 00:31:12.240
像是分发给一些需要恢复才能满足要求的同龄人

00:31:12.240 --> 00:31:16.640
内容，所以有很多

00:31:16.640 --> 00:31:23.120
未来的新事物

