WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:02.909
我将讨论完全分布式的应用程序以及我们如何

00:00:02.909 --> 00:00:08.429
在协议应用程序上为它们构建平台，我会给出一些建议

00:00:08.429 --> 00:00:15.179
关于协议Absum的上下文只是为了让您了解我们的工作方式

00:00:15.179 --> 00:00:19.439
去解决问题，以及我们正在构建的堆栈和模型

00:00:19.439 --> 00:00:25.109
为此，这就像很多介绍一样，

00:00:25.109 --> 00:00:32.570
每个段落的开头都非常宽泛，但我们会压缩下来，因此我们处于

00:00:32.570 --> 00:00:37.530
令人惊叹的历史时期，我们正在连接整个星球，

00:00:37.530 --> 00:00:40.610
连接自己并建立这个惊人的神经系统并建立一个

00:00:40.610 --> 00:00:46.110
任何人都可以使用的计算平台和应用程序平台

00:00:46.110 --> 00:00:48.690
互联网的属性及其底层的属性

00:00:48.690 --> 00:00:54.590
这些应用的基材现在具有深远的意义

00:00:54.590 --> 00:01:00.960
进入人类生活，因此应用程序数据或

00:01:00.960 --> 00:01:05.820
应用程序是否可以工作的可靠性不仅意味着

00:01:05.820 --> 00:01:09.750
人们今天是否可以工作，在很多情况下都可以生活，或者

00:01:09.750 --> 00:01:15.119
如此死亡，正如我们在最近的选修课中看到的那样

00:01:15.119 --> 00:01:19.020
最后一刻半，非常重要的动作开始依靠

00:01:19.020 --> 00:01:22.080
这些应用程序有时依赖于Twitter和

00:01:22.080 --> 00:01:29.909
Facebook等，您知道我们看到了

00:01:29.909 --> 00:01:36.049
中东是依赖这些系统的一个例子，因此

00:01:36.049 --> 00:01:42.869
他们会更好地工作，在某些情况下会更好地工作

00:01:42.869 --> 00:01:49.110
互联网可能分裂的问题或灾难，或者您知道并拥有

00:01:49.110 --> 00:01:53.430
您知道您无法到达骨干网，或者他们需要在某些情况下运转良好

00:01:53.430 --> 00:01:57.950
可能有巨大的攻击者或试图收集所有这些信息的地方

00:01:57.950 --> 00:02:02.820
信息并以某种方式对您不利，因此有一堆

00:02:02.820 --> 00:02:06.930
各种问题，我们倾向于分解问题并思考

00:02:06.930 --> 00:02:13.340
启动项目来解决其中一些问题，随着时间的流逝，我们倾向于

00:02:13.340 --> 00:02:17.790
重构项目并说哦，这东西实际上很大，也许我们

00:02:17.790 --> 00:02:21.990
可以分解一些子集，所以我们从ipfs项目开始，最后

00:02:21.990 --> 00:02:29.040
在此过程中产生了许多其他项目，我们进行递归，所以我认为

00:02:29.040 --> 00:02:32.610
您知道这些是我们最终要考虑的事情

00:02:32.610 --> 00:02:36.210
我不会详细介绍，我认为这里的每个人都非常熟悉

00:02:36.210 --> 00:02:43.260
这些只是为了给您一种感觉，所以关于协议实验室的一些知识只是出于某种考虑

00:02:43.260 --> 00:02:49.260
答案，我想我们倾向于这样思考自己的一些问题：

00:02:49.260 --> 00:02:53.910
说的恒星托儿所模型让我们考虑一下问题和

00:02:53.910 --> 00:02:59.489
一个空间中的潜在解决方案，然后构建一个项目

00:02:59.489 --> 00:03:04.500
可以解决它，然后考虑随着时间的推移逐渐发展并建立一个

00:03:04.500 --> 00:03:08.700
它周围的社区，所以这就是为什么我们最终会有许多不同的原因

00:03:08.700 --> 00:03:13.880
在自己的社区中具有自己身份的事物等等

00:03:13.880 --> 00:03:18.360
作为组织的协议应用程序是围绕此管道的思想构建的

00:03:18.360 --> 00:03:23.730
从想法一直发展到人类的超级大国，所以我们再次生活在一个

00:03:23.730 --> 00:03:30.750
美好的时光，我们可以从构思和做事中受益

00:03:30.750 --> 00:03:35.370
研究并将其移至发展中并将其移至

00:03:35.370 --> 00:03:39.420
发展成一些部署到人们手中，并给人们

00:03:39.420 --> 00:03:44.070
人类的超级大国以及20世纪很多涉及硬件的领域

00:03:44.070 --> 00:03:48.810
而对于像这样的软件和应用程序平台而言，这既昂贵又困难

00:03:48.810 --> 00:03:55.310
在网络上，我们可以使它变得非常快，以便有人可以坐在一台计算机上

00:03:55.310 --> 00:04:01.620
对应用程序进行编程，然后向其他人授予超能力

00:04:01.620 --> 00:04:05.430
问题是那的可靠性保证是什么

00:04:05.430 --> 00:04:09.090
超级大国是这样，因此我们实际上将根据一大堆来进行工作

00:04:09.090 --> 00:04:13.920
潜在有问题的状况，所以现在发生的事情是人类

00:04:13.920 --> 00:04:18.180
开始经常依赖很多这些东西，却不了解什么时候

00:04:18.180 --> 00:04:23.340
它们可能会崩溃，所以我们应该建立稳固的基础和良好的原始体

00:04:23.340 --> 00:04:27.230
以便应用程序构建者可以构建非常好的软件

00:04:27.230 --> 00:04:31.680
这一点当然不是线性的，它确实遍及整个

00:04:31.680 --> 00:04:34.980
有时我们从存在的事物开始，然后思考

00:04:34.980 --> 00:04:38.520
有时我们会如何思考新的想法以及如何设定这些想法

00:04:38.520 --> 00:04:41.340
通过有时我们会接受别人已经提出的想法

00:04:41.340 --> 00:04:45.480
和说哦，这太棒了，为什么还没有建成，我们来考虑一下

00:04:45.480 --> 00:04:50.010
建造它，我爱提到的关于这架双翼飞机的另一件事是

00:04:50.010 --> 00:04:55.590
在这些阶段，存在许多无关紧要的过滤器

00:04:55.590 --> 00:05:00.660
与想法本身或想法的可行性有关

00:05:00.660 --> 00:05:05.040
人类和建筑事物以及人类擅长的领域，所以有时您会知道

00:05:05.040 --> 00:05:11.100
许多优秀的实验室根据学术界的观点提出了许多想法

00:05:11.100 --> 00:05:15.540
今天工作起来就产生了，但要真正实现它们真的很难

00:05:15.540 --> 00:05:19.770
存在于现实世界中，它的应用和翻译

00:05:19.770 --> 00:05:23.880
在某些情况下，该流程可能需要数十年的时间，因此您可以将IP FS视为

00:05:23.880 --> 00:05:27.570
一个这样的例子，绝大多数ipfs中的想法

00:05:27.570 --> 00:05:33.210
大概在10到15年之前就被构思出来了，只是花了一段时间

00:05:33.210 --> 00:05:39.840
成为可能真正建立或实际上是有可能的

00:05:39.840 --> 00:05:46.110
只是人们还没有做到这一点，我们公开工作，我们与很多人一起工作

00:05:46.110 --> 00:05:53.220
全球各地，所以这是github和

00:05:53.220 --> 00:05:59.370
我们尝试做，是的，我们尝试通过github尽可能多地做，

00:05:59.370 --> 00:06:04.320
在某些情况下涉及两项研究，很多发展需要交叉

00:06:04.320 --> 00:06:11.610
数百个存储库，等等，通过我们的数字有点看它

00:06:11.610 --> 00:06:17.810
有两个大型生态系统，一个围绕ipfs，另一个围绕文件币，

00:06:17.810 --> 00:06:25.230
超过500个github仓库的12个大型项目500个合理的模型模块

00:06:25.230 --> 00:06:30.120
真的很重视这一点，因此我们在实施时会尽可能地尝试

00:06:30.120 --> 00:06:35.000
一些东西来重构东西，以便其他人可以使用中间件

00:06:35.000 --> 00:06:40.510
有时可能会出错，但我们会尽力

00:06:40.510 --> 00:06:46.840
使我们制造的组件只是改善其他方面，即使最终

00:06:46.840 --> 00:06:51.910
以后不依赖他们，我们有很多贡献者，我们所做的一切

00:06:51.910 --> 00:07:00.640
没有我们庞大的社区是不可能的，所以在研究方面

00:07:00.640 --> 00:07:06.640
我们的意思是这很难衡量，但是您知道我们的基本

00:07:06.640 --> 00:07:09.940
就像我们收集的笔记一样，

00:07:09.940 --> 00:07:13.780
在我们开始构建的数百个想法中，有些大的也有些小

00:07:13.780 --> 00:07:19.480
比较正式的和一些准正式的合作，我们有八个

00:07:19.480 --> 00:07:22.360
研究人员8名以上的全职或兼职研究人员

00:07:22.360 --> 00:07:30.220
能力，我们开始发表适当的论文，我们从

00:07:30.220 --> 00:07:33.910
一系列技术报告，我们现在将朝着

00:07:33.910 --> 00:07:38.980
发表论文和会议，我们有三个开放的RFP

00:07:38.980 --> 00:07:46.720
听听埃文（Evan）的消息，所以我们现在进行了适当的研究

00:07:46.720 --> 00:07:53.950
实验室，您知道Evan会告诉您所有细节，所以我想

00:07:53.950 --> 00:07:58.540
简要提到，在所有这些项目中，都有大量的文档

00:07:58.540 --> 00:08:03.070
在网络上，您可以找到有关他们每个人的一堆话题

00:08:03.070 --> 00:08:11.800
有关项目的信息，因此本简介非常简短，专为

00:08:11.800 --> 00:08:15.880
我们今天在这里遇到的问题以及对Sierra T的思考

00:08:15.880 --> 00:08:23.140
考虑一下我们要在其中运行的分布式模型，让我们

00:08:23.140 --> 00:08:27.160
换档到好东西，所以协议和模型等等

00:08:27.160 --> 00:08:34.240
在我们正在考虑的堆栈上，我们从一种承诺开始

00:08:34.240 --> 00:08:38.800
关于未来的证明和升级能力，我们希望我们所有的协议都不要

00:08:38.800 --> 00:08:43.330
之所以失败，是因为有时人们可能转而使用其他传输协议

00:08:43.330 --> 00:08:47.980
发生这种情况，这是一种耻辱，或者您知道哈希函数，那么您选择了一个哈希

00:08:47.980 --> 00:08:51.370
功能，然后将其烘焙到您所做的所有事情中，突然之间就产生了移动成本

00:08:51.370 --> 00:08:54.470
从手表哈希函数到另一个函数变得极其困难

00:08:54.470 --> 00:09:00.950
我们也不想成为网络中碎片化的受害者

00:09:00.950 --> 00:09:07.490
堆栈，我们希望将所有网络绑定在一起，因此我们构建了一个系统，

00:09:07.490 --> 00:09:13.700
库，我将对此做进一步解释，我们有一种方法可以

00:09:13.700 --> 00:09:20.170
对经过身份验证的数据结构进行建模，其中我们将所有数据都视为

00:09:20.170 --> 00:09:23.870
可能经过身份验证的数据结构，我们有一种方法

00:09:23.870 --> 00:09:27.500
在不同系统之间进行翻译，因此我将详细说明

00:09:27.500 --> 00:09:32.000
可行，但这有点像是对ipfs的心脏进行重构和

00:09:32.000 --> 00:09:38.440
所有可以散列链接的可用数据都属于同一类型的数据结构

00:09:38.440 --> 00:09:44.530
自称是更具体的事情，这是一个项目

00:09:44.530 --> 00:09:51.590
分发文件并构建可以正常工作的完全分布式应用程序

00:09:51.590 --> 00:09:55.700
脱机或处于断开连接的环境中，我将通过一个示例进行介绍

00:09:55.700 --> 00:10:02.290
那就是我们所在的地方，然后Farpoint是一个围绕

00:10:02.290 --> 00:10:08.000
激励地球周围的巨大网络以形成适当的结构

00:10:08.000 --> 00:10:12.860
不受任何一方控制的分散存储市场

00:10:12.860 --> 00:10:17.900
这几乎要集中在这三个方面，这里是塞拉利昂

00:10:17.900 --> 00:10:23.480
泰国存在，但是所有国家都可以使用和使用

00:10:23.480 --> 00:10:32.810
关于上面的应用程序，因此IP LD的观察是

00:10:32.810 --> 00:10:37.820
查看诸如git的数据结构或计划“ nines”文件系统或BitTorrent或

00:10:37.820 --> 00:10:43.370
比特币或以太坊或所有这些东西有默克尔树有数据

00:10:43.370 --> 00:10:47.120
使用散列链接相互寻址的结构，如果存在

00:10:47.120 --> 00:10:51.800
整堆默克尔树为什么我们不能将它们合并成一个巨大的默克尔

00:10:51.800 --> 00:10:55.670
林权，并能够彼此之间解决，并能够移动

00:10:55.670 --> 00:10:59.270
通过它们类似于您如何在其中装载不同类型的文件系统

00:10:59.270 --> 00:11:04.750
您在操作系统或网络中如何访问大量不同的URL

00:11:04.750 --> 00:11:08.089
他们是否托管在同一提供商中，或者

00:11:08.089 --> 00:11:13.939
相同的数据库等等，这是一种基本思想，

00:11:13.939 --> 00:11:17.990
您知道会变成一个思考计算和执行的巨大难题

00:11:17.990 --> 00:11:22.999
和模型以及一大堆东西，但基本思想是

00:11:22.999 --> 00:11:28.699
用于在平台或平台上启用软件开发人员的原语

00:11:28.699 --> 00:11:35.089
应用程序级别来构建可以利用所有出色功能的事物

00:11:35.089 --> 00:11:38.540
有关验证数据结构并使之正常工作的事情，以及

00:11:38.540 --> 00:11:41.779
与其他所有东西都玩的很好，所以这导致了分布式编程

00:11:41.779 --> 00:11:49.430
环境，所以想到像绽放的东西，我想到像像

00:11:49.430 --> 00:11:54.680
分布式闭包（也许是Erlang等等），所以这种模型

00:11:54.680 --> 00:12:01.129
这正朝着基本方向发展，这是一种严重的格式，可以

00:12:01.129 --> 00:12:06.079
帮助您将所有这些数据结构绑定在一起，但在更深层次上，它是

00:12:06.079 --> 00:12:11.569
这是一种不以IDE和

00:12:11.569 --> 00:12:15.470
一个进程中的运行时，但考虑所有机器上的运行时

00:12:15.470 --> 00:12:20.959
行星，无论它们是否已连接，其中都嵌入了很多东西，所以我

00:12:20.959 --> 00:12:23.689
不愿深入探讨，但很乐意与人讨论

00:12:23.689 --> 00:12:29.959
感兴趣的是让p2p变成了什么，所以我要跳下栈

00:12:29.959 --> 00:12:35.569
此刻是一个项目，它只是尝试将网络抽象为

00:12:35.569 --> 00:12:40.209
我们可以做到的高效而便捷的方式，但是却保留了

00:12:40.209 --> 00:12:46.639
基础网络的灵活性，因此今天的网络无法真正正常工作

00:12:46.639 --> 00:12:50.929
像蓝牙之类的东西，您必须尽力使它最有效地工作

00:12:50.929 --> 00:12:55.519
浏览器和服务器等无法通过这种传输方式运行，如果

00:12:55.519 --> 00:13:00.290
您想尝试使用更安全的东西，例如tor，您也必须去

00:13:00.290 --> 00:13:06.079
长度很大，既可以用作代理服务器，也可以设置您自己的隐藏服务器

00:13:06.079 --> 00:13:14.290
服务等等，而且很难完全依靠TCP

00:13:14.290 --> 00:13:19.639
运输使SCTP和DCP等其他运输极为困难

00:13:19.639 --> 00:13:26.450
并坚持让别人知道你们有多少个缩写汤-它阻止了所有人

00:13:26.450 --> 00:13:32.270
这些协议中的任何一项都将其带来的好处带给了应用程序和

00:13:32.270 --> 00:13:35.360
观察很好，嘿，端到端原理被打破了，如果

00:13:35.360 --> 00:13:39.860
我们尝试通过创建驻留在应用程序中的网络堆栈来修复它

00:13:39.860 --> 00:13:45.320
层，但可以向下移动，但是您首先知道抽象的应用程序

00:13:45.320 --> 00:13:49.360
消除了所有这些问题，并使应用程序可以不透明地运行

00:13:49.360 --> 00:13:54.800
网络地址和标识符，只要您可以连接一个应用程序

00:13:54.800 --> 00:13:59.870
到任何其他节点，并可以通过它说的任何传输找到一条路由

00:13:59.870 --> 00:14:04.250
那么应该可以正常工作，而作为应用程序开发人员，您不必重写

00:14:04.250 --> 00:14:07.400
您的应用程序使其可以通过蓝牙正常工作

00:14:07.400 --> 00:14:13.580
透明地讲，这就是脂质EP的含义，但其中之一

00:14:13.580 --> 00:14:20.960
重要的是它不依赖任何现有网络

00:14:20.960 --> 00:14:23.990
基础架构或集中式网络基础架构

00:14:23.990 --> 00:14:28.370
可以将网络分成两半，或者分成任何可以分割的节点

00:14:28.370 --> 00:14:31.910
仍然彼此连接应该可以继续运行就好了

00:14:31.910 --> 00:14:36.200
可能完全由您自己决定离线，也可以与其他人建立联系，所以这是

00:14:36.200 --> 00:14:40.610
我们堆栈中处理您需要的所有对等魔术的一部分

00:14:40.610 --> 00:14:44.570
为了使这项工作在今天相当疯狂

00:14:44.570 --> 00:14:48.050
大量不同协议的网络环境等

00:14:48.050 --> 00:14:54.650
所以这是一个工具包，解决了很多问题，使您能够

00:14:54.650 --> 00:14:58.670
发生，所以您拥有诸如对等路由和连接设置以及natura之类的东西

00:14:58.670 --> 00:15:02.660
通用和一大堆不同种类的加密通道，等等

00:15:02.660 --> 00:15:07.640
只是为了使这成为可能，但想法是，您认为所有

00:15:07.640 --> 00:15:11.810
所有这些辛苦的工作进入这一层，从中你会得到一个非常好的

00:15:11.810 --> 00:15:15.620
应用程序的环境，其中您所要做的就是为

00:15:15.620 --> 00:15:21.020
另一个同龄人是他们的ID，并且您有一个路由系统

00:15:21.020 --> 00:15:25.130
可以找到该ID的地址，然后您可以设置一个加密的频道

00:15:25.130 --> 00:15:30.110
在它们之间，然后开始操作，再一次，这甚至还不是很有限

00:15:30.110 --> 00:15:34.690
到IP，您可以在任何类型的网络上运行此工作

00:15:35.250 --> 00:15:42.130
我要提到的另一件事是IP，如果我说过将其视为应用程序的话

00:15:42.130 --> 00:15:49.420
平台，结合了不错的PDP网络功能和经过身份验证的功能

00:15:49.420 --> 00:15:52.570
数据结构世界，并说让我们在...之上构建文件系统

00:15:52.570 --> 00:15:57.250
并将其公开到网络上，因此现在可以查看文件并小睡，

00:15:57.250 --> 00:16:01.860
网络应用程序等直接通过浏览器作为主要观察点，

00:16:01.860 --> 00:16:07.180
您可以访问此经过身份验证的数据中的所有内容

00:16:07.180 --> 00:16:11.140
在哪里可以得到的结构模型都无关紧要

00:16:11.140 --> 00:16:14.020
从本地计算机上的节点获取它，您可能会从

00:16:14.020 --> 00:16:17.950
节点在其他地方或其他任何地方，它们都是相同的内容，您可以执行它

00:16:17.950 --> 00:16:23.020
同样的方式，我们稍后可以使用此类内容进行演示，我们可以

00:16:23.020 --> 00:16:29.080
告诉你，所以我只想简单谈谈三个应用程序，给你一个

00:16:29.080 --> 00:16:37.390
对CRT T的位置的感觉，我想这是一个预告片，所以如果我们愿意

00:16:37.390 --> 00:16:42.850
应用程序在此环境中工作，然后它们可以完全拆分，然后

00:16:42.850 --> 00:16:47.800
我们想要诸如聊天或协作文档之类的东西

00:16:47.800 --> 00:16:51.130
一种东西，那么我们需要一个不依赖于集中式数据库的模型

00:16:51.130 --> 00:16:56.410
在云中的某个地方，我们需要一个允许融合数据结构的模型

00:16:56.410 --> 00:17:02.800
当然现在要建立建立状态这个应用程序的共享状态

00:17:02.800 --> 00:17:09.160
在我们的模型中，无论是否

00:17:09.160 --> 00:17:13.240
人们之间的联系非常紧密，您很难真正融入其中

00:17:13.240 --> 00:17:18.699
难解决的问题是，您可以允许从不同步日志内容吗？

00:17:18.699 --> 00:17:22.480
一旦他们成长，等等很多有趣的问题，他们也

00:17:22.480 --> 00:17:29.530
访问控制，我们将在今天晚些时候讨论，因此第一个应用程序

00:17:29.530 --> 00:17:35.350
我要提到的是Pierpan可以在今天晚些时候向他们展示，但是这个想法

00:17:35.350 --> 00:17:42.870
如果您有一个协作的实时编辑器，您可以进行很多慈善工作

00:17:42.870 --> 00:17:47.800
工作可以做到这一点，但最酷的是，这完全可以解决

00:17:47.800 --> 00:17:55.030
/ ipfs和lippy dopey，这是我在浏览器上的完整注释，因此

00:17:55.030 --> 00:18:00.430
这里发生的是第一个请求正在命中IP FS

00:18:00.430 --> 00:18:05.980
本地主机或网关中的节点，然后下载

00:18:05.980 --> 00:18:09.970
有效负载，它是应用程序，然后该应用程序运行并在ipfs节点上运行

00:18:09.970 --> 00:18:16.090
选项卡中的，然后使用p2p连接到另一个选项卡，然后开始

00:18:16.090 --> 00:18:21.160
交换CRTC日志，所以这是您知道的应用程序示例

00:18:21.160 --> 00:18:25.030
并不是真的可以在任何域中这样加载

00:18:25.030 --> 00:18:30.190
我们的本地ipfs节点，它的工作原理相同，因此它演示了用例和

00:18:30.190 --> 00:18:35.470
所以在这里我们已经在考虑您如何处理访问控制

00:18:35.470 --> 00:18:39.640
您要处理共享文档，所以现在它具有功能模型，这是

00:18:39.640 --> 00:18:44.170
完全加密，并且如果您共享URL，那么您正在共享和具有能力，并且

00:18:44.170 --> 00:18:48.850
您允许其他人写信，依此类推，但是有一堆

00:18:48.850 --> 00:18:53.970
想撤消访问权限时出现的有趣问题等

00:18:53.970 --> 00:19:02.650
是的，显示URL，还有另一个例子是ipfs cluster，现在

00:19:02.650 --> 00:19:05.680
这取决于共识，但这是一个有趣的问题

00:19:05.680 --> 00:19:11.800
这可能不是C或DT ipfs群集，而是将一个

00:19:11.800 --> 00:19:16.450
想要池化其存储以复制与您相同的ipfs节点的数量

00:19:16.450 --> 00:19:20.800
知道海量数据集，了解可靠性，等等，我们也正在

00:19:20.800 --> 00:19:25.600
能够处理超出一台计算机的处理能力，并且透明地使

00:19:25.600 --> 00:19:28.780
这些节点表现为单个ipfs节点，因此这是一种递归

00:19:28.780 --> 00:19:35.440
这四个节点还将公开相同的ipfs api的构造

00:19:35.440 --> 00:19:40.870
而且您仍然可以发出相同类型的请求，而他们得到的只是

00:19:40.870 --> 00:19:44.470
复制到其余节点，您就达成了传统共识

00:19:44.470 --> 00:19:48.460
在这里进行建模，您知道事情已经完全提交到日志中，然后

00:19:48.460 --> 00:19:52.870
将其外部化给用户，但是关于还是不存在一个有趣的问题

00:19:52.870 --> 00:19:58.390
这实际上可能不是CR dt，并没有真正的硬性要求

00:19:58.390 --> 00:20:01.720
需要达成共识，这里可能会有一个模型

00:20:01.720 --> 00:20:06.670
确定性可能更合适，这就像只是跟踪图钉

00:20:06.670 --> 00:20:11.200
SAT引脚设置它只是一个指向一棵大树的子图的标识符

00:20:11.200 --> 00:20:18.340
我们想要备份，是的，这表明递归

00:20:18.340 --> 00:20:22.060
在集群的构建过程中，位于IP FS旁边的工具知道了这一点，并且

00:20:22.060 --> 00:20:27.850
可以指向一个API，然后与Ducks的其他节点一起使用

00:20:27.850 --> 00:20:35.260
世界，我想最后一个例子是聊天，所以我认为最后一个

00:20:35.260 --> 00:20:39.730
例如，您知道拥有一个聊天应用程序会很棒，

00:20:39.730 --> 00:20:44.440
只是在一个完全分布式的环境中工作，我们在这个房间里可以

00:20:44.440 --> 00:20:47.950
继续谈论我们是否可以连接到世界其他地方，以及

00:20:47.950 --> 00:20:52.570
我们可以让您知道频道，等等，等等。

00:20:52.570 --> 00:20:56.170
当您在与一个频道相同的频道中讲话时出现的问题

00:20:56.170 --> 00:20:59.500
世界上有很多人，而您又分为一个小组，然后您

00:20:59.500 --> 00:21:02.740
合并来自世界其他地方的一大堆其他变化，

00:21:02.740 --> 00:21:05.530
您如何将其显示给用户，从而带来许多有趣的挑战

00:21:05.530 --> 00:21:09.220
但是甚至在我们到达那里之前，在诸如此类的事情上仍然存在艰巨的挑战

00:21:09.220 --> 00:21:12.760
诸如长寿之类的大团体中的撤销等

00:21:12.760 --> 00:21:18.820
大型团体可能为此而互不相让

00:21:18.820 --> 00:21:23.050
持续的时间里，还有很多其他类型的应用程序

00:21:23.050 --> 00:21:27.460
用ipfs很好地构建，可以给您一些味道，我们可以

00:21:27.460 --> 00:21:31.550
可能还有更多的话题，谢谢，对我来说就是这样

00:21:31.550 --> 00:21:37.990
[掌声]

