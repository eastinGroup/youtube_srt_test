WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:10.019
嗨，我叫丽塔（Rita），我也是阿里（Ali）的实验室研究员，我将讨论这个

00:00:10.019 --> 00:00:14.670
基于州的职责中存在的身份爆炸问题，这是一个

00:00:14.670 --> 00:00:20.130
与卡洛斯·巴基尔·萨德尔在新闻界的合作，另一位来自纳瓦

00:00:20.130 --> 00:00:27.570
两位审计师是从恋爱而来的，所以也许甚至没有金属激励我们

00:00:27.570 --> 00:00:34.739
实际进行复制，然后我将讨论这个问题

00:00:34.739 --> 00:00:41.309
安全方面的问题是身份爆炸，然后是我们实际上如何构建

00:00:41.309 --> 00:00:45.360
慈善事业，因此这对于现在正在听到有关了解我们的人的帮助

00:00:45.360 --> 00:00:50.730
第一次履行职责，然后我们使用这些技术来建立借贷

00:00:50.730 --> 00:00:59.219
试图解决该问题的计数器，所以您会复制，因为它

00:00:59.219 --> 00:01:02.640
改善了我们系统的容错能力，我们仍然可以回复客户

00:01:02.640 --> 00:01:08.400
即使某些服务器出现故障，它也可以提高性能，因为我们

00:01:08.400 --> 00:01:13.200
可以将副本放置在靠近客户的地方，而我们只提供来自

00:01:13.200 --> 00:01:18.810
同时使用多台服务器，吞吐量提高了，但现在

00:01:18.810 --> 00:01:24.420
由于我们有多个相同数据的副本，因此我们需要选择哪种

00:01:24.420 --> 00:01:28.799
我们想要这些副本之间的一致性模型，我们拥有强大的

00:01:28.799 --> 00:01:32.460
一致性非常成功，我们决定在中心进行，但是一旦我们搬家

00:01:32.460 --> 00:01:37.500
到广域网，我们的客户将不得不等待很多时间，因此只有一个

00:01:37.500 --> 00:01:43.110
使用Google的想法使伦敦和孟买之间的往返时间接近

00:01:43.110 --> 00:01:48.869
到700毫秒，所以这意味着如果我们运行的是pax之类的东西，

00:01:48.869 --> 00:01:54.750
在伦敦的早期，我们需要联系孟买的副本，因为它是

00:01:54.750 --> 00:02:00.030
我们大多数人中最接近我们的一部分，而一致性的下限是

00:02:00.030 --> 00:02:04.829
一次往返，我们的客户将等待至少700毫秒以及所有其他时间

00:02:04.829 --> 00:02:10.080
否则我们会在堆栈中进行选择，替代方法是我们立即回复

00:02:10.080 --> 00:02:13.610
给我们的客户，我们最终会保持一致

00:02:13.610 --> 00:02:19.070
背离，我们可能会发生冲突，所以该工作如何想象我们有三个

00:02:19.070 --> 00:02:26.000
他们从头开始复制一个空集的副本B添加一个

00:02:26.000 --> 00:02:32.810
元素XI知道它发送了一些东西来查看看到的房屋X，现在同时

00:02:32.810 --> 00:02:38.720
您有一个X的加法和一个X的去除，所以这是这里

00:02:38.720 --> 00:02:46.450
我们称之为冲突的地方，在这里我们需要决定我们的国家将会发生什么

00:02:46.450 --> 00:02:53.660
以及可能的解决方案系列我们说集合中的X或集合中不存在X

00:02:53.660 --> 00:03:00.860
这些都与我们在C职责中遇到的冲突解决方案有关

00:03:00.860 --> 00:03:08.090
其他其他数据类型，例如寄存器，计数器，标志映射和两个主要数据类型

00:03:08.090 --> 00:03:14.020
变体操作基础数据库，在本次演讲中，我将重点介绍状态基础和

00:03:14.020 --> 00:03:22.040
我们将讨论计数器，所以让我们想象一下，我们有一个客户端和一个服务器

00:03:22.040 --> 00:03:28.700
服务器的计数器为0，客户端向服务端发出增量

00:03:28.700 --> 00:03:34.250
由于这是一条消息，因此服务器现在将其状态设为0并递增

00:03:34.250 --> 00:03:40.489
稍后在客户端上执行1，则另一个增量发送另一个消息，现在

00:03:40.489 --> 00:03:47.420
服务状态为2，所以问题是，如果M 1在这里丢失，我们可以

00:03:47.420 --> 00:03:54.080
看到国家的最终值将是1，因为当服务器

00:03:54.080 --> 00:04:00.799
接收到M 2，实际上它的值为0，所以我们得到1，如果M 2是

00:04:00.799 --> 00:04:10.670
复制后，我们将在此处得到3，这实际上很难解决，甚至

00:04:10.670 --> 00:04:17.060
卡桑德拉（Cassandra）他们有这些问题，或者是经过适当尝试的机制，他们只是

00:04:17.060 --> 00:04:25.729
将其标记为“ ok”（已解决），但我们不会对其进行修复，因此您会发现它是否丢失

00:04:25.729 --> 00:04:30.650
客户应该重试还是重试，在这种情况下

00:04:30.650 --> 00:04:35.090
它不知道柜台的最终价值是多少，所以任何股票都会

00:04:35.090 --> 00:04:40.010
尝试解决这个问题，第一步是实际上将状态保持在客户端上，这样

00:04:40.010 --> 00:04:45.980
客户端还具有从零开始的计数器状态，我们将其递增，

00:04:45.980 --> 00:04:50.090
现在，我们发送的消息不是与操作有关，而是与

00:04:50.090 --> 00:04:55.010
计数器，现在服务器将执行此操作，这将最大程度地执行

00:04:55.010 --> 00:05:01.190
它曾经有过，现在又做了什么，我们再做一次，现在您可以做同样的事情

00:05:01.190 --> 00:05:09.020
像以前一样提问，如果丢失了m1怎么办，那很好，因为当我们这样做时

00:05:09.020 --> 00:05:13.220
这个在这里我们到达零，我们将在零和两个之间取最大值

00:05:13.220 --> 00:05:21.080
你会得到两个，我们可以的，所以这个，我们甚至可以再次发送给他们

00:05:21.080 --> 00:05:27.530
这很好，最多只能有两个，我们总会得到两个，这样我才能生活下去，我们

00:05:27.530 --> 00:05:34.010
解决我们所有的问题，所以这里可能出现的问题是

00:05:34.010 --> 00:05:38.660
如果我们有两个这两个客户，而他们这样做，我们可以向

00:05:38.660 --> 00:05:43.820
两者中的最大值，因为我们将失去增量权利之一，而

00:05:43.820 --> 00:05:58.130
CRD T的作用是每个副本都有一个计数器，因此当客户端B没有

00:05:58.130 --> 00:06:03.230
增加它注释自己的地图条目（对于客户端a和现在）

00:06:03.230 --> 00:06:09.440
服务器只保留所有这些条目，而最大的技巧也可以做到这一点

00:06:09.440 --> 00:06:16.900
因此像客户一样，我仍然可以再次发送这些邮件，它将在此处进行最大

00:06:16.900 --> 00:06:23.390
我们很好，我们仍然像这些重试问题一样处理现在的问题

00:06:23.390 --> 00:06:27.800
是这无法扩展，因为我们必须在所有

00:06:27.800 --> 00:06:33.320
系统中的客户以及我们的观察如何，我们需要这样做

00:06:33.320 --> 00:06:40.849
即使其中一些节点存在，所以我们在这里要做的是

00:06:40.849 --> 00:06:45.439
是要区分始终在系统中的永久节点

00:06:45.439 --> 00:06:53.539
从知道它正在实时加入，这些瞬态节点将借用身份

00:06:53.539 --> 00:06:58.159
永久不增加计数器的数量，当他们决定离开时，我们

00:06:58.159 --> 00:07:02.089
有办法安全撤离这些节点并合并

00:07:02.089 --> 00:07:11.800
永久节点的增量还可以，所以我们已经看到了地图符号

00:07:11.800 --> 00:07:19.969
设置类似，所以我会用这些好吧，这是我的副本，这是什么

00:07:19.969 --> 00:07:25.789
标识符和成长中的国家/地区，因此在我们映射副本之前

00:07:25.789 --> 00:07:32.479
绝望中的自然数的标识符，我有一个副本

00:07:32.479 --> 00:07:37.819
标识符和自然数，我会这样表示，如果

00:07:37.819 --> 00:07:45.379
我有一个布尔值，所以我们从true到false，这意味着

00:07:45.379 --> 00:07:50.659
下划线到上划线，您可以将其视为活动到非活动状态，就像

00:07:50.659 --> 00:07:58.399
有效到无效的条目，我将讨论唯一的点

00:07:58.399 --> 00:08:05.990
标识符，现在我们将使用几何图形和

00:08:05.990 --> 00:08:11.839
记号音乐就是这个螺栓圈，所以这是相同的例子

00:08:11.839 --> 00:08:16.399
我们已经从另一个角度看到了增量

00:08:16.399 --> 00:08:22.849
现在他们合并更多的增量而不是合并，所以此图非常有用

00:08:22.849 --> 00:08:34.099
理解CRD中状态的演变就可以了，所以一个数据类型

00:08:34.099 --> 00:08:41.899
edwin集具有非常古老的设计，其中我们将元素映射到集并

00:08:41.899 --> 00:08:47.000
他们将其设置为标记有布尔值的点，该布尔值将说明该点是否为

00:08:47.000 --> 00:08:53.540
活动与否，所以我们有x，我们在这个三角形中创建了一个唯一的标识符

00:08:53.540 --> 00:08:56.600
目前处于活跃状态，如果我们要删除您，只需标记

00:08:56.600 --> 00:09:02.689
作为非活动状态，我们对另一个元素执行相同的操作，我们创建了一个新的

00:09:02.689 --> 00:09:09.470
标识符现在处于活动状态，现在处于非活动状态，所以这里的问题是

00:09:09.470 --> 00:09:13.730
即使我们删除了这两个元素，我们仍然记得

00:09:13.730 --> 00:09:21.559
他们永远，而没有这些汤姆石的另一种设计是将这些映射

00:09:21.559 --> 00:09:26.899
这些点的元素，我们将保留一些东西

00:09:26.899 --> 00:09:34.670
对的，我们将其称为因果上下文，所以现在当我们创建时，我们添加一个元素

00:09:34.670 --> 00:09:41.299
将其映射到唯一标识符，但是我们将其放在权限上，因此当我们

00:09:41.299 --> 00:09:48.829
想要删除，我们可以忘记它，这是因为看到种子

00:09:48.829 --> 00:09:54.559
右边，我们知道它在左边，被删除了，这是我最后学到的

00:09:54.559 --> 00:09:59.990
这周被称为诺诺连胜了一段时间，他在这里，如果你想要的话

00:09:59.990 --> 00:10:07.220
问他这是如何工作的或更详细的信息，所以现在您只需添加

00:10:07.220 --> 00:10:13.850
相同的Y元素，我们将其删除，您会看到这很好，因此我们添加了

00:10:13.850 --> 00:10:19.069
在我们州发生的事情，我们不再关心它们，我们只是

00:10:19.069 --> 00:10:23.839
放弃它，在实践中没有永久性影响

00:10:23.839 --> 00:10:28.819
这些点不是几何图形，您可能已经猜到它们实际上是

00:10:28.819 --> 00:10:34.790
一对副本标识符和序列号，以及是否有因果关系

00:10:34.790 --> 00:10:40.999
传播这种因果关系可以是我将使用CC知道的原因

00:10:40.999 --> 00:10:46.519
编码为向量，如果没有，则仍然有可能

00:10:46.519 --> 00:10:51.259
你可以做的大学，但我会保留幼稚的记号，所以我会保留

00:10:51.259 --> 00:10:57.769
抱歉，我将继续这样做，以便另一个数据类型多值寄存器

00:10:57.769 --> 00:11:03.529
所以您现在看到我们有点映射到寄存器的值，并且我们有

00:11:03.529 --> 00:11:07.369
这个因果关系总是有这个因果关系，因为它

00:11:07.369 --> 00:11:12.220
让我们能够忘记事情的地方

00:11:12.220 --> 00:11:18.140
复制写里斯本，它创建一个点，这也是在因果关系中

00:11:18.140 --> 00:11:24.140
因此，当复制在寄存器中写入其他内容时，您会发现它只是忘记了

00:11:24.140 --> 00:11:30.770
关于里斯本，现在有一个新的点阵地图到ello，同时您已经

00:11:30.770 --> 00:11:35.930
书写世界，这就是您在多值寄存器中获得的东西

00:11:35.930 --> 00:11:40.970
出现在寄存器中的并发权利时，您将保留这些权利

00:11:40.970 --> 00:11:49.220
两者都有问题，因为这些不是用户期望的，所以

00:11:49.220 --> 00:11:52.850
他们写东西，当他们阅读时，他们期望读一个值

00:11:52.850 --> 00:11:57.650
不喜欢多个值，这实际上与谈话无关，但是

00:11:57.650 --> 00:12:05.960
我会继续前进，因为我知道您使用左作家赢的解决方案

00:12:05.960 --> 00:12:11.420
现在，当您撰写本文时，您以用户身份提供了一个时间戳，因此您说我

00:12:11.420 --> 00:12:18.770
在11:02写里斯本，我在11:04写lo，目前可以使用

00:12:18.770 --> 00:12:25.220
11:30您知道出现在紧急情况中，因为此时间戳大于您

00:12:25.220 --> 00:12:30.380
你的意思是世界上胜这里的问题是，我们刚刚失去的权利之一。

00:12:30.380 --> 00:12:38.060
所以现在不满意-假设任何单个时间戳都很好-嗯，任何系统

00:12:38.060 --> 00:12:42.860
因为就像用相同的时间戳记写hello和world一样

00:12:42.860 --> 00:12:48.860
我们应该在这里做什么，问题还在于，由于时钟可能不是

00:12:48.860 --> 00:12:53.210
同步，我无法尝试在寄存器中写一些东西，比如

00:12:53.210 --> 00:13:01.030
11 17但这不能，因为如果您愿意的话，将来就不会写任何世界

00:13:01.030 --> 00:13:05.290
我就让你读一下

00:13:10.600 --> 00:13:20.960
所以现在我们知道足够多的东西来制造这种洞穴癌症，再次的想法是

00:13:20.960 --> 00:13:28.880
传输节点会向永久性票据询问一些问题，因此

00:13:28.880 --> 00:13:33.200
点的形式，运输节点将使用这些点增加计数器

00:13:33.200 --> 00:13:40.250
点，您可能已经想象到姐姐正在使用这些点，

00:13:40.250 --> 00:13:44.510
在因果关系中，我们可以做到这一点，从而使我们能够忘记这些

00:13:44.510 --> 00:13:51.410
运输知道我们的存在，那么从小小的步骤开始构建它，然后

00:13:51.410 --> 00:13:56.120
最后，我们将获得最终设计，因此最初将有一个点映射到

00:13:56.120 --> 00:14:02.800
计数器的值和因果关系，现在我们有了一个很好的起点

00:14:02.800 --> 00:14:07.790
计数器为零，只是增加就可以了，所以这个滑动

00:14:07.790 --> 00:14:13.300
表示这是我们为此要保留柜台价值的地方

00:14:13.300 --> 00:14:21.140
但是现在我们还需要跟踪谁拥有哪个点，所以它的副本应该说

00:14:21.140 --> 00:14:25.580
这就是我拥有的，这是我可以用来增加计数器的原因

00:14:25.580 --> 00:14:29.990
在我们只有一张从点到自然的地图之前，现在我们要进行地图

00:14:29.990 --> 00:14:35.240
此地图的标识符，因此这意味着，如果某些副本复制了要保存的条目

00:14:35.240 --> 00:14:42.110
两年中有一些点，在这个例子中，我们要注意的是

00:14:42.110 --> 00:14:50.030
永久节点，而3t是暂时的，所以我们要创建一个点，这样我们就可以

00:14:50.030 --> 00:14:57.110
增加aa是永久的，它会在以后为您自己创建一个点

00:14:57.110 --> 00:15:03.530
tt-加入系统的人会问好，我想增加一个计数器给我一个

00:15:03.530 --> 00:15:13.670
点，所以我们可以在这里看到这是T的点，它是beta，所以现在如果T想

00:15:13.670 --> 00:15:18.320
将我们的值增加17您只需增加该位置并

00:15:18.320 --> 00:15:21.680
现在你有一个问题，那就是T想生活，但是我们

00:15:21.680 --> 00:15:28.670
没有办法在美国正确地说出来，所以想法是我们要

00:15:28.670 --> 00:15:34.790
茶保证不会增加计数器，我们将

00:15:34.790 --> 00:15:43.700
用它来安全地从该地图中删除茶中的茶，因此

00:15:43.700 --> 00:15:49.339
运输票据应将点标记为非活动状态，因此发生了什么变化

00:15:49.339 --> 00:15:53.779
这是现在我们在这里有这个布尔值，将说出这些点是活动的

00:15:53.779 --> 00:15:59.600
还是不，这是酒吧国家的最终设计，所以相同的例子和现在

00:15:59.600 --> 00:16:08.450
您会看到该点处于活动状态，因此就像下划线活动mmm一样

00:16:08.450 --> 00:16:14.240
示例现在它增加，我们激活了这个点，现在退休，我们只是

00:16:14.240 --> 00:16:22.040
营销人员不活跃，现在当王牌时，它会知道茶要

00:16:22.040 --> 00:16:26.390
离开系统并没有使所有这些点都处于非活动状态，所以我可以

00:16:26.390 --> 00:16:34.820
将所有这些增量转移给我，好极了，这样您就可以看到

00:16:34.820 --> 00:16:41.089
执行，我们不得不吃掉他加入了系统，它做了它想要的，我没有

00:16:41.089 --> 00:16:46.839
想要做任何事情我就走了，在美国没有任何影响

00:16:47.560 --> 00:16:54.650
好的，这就是我们涵盖的内容，我们为计数器设计了一个仍然可以使用的设计

00:16:54.650 --> 00:17:00.250
通过这些不可靠的网络进行思考和归档，我们可能需要重试

00:17:00.250 --> 00:17:04.970
我们只关注增量计数器，但是如果您想

00:17:04.970 --> 00:17:12.500
减少它是一件微不足道的练习，要加上我们没有涵盖的内容，所以这是

00:17:12.500 --> 00:17:22.040
就像平板上的一些作品一样，我没有复制任何幻灯片，所以好吧，还有其他CIT

00:17:22.040 --> 00:17:28.130
三角洲州立变种本文展示了一些我们在发现时遇到的问题

00:17:28.130 --> 00:17:34.370
实施纯运营基础，这样的组成是当我们有几个

00:17:34.370 --> 00:17:37.789
看到我们的职责，我们希望将它们放入内部

00:17:37.789 --> 00:17:46.010
其他人喜欢将Cantor的内部地图放进去，这是两篇表明可能

00:17:46.010 --> 00:17:51.919
问题和潜在的解决方案，但我没有找到这个名字

00:17:51.919 --> 00:17:58.520
但是这些可扩展的最终一致性计数器是尝试的工作

00:17:58.520 --> 00:18:09.200
为了解决这个确切的问题，我描述了数据库使用da作为一种方法

00:18:09.200 --> 00:18:15.110
在不使用默特尔树的情况下同步两个副本，因此您可能会对

00:18:15.110 --> 00:18:20.210
看着那，最后一个是当你有一个分区，你想要

00:18:20.210 --> 00:18:26.419
如果可以的话，可以有效地同步到州立慈善机构，这就是

00:18:26.419 --> 00:18:28.570
它

00:18:28.680 --> 00:18:38.640
[鼓掌]所以最后一个例子让我想起了

00:18:38.640 --> 00:18:44.650
返回后，获取租约以能够写至特定国家/地区

00:18:44.650 --> 00:18:51.760
租约，那么您可以离开的是该租约与特定租约的绑定

00:18:51.760 --> 00:18:55.030
永久节点，因为该永久注释将要执行

00:18:55.030 --> 00:18:59.200
完全是这样合并，因此不仅所有永久性注释都可以

00:18:59.200 --> 00:19:03.730
合并，就好比我为您创建的那样，您可以合并我的

00:19:03.730 --> 00:19:08.290
增量，因此，如果您要虚拟化这些节点，则必须

00:19:08.290 --> 00:19:12.700
有某种过渡方式，由谁来进行合并，如果您

00:19:12.700 --> 00:19:17.410
您想进一步说我们不知道所有这些永久性说明

00:19:17.410 --> 00:19:21.280
他们会留下来很长一段时间，但我们可以创建一个虚拟的领导者，是的，

00:19:21.280 --> 00:19:26.260
然后您获得该虚拟休假的合并保留功能，是的

00:19:26.260 --> 00:19:30.370
这意味着您的电汇在写书时具有租赁权，而您拥有合并能力的人

00:19:30.370 --> 00:19:35.410
可以合并是的，这是一种有趣的查找方式，因此

00:19:35.410 --> 00:19:40.270
只是工作进展，所以只提出了我所遇到的问题之一

00:19:40.270 --> 00:19:44.890
认为目前州政府中存在您的州将生活

00:19:44.890 --> 00:19:49.540
将被在此状态下执行过任何操作的所有副本污染，因此

00:19:49.540 --> 00:19:54.490
这可能是开始研究此问题并尝试做一些事情的一种方法

00:19:54.490 --> 00:19:59.530
系统没有永久的永久影响，我认为这是自然的结果

00:19:59.530 --> 00:20:05.350
聚合树，这样您就可以将它们长链地组成，并且随着时间的流逝

00:20:05.350 --> 00:20:11.080
合并操作，所以这些工作在这里我想他们有这种方法

00:20:11.080 --> 00:20:17.740
您可以在其中建议节点之间的错误密钥，并且可以在

00:20:17.740 --> 00:20:21.640
你提议的方式是的，谢谢

00:20:21.640 --> 00:20:25.169
[掌声]

