WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.920 --> 00:00:07.589
嗨，我是埃里克（Eric），我要讲的非常快，所以我有一个想要

00:00:07.589 --> 00:00:11.580
构建，这就是为什么我讨厌构建软件的原因，但我想使用该软件，但是

00:00:11.580 --> 00:00:14.730
有时这意味着我必须编译软件有时，该软件不是

00:00:14.730 --> 00:00:18.690
完成它并不能完全满足我的需要，所以我实际上是说我需要打补丁并

00:00:18.690 --> 00:00:22.260
然后编译，然后构建，然后也许使用软件，在我完成之后

00:00:22.260 --> 00:00:25.730
所有这些工作，也许我需要共享该软件，以便其他人可以做到，我做到了

00:00:25.730 --> 00:00:32.460
这进入了有时被称为包管理的领域

00:00:32.460 --> 00:00:35.399
进行包裹管理的许多不同方法，这大概是第四种

00:00:35.399 --> 00:00:40.530
关于营地管理的营地闪电演讲，所以这旨在

00:00:40.530 --> 00:00:44.789
成为最外太空的人对这个话题最深刻的反思

00:00:44.789 --> 00:00:47.879
您今天会听到，并尝试通过以下方式到达其他地方

00:00:47.879 --> 00:00:53.660
只是去了最元论坛而不是具体的论坛

00:00:53.660 --> 00:00:59.340
所以尽管我用了一些最初的词来构建，但棘手的并不是

00:00:59.340 --> 00:01:03.780
建筑我们有建筑工具我们有许多建筑工具我们还有更多建筑

00:01:03.780 --> 00:01:06.900
工具，我可能会列出我什至没有尝试过我们已经建立了以下工具

00:01:06.900 --> 00:01:13.490
几十年来，各种各样的建筑不是问题集成的棘手问题是什么

00:01:13.490 --> 00:01:16.860
棘手的是弄清楚如何连接不同的构建过程

00:01:16.860 --> 00:01:22.580
一起，棘手的是找出如何组成整个系统

00:01:22.610 --> 00:01:27.720
所以在弄清楚如何整合事物时，我认为有时最好

00:01:27.720 --> 00:01:35.340
弄清楚如何首先解决这个问题，那么我会建立什么

00:01:35.340 --> 00:01:38.400
说这些，顺便说一句，这些只是意见，但我们将探索更多意见

00:01:38.400 --> 00:01:44.909
以后的构建中包含一堆文件，我们很方便地输入了一个文件

00:01:44.909 --> 00:01:50.040
称为ipfs的系统，它实际上非常擅长识别文件，最终有些

00:01:50.040 --> 00:01:54.060
文件出来，中间发生某种动作

00:01:54.060 --> 00:02:00.689
无论是什么，我想丢掉的一个主意也许就是我们

00:02:00.689 --> 00:02:04.049
可以建立更好的构建方式和更好的集成方式，如果

00:02:04.049 --> 00:02:08.119
我们使用IP LD做了这样的事情，我们的星际链接数据格式

00:02:08.119 --> 00:02:14.370
因为这意味着我们可以对...进行哈希处理

00:02:14.370 --> 00:02:18.269
这整个构建指令，我们可以从内容寻址开始

00:02:18.269 --> 00:02:24.000
通过内容哈希对文件进行寻址以进行计算可寻址，这可能是

00:02:24.000 --> 00:02:27.930
主键变成了一种完全不同的计算方式

00:02:27.930 --> 00:02:31.920
可以将其用于很多事情，这对于制作非常有用的构建块

00:02:31.920 --> 00:02:35.099
更大，更有趣的系统，您可以共享完整的构建说明

00:02:35.099 --> 00:02:38.790
您可以稍后重建内容，也可以共享这些内容以进行错误报告，以便

00:02:38.790 --> 00:02:42.180
上下文无关是一件非常有用的事情，并且对bug有全面的好处

00:02:42.180 --> 00:02:48.510
报告有利于审计日志的优点，是否有利于此操作？

00:02:48.510 --> 00:02:55.290
向后在过程结束时具有输出哈希值哦，如果可以，

00:02:55.290 --> 00:03:00.150
您拥有来自构建的文件系统的哈希值，这确实是

00:03:00.150 --> 00:03:03.450
对于检查可重复性很有用，而不是假设过程是

00:03:03.450 --> 00:03:09.060
确定性和可复制性，因此这是理智的一般强制功能

00:03:09.060 --> 00:03:13.829
这可以帮助我们建立健全的系统，但这只是打破了概念

00:03:13.829 --> 00:03:17.579
的构建，现在让我们尝试再次集成，让我们尝试构建更大的系统

00:03:17.579 --> 00:03:22.379
有了它，解决我们已经建立的构建非常有用

00:03:22.379 --> 00:03:27.239
起草一次，但这并不能解决很多问题，只是开始

00:03:27.239 --> 00:03:32.310
没有人喜欢复制和粘贴散列，以及为了构建更大的系统

00:03:32.310 --> 00:03:35.609
其中包含构建的多个部分或不同的构建工具

00:03:35.609 --> 00:03:40.260
不同的编译器，无论我们需要哪种方法来描述多个步骤

00:03:40.260 --> 00:03:43.949
事先建立并描述他们的关系，这仅仅是

00:03:43.949 --> 00:03:48.989
对于任何一种生产力而言都是必不可少的，因此请描述多个步骤并进行关联

00:03:48.989 --> 00:03:53.159
他们是高级手段，我们不能使用哈希，我们还没有要哈希的东西

00:03:53.159 --> 00:03:59.639
所以我们有一个命名问题hooray分布式命名问题很难

00:03:59.639 --> 00:04:03.720
认为房间里的每个人都知道与之搏斗的每个人都有

00:04:03.720 --> 00:04:09.120
知道了，所以我们尝试了一点整合，然后我们遇到了一个命名问题，所以

00:04:09.120 --> 00:04:12.629
让我们尝试再次解决它，也许如果我们解决问题

00:04:12.629 --> 00:04:18.449
足够，它将变得更加容易，现在这将非常容易，我几乎没有

00:04:18.449 --> 00:04:20.840
在这里谈论包装管理一会儿

00:04:20.840 --> 00:04:24.350
有很多不同种类的命名，有时我使用

00:04:24.350 --> 00:04:29.960
有时我会想在标签中命名节点，以便我可以

00:04:29.960 --> 00:04:32.380
识别即使在拓扑上相同的不同节点

00:04:32.380 --> 00:04:36.320
有时当我说命名时，我的意思是我要寻找最新的更新

00:04:36.320 --> 00:04:40.490
某些名称的东西有时我想使用带有某种前缀的命名

00:04:40.490 --> 00:04:43.370
只是为了进行分组和分类而设计的模式

00:04:43.370 --> 00:04:47.690
用它来赢得声誉所有这些都是截然不同的用户故事，也许是通过

00:04:47.690 --> 00:04:53.120
将它们分解得很好，我们可能会发现它们更容易

00:04:53.120 --> 00:04:56.900
仅命名标签的示例仍然可以做为一成不变的事情

00:04:56.900 --> 00:05:01.310
如果要在标签中标记内容，则在某些情况下使用不可变名称引用

00:05:01.310 --> 00:05:06.530
图，您只需要在图的上下文中具有唯一的名称，因此

00:05:06.530 --> 00:05:11.000
这些问题比其他问题容易解决

00:05:11.000 --> 00:05:14.450
也很有趣，因为它们纠缠了应用程序逻辑，例如

00:05:14.450 --> 00:05:17.840
事实证明，更新软件包管理器对如何获得软件包有不同的意见

00:05:17.840 --> 00:05:23.960
最新的事情，所以我认为这是分布式系统的一般课程

00:05:23.960 --> 00:05:27.410
随时进行设计，您可以将分布式命名问题转化为

00:05:27.410 --> 00:05:32.240
本地范围内的命名问题，这样做会容易得多，然后再回过头来尝试

00:05:32.240 --> 00:05:37.310
使它变得可组合，例如，我可能会进行一些本地范围的命名

00:05:37.310 --> 00:05:41.810
系统将一堆东西作为构建图连接起来，这很容易

00:05:41.810 --> 00:05:48.229
只是使用一些本地唯一的名称，而是再次集成到更大的系统中

00:05:48.229 --> 00:05:52.190
问题变成了与其他人的协作，现在不是这样

00:05:52.190 --> 00:05:58.580
很简单，但是我们拥有一堆完整的常量可寻址的东西，我们有这个

00:05:58.580 --> 00:06:01.940
整个协议称为IP LD，旨在帮助我们进行其他

00:06:01.940 --> 00:06:08.210
内容可寻址的消息很容易，所以如果我们采用这种概念

00:06:08.210 --> 00:06:13.430
图的局部受限大小中的局部范围名称和

00:06:13.430 --> 00:06:18.320
谁一直在慢慢扩大对本地范围的定义，我们

00:06:18.320 --> 00:06:22.669
本身在不同范围之间的消息传递系统

00:06:22.669 --> 00:06:26.300
所有内容可寻址的消息，因此我们可以继续构建越来越大的内容

00:06:26.300 --> 00:06:33.140
默克尔树在一定范围内都是不变的，但在功能上给了我们

00:06:33.140 --> 00:06:38.270
我们希望我几乎可以在可读命名中组合

00:06:38.270 --> 00:06:42.830
时间已不多了，但您可以稍后与我联系，或者找到更多文档和

00:06:42.830 --> 00:06:46.879
这些链接上的系统原型是一些用于构建的工具

00:06:46.879 --> 00:06:51.380
语言不可知的构建集成系统

00:06:51.380 --> 00:06:54.420
[音乐]

