WEBVTT
Kind: captions
Language: zh-Hans

00:00:01.329 --> 00:00:06.880
我将通过je和J si与您谈谈间隔中的流

00:00:06.880 --> 00:00:10.840
我将解释一些有关这些来源的类型

00:00:10.840 --> 00:00:17.820
转换接收器和双工是，仅此而已，所以一切都始于

00:00:17.820 --> 00:00:23.499
迭代器和JavaScript中的许多内容目前都可以迭代

00:00:23.499 --> 00:00:29.919
例如设置地图和数组，因此通常您会喜欢一些东西

00:00:29.919 --> 00:00:40.179
数据，如果您想从数据中获取迭代，则只需调用

00:00:40.179 --> 00:00:50.679
该函数的功能，以便您对其进行处理，这将使您返回一个迭代器，并且

00:00:50.679 --> 00:00:55.629
然后，您可以调用下一个，然后调用它直到完成

00:00:55.629 --> 00:00:59.559
然后我得到了值，然后返回了一个对象，该对象告诉我是否已完成或

00:00:59.559 --> 00:01:03.070
不是，但这是从数组中获取值，然后我可以继续调用

00:01:03.070 --> 00:01:07.360
直到完成为止，这也很酷，因为我可以

00:01:07.360 --> 00:01:17.830
在for循环中使用它，然后for循环将要做的是

00:01:17.830 --> 00:01:21.910
拆开它返回的那个对象，并给我值，所以我不，我不明白

00:01:21.910 --> 00:01:26.500
那个价值完成的事情，我只是得到了价值，它就自动完成了

00:01:26.500 --> 00:01:30.700
循环完成所有操作后，我得到了很棒的值，所以

00:01:30.700 --> 00:01:35.650
迭代器或可迭代对象，然后发生的事情是异步

00:01:35.650 --> 00:01:41.530
出现了Ettore迭代器，而不是接下来返回一个对象

00:01:41.530 --> 00:01:48.510
刚完成，它的值返回该对象的承诺，所以现在

00:01:48.510 --> 00:01:52.900
我们获取数据相对的东西可以异步给我们

00:01:52.900 --> 00:01:58.470
事物，还有什么我们知道异步产生事物和流

00:01:58.470 --> 00:02:05.080
所以我们现在可以做的是可以使用语言本地的东西来流数据

00:02:05.080 --> 00:02:09.850
在浏览器中没有任何库，这非常有趣，而且我真的很容易

00:02:09.850 --> 00:02:14.920
所以这是我称之为无限迭代的无限迭代

00:02:14.920 --> 00:02:23.380
因为它永远产生一个随机数，所以这很酷，

00:02:23.380 --> 00:02:27.849
您对异步可迭代对象所做的一切就是可以使用a等待

00:02:27.849 --> 00:02:33.280
循环，然后我就可以获取每个值，所以这是我们要使用的迭代器

00:02:33.280 --> 00:02:37.480
说每个都会给我无限随机的所有价值，它只会

00:02:37.480 --> 00:02:41.800
不断地拥抱和拥抱，并给我随机的值，所以让我们

00:02:41.800 --> 00:02:45.569
看看我可以把它放到这里，它会有点

00:02:45.569 --> 00:02:51.340
偶尔会喷出一些随机的随机值，这很酷

00:02:51.340 --> 00:02:57.610
之所以容易，是因为流式传输现在就像是一个for循环，就好像您不一样

00:02:57.610 --> 00:03:01.420
不再需要考虑像nodejs流和像附加数据事件

00:03:01.420 --> 00:03:05.470
并触摸结束事件并将它们传递到类似的地方和东西，就是这样

00:03:05.470 --> 00:03:08.680
这只是一个for循环，这是当您

00:03:08.680 --> 00:03:15.459
程序员，很好，这很好，但是请稍等，我们不仅仅是

00:03:15.459 --> 00:03:20.650
我们不仅从流中读取信息，还向它们写入数据，我们也有流

00:03:20.650 --> 00:03:24.579
可以获取一些数据并将其转换并吐出一些数据，然后

00:03:24.579 --> 00:03:29.380
网络的东西，我们有双工流，所以我们可以有没有真正连接

00:03:29.380 --> 00:03:33.880
数据传输到服务器，反之亦然，因此我们需要整个流系列

00:03:33.880 --> 00:03:39.010
到目前为止，我一直在谈论消息来源，这只是一个

00:03:39.010 --> 00:03:44.200
异步可迭代，这就是我们所说的源，同步只是一个

00:03:44.200 --> 00:03:50.590
功能，所以在这里，我们就像一个记录器同步，它的功能只是一个

00:03:50.590 --> 00:03:54.160
函数，它需要一个源，然后通常用它来做点什么

00:03:54.160 --> 00:03:57.609
消耗它，因为否则它会有点无用，然后可以选择

00:03:57.609 --> 00:04:02.739
返回的东西，所以这是这个记录器同步需要源对其进行迭代

00:04:02.739 --> 00:04:06.609
并注销每个值，就像我们第二次使用

00:04:06.609 --> 00:04:14.049
随机随机事物，但我们已经将其形式化为一种变换

00:04:14.049 --> 00:04:19.930
是一种同步和来源，因为它需要它，所以这是我们的转换

00:04:19.930 --> 00:04:25.930
在这里加倍的东西，它需要一个源并返回，所以我不会

00:04:25.930 --> 00:04:28.900
进入发电机，但是当您打电话时是发电机

00:04:28.900 --> 00:04:33.370
他们将返回您一个，并且在此中，因为异步生成了它或返回了

00:04:33.370 --> 00:04:38.020
您一个异步迭代的对象，而我们所做的只是暂停执行

00:04:38.020 --> 00:04:45.070
的功能，直到无论如何都重要的一点是，它需要一个源，并且它

00:04:45.070 --> 00:04:48.990
返回异步可迭代，因此它只是一个返回异步可迭代的函数

00:04:48.990 --> 00:04:52.720
所以这很酷，这是一个转换，然后我们有一个双工

00:04:52.720 --> 00:04:57.550
有点奇怪，因为它实际上是一个具有源的对象

00:04:57.550 --> 00:05:02.680
和一个水槽，有点像一个转换，就像您可以为转换建模一样

00:05:02.680 --> 00:05:08.860
作为一个双工，这两件事以某种方式连接在一起，真是太有趣了

00:05:08.860 --> 00:05:12.790
然后您通常会做什么，因为我没有向您展示这些东西

00:05:12.790 --> 00:05:18.220
我的意思是说，我们可以在这里做些什么，就可以接受这些，这就是转换

00:05:18.220 --> 00:05:25.180
这会使我的随机性加倍，所以如果我将其粘贴而不是像

00:05:25.180 --> 00:05:32.620
零点值，我将获得双倍的随机数，所以在那里很有趣

00:05:32.620 --> 00:05:36.910
我们走了，然后常常你会想要一些实用程序和东西

00:05:36.910 --> 00:05:42.100
使用异步迭代器，因为这可能是您最有用的事情之一

00:05:42.100 --> 00:05:46.870
想要的是管道，因为您有时会拥有以下这些管道

00:05:46.870 --> 00:05:50.890
您想要保持分离的流，作为不同的不同类型的流

00:05:50.890 --> 00:05:56.080
离散的功能，但您不想像东西一样喜欢

00:05:56.080 --> 00:06:01.810
像这样，我们已经有了，我们已经有了这个，源正在传递到

00:06:01.810 --> 00:06:05.680
他们被传送到记录器的倍增器，就像你只有这么大

00:06:05.680 --> 00:06:09.130
就像功能酷链一样，实际上更容易看到它

00:06:09.130 --> 00:06:14.740
像这样的东西，所以我们可以使用一个叫做管道的东西

00:06:14.740 --> 00:06:19.660
然后是其他实用程序，例如我们创建的正义模块

00:06:19.660 --> 00:06:25.210
像上次那样可迭代时真的很有用

00:06:25.210 --> 00:06:30.670
现在是它返回一个异步迭代，实际上当您添加内容时

00:06:30.670 --> 00:06:35.560
ipfs，如果要添加很多文件，则无法

00:06:35.560 --> 00:06:40.920
iturra迭代器，因此您可能希望使用它的目标具有get tar的返回值

00:06:40.920 --> 00:06:47.730
和tard更新程序，您必须用Claude有用的方式对其进行打包或打包

00:06:47.730 --> 00:06:52.710
当您要从文件系统中添加类似文件时，可能需要

00:06:52.710 --> 00:06:56.730
到全局规则文件，它只会带给您一些东西，而且经常给我们做

00:06:56.730 --> 00:07:02.190
ipfs是带有变体的前缀，因此您可能需要一些实用程序，例如

00:07:02.190 --> 00:07:04.860
所以我们在过程中做了这些负载

00:07:04.860 --> 00:07:10.170
异步/等待，然后我做了一个很棒的清单，因为它们都是

00:07:10.170 --> 00:07:14.070
真的很棒，因为有很多这样的东西

00:07:14.070 --> 00:07:18.720
实用程序将不复存在，因为实际上是异步迭代器

00:07:18.720 --> 00:07:25.920
我喜欢他们要得到的东西，有一个建议让他们得到很多

00:07:25.920 --> 00:07:30.840
的实用程序，所以您将能够做到，就像有一个名为它的实用程序

00:07:30.840 --> 00:07:35.520
全部以可迭代的方式收集所有项目，例如将它们缓冲起来，但是

00:07:35.520 --> 00:07:40.830
我认为可迭代对象将具有两个数组函数，您可以等待

00:07:40.830 --> 00:07:45.240
然后，这将为您做，然后您将不需要

00:07:45.240 --> 00:07:48.650
需要的模块，您不需要一半，所以其中一些是临时的，但

00:07:48.650 --> 00:07:53.730
是的，所以像我向他们解释的那样，流式可迭代对象的确是

00:07:53.730 --> 00:07:57.810
希望在不到五分钟的时间内迅速完成，

00:07:57.810 --> 00:08:04.970
以及在JSI bfsd asleep p2p和III LD中进行流式传输，这就是我所拥有的全部

00:08:04.970 --> 00:08:08.519
[掌声]

