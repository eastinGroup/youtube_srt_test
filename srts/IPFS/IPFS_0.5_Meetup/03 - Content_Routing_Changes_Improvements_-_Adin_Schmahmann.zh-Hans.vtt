WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:05.970
好吧，我是丹麦的鲍曼（Bowman），我们会谈一些

00:00:05.970 --> 00:00:15.420
DHT的改进并获得了0.5的良好通过，所以总体而言，我们有四件事

00:00:15.420 --> 00:00:19.619
我要看看一种是汽车无法维修史蒂文的方式

00:00:19.619 --> 00:00:26.670
DHT默认使用的是简短提到的第二个是我们清理的方式

00:00:26.670 --> 00:00:31.109
我们的路由表，但第三是查找算法，您如何查找内容并

00:00:31.109 --> 00:00:35.660
如何进行了改进，最后进行了一些测试，

00:00:35.660 --> 00:00:43.350
我们如何确保在网络上一切正常，所以自动

00:00:43.350 --> 00:00:49.800
没有清理DHT，我们有这个Kadhim lea网络，这是

00:00:49.800 --> 00:00:54.930
我可以将其用于分布式哈希表的算法

00:00:54.930 --> 00:01:00.329
基本上只是问一些问题，例如您知道数据X或

00:01:00.329 --> 00:01:08.640
您知道有人拥有它，但是当您不能问一些问题时会发生什么

00:01:08.640 --> 00:01:12.270
被告知作为回应而被告知您的人您知道您被告知

00:01:12.270 --> 00:01:18.330
大约有十个同伴，您可以与他们交谈，但是其中六个不可用。

00:01:18.330 --> 00:01:23.729
网络结构开始退化，以及类似的数学性质，

00:01:23.729 --> 00:01:29.180
允许某种对数查找时间开始崩溃

00:01:29.180 --> 00:01:36.659
所以计划是您问其他同龄人是否认为您的电话是可拨号的，而您

00:01:36.659 --> 00:01:41.840
收集这些信息，如果您知道之后又决定

00:01:41.840 --> 00:01:46.439
解释来自同级的所有结果都是不可拨号的，然后您停止

00:01:46.439 --> 00:01:51.390
告诉人们您是DHT路由层的一部分，您是服务器

00:01:51.390 --> 00:01:57.689
您可以回答查询，因为您不是，我们无法使用

00:01:57.689 --> 00:02:05.520
也有一种备份计划，您可以在那里防守

00:02:05.520 --> 00:02:10.890
在出现的连接中，看这看起来像一个吗

00:02:10.890 --> 00:02:16.019
纯粹是别人可以与他们交谈的地址，或者是可以公开访问的地址

00:02:16.019 --> 00:02:24.120
他们所有的IP地址看起来像localhost，或者您知道一种92168类型的

00:02:24.120 --> 00:02:31.170
可以解决所有问题，因此我们已经清理了很多路由表，但是现在

00:02:31.170 --> 00:02:33.720
我们已经摆脱了坏人，我们如何确保保留一些好人

00:02:33.720 --> 00:02:38.730
大家在那里之前，我们试图成为一个

00:02:38.730 --> 00:02:42.750
我们的路由表没有什么防御性，因为有很多不可侵犯的东西

00:02:42.750 --> 00:02:47.910
我们说过的节点，如果我们只尝试消除一些不可行的节点，

00:02:47.910 --> 00:02:56.010
让周围的人与之保持联系，那么我们可以保证，当我们听到

00:02:56.010 --> 00:02:59.790
关于某人的信息，因为他们不在

00:02:59.790 --> 00:03:05.879
与他人建立联系的中间，这很好，但是如果

00:03:05.879 --> 00:03:10.769
您的路由器出现故障，现在您将失去所有连接，

00:03:10.769 --> 00:03:15.299
开始就像您将不得不重新设置一样，您从头开始是DHT

00:03:15.299 --> 00:03:21.600
再次引导，这很不幸，如果您的机器只是

00:03:21.600 --> 00:03:26.489
超载，您知道一千个真正重要和有价值的地方

00:03:26.489 --> 00:03:32.730
连接或其他应用程序层的东西，所以您的DHT连接

00:03:32.730 --> 00:03:36.269
不断被杀死，因为它们对您的应用程序而言价值不大

00:03:36.269 --> 00:03:40.769
总体而言，您仍然知道这些同行在哪里，您仍然可以向他们提问

00:03:40.769 --> 00:03:43.290
事实证明您无法与他们保持联系，因为您不在

00:03:43.290 --> 00:03:50.910
资源并不意味着您应该忘记它们，所以现在我们只删除同伴

00:03:50.910 --> 00:03:56.040
从我们的路由表中，如果我们使他们失败了，我们要么问他们一个

00:03:56.040 --> 00:04:00.329
问题，他们失败了，或者已经有一段时间了，每次我们

00:04:00.329 --> 00:04:04.530
问他们一个问题，他们只是不给我们我们需要的答复，我们发现

00:04:04.530 --> 00:04:12.610
更好的人可能会及时做出回应，所以

00:04:12.610 --> 00:04:16.540
看你自己而不是你倾向于看的东西是罪魁祸首的罪魁祸首

00:04:16.540 --> 00:04:19.750
即使是其他两层，这种速度也会变慢还是变慢

00:04:19.750 --> 00:04:23.320
这是布线层，然后整个基板出现在下面

00:04:23.320 --> 00:04:27.600
那是有问题的，我们问谁

00:04:28.490 --> 00:04:32.910
因此，再次向学员Malia询问，您知道比X更近的人吗

00:04:32.910 --> 00:04:40.080
这就像是您之前一直问这些问题时一直在问的问题

00:04:40.080 --> 00:04:45.570
路由表中充满了对等节点，因为缺少自动网络集成并且

00:04:45.570 --> 00:04:50.070
我们是您的事实，因为您知道您知道，所以失去同龄人

00:04:50.070 --> 00:04:53.700
间歇性断开连接或断开连接会使操作花费很长时间

00:04:53.700 --> 00:05:00.270
时间既是因为拨号失败，也是因为查找算法

00:05:00.270 --> 00:05:06.060
需要弥补对数学的信心不足

00:05:06.060 --> 00:05:12.180
路由表的结构，结果我们不得不搜索更多

00:05:12.180 --> 00:05:16.050
网络，我们不能说哦，我们认为我们很接近，因为可能有

00:05:16.050 --> 00:05:23.880
是一些更接近，但现在，因为该结构看起来不

00:05:23.880 --> 00:05:29.940
看起来更干净，更稳定，我们可以早点放弃

00:05:29.940 --> 00:05:35.760
可以找到网络中最接近我们的那段数据的三个对等点

00:05:35.760 --> 00:05:38.940
寻找三个人中应该有的二十个人中的三个

00:05:38.940 --> 00:05:45.570
有我们要寻找的内容的副本，就足够了，因为我们应该知道

00:05:45.570 --> 00:05:50.670
不应有我们不知道的任何人，因为

00:05:50.670 --> 00:05:55.080
吉打玛利亚（Kedah Malia）的结构使得每个人都应该知道

00:05:55.080 --> 00:06:02.460
最接近它们的位置，我们现在可以放心了，所以测试让我们

00:06:02.460 --> 00:06:06.210
看看这东西是如何工作的，所以在我们进入这之前，另一个是

00:06:06.210 --> 00:06:13.800
测试是在正确的测试场地上进行的，这非常有帮助，但

00:06:13.800 --> 00:06:17.820
也是一个孤立的网络，不具备真正网络的所有相同条件

00:06:17.820 --> 00:06:22.560
我不会模拟您知道的真实网络的所有条件

00:06:22.560 --> 00:06:27.270
我们将所有延迟设置为大约100的几个重要事情

00:06:27.270 --> 00:06:33.630
毫秒的往返时间，我们也可以控制您知道的时间，

00:06:33.630 --> 00:06:36.570
我们可以控制网络说出鼻子看起来要拨多少碗

00:06:36.570 --> 00:06:41.610
或毋庸置疑，这就是它要花多长时间

00:06:41.610 --> 00:06:48.050
Aizen告诉某人您有一条数据，您可以看到

00:06:48.050 --> 00:06:57.330
差异是巨大的，一方面是如果整个

00:06:57.330 --> 00:07:05.310
网络是23的0，右侧是整个过程需要多长时间

00:07:05.310 --> 00:07:10.680
网络再次为0.5，这具有100毫秒的延迟z'和其他种类

00:07:10.680 --> 00:07:14.400
内置的假设，但差异确实很大

00:07:14.400 --> 00:07:19.770
特别是第95个百分位数非常大，因为

00:07:19.770 --> 00:07:25.139
结构稍微有些偏离，您可能会迷失在网络中，而现在

00:07:25.139 --> 00:07:31.439
您不会有效地找到第一个提供者

00:07:31.439 --> 00:07:35.789
您需要花很长时间才能开始使用位法和

00:07:35.789 --> 00:07:44.729
速度变快了，但没有那么快，最后我还是钢琴家

00:07:44.729 --> 00:07:51.779
得到x的速度也很慢，因为您会看到比IP FS x慢得多，并且

00:07:51.779 --> 00:07:56.260
那些已经变得快很多了

00:07:56.260 --> 00:08:01.150
对于HT改进我们一直在努力，这是一个速成课程，

00:08:01.150 --> 00:08:05.910
任何人都有任何疑问，他们有一点时间

