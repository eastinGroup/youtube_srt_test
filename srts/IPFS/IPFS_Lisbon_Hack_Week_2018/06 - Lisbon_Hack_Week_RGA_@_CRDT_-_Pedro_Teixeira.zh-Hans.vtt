WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.060 --> 00:00:09.150
所以今天我在这里告诉你我完成了一项任务

00:00:09.150 --> 00:00:15.330
Delta慈善机构实施复制的Global阵列，我将

00:00:15.330 --> 00:00:20.490
向您解释简要向您解释为何达美慈善机构可能很有趣或

00:00:20.490 --> 00:00:26.640
比其他慈善机构还好，所以让我们举个例子

00:00:26.640 --> 00:00:32.579
慈善机构的基本类型，所以它们是基于州的，基于运营的，所以

00:00:32.579 --> 00:00:38.670
基于状态的状态通过复制广播或广播中的状态来工作

00:00:38.670 --> 00:00:43.410
闲聊自己的国家，并将其他对等国家纳入

00:00:43.410 --> 00:00:48.600
加入其他对等国家进入其国家，所以让我们举一个快速的例子

00:00:48.600 --> 00:00:54.230
像成长的Lea那样的组合成长，很遗憾，柜台的成长，这是错误的

00:00:54.230 --> 00:00:58.800
假设我们有3个节点，第一个增加了

00:00:58.800 --> 00:01:04.080
已经到三，然后这个玩具到三，然后第二到一，然后

00:01:04.080 --> 00:01:09.540
第三对一，所以三加一加二等于六，让我们看看他们是如何

00:01:09.540 --> 00:01:21.270
传播糟糕的低位比赛，您能不能打出不好的比赛，好吧，所以首先

00:01:21.270 --> 00:01:26.549
一个传播到这里加入，所以它是由于一个传播到

00:01:26.549 --> 00:01:31.560
上面由于我的观点明智的最大是三比一然后这个

00:01:31.560 --> 00:01:35.850
在此处传播T到一点，最大值为三比一

00:01:35.850 --> 00:01:47.280
现在是的，回到这里三两两并同步，但它是一样的，所以唱歌

00:01:47.280 --> 00:01:51.780
六点还好，所以现在整个州都认为这已经融合了，这就是

00:01:51.780 --> 00:01:59.820
是基于州的慈善机构，这是基于州的慈善机构的非常简单的示例

00:01:59.820 --> 00:02:04.649
我们的慈善机构设定的问题是，国家往往会变得越来越庞大

00:02:04.649 --> 00:02:13.770
复杂的现实还可以，因此解决方案是由慈善机构运营

00:02:13.770 --> 00:02:19.860
他们在本地形成了一系列的操作，所以我们说我们有一个

00:02:19.860 --> 00:02:27.330
称为a的节点已经有两个操作a 1和a 2，因此这

00:02:27.330 --> 00:02:34.320
操作取决于此因果关系，因此局部因果关系由

00:02:34.320 --> 00:02:40.200
箭头，现在有一个节点B知道这些操作，但会追加

00:02:40.200 --> 00:02:45.450
操作日志开头的新操作，然后他追加了一个新操作

00:02:45.450 --> 00:02:52.830
再进行一次操作，然后再进行操作，否，他们会追加另一个操作，

00:02:52.830 --> 00:02:56.550
同时它只知道这个操作，不知道这个

00:02:56.550 --> 00:03:01.710
操作还可以，所以他们还没有互相谈论这个

00:03:01.710 --> 00:03:12.450
这个，所以他附加到这个确定上，所以现在我们不喜欢他们

00:03:12.450 --> 00:03:15.900
反对这一点，而节点B依赖于这一点，因此他们不了解每个

00:03:15.900 --> 00:03:21.750
在这一点上还没有其他，所以它们是可交换的，所以您必须

00:03:21.750 --> 00:03:27.990
存储，所以我们永远不知道什么时候有换行操作，所以

00:03:27.990 --> 00:03:34.890
您对此有解决方案我最近学到了，但原则上您

00:03:34.890 --> 00:03:40.560
必须存储所有操作，因为您可能在其中拥有这些操作

00:03:40.560 --> 00:03:44.370
这一权利的未来，我们必须存储这一权利，因为您可能有

00:03:44.370 --> 00:03:47.250
此操作的未来操作，所有操作都一样

00:03:47.250 --> 00:03:54.150
然后在待办事项上就可以了，所以有一个或多或少的紧凑型解决方案

00:03:54.150 --> 00:04:00.930
这是为了推断操作的因果稳定性，这意味着如果

00:04:00.930 --> 00:04:05.280
操作正在以稳定的方式引起，将不会有并发

00:04:05.280 --> 00:04:12.690
操作到这一步还可以，所以在将来这一步还可以

00:04:12.690 --> 00:04:20.880
这样一来，当您听到时，有一种方法可以通过使用垂直牛来推断

00:04:20.880 --> 00:04:24.870
您知道所有成员的前提下的音频操作状态

00:04:24.870 --> 00:04:29.250
这是假设，但我认为还有很多方法可以解决

00:04:29.250 --> 00:04:37.319
拥有动态成员资格就可以了，但这不是我要去做的，所以我们有了

00:04:37.319 --> 00:04:47.340
另一种类型的慈善机构是基于州的慈善机构，但我们

00:04:47.340 --> 00:04:54.599
Delta和基于Delta的慈善机构，复制品通过Delta的Not

00:04:54.599 --> 00:05:00.900
就整个州而言，医生并非完全是一种手术，因此

00:05:00.900 --> 00:05:07.680
直觉是Delta应该是各州的一部分，而Delta

00:05:07.680 --> 00:05:12.030
在适用于各州时是幂等的，操作并不那么重要，所以如果

00:05:12.030 --> 00:05:17.639
你的党两次相同的操作，它会产生不同的状态，所以

00:05:17.639 --> 00:05:22.409
但两次将Delta应用于相同状态应产生相同的

00:05:22.409 --> 00:05:29.340
状态相同，因此将ss2加入的s 1和Delta 1再次加入2 Delta 1

00:05:29.340 --> 00:05:37.919
仍为2，所以Delta的优势可以结合在一起，所以

00:05:37.919 --> 00:05:43.530
它们很容易禁止，因为您可以缓冲一堆由

00:05:43.530 --> 00:05:47.190
加入它们，您可以压缩它们，然后可以发送它们，而不必

00:05:47.190 --> 00:05:51.380
像您在慈善行动中所做的那样缓冲所有事情，您不必

00:05:51.380 --> 00:06:00.659
缓冲所有人，您可以加入他们，这样他们就可以互相关联

00:06:00.659 --> 00:06:07.500
基于医生的慈善机构是通过状态集初始集而不是变异符来定义的

00:06:07.500 --> 00:06:12.630
函数具有Delta mutator函数，该函数返回delta，并且您有一个联合

00:06:12.630 --> 00:06:17.300
州慈善组织也有的职能

00:06:17.300 --> 00:06:27.900
返回慈善机构的观点的值，因此基于

00:06:27.900 --> 00:06:37.010
以前的增长唯一计数器是，所以状态集是整数的向量

00:06:37.010 --> 00:06:43.229
大于或等于0的她将设置此向量时钟，并且

00:06:43.229 --> 00:06:54.210
如果我不是，Delta mutator函数只是我身上的一个增量

00:06:54.210 --> 00:07:00.120
请注意零，我只发送该值一个就可以了，所以我不必设置

00:07:00.120 --> 00:07:04.529
在发送更新到我的状态之前，我一直在发送整个状态

00:07:04.529 --> 00:07:10.199
增量好吧，但这不是一项操作，因为如果我将结果加入增量中

00:07:10.199 --> 00:07:20.400
设置好我的状态后，我仍然可以得到我的状态，因此加入非常

00:07:20.400 --> 00:07:26.789
类似，通过安全性，它与一个状态的连接是相同的，所以这是明智的选择

00:07:26.789 --> 00:07:36.569
两种状态的最大值，仅此而已，这一切都告诉我我完成了

00:07:36.569 --> 00:07:42.659
复制的可增长数组的第一个JavaScript实现，以及

00:07:42.659 --> 00:07:52.379
关于复制的全局数组的好处是它可以维护用户

00:07:52.379 --> 00:08:00.810
意图，所以当发生冲突时，假设用户输入我会

00:08:00.810 --> 00:08:06.930
增加这些是测试，假设用户您有两个副本

00:08:06.930 --> 00:08:11.460
复制一个和副本-假设一个副本A和B的副本

00:08:11.460 --> 00:08:17.909
在并发操作中以及在直接

00:08:17.909 --> 00:08:28.770
交换了三角洲，它们都可以收敛到abcd和bcd

00:08:28.770 --> 00:08:34.620
他们两个都可能是结果之一可能是发展结果可能会

00:08:34.620 --> 00:08:41.190
是正确的，但这并不能保留两个用户的意图

00:08:41.190 --> 00:08:49.199
因为如果我写我在鲍勃这里写我们的，我想将结果转换为

00:08:49.199 --> 00:08:53.850
爱丽丝·鲍勃（Alice Bob）或鲍勃·爱丽丝（Bob Alice），而不是人物的交织

00:08:53.850 --> 00:09:01.019
好吧，所以这就是为什么这种类型的策略很适合文本编辑的原因

00:09:01.019 --> 00:09:07.529
据我所知，这是delta状态的第一个实现，

00:09:07.529 --> 00:09:19.850
我们GA中的安全性和测试都通过了，是的，就是这样

00:09:19.850 --> 00:09:42.829
谢谢哦，有什么问题吗

00:09:43.250 --> 00:09:49.069
是的，你是支离破碎的，是的，好的

00:09:52.160 --> 00:10:04.800
数据是说好吧，这就像不是

00:10:04.800 --> 00:10:20.029
记录下来，所以这是我的意思，测试可能是这样的，所以我

00:10:20.209 --> 00:10:29.339
认为您看得很好，是的，所以您可以推动插入，将所有阵列移除

00:10:29.339 --> 00:10:35.250
以此类推，这只是RGA，还有其他慈善类型，例如

00:10:35.250 --> 00:10:39.959
设置类似类型或映射类似类型或数组类似类型，这是一个类似数组

00:10:39.959 --> 00:10:48.689
序列的类型，然后您必须通过推动将其删除，然后才能获得

00:10:48.689 --> 00:10:59.959
计算视图的值，因此数组可以回答您的问题

00:11:03.230 --> 00:11:08.940
是的，一旦复制品发出了一些事件

00:11:08.940 --> 00:11:19.370
更新任何其他问题，不，谢谢

