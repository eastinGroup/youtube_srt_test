WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:07.519
我要向您展示的是点对点的一些可视化

00:00:07.519 --> 00:00:12.840
协议，有点像脂质EP的一般想法，所以我可能会

00:00:12.840 --> 00:00:21.660
明天再给模仿者展示一些这样的东西，但是

00:00:21.660 --> 00:00:26.310
你知道你得到了两回合，但是将军我要给你看

00:00:26.310 --> 00:00:31.619
我们为文件硬币构建的内容的演示，但通常足以应用

00:00:31.619 --> 00:00:40.320
到ipfs和脂质束输入，因此这确实是降低p2p的工具

00:00:40.320 --> 00:00:45.690
意味着低p2p和调试它的一些协议，所以我将从

00:00:45.690 --> 00:00:49.640
像可视化的一般想法

00:00:49.670 --> 00:00:56.460
分布式协议是一件困难的事情，并且有很多类似的东西

00:00:56.460 --> 00:01:01.920
有趣的工作，就像您如何推理一些真正的

00:01:01.920 --> 00:01:07.619
复杂，您知道一堆类似的不同机器正在发生的事情

00:01:07.619 --> 00:01:11.700
以及经历的不同角色和消息，所以您很长一段时间都知道

00:01:11.700 --> 00:01:15.540
传统的想法是嘿，您只需要查看日志记录就可以了解

00:01:15.540 --> 00:01:20.610
这是怎么回事，也许如果您真的想拿走那些障碍

00:01:20.610 --> 00:01:24.360
跟踪并可视化，也许您可​​以在几秒钟内找到错误，而不是

00:01:24.360 --> 00:01:31.650
天，不仅如此，您还可以解释协议应如何运作

00:01:31.650 --> 00:01:35.880
以更简单的方式向人们提供信息，因此这方面有很多历史

00:01:35.880 --> 00:01:40.400
人们尝试了不同的方法，我想我会讲出非常好的方法

00:01:40.400 --> 00:01:46.560
对于筏，它称为筏范围，它是

00:01:46.560 --> 00:01:51.960
这是在筏式共识协议的首页中

00:01:51.960 --> 00:01:55.579
确保我正在记录我的屏幕

00:01:57.890 --> 00:02:06.890
我将继续从这里出发，这就是说筏的可视化

00:02:06.890 --> 00:02:11.860
由于某些原因，我们无法将该页面放大

00:02:11.860 --> 00:02:18.490
哎呀，这是怎么回事，所以您看到五个节点，这是内部

00:02:18.490 --> 00:02:24.940
筏定时器他们会结束，然后他们会尝试当选

00:02:24.940 --> 00:02:30.760
领导者首先走这种道路，那是一轮失败的比赛，因为

00:02:30.760 --> 00:02:34.960
多个试图同时选举，但现在的时钟有点像

00:02:34.960 --> 00:02:42.010
改组，所以看起来s4将会赢得您要竞选的下一次选举

00:02:42.010 --> 00:02:47.530
哦，是的，我们走了，现在这些票是正确的，现在是

00:02:47.530 --> 00:02:52.360
由于某种原因开始复制内容，这有点问题

00:02:52.360 --> 00:02:57.270
可能是快速的时间，但同时却很不愉快，但是

00:02:57.270 --> 00:03:02.140
现在开始像复制品了现在这就像是正确的领导者

00:03:02.140 --> 00:03:05.770
所以我想在这一点上我可以输入一个值或其他东西，并记住如何

00:03:05.770 --> 00:03:14.200
使用这个实际上我可以停下来，喜欢在这里恢复整个事情

00:03:14.200 --> 00:03:18.090
暂停快速的时间，因为我认为这完全破坏了一切

00:03:18.090 --> 00:03:24.300
抱歉，我们不得不喜欢记录一下，让我再次刷新

00:03:26.640 --> 00:03:33.540
太好了，我要加快速度，大惊小怪

00:03:35.090 --> 00:03:42.080
我认为在这一点上我应该可以输入值

00:03:42.080 --> 00:03:46.250
无论如何，这应该是一个交互式工具，可让您执行

00:03:46.250 --> 00:03:51.580
使用协议并理解它，以便您可以杀死节点并进行定义

00:03:51.580 --> 00:03:56.680
开始添加值以查看状态机复制的工作原理噢，我们走了

00:03:56.680 --> 00:04:04.160
停止，所以我只是停止了该节点，也许它停止了整个播放过程，是的，所以

00:04:04.160 --> 00:04:14.090
现在s2已死，然后我可以将其恢复，依此类推，就像

00:04:14.090 --> 00:04:19.910
该协议的实时完整实施，可让您思考一下

00:04:19.910 --> 00:04:27.650
并调试它，所以我想要的是不仅可以

00:04:27.650 --> 00:04:32.390
协议在JavaScript中的不同实现，但实际

00:04:32.390 --> 00:04:35.570
实施，因此无论它们处于运行状态还是处于活动节点中的协​​议

00:04:35.570 --> 00:04:41.840
JavaScript或其他方法，执行此操作的方法是我们可以采用协议

00:04:41.840 --> 00:04:46.100
自己，并从协议中获取事件日志，并让您知道摘录

00:04:46.100 --> 00:04:50.870
该跟踪结合了来自所有不同节点的所有事件日志，然后

00:04:50.870 --> 00:04:55.460
然后使用它来显示可视化，我们可以收集所有这些

00:04:55.460 --> 00:05:00.700
跟踪并保留它们，然后在任何时候或我们可以的情况下回放可视化效果

00:05:00.700 --> 00:05:06.740
实时进行，就像我们实际上可能想像现场看到的东西，所以我

00:05:06.740 --> 00:05:11.210
将向您展示此实现的版本，这是一个旧想法，所以

00:05:11.210 --> 00:05:19.669
就像几年前讨论过的，是的，不是15岁，我认为这是

00:05:19.669 --> 00:05:26.120
像这样的第一个实现，您可以播放它，依此类推，但是

00:05:26.120 --> 00:05:39.110
我将向您展示一个更好的人，是的，所以实际上

00:05:39.110 --> 00:05:43.900
产生可视化效果，所以那里的深度深度图有点破

00:05:43.900 --> 00:05:48.020
其实让我有一个虫子，所以我必须喜欢星星

00:05:48.020 --> 00:05:55.120
与未成年人而不是与客户在一起，否则他将不会工作

00:05:55.120 --> 00:06:00.169
再滚一次，是的，是的，我知道我很认真，就像我应该修复

00:06:00.169 --> 00:06:03.020
我该死的错误，我想回复上一次更改

00:06:03.020 --> 00:06:06.379
我所做的介绍给我们带来了极大的好处，所以这是一个

00:06:06.379 --> 00:06:09.020
轻微忽略错误的深度图

00:06:09.020 --> 00:06:16.460
所以现在这些都是我机器上的实时文件硬币节点，

00:06:16.460 --> 00:06:22.610
他们将其设置为第二个阻塞时间，因此它们的运行速度非常快，所以这

00:06:22.610 --> 00:06:27.319
是资金转移是实际交易中的每一种

00:06:27.319 --> 00:06:32.750
是被传播，是的，让我让我与时机一起玩一点

00:06:32.750 --> 00:06:48.370
太快了，看不到让我们做两秒钟，所以现在这将花费更长的时间，

00:06:48.370 --> 00:06:56.530
现在我们必须祈祷，这就像是未成年人，而不是客户，哦，该死的

00:06:56.530 --> 00:07:10.639
再次滚动调查说，所以整个过程就像我们走了一样，那是什么

00:07:10.639 --> 00:07:15.139
这里发生的是，有一个过程是模拟器随机选择的

00:07:15.139 --> 00:07:19.580
在一组选择之间，您知道它可能会产生一个加入

00:07:19.580 --> 00:07:24.740
网络，所以您每隔两秒钟就知道它像随机生成一个节点，然后

00:07:24.740 --> 00:07:29.539
将其连接到网络，然后每隔几秒钟就会抛出一个

00:07:29.539 --> 00:07:32.750
随机动作，它是从多种动作中选择的，所以就像

00:07:32.750 --> 00:07:38.569
它以要价（美分）要价交易提醒一个区块，所以又像深度一样

00:07:38.569 --> 00:07:42.289
图表是完全错误的，这是一个正在进行的工作，但是发生了什么

00:07:42.289 --> 00:07:47.150
这是实际的节点，这里要解析的是事件

00:07:47.150 --> 00:07:53.360
它们走出文件硬币时记录日志，然后将这些事件日志

00:07:53.360 --> 00:07:57.469
转化为可视化可以消耗的东西，所以我要

00:07:57.469 --> 00:08:06.620
想通过那种方式，所以我想

00:08:06.620 --> 00:08:15.340
废话是的，我只是想尝试并喜欢

00:08:16.330 --> 00:08:19.569
让我们来看看

00:08:23.440 --> 00:08:33.820
我将尝试连接其中一个，让我以更好的方式编辑命令

00:08:33.820 --> 00:08:45.150
等待，我想我想要事件日志，日志尾部，我认为

00:08:53.250 --> 00:08:57.930
所以我考虑这样做，这就是从Falkor节点中抽出的东西

00:08:57.930 --> 00:09:06.710
自己，所以也许那个音符没有得到，所以我收到了两条信息

00:09:06.710 --> 00:09:11.900
所以每隔一段时间，就像发生的事情一样，这正在抽出日志

00:09:11.900 --> 00:09:16.140
这些都是JSON，这与事件日志结构完全一样

00:09:16.140 --> 00:09:20.370
在Go ipfs中，这是相同的想法，一路走来-让p2p代码充满了这一点

00:09:20.370 --> 00:09:24.360
东西，所以您会注意到其中一些事件实际上是同一件事

00:09:24.360 --> 00:09:30.450
如果s发出的信号会上升，也许其中大多数是特定于他妈的的，但是一堆

00:09:30.450 --> 00:09:38.910
这些就像表盘，等等，我想也许我已经将那些静音了，但是

00:09:38.910 --> 00:09:44.480
该模拟器的作用是获取事件日志，然后将其解析为

00:09:44.480 --> 00:09:53.730
因此，这些日志就是网络可视化所接收的内容，这是什么

00:09:53.730 --> 00:09:58.620
继续是，我们让程序定义了自己的事件日志，但是

00:09:58.620 --> 00:10:02.130
它想要，因为它会随着时间的流逝而改变，人们

00:10:02.130 --> 00:10:05.310
将会基于对什么有意义的事情来做出如何决定的决定

00:10:05.310 --> 00:10:10.950
该程序，然后我们编写可视化文件，并希望创建一个

00:10:10.950 --> 00:10:14.790
事件跟踪对于使可视化有意义的事件

00:10:14.790 --> 00:10:20.850
理解我们真正想要看到的东西，所以在这种情况下，就像节点进入

00:10:20.850 --> 00:10:24.270
就像传播传播的交易一样，

00:10:24.270 --> 00:10:29.820
依此类推，所以您可能会注意到它们的长度要短得多

00:10:29.820 --> 00:10:34.800
比其他的要多，因此在转换过程中，一堆日志

00:10:34.800 --> 00:10:39.330
被淘汰，然后他们就变成了

00:10:39.330 --> 00:10:42.330
JavaScript可以消耗的东西也正在聚合

00:10:42.330 --> 00:10:46.500
因此，我们将所有这些事件日志都放入这些节点中，并将它们放在

00:10:46.500 --> 00:10:50.960
放入同一管道，然后将其推送到网络上的可视化文件

00:10:50.960 --> 00:11:01.290
因此，有一种方法可以看到所有这些事件，我们希望

00:11:01.290 --> 00:11:07.170
跟踪，是的，所以我们有一个程序，它输出事件日志

00:11:07.170 --> 00:11:12.829
现在有一个叫做文件netsim的东西，然后发出命令并

00:11:12.829 --> 00:11:20.189
然后获取所有事件日志，然后将其输出到日志中，我可以

00:11:20.189 --> 00:11:24.480
为此，因此包括像现在这样的控制器或模拟器，

00:11:24.480 --> 00:11:29.579
等等，我应该可以在所有这些程序中做到这一点，

00:11:29.579 --> 00:11:33.449
我可以输入任意数量，很酷的是，不仅可以

00:11:33.449 --> 00:11:37.410
在我的计算机上的模拟器上工作，这应该能够在我的任何节点上工作

00:11:37.410 --> 00:11:42.749
应该能够喜欢正确地抓住随机笔记，所以我实际上可以喜欢刷新

00:11:42.749 --> 00:11:47.730
此页面，它应该下载整个日志历史记录并进行播放

00:11:47.730 --> 00:11:52.980
所以那可能不是什么，所以我想那就像d3一样cho

00:11:52.980 --> 00:11:58.049
所有动画序列，但现在又回到了正确的状态，因此

00:11:58.049 --> 00:12:01.230
理想情况下，会有一个您知道的酒吧，您知道该酒吧允许您显示

00:12:01.230 --> 00:12:07.109
您可以停下来播放，知道倒带等等，但是

00:12:07.109 --> 00:12:11.069
嗯，是的，这就像直播一样，您可以将其挂接到

00:12:11.069 --> 00:12:18.209
实时网络，然后您就知道可以使用ipfs了，我们可以使用它来查看我们的

00:12:18.209 --> 00:12:22.470
我们的鼻子和网关，看看他们在做什么，什么样的消息

00:12:22.470 --> 00:12:25.829
他们正在展示，很酷的想法是我们应该能够

00:12:25.829 --> 00:12:30.869
生成一堆不同的最终可视化效果，向我们展示不同的效果

00:12:30.869 --> 00:12:33.449
在某些情况下，我们希望看到的东西只是希望看到

00:12:33.449 --> 00:12:39.419
DHT只是专注于DHT协议，它不是ipfs特定的，只是让p2p

00:12:39.419 --> 00:12:44.339
特定于DHT，在其他情况下就是这样，我们可能希望看到一些东西

00:12:44.339 --> 00:12:49.769
差异非常大，因此我们可以选择可视化对象来定位

00:12:49.769 --> 00:12:53.819
我们希望看到，因此在这种情况下，我们将它们全部圈了起来，但是就像这些

00:12:53.819 --> 00:12:57.509
我们可以轻松地将它们放在地图上，这样我们实际上就可以像地球仪一样放

00:12:57.509 --> 00:13:02.309
他们在那里等等，所以这有点像一个非常灵活的架构

00:13:02.309 --> 00:13:06.480
这样，如果所有进程都坚持使用此事件日志，然后

00:13:06.480 --> 00:13:10.220
我们有这个模拟器，可以轻松地生成它们并发送命令，

00:13:10.220 --> 00:13:16.819
提取这些日志，然后将其转换为可视化所需的内容

00:13:16.819 --> 00:13:20.940
然后我们可以像您知道的那样编写

00:13:20.940 --> 00:13:26.400
我们希望看到，其中许多将是可重用的组件，您知道

00:13:26.400 --> 00:13:33.620
想法是要有类似你知道的东西，你可能已经看过

00:13:35.570 --> 00:13:41.670
福特三世（Ford III），人们只要写出要点，便会发现友善

00:13:41.670 --> 00:13:50.010
像真正的d3魔术一样发生在理想情况下，将很容易编写

00:13:50.010 --> 00:13:55.710
这些像可视化插件，然后像收集一样运行

00:13:55.710 --> 00:13:59.610
一些跟踪，然后在跟踪上运行运行此可视化效果，然后查看

00:13:59.610 --> 00:14:05.520
看到有关它的东西，两者都有助于调试，有助于理解

00:14:05.520 --> 00:14:11.070
这些协议可以帮助您了解组织的状况等等。

00:14:11.070 --> 00:14:37.010
那是该工具的目标，是的，所以通过这个斜线日志

00:14:37.610 --> 00:14:43.260
是的，最终的结果是，sim卡既是发行的单个程序，

00:14:43.260 --> 00:14:46.680
所有命令并将它们旋转起来，收集事件日志，然后

00:14:46.680 --> 00:14:51.150
汇总它们并缓冲其中一些，因为您实际上想保留

00:14:51.150 --> 00:14:57.030
缓冲一定的大小，以便您可以轻松刷新页面，然后将其暴露

00:14:57.030 --> 00:15:02.340
通过HTTP，以便为资产本身以及其记录的聚合提供服务

00:15:02.340 --> 00:15:05.280
但是所有这些都可以改变，这只是获得它的一种技巧

00:15:05.280 --> 00:15:09.150
如果我们想为p2p大致做到这一点，我们会想要

00:15:09.150 --> 00:15:13.860
是那个中心的东西是通用的并且是一个单一的程序，然后您将

00:15:13.860 --> 00:15:18.600
可能写了另一个使用该程序作为库的程序，或

00:15:18.600 --> 00:15:22.020
由您知道的那个调用发送命令并进行Trent转换

00:15:22.020 --> 00:15:26.910
日志，但我们只需要写一件事，即控制器并输出

00:15:26.910 --> 00:15:31.710
日志等等，我们只需要一次写一次，然后再写一次

00:15:31.710 --> 00:15:36.110
可视化会做的就是说我想过滤这些事件日志

00:15:36.110 --> 00:15:40.130
我想以这种方式进行转换，所以看起来像是

00:15:40.130 --> 00:15:49.520
非常简单，所以在此可视化中，我就是这样的

00:15:49.520 --> 00:15:55.340
巨大的switch语句，每当我看到您知道II都会提取汇总的语句

00:15:55.340 --> 00:16:01.250
来自所有不同节点的日志，然后每当我看到一个事件时，我都会进行转换

00:16:01.250 --> 00:16:05.570
它变成了一个不同的事件，我从特定于该事件的事件开始，一直到程序

00:16:05.570 --> 00:16:09.320
特定于可视化的事件，因此只需应用

00:16:09.320 --> 00:16:14.990
我从您了解的每个过滤器中了解实现的具体内容，

00:16:14.990 --> 00:16:18.650
我的可视化想要的东西，然后我们还必须编写

00:16:18.650 --> 00:16:23.840
可视化，但这是不可避免的，因为您最终会

00:16:23.840 --> 00:16:26.300
想要很多不同的东西，我们可能会有一些像可重用的组件

00:16:26.300 --> 00:16:29.360
例如，如果我们有能力停止播放等等，那可能是

00:16:29.360 --> 00:16:33.830
只写过一次，但是您知道可视化Magana DHD与

00:16:33.830 --> 00:16:37.340
可视化它，所以op不同于可视化弹出窗口

00:16:37.340 --> 00:17:02.540
与可视化这些东西有很多不同，是的，但是这允许

00:17:02.540 --> 00:17:06.709
我们来到模拟器，可视化效果就像不运行

00:17:06.709 --> 00:17:10.670
并且只要您从原始过程中捕获事件日志

00:17:10.670 --> 00:17:14.540
只要捕获这些日志，这只是标准的日志记录过程

00:17:14.540 --> 00:17:18.920
然后您可以随时通过此模拟器筛选这些对象，因此您

00:17:18.920 --> 00:17:22.430
将来可以重播它们，您知道自己想要什么，这样也可以

00:17:22.430 --> 00:17:28.520
为测试套件工作，因此您可以运行一个测试套件，然后测试文件和一个

00:17:28.520 --> 00:17:32.270
它的输出不仅像标准路线一样，而且还包括所有事件

00:17:32.270 --> 00:17:35.090
日志，然后您可以将事件日志扔到模拟器中，然后

00:17:35.090 --> 00:17:37.690
看看发生了什么

00:17:38.460 --> 00:17:44.529
是的，所以我们可以，呃，您知道很多自动化的事情，所以

00:17:44.529 --> 00:17:50.940
而且，你知道这就像是一个虚拟化，我们

00:17:50.940 --> 00:17:57.250
写道，我认为它由于某些原因而被cho住，并且喜欢不杀死进程

00:17:57.250 --> 00:18:00.940
他是如此一堆程序挂起，所以我大概有数百个

00:18:00.940 --> 00:18:05.799
传出的流程或成千上万的流程，但我的意思是，这很简单

00:18:05.799 --> 00:18:08.500
您能看到更复杂的东西吗，例如3d发光效果

00:18:08.500 --> 00:18:14.559
它上面的所有东西，或者您知道其他一些其他方式

00:18:14.559 --> 00:18:18.490
可视化结冰的东西，特别是对于聚集的弹出窗口

00:18:18.490 --> 00:18:21.879
树木等等，您可以使用等待时间来处理等待时间

00:18:21.879 --> 00:18:26.529
显示您喜欢两个节点之间的距离，然后您可以看到

00:18:26.529 --> 00:18:29.830
消息传播，因此您可以看到是否像

00:18:29.830 --> 00:18:33.669
正确形成树的算法是正确传播的算法哦

00:18:33.669 --> 00:18:37.330
就像这条消息正在通过，但喜欢它通过此节点但不是这样

00:18:37.330 --> 00:18:40.659
一个正在发生的事情，你知道它将使我们能够做很多这样的事情

00:18:40.659 --> 00:18:48.179
有点调试，但是很酷，还有其他问题

00:18:48.509 --> 00:18:55.440
听起来不错，就是这样

00:19:30.190 --> 00:19:39.770
是的，是的，有时您的模型实际上是错误的，所以您认为

00:19:39.770 --> 00:19:42.500
发生了一些事情，因为您已经考虑了这一点

00:19:42.500 --> 00:19:46.160
协议很多，您正在进行某些操作，但是现在有所更改

00:19:46.160 --> 00:19:50.179
发生了其他事情，现在您不仅要尝试模拟它

00:19:50.179 --> 00:19:54.620
在您的脑海中，您正在尝试调试自己，并确保像您一样

00:19:54.620 --> 00:19:59.450
心理模型仍然正确，所以是的，实际上使用了真实的可视化

00:19:59.450 --> 00:20:33.890
可能会更好，甚至在第三种情况下，这也很棒

00:20:33.890 --> 00:20:39.920
由其他人设计的Raft的可视化效果，所以这可能

00:20:39.920 --> 00:20:44.600
有点极端，但这部分是我们可以做到的

00:20:44.600 --> 00:20:50.990
这表明这将引导您完成整个算法，并演示如何

00:20:50.990 --> 00:20:54.500
它可能会起作用，这里的某些组件可以在您可以使用的地方使用

00:20:54.500 --> 00:20:58.070
生成特定的轨迹，然后将其回放到仿真中，然后

00:20:58.070 --> 00:21:01.700
这样一来，您就可以解释算法如何正确运行，从而适用于DHD和

00:21:01.700 --> 00:21:05.929
在帮助了解DHT遍历如何工作的过程中，这将是

00:21:05.929 --> 00:21:10.220
超级好，因为您可以只写一个然后再为那个人演奏

00:21:10.220 --> 00:21:14.540
学习正确，所以这将是一种更容易理解的方法

00:21:14.540 --> 00:21:19.460
这些协议中有很多是如何工作的，是的，我要在其中添加一些链接

00:21:19.460 --> 00:21:26.570
这其中的每一个，因为它绝对是一种更简单的方法

00:21:26.570 --> 00:21:34.870
了解该协议，然后阅读论文是的，谢谢

