WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.089 --> 00:00:06.150
这只袜子会短暂地穿过脂质EP界面，并且实际上会开始

00:00:06.150 --> 00:00:11.040
看看Lapita小便最终如何被其他程序所使用，以及

00:00:11.040 --> 00:00:15.990
我们如何架构事物，然后我们将经历当前

00:00:15.990 --> 00:00:20.310
我们正在考虑对整个项目的接口进行清理的方向

00:00:20.310 --> 00:00:28.230
这部分是暂时的ipfs转换，但犯规硬币是

00:00:28.230 --> 00:00:33.239
同样的事情和其他系统可能做的事情完全一样，这里有一个

00:00:33.239 --> 00:00:42.300
系统的核心实现，它具有一些协议api，并且具有一些

00:00:42.300 --> 00:00:46.230
客户端接口，因此这些客户端接口将成为

00:00:46.230 --> 00:00:51.059
像ipfs这样的用户，例如爆米花之类的用户

00:00:51.059 --> 00:00:55.500
我们设计的东西是程序接口在这里

00:00:55.500 --> 00:01:02.670
客户使用API​​和程序化API表示，然后我们使用

00:01:02.670 --> 00:01:07.260
一个命令库，我想JavaScript我不知道你在干什么

00:01:07.260 --> 00:01:14.580
伙计们这样做，然后给了我们所有的东西，就像给了我们一些工具

00:01:14.580 --> 00:01:21.420
拥有一个RPC库从任何地方调用这些命令的想法，所以想一想

00:01:21.420 --> 00:01:26.909
相当于G RPC，不是您的PC，而是

00:01:26.909 --> 00:01:30.240
可能在HP插槽上等等，实际上这可能是任何脂质脂

00:01:30.240 --> 00:01:37.200
传输，使我们能够将客户端API暴露给任何事物，然后

00:01:37.200 --> 00:01:42.960
现在其他程序最终如何调用这些系统

00:01:42.960 --> 00:01:50.729
协议端是通过将脂质开放节点嵌入到已知的方式来实现的

00:01:50.729 --> 00:01:58.320
不管系统是什么，并为协议设置一些处理程序，然后每个

00:01:58.320 --> 00:02:01.979
其中是来自这些协议实现的实际代码

00:02:01.979 --> 00:02:05.820
他们的同行在拉皮塔（Lapita）的部分溪流中当然是

00:02:05.820 --> 00:02:13.099
到目前为止的MUX或类似的东西到目前为止还不错，对此有任何疑问

00:02:13.370 --> 00:02:16.550
好，太棒了

00:02:18.230 --> 00:02:23.670
是的，这有点像同一件事的简单版本，最终是

00:02:23.670 --> 00:02:29.819
人们只是在使用p2p时就不得不这样做，否则最终不得不

00:02:29.819 --> 00:02:36.300
实施这方面的东西，这与脂质无关，但这是相同的

00:02:36.300 --> 00:02:38.750
那种故事

00:02:39.540 --> 00:02:42.630
所以这最终是一些手动实施，并且已实施

00:02:42.630 --> 00:02:47.760
每个人都知道，所以您知道HT的实现或弹出等等

00:02:47.760 --> 00:02:54.390
这就是在脂质B项目中，这将是脂质的客户的一部分，所以

00:02:54.390 --> 00:03:02.010
我们要去的地方是分解我们使用的系统的接口

00:03:02.010 --> 00:03:08.310
并使用界面定义语言来定义中心阶段

00:03:08.310 --> 00:03:12.030
实际上是这些接口的类型，以便我们大家都可以达成共识

00:03:12.030 --> 00:03:18.090
该函数实际上应该是什么，以便我们检查您是否知道

00:03:18.090 --> 00:03:20.820
诸如接口合规性之类的东西现在可能会有一个像您一样的映射

00:03:20.820 --> 00:03:25.320
选择对某种语言做一些更惯用的事情，因此您可能会考虑如何

00:03:25.320 --> 00:03:29.790
做到这一点，并支持某种形式的映射，但是具有此接口

00:03:29.790 --> 00:03:33.900
定义语言允许做的是然后以您知道的某种结局

00:03:33.900 --> 00:03:40.590
像代码Jenning出来的存根，现在在这里我代表

00:03:40.590 --> 00:03:45.060
p2p作为一种界面，但实际上会有一种

00:03:45.060 --> 00:03:51.570
loopy，然后每个人都知道DHT pub / sub，依此类推，您知道他们可以

00:03:51.570 --> 00:03:57.420
艾米丽（Emily）确实看到了Flood Sub和所有此类实现，我将展示

00:03:57.420 --> 00:04:04.670
您马上就会进入我所描述的那种界面

00:04:06.500 --> 00:04:10.260
所以您知道一旦产生了这些东西，人们就可以实施

00:04:10.260 --> 00:04:14.190
他们现在又可以随着时间的推移而变异和变化，最终分化

00:04:14.190 --> 00:04:18.450
在某种程度上，理想情况下，我们不希望所有内容保持不变，因为那样

00:04:18.450 --> 00:04:24.479
使推理和测试变得更加容易，以便这些系统的客户可以

00:04:24.479 --> 00:04:27.060
针对这些接口编写，然后期望这些

00:04:27.060 --> 00:04:31.050
实现与它们匹配，但您知道可能存在一些

00:04:31.050 --> 00:04:38.430
即使在JavaScript中可能需要更改的情况也是一样

00:04:38.430 --> 00:04:43.469
没有类型化的界面，这可以指导正常停止，并且

00:04:43.469 --> 00:05:02.370
功能是的，但是您是否正在针对go实施对它进行测试

00:05:02.370 --> 00:05:23.240
针对您要测试的源进行测试，但这就是

00:05:23.240 --> 00:05:29.039
就像流MUX或特定的东西好吗

00:05:29.039 --> 00:05:38.969
但这只是我认为JavaScript所执行的操作与语言无关，因此

00:05:38.969 --> 00:05:57.180
我想告诉你的是我没有录制屏幕，所以现在我是什么

00:05:57.180 --> 00:06:02.669
我要告诉你的是我们正在研究的草案的草稿，所以不要花任何

00:06:02.669 --> 00:06:09.240
这些类型太强到太难或我将如何定义这些类型

00:06:09.240 --> 00:06:12.810
很快，它们就像外部类型，因此我们要加入

00:06:12.810 --> 00:06:20.909
循环它出现，然后从中我们将构造我们使用的Lib poopy

00:06:20.909 --> 00:06:25.770
为了能够摆脱公关ID的多重哈希，有一个理由是

00:06:25.770 --> 00:06:28.909
我们可能还需要编码

00:06:29.120 --> 00:06:33.230
但除此之外，您确实可以想到这两个是

00:06:33.230 --> 00:06:36.199
我们从外部世界进口的主要东西最终都寄托了出来

00:06:36.199 --> 00:06:39.860
被诸如唱片店之类的其他东西所使用，我什至都不会去

00:06:39.860 --> 00:06:51.770
到今天，真的不需要考虑太多了

00:06:51.770 --> 00:06:54.740
您更喜欢从底层开始，或者更喜欢从下面考虑

00:06:54.740 --> 00:07:07.540
就像客户端很好一样，所以我们认为这是主要的

00:07:07.540 --> 00:07:14.450
现在的界面再次在这些类型上还不太畅销，但脂质

00:07:14.450 --> 00:07:19.100
开放节点将具有一个ID，该ID是PID，我们将具有一个关联的键，该键

00:07:19.100 --> 00:07:24.169
将是一个签名密钥，稍后我将了解这意味着什么

00:07:24.169 --> 00:07:27.820
有一个同行商店，可以理解有关皮尔斯的信息

00:07:27.820 --> 00:07:33.440
它里面有一个开关，它有能力安装一个

00:07:33.440 --> 00:07:36.110
协议不是我，这可能是生锈的习惯用法，可能是

00:07:36.110 --> 00:07:40.280
编译，所以我们必须考虑一下它的外观，它具有

00:07:40.280 --> 00:07:49.700
与其他同龄人建立联系的能力几乎就是这些同龄人所做的一切

00:07:49.700 --> 00:07:56.300
事物是对等ID，就像密钥的内容一样，所以您知道多

00:07:56.300 --> 00:08:03.139
如果是CID，则在此处进行哈希处理，然后再进行一些散布，仅此而已

00:08:03.139 --> 00:08:08.539
对等存储只是一些您可以想到的东西，它只是从对等ID映射到

00:08:08.539 --> 00:08:11.720
这些同行信息中可能还有其他内容，我认为go实施中

00:08:11.720 --> 00:08:14.690
被邀请的工作还有其他的东西还不清楚

00:08:14.690 --> 00:08:23.030
需要成为界面的一部分，所以就像所有的嘴唇客户一样

00:08:23.030 --> 00:08:30.470
PDP节点可能需要大多数使用Pippy的协议，但可能只使用了Pippy，但是我们

00:08:30.470 --> 00:08:38.620
可能还有其他内容，所以这就是协议类别的所在

00:08:40.240 --> 00:08:47.150
纯粹的发现，实际上只是具有功能发现的接口

00:08:47.150 --> 00:08:52.100
穿刺，您会知道Russ交易或某种可以使您纯正的交易

00:08:52.100 --> 00:08:56.810
纯信息本身就是它的期间发布，仅此而已，因此，这是一个示例

00:08:56.810 --> 00:09:01.430
这将是本地DNS，您可以坐在本地DNS中侦听它

00:09:01.430 --> 00:09:07.190
向您发出对等信息，纯信息是对等ID和地址

00:09:07.190 --> 00:09:15.350
有没有人有一个周期发现协议的另一个例子，我说过mdns，所以

00:09:15.350 --> 00:09:18.400
你的榜样是什么

00:09:19.360 --> 00:09:25.580
因此，另一个发现协议可能是，如果我们有DHT，则可以使用DHT来

00:09:25.580 --> 00:09:30.190
通过在DHT上发出随机查询来随机发现DHT上的对等节点

00:09:30.190 --> 00:09:36.140
因此我们稍后将看到的DHT也可以满足此要求

00:09:36.140 --> 00:09:41.750
很好，让其他人过一会儿就像你在前面一样

00:09:41.750 --> 00:09:48.920
我静态列表中的类绝对可以，这就像引导程序集

00:09:48.920 --> 00:09:55.610
请注意，静态列表将完全实现此功能，我们可以如何使用DNS

00:09:55.610 --> 00:10:01.850
具有一组特定的DNS服务器，可以返回具有以下内容的记录，例如

00:10:01.850 --> 00:10:06.110
文本记录可以指出我们还有其他什么可能

00:10:06.110 --> 00:10:09.860
是他是BitTorrent用来对等的对象吗

00:10:09.860 --> 00:10:16.520
发现使用跟踪器，因此您可以拥有一个跟踪器类型的东西，他还有什么其他用途

00:10:16.520 --> 00:10:25.510
使用这三件事跟踪器DHCS，该模式使用的最后一件事是什么

00:10:27.300 --> 00:10:31.520
[音乐]我们将其随机行走发现

00:10:31.520 --> 00:10:36.020
使用称为PEX对等交换的东西，您听说过这一切吗

00:10:36.020 --> 00:10:40.670
随机其他BitTorrent节点会告诉您有关其他Batory节点的信息

00:10:40.670 --> 00:10:44.630
他们甚至不保证会在乎您要查找的相同种子

00:10:44.630 --> 00:10:50.540
在您身上发现其他节点可能还有其他东西可以接受的东西

00:10:50.540 --> 00:10:53.440
发出同行

00:10:55.220 --> 00:11:01.680
蓝牙环境监听如何让我进入房间，如果我想告诉我

00:11:01.680 --> 00:11:04.530
我正在通过蓝牙在p2p上收听的世界，我可以做到这一点，

00:11:04.530 --> 00:11:25.170
有人听蓝纹奶酪也可以做同样的事情

00:11:25.170 --> 00:11:28.740
让我们看一下同伴写作，然后，这将使您与众不同

00:11:28.740 --> 00:11:34.860
它们，所以对等路由器是一个接口，因此它仅具有一个称为“查找对等”的功能

00:11:34.860 --> 00:11:40.230
您在此处放弃ID并返回对等信息的地方，所以这意味着

00:11:40.230 --> 00:11:46.590
同行编辑的客户明确地告诉了我这件事

00:11:46.590 --> 00:11:53.150
这个纯净的身份证，请给我一种连接到这个码头的方式，这是

00:11:53.150 --> 00:11:58.560
明确地试图在这里找到，所以这将在DHT中要求步行

00:11:58.560 --> 00:12:01.860
沿着它找到一个特定的对等点，并尝试连接到该对等点

00:12:01.860 --> 00:12:05.540
将是这个优秀同行的另一个例子

00:12:13.010 --> 00:12:16.970
卡车司机不是因为您在这里不要求提供详细信息er ID a

00:12:16.970 --> 00:12:21.199
追踪器，您需要内容，然后您可以得到一堆

00:12:21.199 --> 00:12:24.560
与该内容相关联的对等点，就像提供者的东西

00:12:24.560 --> 00:12:50.779
就是这样，这更加困难，是的，您的lip p2p节点将被绑定到

00:12:50.779 --> 00:12:56.540
多个接口，您可能最终会遇到相同的节点，是的，所以您可以进行讨论

00:12:56.540 --> 00:13:02.870
关于Wi-Fi，是的，您实际上可以完全在以太网上找到对等设备

00:13:02.870 --> 00:13:11.930
任何人都知道什么是ARP ARP实际上就是在以太网层

00:13:11.930 --> 00:13:18.380
正确的ARP是说嘿，谁拥有这个IP地址，谁拥有这个IP地址，

00:13:18.380 --> 00:13:25.190
然后一个MAC地址响应我就知道了，所以这里的想法是

00:13:25.190 --> 00:13:30.260
这些接口可以通过DHT等更具体的东西来实现

00:13:30.260 --> 00:13:37.699
完成所有这些操作，但是重要的是发出它来思考是很有用的

00:13:37.699 --> 00:13:42.459
关于它有点像矩阵

00:13:54.330 --> 00:14:07.620
您拥有纯路由或纯发现对等路由，因此mdns给

00:14:07.620 --> 00:14:13.200
你这个，它给你这个，DHT给你，这个给你这个，但是当然

00:14:13.200 --> 00:14:19.550
就像给您完全不同的保证一样

00:14:19.550 --> 00:14:28.710
可发现性和效率以及各种各样的东西，等等

00:14:28.710 --> 00:14:32.430
对等系统必须做的所有事情是，它们必须使用尽可能多的

00:14:32.430 --> 00:14:37.050
在各种情况下尝试和工作的有利工具

00:14:37.050 --> 00:14:41.310
是的，所以像firechat之类的东西应该能够找到

00:14:41.310 --> 00:14:45.180
其他电话以及在其他电话之间只能进行通信

00:14:45.180 --> 00:14:49.350
在本地做事，不一定需要访问全局DHT

00:14:49.350 --> 00:14:56.940
是的，所以pp里面的一个问题就是发出问题，而不是仅仅考虑

00:14:56.940 --> 00:14:59.940
在每个方面实施分布式系统或Piter Piter系统

00:14:59.940 --> 00:15:04.110
这些协议在水平方向上是巨大的，这就是BitTorrent的其他方式

00:15:04.110 --> 00:15:07.590
考虑它实际上是根据您的需要考虑它，您需要一个

00:15:07.590 --> 00:15:10.800
可以进行对等发现的系统，您需要一个可以进行对等路由的系统

00:15:10.800 --> 00:15:15.420
依此类推，然后根据上下文中的具体情况选择哪种协议

00:15:15.420 --> 00:15:23.030
您想使用该系统的位置

00:15:24.680 --> 00:15:30.930
其他这样的示例，例如不太面向DHT的方法，您还可以怎么做

00:15:30.930 --> 00:15:33.110
路由

00:15:34.920 --> 00:15:39.360
你还可以怎么做对等路由我

00:15:40.740 --> 00:15:46.270
可能只需要问一个HTTP服务器，我可能在某处有大量现金

00:15:46.270 --> 00:15:50.620
我们同意，我可以要求那笔现金像是给我最后一笔

00:15:50.620 --> 00:15:54.250
他们所见过的东西的版本，或者如果您知道自己万岁

00:15:54.250 --> 00:15:59.380
地址，您可以将其写入区块链，就像您可以这样做

00:15:59.380 --> 00:16:03.280
一些地址，例如游客，会打通您将要接受的服务

00:16:03.280 --> 00:16:11.590
在这里ID并将其绑定到tor隐藏的服务，并希望永久地对其进行提交，因此

00:16:11.590 --> 00:16:22.090
您可以做正确的事，因此您可以在HT处将其视为实施每个

00:16:22.090 --> 00:16:28.710
这些东西现在变得有点时髦了

00:16:36.800 --> 00:16:40.550
所以我有很多其他的作品，所以像更高层次的作品

00:16:40.550 --> 00:16:50.990
PDP可能需要花一会儿时间进入它并看起来像

00:16:50.990 --> 00:16:54.649
网络，因为那可能是一些接口的地方

00:16:54.649 --> 00:17:00.339
现在的问题是，这有点像网络存在连接

00:17:00.339 --> 00:17:04.130
远程端点中有一个本地端点，并且有选择的传输方式

00:17:04.130 --> 00:17:09.470
该连接的端点只是一个ID，我可以关联密钥和关联

00:17:09.470 --> 00:17:14.270
签名密钥，对不起Eddy密钥，然后是指向的地址

00:17:14.270 --> 00:17:18.319
那个端点你有加密的连接，你有像这样的连接

00:17:18.319 --> 00:17:26.240
MUX为您提供多个流，这又再次成为惯用语言

00:17:26.240 --> 00:17:31.910
因此，尽管我们很多人喜欢这些界面，但可能不是

00:17:31.910 --> 00:17:37.670
Lib TP的所有需求都应运而生，我们有一个带有以下概念的拨号器概念：

00:17:37.670 --> 00:17:42.200
聆听者是否来自运输运输，您知道很多C

00:17:42.200 --> 00:17:46.340
进入事物或聆听事物，然后我们有一个开关和

00:17:46.340 --> 00:17:49.220
开关是接口中繁重的工作

00:17:49.220 --> 00:17:53.120
网络堆栈，所以这又是大多数人的内部浮躁

00:17:53.120 --> 00:17:56.090
除非您要实施它，否则不必担心它，但这

00:17:56.090 --> 00:18:02.270
这是处理节点绑定到多个接口，多个传输的方法

00:18:02.270 --> 00:18:08.990
和多个接口进行拨号，就像协议混合任何

00:18:08.990 --> 00:18:15.080
到目前为止，关于这个问题，我想将其嵌入其中

00:18:15.080 --> 00:18:21.160
谈，所以我们谈论了一些纯粹的路由，我们还没有谈论IP NS，

00:18:21.160 --> 00:18:26.450
规格和合规性还有哪些其他内容，我们最终要完成什么

00:18:26.450 --> 00:18:32.540
与是一个单一的文件，像这样的珊瑚唇

00:18:32.540 --> 00:18:38.330
小便，然后是一些诸如DHD之类的文件，不一定

00:18:38.330 --> 00:18:43.130
Loopy的核心，但对等路由和对等发现是Gordon Loopy

00:18:43.130 --> 00:18:49.269
因此我们将有一个文件描述接口，

00:18:49.269 --> 00:18:54.309
我们达成了共识，然后找到了一种方法来确保实现和

00:18:54.309 --> 00:18:59.169
接口与客户端的接口匹配，然后我们需要相同的接口

00:18:59.169 --> 00:19:02.909
从协议层的角度来看，例如我们希望协议可以互操作

00:19:02.909 --> 00:19:07.539
我们需要找到一种在笔测试套件中编写语言的好方法

00:19:07.539 --> 00:19:13.419
这样做是为了让我认为我们已经写过有关创建痕迹的信息。

00:19:13.419 --> 00:19:18.250
可以针对某个实现重播的数据包

00:19:18.250 --> 00:19:21.330
确保它正常工作

00:19:21.509 --> 00:19:26.590
是的，所以我不知道你想做多少演讲，而不是那种

00:19:26.590 --> 00:19:30.850
讨论，但我想我想听听他们的反馈会很棒

00:19:30.850 --> 00:19:33.669
观众对该整体的正面或负面看法

00:19:33.669 --> 00:19:40.929
基本上像这样的一组dot go文件将取代规范

00:19:40.929 --> 00:19:46.230
这样的回购将成为衡量一致性的标准

00:19:46.230 --> 00:19:53.019
反对Lib Lib p2p，听到Jas和锈的声音会很有趣

00:19:53.019 --> 00:20:07.590
考虑一下，如果他们有任何反应

00:20:21.390 --> 00:20:26.730
现有的是的您是对的替换了我认为这是一个错误的单词，嗯，补充

00:20:26.730 --> 00:20:31.710
或但这将是幽灵的开始，然后将是

00:20:31.710 --> 00:20:35.940
其次是对这些含义和行为的文字描述

00:20:35.940 --> 00:20:51.360
期望他们不能读到我们康普顿发现和

00:20:51.360 --> 00:21:00.480
具有与否相关的功能，而不仅仅是具有

00:21:00.480 --> 00:21:08.880
对内容发现查询的响应原因是

00:21:08.880 --> 00:21:23.160
选择实施者，选择您的编辑内容，是的，我想我们是

00:21:23.160 --> 00:21:28.440
挂在不同种类的接口上，所以你们想要一个协议

00:21:28.440 --> 00:21:37.260
级别的有线协议测试套件，可以确保所有

00:21:37.260 --> 00:21:41.929
不同的协议，就像您要去的东西一样

00:21:52.040 --> 00:22:01.050
因此，您不必说他们在做什么，这是因为我的意思是

00:22:01.050 --> 00:22:03.750
认为他们会有所不同，您带来了语义，而您带来了

00:22:03.750 --> 00:22:20.700
制定水协议，我认为这将通过拥有一个测试套件来实现

00:22:20.700 --> 00:23:14.490
具有一连串的信息，可以发送到树林，然后另一个

00:23:14.490 --> 00:23:36.050
我们所做的甚至是

00:24:00.700 --> 00:24:06.109
我建议您在其中进行测试的更极端的版本

00:24:06.109 --> 00:24:09.950
与序列相关的案例，您需要执行一系列的操作，例如

00:24:09.950 --> 00:24:13.849
建立连接并尝试打开流，然后您将拥有一组

00:24:13.849 --> 00:24:16.759
数据包与此相关联，然后针对一个实现运行，然后说哦

00:24:16.759 --> 00:24:20.979
看起来你无法打开那个流

00:24:38.320 --> 00:24:52.369
这在两个实现中都是很好的测试权利，如果这样做

00:24:52.369 --> 00:25:20.599
就像是一次针对我们所能做的一次一次性测试

00:25:20.599 --> 00:25:22.779
金属丝

00:25:31.010 --> 00:25:34.279
[音乐]

00:25:49.110 --> 00:25:56.110
到目前为止，我们主要讨论的是有线协议协议

00:25:56.110 --> 00:26:06.400
接口是关于其他的东西是关于模块化接口

00:26:06.400 --> 00:26:13.390
如果别人想写一件可能是

00:26:13.390 --> 00:26:18.370
插入lip PDP节点后，他们需要一组标准接口，

00:26:18.370 --> 00:26:22.870
需要匹配以能够将该协议安装到事物中

00:26:22.870 --> 00:26:27.850
没错，例如，如果有人要编写新的DHT，

00:26:27.850 --> 00:26:31.810
完全可以做到这一点，只要他们有，它们就会暴露出一些东西

00:26:31.810 --> 00:26:36.280
正确的接口，然后他们可以将整个东西安装到脂质DP中，然后

00:26:36.280 --> 00:26:43.450
应用程序可以使用它，因此这是一种不同类型的接口，甚至

00:26:43.450 --> 00:26:52.960
这与像客户一样是不同的，所以我没有表现出任何东西

00:26:52.960 --> 00:26:55.150
你这有点像客户端界面

00:26:55.150 --> 00:27:00.430
而我向您展示的这个分类主义者的东西有点像模块化

00:27:00.430 --> 00:27:06.130
接口，通过同意创建这样的模块化接口，我们

00:27:06.130 --> 00:27:12.580
使人们能够编写这些不同的实现，以便可以将其插入

00:27:12.580 --> 00:27:18.150
是否有助于区分和分离关注点

00:27:42.930 --> 00:27:46.009
[音乐]

00:28:04.279 --> 00:28:41.850
并正确插入，这样我们就到了ipfs不会知道的地步

00:28:41.850 --> 00:28:46.799
关于DHT ipfs将会了解对等点发现和内容发现，并且会

00:28:46.799 --> 00:28:56.850
正确的反对是有道理的，所以如果您导入的话，我

00:28:56.850 --> 00:29:01.830
宣告图书馆，您的重要脂质出现图书馆，您可以说我想要

00:29:01.830 --> 00:29:07.220
与学术界DHT对话的IP快速节点

00:29:24.090 --> 00:29:28.660
因此，在DHD上进行写操作的人必须是将其插入DHD的人

00:29:28.660 --> 00:29:32.410
TFS，然后编写其他应用程序的人无法利用

00:29:32.410 --> 00:29:44.770
那些直线，他们将不得不再次写特征，所以我们应该认为我们

00:29:44.770 --> 00:29:50.200
我们应该对此进行更详细的讨论，因为这是

00:29:50.200 --> 00:29:55.690
使各方能够实施难以实施的事情的口头禅

00:29:55.690 --> 00:30:00.280
像整个DHT之类的东西，并使成为应用程序开发人员的人们

00:30:00.280 --> 00:30:05.340
只是针对这些界面写东西，并允许一个人在一起

00:30:05.340 --> 00:30:09.370
轻松地将这两个插件连接在一起，而无需重新编译任何内容

00:30:09.370 --> 00:30:15.220
必要或不需要在任何地方修改代码

00:30:15.220 --> 00:30:20.770
重新编译库，但是就像我要报告那些库并且我要去

00:30:20.770 --> 00:30:23.950
在我的程序中重新编译它，但我应该能够喜欢连接这些

00:30:23.950 --> 00:30:34.120
像乐高积木一样，我不明白开销和铁锈

00:30:34.120 --> 00:30:37.620
那不是就被编译掉了吗

00:30:48.330 --> 00:30:54.910
我们说白痴我的意思是，让我们走吧，我认为史蒂芬可能是一个好人

00:30:54.910 --> 00:30:58.630
之所以这样做，是因为他来自像铁锈之地，而不是去之类的东西

00:30:58.630 --> 00:31:02.470
否则，他对这些界面已经考虑了很多，所以可能想和他谈谈

00:31:02.470 --> 00:31:11.890
关于它，哇，所以我只想让它适合戴维德，你怎么样

00:31:11.890 --> 00:31:18.360
对于J的感觉就像是如果您有一组接口文件并且

00:31:19.950 --> 00:32:29.850
好的，好的，好的，是的，是的，是的，是的，是的，是的

00:32:32.310 --> 00:32:40.020
人们问有关IP NS的问题，我想描述一下它是如何工作的

00:32:40.020 --> 00:32:49.300
是我们对此感兴趣还是要停止？是的，介意我不只知道

00:32:49.300 --> 00:32:52.530
尽管我已经知道了一点Syd

00:32:52.530 --> 00:32:58.300
还有谁对此夫妇感兴趣

00:32:58.300 --> 00:33:08.830
双手还好，所以像IP LD这样的摘要您拥有内容地址的内容，因此您

00:33:08.830 --> 00:33:16.000
具有表示图中节点的字节序列，该图已链接

00:33:16.000 --> 00:33:21.940
通过哈希，这些哈希表示为字节序列，称为multi

00:33:21.940 --> 00:33:25.600
表示您使用哈希函数的哈希的函数

00:33:25.600 --> 00:33:32.590
计算它，以及如何继续前进，我们将剥离这些库集并

00:33:32.590 --> 00:33:37.720
能够读取此哈希之后的任意数据结构的格式

00:33:37.720 --> 00:33:43.120
链接的事物，以便能够遍历不同域中的链接

00:33:43.120 --> 00:33:50.020
例如，有个很酷的话题，杰里米（Jeremy）展示了摄取所有

00:33:50.020 --> 00:33:55.210
将Z缓存链转换为ipfs，然后可以使用

00:33:55.210 --> 00:34:00.400
路径符号类似于您在文件系统中的方式，就是这样

00:34:00.400 --> 00:34:03.490
通过Y field II，我给你像这个小小的入门书，然后表达

00:34:03.490 --> 00:34:14.310
其余所有IP NS的工作原理是一个名称系统，我们正在映射一个密钥，因此

00:34:14.310 --> 00:34:20.290
公钥后悔公钥，我们将其视为指向一个

00:34:20.290 --> 00:34:26.830
随时间变化的价值，想法是我们需要一些地方来写

00:34:26.830 --> 00:34:33.730
这些记录是正确的，所以如果我想随着时间的推移对名称进行更改，我需要

00:34:33.730 --> 00:34:37.780
能够构造记录，所以我需要将我的私钥与

00:34:37.780 --> 00:34:44.080
公钥写入值，然后在该值上写入签名，然后

00:34:44.080 --> 00:34:49.630
把它捆起来，放在别人可以看的地方

00:34:49.630 --> 00:34:56.920
能够找到并正确解决它，因此在某种程度上类似于DNS

00:34:56.920 --> 00:35:02.560
 DNS不安全且未签名，但具有相同的想法

00:35:02.560 --> 00:35:08.080
就像在您可以使用名称的地方放置一些小指针

00:35:08.080 --> 00:35:15.100
解析名称并正确获取值，因此发现很多

00:35:15.100 --> 00:35:21.640
点对点系统使用这样的想法，即在某些易于记录的地方创建小记录

00:35:21.640 --> 00:35:27.640
为了一整套目的进行加密签名，包括

00:35:27.640 --> 00:35:34.540
广告，例如您应该去看哪个跟踪器，以显示不良行为

00:35:34.540 --> 00:35:41.530
在某些节点中说某个特定节点正在存储所有内容

00:35:41.530 --> 00:35:46.420
各种各样的东西最终沦落到了能够表达一种非常

00:35:46.420 --> 00:35:51.550
在系统中具有有意义语义的小记录，但是通常

00:35:51.550 --> 00:35:58.870
打算张贴在很多人可以看到的地方，所以我们想到了

00:35:58.870 --> 00:36:05.680
就像具有某种价值和某种检查能力的记录类型一样

00:36:05.680 --> 00:36:11.200
与之相关的有效性，因为我们必须取消记录三

00:36:11.200 --> 00:36:18.520
取消带有地址记录的记录，我们有提供者记录，并且我们有名称

00:36:18.520 --> 00:36:26.080
记录，因此该地址记录将是一个向世界发布广告的节点

00:36:26.080 --> 00:36:29.320
有一组特定的地址，并能够将其放置在

00:36:29.320 --> 00:36:36.040
您可以在其中找到提供者记录的世界是一个节点广告

00:36:36.040 --> 00:36:41.020
他们正在存储并愿意分发一些内容，并且

00:36:41.020 --> 00:36:47.260
第三个是一个节点，该节点在某些指针中通告下一个值

00:36:47.260 --> 00:36:50.850
就是这样，这就是我们考虑过的名字

00:36:50.850 --> 00:36:57.970
使用这种记录结构来宣传塞阿拉奶头的签名头

00:36:57.970 --> 00:37:04.270
因此您可以使用完全相同的结构来进行一些公共搜索

00:37:04.270 --> 00:37:09.310
聚会所在的空间创建记录并说嘿，这就像最后一个

00:37:09.310 --> 00:37:16.480
我没有整个日志的值的最后值，然后

00:37:16.480 --> 00:37:20.230
这样，各方就可以找到该记录，然后再找到另一条记录，

00:37:20.230 --> 00:37:22.599
然后找到地址记录，然后连接到他们并唱歌

00:37:22.599 --> 00:37:29.410
如果第四条记录实际上同步，实际上忘记了一个发布/订阅内容

00:37:29.410 --> 00:37:35.920
是冲动的土地，您需要一种宣传渠道和渠道的方法

00:37:35.920 --> 00:37:42.849
会员资格，所以您需要能够说声嘿，我要创建一个公共频道

00:37:42.849 --> 00:37:48.119
在主题X周围，您知道我是这个码头，并且对主题X感兴趣

00:37:48.119 --> 00:37:53.290
所以它与内容非常相似，但是语义有所不同

00:37:53.290 --> 00:37:57.700
因此在史诗般的土地上，我们最终将DHT用于很多东西，但是

00:37:57.700 --> 00:38:02.230
基本的抽象是您拥有所有这些点点滴滴的信息，可为您提供帮助

00:38:02.230 --> 00:38:07.270
团体协调，他们通常是签名，他们通常是

00:38:07.270 --> 00:38:12.130
期望他们会喜欢存在于某个地方，并且将会有很多

00:38:12.130 --> 00:38:17.619
它们是瞬态的，所以我们有一个叫做“记录存储”的东西

00:38:17.619 --> 00:38:24.069
什么真的像修复一样解决所有这些问题，所以给了一个记录存储

00:38:24.069 --> 00:38:28.900
就像您可以处理记录一样，就像我再次

00:38:28.900 --> 00:38:32.710
它指向的东西可能指向其他东西

00:38:32.710 --> 00:38:37.720
它可以被签名，所以任何可以验证的东西都像一个特定的

00:38:37.720 --> 00:38:42.900
鉴于您可以实现命名，因此需要满足的接口

00:38:42.900 --> 00:38:49.270
只需设置值，然后将其发布到任何内容即可轻松进行

00:38:49.270 --> 00:38:57.099
您正在使用的记录存储，因此在DHT情况下，这将是我的PFS节点具有密钥

00:38:57.099 --> 00:39:01.480
价值迹象会制作一条记录，然后将其扔到右侧的DHT

00:39:01.480 --> 00:39:07.390
当场，因此，如果您想解决它，请向DHT索取该记录，然后

00:39:07.390 --> 00:39:10.540
您找到记录，然后就可以使用名称了

00:39:10.540 --> 00:39:14.080
周围有很多问题，您是否得到了该问题的最新版本

00:39:14.080 --> 00:39:18.490
记录是否还有其他的东西，它被沉默了，整整一堆

00:39:18.490 --> 00:39:22.690
嵌入在其中的安全问题，它们也是性能问题

00:39:22.690 --> 00:39:29.109
惠普解决DHT的问题很慢，如果您还

00:39:29.109 --> 00:39:36.369
消失，您的记录可能不会为您重新发布，因此DFC适合

00:39:36.369 --> 00:39:38.859
一些用例，但它并不太好，因为它确实具有很高的性能

00:39:38.859 --> 00:39:43.210
东西，它对于长期持久性没有用，所以对于长期持久性而言

00:39:43.210 --> 00:39:47.349
您可以轻松地获取这些记录并将它们放置在真正持久的位置，即

00:39:47.349 --> 00:39:50.290
像区块链之类的东西，您实际上可以直接将这些记录

00:39:50.290 --> 00:39:54.940
进入区块链并写一个，你可以在任何一个上面写一个记录存储

00:39:54.940 --> 00:39:58.390
区块链，您知道将这些记录丢在以太坊上已经是人们了

00:39:58.390 --> 00:40:04.180
已经这样做了，我想您已经在我们这里进行了实验，他们喜欢

00:40:04.180 --> 00:40:13.780
一个IP NS事物，您将其中的映射和我的定理地址映射到一个名称，以便

00:40:13.780 --> 00:40:15.580
为您提供参与者，但不为您提供高性能

00:40:15.580 --> 00:40:20.830
您实际上可以对待pub / sub的东西，这是一个非常奇怪的记录存储，您

00:40:20.830 --> 00:40:24.849
可以说我要获取最新的价值，然后传播它或发布订阅

00:40:24.849 --> 00:40:28.690
频道，如果某人的收听很好，如果不是，那只是一个

00:40:28.690 --> 00:40:34.020
非常令人难忘，在我发送完之后它就消失了，所以现在使用名称系统

00:40:34.020 --> 00:40:40.450
如果我要更新自己的名字，可以，如果我希望此更新可以持续一个

00:40:40.450 --> 00:40:44.700
很长时间，如果我想要这个名字，我会把它放在像区块链之类的东西上

00:40:44.700 --> 00:40:48.160
坚持中等的时间，我和我不在乎

00:40:48.160 --> 00:40:53.440
性能我将它放在DHT上，或者如果我想让事情真的很快，

00:40:53.440 --> 00:40:56.080
会很快进行大量更新，我不想做任何一个

00:40:56.080 --> 00:40:59.080
我想把它们扔出去的那些弹出来弹出给那些

00:40:59.080 --> 00:41:05.290
现在对这个名字感兴趣，所以如果我们写这个

00:41:05.290 --> 00:41:09.630
接口，其余的东西就可以流出

00:41:10.940 --> 00:41:24.480
问题很多，我看到很多人都在点头，所以实际上你

00:41:24.480 --> 00:41:38.580
也可以在记录类型的唱片商店使用二氧化碳茶，所以我怎么看

00:41:38.580 --> 00:41:46.640
我们只需要同意一下就可以发货

00:41:51.599 --> 00:41:57.449
是的，我是说我认为，很长一段时间以来，我们一直在等待IPL

00:41:57.449 --> 00:42:03.329
语言的东西降落的东西，我不知道什么时候降落，所以如果

00:42:03.329 --> 00:42:11.989
我们只想使用类似山羊的结构之类的东西来定义类型

00:42:11.989 --> 00:42:15.680
我们可以做到这一点

00:42:30.829 --> 00:42:40.440
是的，可能是因为有很多相似的背景

00:42:40.440 --> 00:42:44.099
先生，关于命名的其他问题

00:42:44.099 --> 00:43:00.299
否则见到你非常感谢你非常感谢你来到这里

00:43:00.299 --> 00:43:06.019
像这样的演示取消命名的神秘感仍然很抽象

00:43:47.330 --> 00:43:51.800
所以当我创建一个我自称的对象时，它具有特定的哈希值，因此我可以看一下

00:43:51.800 --> 00:44:00.110
我应该能够在世界上看到的那个物体，它将起作用

00:44:00.110 --> 00:44:05.800
我不知道我不知道这里的自然虚拟故事是什么样的

00:44:07.780 --> 00:44:11.620
好多皮尔斯

00:44:18.230 --> 00:44:29.640
它会融合好吗，所以无论我首先点击哪个网关都找不到我，但是

00:44:29.640 --> 00:44:35.700
现在，它做到了，所以它在那里，现在它在另一台计算机上，现在我可以

00:44:35.700 --> 00:44:46.680
取一个名字，然后我就可以发布哈希作为我的名字，所以这就是创建

00:44:46.680 --> 00:44:50.550
记录将其签名，然后将其发布（在这种情况下，它会将其发布到

00:44:50.550 --> 00:44:57.410
VHD为什么要花这么长时间哦

00:44:58.579 --> 00:45:08.180
就像卡住拨号一样，从理论上讲

00:45:10.790 --> 00:45:20.810
从理论上讲，它可能已经在某些注释中正确了

00:45:27.980 --> 00:45:32.680
是的，主要是卡在那儿

00:45:32.710 --> 00:45:35.829
决不

00:45:38.360 --> 00:45:42.770
我认为我已连接，因为我可能连接到200个节点

00:45:42.770 --> 00:45:51.230
只是真的很慢，您可能都像加密握手一样陷入困境，我们

00:45:51.230 --> 00:46:02.420
现在就去解决吧，我不必刷新，但是如果

00:46:02.420 --> 00:46:05.050
我打了另一个

00:46:08.950 --> 00:46:18.620
他们中没有一个人工作其中一个工作，所以这就像人类无法理解的

00:46:18.620 --> 00:46:25.940
名称正确，因为这些是键，我认为它也具有使用能力

00:46:25.940 --> 00:46:30.350
DNS是名称系统，因此Pierre如何使用这些来填充我们的网站

00:46:30.350 --> 00:46:37.520
因此，如果您访问过我们的任何网站，就像Pierre pad一样，

00:46:37.520 --> 00:46:45.560
普通的HTTP服务器，它是IP节节点，它的工作方式是

00:46:45.560 --> 00:46:50.510
知道您是否像传统浏览器那样跟踪浏览器

00:46:50.510 --> 00:46:56.960
发送一条记录到Pierre pad net，每条记录都不好意思发送DNS查询

00:46:56.960 --> 00:47:04.550
为了记录，我要简短地做，以便您看到它，就像

00:47:04.550 --> 00:47:09.830
我在上面得到Pierre pads的响应，因此浏览器将拨号到

00:47:09.830 --> 00:47:18.890
它会说“嘿”是什么，但是什么也不会返回该IP地址

00:47:18.890 --> 00:47:27.470
不返回任何内容，因为它是一个IP总线节点，因此当您进行HTTP请求时

00:47:27.470 --> 00:47:34.400
浏览器称，当浏览器净化网络时，它还会设置

00:47:34.400 --> 00:47:40.850
HTTP请求权限中的主机标头，因此将主机标头设置为

00:47:40.850 --> 00:47:49.190
对等的Pinet，IFS节点会将其翻译为我没有您

00:47:49.190 --> 00:47:52.220
大家看到了，抱歉，我不能在这里增加字体大小，但这是

00:47:52.220 --> 00:48:01.700
只是IP地址/ IP NS /纯净的网络，并解决了此内容抱歉

00:48:01.700 --> 00:48:09.580
让我反转颜色是，即使有更好的计划，我也有一个计划

00:48:13.990 --> 00:48:18.160
我可以比720小吗

00:48:22.950 --> 00:48:30.540
您可以看到其余的那个正确的IP地址，这样的工作方式是

00:48:30.540 --> 00:48:36.859
ipfs节点自行运行的幕后检测DNS记录检查

00:48:36.859 --> 00:48:58.290
哎呀，按人的标准来行，不行，所以我现在就可以接受，这是怎么回事

00:48:58.290 --> 00:49:04.470
在幕后的是那个名字映射到这个抱歉让我打开一个新的

00:49:04.470 --> 00:49:17.660
标签，这就是我获取此内容的方式，因此我们脱离了普通的人类可读格式

00:49:17.660 --> 00:49:23.609
与某些服务器通信的标准HTTP链接，告诉我们我们想要

00:49:23.609 --> 00:49:29.309
这个名称到达该哈希地址，现在我们可以将其提供给我

00:49:29.309 --> 00:49:35.119
您可以在本地执行此操作，因此请在localhost中查看

00:49:41.500 --> 00:49:45.790
所以这正是我从本地本地Ida本地主机获取的内容

00:49:45.790 --> 00:49:53.530
野鸡，那将是相同的东西，而真正酷的是

00:49:53.530 --> 00:49:58.510
看看它可以在同一垫子上工作，所以让我告诉你我要打开垫子

00:49:58.510 --> 00:50:07.980
这是什么，星期三，嘿，什么

00:50:16.720 --> 00:50:21.880
然后我要使用其余的地址，然后转到localhost和

00:50:21.880 --> 00:50:26.410
查看它，我想我需要以正确的方式打开

00:50:26.410 --> 00:50:40.480
所以隐身模式不起作用是什么，它在过去对我有用

00:50:40.480 --> 00:51:07.319
让我们看看它是否可以正常运行，并不是所有的Firefox都很好，是的。

00:51:25.290 --> 00:51:36.880
我们都在注意一场很短的比赛，我花了很长时间

00:51:36.880 --> 00:51:41.590
我认为那大概是每个发送一个WebSocket的WebSockets

00:51:41.590 --> 00:51:45.640
连接执行加密通道，然后要求该节点中继连接

00:51:45.640 --> 00:51:50.740
到南部颂歌，并使用RSA I在那建立一个加密通道

00:51:50.740 --> 00:52:05.680
认为对，这也只是可能存在的服务器-我们去了Owen

00:52:05.680 --> 00:52:18.340
来到Neto，它确实奏效了，所以三个或全部奏效了，是的，

00:52:18.340 --> 00:52:27.040
易读的i pns东西的工作原理是DNS，您知道不是

00:52:27.040 --> 00:52:33.550
需要重新发明一个新的可读名称系统，还有其他

00:52:33.550 --> 00:52:41.530
像ENS之类的东西都可以做到，关于是的任何问题，是的，不是

00:52:41.530 --> 00:52:47.350
问题，但是在ipfs组织中，我们只是移动了DNS链接

00:52:47.350 --> 00:52:52.150
到今天的激进组织，所以如果您想用自己的方式进行设置

00:52:52.150 --> 00:52:57.130
记录您自己的DNS和东西，您可以在ipfs组织中找到该工具

00:52:57.130 --> 00:53:00.970
谢谢你，斯科特·迪安娜（Scott Deanna sim）哦-你知道弦还是走东西

00:53:00.970 --> 00:53:08.050
通过组织，我们会看到这只是组织

00:53:08.050 --> 00:53:10.650
它应该是

00:53:14.869 --> 00:53:21.510
嗯，是的，我们还没有完成移动，但是他将一分为二

00:53:21.510 --> 00:53:25.619
分钟后，当我决定重新回到笔记本电脑时，

00:53:25.619 --> 00:53:32.990
我认为是两张或两张船票，然后我们还有另外一个简单的吉尼斯（Guinness）

00:53:32.990 --> 00:53:40.380
是的，我的意思是可能应该有一个类似的解决方案

00:53:40.380 --> 00:53:43.859
数字海洋等等等等，真的很喜欢将它们全部合并成

00:53:43.859 --> 00:53:54.569
一个不，它只是一个二进制，是的，基本上是数字海洋

00:53:54.569 --> 00:53:59.430
JavaScript，但是在新工具下，该工具现在正在自动使用

00:53:59.430 --> 00:54:03.630
部署和填充的东西只是战斗机，您刚刚下载了但Petrecca

00:54:03.630 --> 00:54:11.940
储存，但您要做的就是在DNS上设置税收记录的那个

00:54:11.940 --> 00:54:17.130
地址，然后它自然就会在您不走的情况下起作用，您需要设置

00:54:17.130 --> 00:54:25.619
一个指向点或FS网关的记录，是的，这两个记录可能是

00:54:25.619 --> 00:54:30.000
返回两个或三个哦，在任何情况下都可以使居中设置

00:54:30.000 --> 00:54:36.299
别名逃脱-更快的IO点，然后得到like或or public

00:54:36.299 --> 00:54:55.609
网关，是的，所以如果您的其他插孔还可以，则可以为您完成所有操作

00:54:56.569 --> 00:55:06.319
是的，这就是我们所有网站对此的任何其他疑问，或者

00:55:06.319 --> 00:55:13.230
每个人都知道这不是如何工作的吗，是的，我们去了

00:55:13.230 --> 00:55:20.760
您是否谈到过洪流表现如何，目前如此

00:55:20.760 --> 00:55:26.630
IDHD对DHD的承诺因各种原因而糟透了

00:55:27.420 --> 00:55:32.890
这就是为什么现在在体外受精中有一个实验性标志可供使用

00:55:32.890 --> 00:55:38.349
pop sub用于真正快速的更新，但是如果您不这样做，那是行不通的

00:55:38.349 --> 00:55:43.930
长期来看，你希望它成为

00:55:43.930 --> 00:55:47.680
坚持进入区块链或类似的东西以允许长期

00:55:47.680 --> 00:55:53.859
命名为要发生的事情是一个整体，就像一个小小的一样

00:55:53.859 --> 00:56:30.069
派，我们应该让这些不同的出版商，但我不知道

00:56:30.069 --> 00:56:36.730
正常的DNS名称，那么无论通过了什么访问策略DNS，它都将失效

00:56:36.730 --> 00:56:42.250
更改DNS记录，然后您可以使用另一个名称更改名称

00:56:42.250 --> 00:56:47.130
密钥名称不是人类可读的，那么它就是拥有私钥的人，因此

00:56:47.130 --> 00:56:52.329
在这种情况下，这是我的节点，所以我在这里有密钥，您只需要分享

00:56:52.329 --> 00:57:02.740
是另一方的密钥是密钥，您也可以发布IP NS记录

00:57:02.740 --> 00:57:08.109
首先，您具有节点标识T，这大概是之前使用的，但是

00:57:08.109 --> 00:57:11.289
那么您也可以正确地编写新密钥，因为如果您认为使用

00:57:11.289 --> 00:57:16.809
相同的节点ID密钥或多个混淆的节点，但是如果您

00:57:16.809 --> 00:57:19.930
生成一个新密钥，您可以在此处共享该密钥，并且多个人可以使用该密钥

00:57:19.930 --> 00:57:25.089
像同一个网站一样进行更新的密钥，但它应该是一个新密钥，而不是自身

00:57:25.089 --> 00:57:34.529
关键，你是否等着做ki jaana嗯，是的，关键在ipfs关键

00:57:56.359 --> 00:59:11.819
是的，现在卡住了，因为它在移动DHD时正在设置

00:59:11.819 --> 00:59:14.670
建立了一大堆新连接，其中一些节点不可行，

00:59:14.670 --> 00:59:17.790
现在，拨号操作可能会花费很长时间

00:59:17.790 --> 00:59:21.660
因为它将尝试许多地址，直到停止为止，这就是原因

00:59:21.660 --> 00:59:23.819
它完全像它那样被大脑破坏了

00:59:23.819 --> 00:59:31.020
可能会更快，它只是卡在那等着，很快

00:59:31.020 --> 00:59:38.760
其他许多事情将大大加快这一步，所以这是

00:59:38.760 --> 00:59:42.140
越野车需要修复

00:59:44.180 --> 00:59:50.750
有人问所有这些IPA工程问题答案

00:59:56.110 --> 01:00:03.410
还没有结束共和国，我们再也见不到这个梦想了，是的

01:00:03.410 --> 01:00:07.220
你想让维斯塔什么都没有吗？我昨天谈到了这个吗？

01:00:07.220 --> 01:00:12.080
一点点，但基本上很好，你想知道我重申这个问题吗？

01:00:12.080 --> 01:00:18.050
是关于HDPE与快速的关系，我只是在重复我所理解的

01:00:18.050 --> 01:00:21.800
在这里，我认为speedy已被弃用，但如果我理解正确，我们就无法

01:00:21.800 --> 01:00:29.530
由于某些原因，我们不能使用HTTP 2，它应该是继任者

01:00:29.630 --> 01:00:40.910
哦，首先，还没有HDPE的节点包，第二个问题是

01:00:40.910 --> 01:00:46.460
NAT遍历更加困难，并且还没有办法将其与TLS一起使用

01:00:46.460 --> 01:00:53.200
1.3这对我们来说是一项要求，因为我们不想拥有CA

01:00:53.530 --> 01:00:58.640
说最终发表，但是的，我认为它也捆绑在一起

01:00:58.640 --> 01:01:02.930
一堆来自HTTP领域的东西，我们可以忽略，但这不是

01:01:02.930 --> 01:01:12.820
琐碎的是，我的意思是NGO使用yeah MOX与其他go节点进行对话，然后使用

01:01:12.820 --> 01:01:23.090
em Plex与节点多路复用，我认为是的，所以有两个

01:01:23.090 --> 01:01:26.870
如果我们找到与我们兼容的东西，就会出现不同的混音器

01:01:26.870 --> 01:01:31.460
贾斯（Jas）和我们发现，从生锈到后来，还有其他兼容的东西

01:01:31.460 --> 01:01:34.820
它会起作用，我们希望它会变得如此简单

01:01:34.820 --> 01:01:39.290
就像说哦，是的，应该使用它-我们已经学会了非常困难的方法

01:01:39.290 --> 01:01:45.980
shree混音器不容易实现，当您拥有它们时，它们会非常棘手

01:01:45.980 --> 01:01:50.360
数百到数千个流，并且连接寿命长，并且大多数

01:01:50.360 --> 01:01:53.810
我们曾经以某种方式发现我们的错误的实现，我们会固定数字

01:01:53.810 --> 01:01:58.250
在我们发现的大多数实现中，我们对它们的要求很差

01:01:58.250 --> 01:02:04.490
我们希望quick可以解决很多问题，因为quick是一个标准，

01:02:04.490 --> 01:02:09.320
很多人都转向我不会将任何h-2b打赌到实现上

01:02:09.320 --> 01:02:12.910
因为我不认为htv-2实现是

01:02:12.910 --> 01:02:20.990
像我们那样经过成千上万的流，我不认为我

01:02:20.990 --> 01:02:26.960
意思是我要说的是我们可以尝试一下，这很可能是我们的实现

01:02:26.960 --> 01:02:32.780
使用将是有问题的，因此修复这些bug将会花费很长的时间

01:02:32.780 --> 01:02:36.319
可以做的只是寻找我们是否要解决要修复的虫子和卵子的问题

01:02:36.319 --> 01:02:41.480
我们将尽快修复错误，所以我认为对不起Sudha提出了问题

01:02:41.480 --> 01:02:49.010
我们希望Quick成为95％的主要案例，但我们需要一个TCP

01:02:49.010 --> 01:02:54.640
回退到另一个，然后我认为这个问题出现了

01:03:38.920 --> 01:03:58.329
这是语言

01:04:36.220 --> 01:04:44.440
[音乐]

01:05:09.020 --> 01:05:14.190
所以您认为从规范的角度来看，我们应该像每个人一样

01:05:14.190 --> 01:05:18.180
输入任何实现，需要实现任何有效的实现

01:05:18.180 --> 01:05:53.130
快速且至少满足以下条件之一，它是TCP传输的列表，因此

01:05:53.130 --> 01:05:58.200
让p2p本身在理论上不需要任何内容​​，是的，可以，因为它

01:05:58.200 --> 01:06:01.440
可以要求您实施任何转帐，因为它不存在

01:06:01.440 --> 01:06:07.380
是的，首先，您可以，所以巡演我真的不，我不认为

01:06:07.380 --> 01:06:13.080
游览会进行流多路复用，如果您得到一个可靠的流，但这是

01:06:13.080 --> 01:06:17.700
如果人们广泛使用Tor，他们可能会

01:06:17.700 --> 01:06:24.180
最终将其沉入较低的层中，所以这将是

01:06:24.180 --> 01:06:28.530
像Tor一样的东西，您可以访问与tor和一起使用的键

01:06:28.530 --> 01:06:32.910
你可能会给你流混合，所以你不需要管道其他流

01:06:32.910 --> 01:06:38.250
框或顶部，所以我们需要深入了解

01:06:38.250 --> 01:06:45.600
流多路复用是整个连接与连接的重要组成部分

01:06:45.600 --> 01:06:48.750
实现会有所不同，有时较低级别的协议会将其交给

01:06:48.750 --> 01:06:54.300
如果我们使用了真正的SCTP连接，例如，您和您有时会不喜欢SCTP

01:06:54.300 --> 01:06:57.450
 rah而不是像通过工作那样，我们可以使用街道标记

01:06:57.450 --> 01:07:02.700
马上就可以了，还有其他传输协议也可以做到这一点，因此

01:07:02.700 --> 01:07:06.750
就像现在的错误一样，仅仅是因为这些

01:07:06.750 --> 01:08:49.529
实现非常难，而且您知道汇编，所以我的意思是

01:08:49.529 --> 01:08:53.250
直接去，以便一些主要的努力实现直接去http

01:08:53.250 --> 01:08:56.790
到应该变得非常健壮快速，并且有多个快速

01:08:56.790 --> 01:08:59.790
每个实现都与实现不同的实现，是的，最大，我们

01:08:59.790 --> 01:09:05.160
使用和使用原本是快速重新实施​​，而他们只是放弃了

01:09:05.160 --> 01:09:10.250
一些东西，就是那样，只是略有不同

01:09:34.520 --> 01:09:50.670
好的stim盲目快速每个人都快点去问Mozilla公开密钥

01:09:50.670 --> 01:09:57.090
我的意思是，IETF将于今年年底前实现银行标准化，因此

01:09:57.090 --> 01:10:03.180
浏览器供应商，也许这就是我们快速马丁公司的人告诉我的，所以他在

01:10:03.180 --> 01:10:24.150
Martin委员会正在进行的IETF快速标准化是和

01:10:24.150 --> 01:10:27.660
然后是浏览器供应商，因为渲染是像yeah这样的核心

01:10:27.660 --> 01:10:31.410
实际上要做标准化和实施的工作，

01:10:31.410 --> 01:10:38.460
他们会如此，所以我不希望所有的事情都像我一样发生几年

01:10:38.460 --> 01:10:45.000
认为我们会很快使用并进入节点，我们会很快

01:10:45.000 --> 01:10:51.000
在Chrome和Firefox的内部，但不是我们可以使用的方式

01:10:51.000 --> 01:10:54.810
从浏览器看来，它看起来像Web RTC

01:10:54.810 --> 01:10:58.500
我的意思是也许网站cuz不知道他们是否会将其公开给WebSockets

01:10:58.500 --> 01:11:10.100
他们可能会喜欢快速吸吮的东西，不，不，那就像是一团糟

01:11:20.849 --> 01:12:07.079
我们有，因为是的，埃里克（Eric）发送了

01:12:10.559 --> 01:12:17.260
在用户库上尝试操作传输以使其成为

01:12:17.260 --> 01:12:23.289
传输大量文件数据（例如词组）的效率更高，如果

01:12:23.289 --> 01:12:27.010
有一条说明支持电子运输

01:12:27.010 --> 01:12:59.739
我可能会尝试最受支持的一个或一个，但如果有的话

01:12:59.739 --> 01:13:10.599
一种更快的方式，很多控制器从连接中切断

01:13:10.599 --> 01:13:15.659
我们使用的是我们没有使用的

01:13:21.809 --> 01:13:28.840
因此，当我们制作包装时，其中一些可能会变得容易得多

01:13:28.840 --> 01:13:34.389
切换脂质oopy中的内容，因为我们将能够摆脱很多

01:13:34.389 --> 01:13:40.630
沿途有很多抽象协议，例如DFG协议

01:13:40.630 --> 01:14:10.179
等等可能完全是面向数据包的，是的，有时可能是

01:14:10.179 --> 01:14:13.300
现在有点困难，我们将不得不考虑语义

01:14:13.300 --> 01:14:19.270
撒谎的能力能够像按协议一样在协议上移动

01:14:19.270 --> 01:14:25.270
我们建立了两个连接，然后像DHD屏幕一样移动

01:14:25.270 --> 01:14:30.340
在飞行中流媒体或某些我们无法轻易中断的内容，因为那时我们

01:14:30.340 --> 01:14:34.599
弄乱了高层协议的语义，所以我们将有

01:14:34.599 --> 01:14:38.290
希望能够准确地暂停视频流，然后在

01:14:38.290 --> 01:14:42.099
另一面，或者只是说那条流一直停留在那条，新的流得到了

01:14:42.099 --> 01:14:46.690
在这里生成脂质Opie可以透明地处理所有这些问题，就像

01:14:46.690 --> 01:14:50.349
它可以使用两个连接，然后以某种方式将它们多路复用

01:14:50.349 --> 01:14:54.550
不知道会有两个潜在的联系

01:14:54.550 --> 01:14:58.030
能够同时使用和，并且最初的梦想之一是能够使用说

01:14:58.030 --> 01:15:02.980
就像我的有线连接和无线同时喜欢增加

01:15:02.980 --> 01:15:08.440
应用程序的吞吐率，这并不是您完全可以做到的，而我

01:15:08.440 --> 01:15:12.760
甚至都没有注意到，但是苹果使用它使用的一些应用程序来做到这一点。

01:15:12.760 --> 01:15:21.010
既有LTE，有时也有无线，所以一旦我们收到其中一个数据包，

01:15:21.010 --> 01:15:23.969
从我的角度来看，一旦我们进行了数据包交换，这将变得更加容易

01:15:23.969 --> 01:15:27.730
当您没有数据包交换而您正在做时，这很难做

01:15:27.730 --> 01:15:33.280
它具有您无法真正控制的流连接，例如快速或

01:15:33.280 --> 01:16:59.340
WebRTC会因为您而变得更难，所以您真正需要的是

01:16:59.340 --> 01:17:03.780
发短信

01:17:25.040 --> 01:18:17.940
是的，我们明天应该尝试这样做吗

01:18:17.940 --> 01:18:24.510
Pippi Liberty是其中很多不酷的东西

01:18:24.510 --> 01:18:30.030
并没有真正依赖我们其他很多东西，所以很多ipfs最终

01:18:30.030 --> 01:18:33.630
就像是依靠上诉交易或流动性交易

01:18:33.630 --> 01:18:38.610
等等，因此很难将其全部借给立普妥（Lipitor）

01:18:38.610 --> 01:18:43.410
完全独立的想法，可以独立构建，因此您

01:18:43.410 --> 01:18:47.880
知道这几乎就是我写的，就像在为

01:18:47.880 --> 01:18:51.690
去脂质OJ的脂质饲料或类似的东西

01:18:51.690 --> 01:18:57.210
可能就像完全自成体系，然后将其构建并交付使用，您知道

01:18:57.210 --> 01:19:03.780
如果ipfs导入的话，这是一个单独的问题，那么我们就是希望

01:19:03.780 --> 01:19:07.260
我可以让我们变得胖乎乎的是，我们拥有所谓的

01:19:07.260 --> 01:19:13.060
这些ID等，然后人们会喜欢随着时间的推移攻击其中一些

01:19:13.060 --> 01:19:17.830
是的，伙计，所以我们应该考虑我们想过多少个PETA依赖项

01:19:17.830 --> 01:19:22.990
竞争能够拥有，取决于IPL d类型，我们可以接受吗

01:19:22.990 --> 01:19:26.770
就像那是我们所展示的，我的意思是我不知道这是一个推销

01:19:26.770 --> 01:19:31.090
这是一个很好的好问题，是的，我没有答案，但我认为

01:19:31.090 --> 01:19:35.500
记录真的归结为我们是否想要记录存储的东西

01:19:35.500 --> 01:19:42.820
正式成为p2p的一部分，我们认为应该出于很多原因

01:19:42.820 --> 01:19:50.740
如果您获得IPL，那将变得容易得多，可以说一点

01:19:50.740 --> 01:19:55.290
关于为什么您认为它应该是p2p的一部分，目前尚不清楚，因为

01:19:55.290 --> 01:20:07.150
像是的东西，所以这真的是因为

01:20:07.150 --> 01:20:13.390
记录存储区我无法实现内容路由器或

01:20:13.390 --> 01:20:18.520
对等路由器或对等发现等等在任何记录存储之上等等

01:20:18.520 --> 01:20:24.070
如果系统实现了记录存储接口，就变得很像

01:20:24.070 --> 01:20:27.340
然后您就可以得到几乎所有其他一切，然后看到一个高峰

01:20:27.340 --> 01:20:33.990
因此，它变得有点像最坏的情况，您可以得到

01:20:33.990 --> 01:20:38.710
您想要的所有内容，就像他们不愿意使用的那样，

01:20:38.710 --> 01:20:45.040
如果他们拒绝实施诸如sub和DHT之类的其他方式，是的

01:20:45.040 --> 01:20:50.440
还有另一种方式，例如DHT可以让您发现同伴

01:20:50.440 --> 01:20:54.460
开箱即用的功能使您可以对等路由开箱即用，并为您提供记录存储

01:20:54.460 --> 01:20:58.960
开箱即用，它并不能为您提供内容发现功能，我们只是

01:20:58.960 --> 01:21:03.910
通过将内容发现记录放在这些记录之上，在其之上实施该记录

01:21:03.910 --> 01:21:12.940
记录服务器，我认为还不错，所以记录存储必须依靠

01:21:12.940 --> 01:21:21.470
IP LD类型um只是试图找出什么蓝色

01:21:21.470 --> 01:21:27.800
绝对最小的兔子好有趣，李，我觉得他因为这个而存在

01:21:27.800 --> 01:21:33.080
事情，所以我们正在考虑这些东西，我们就像哦，人

01:21:33.080 --> 01:21:37.570
突然您有不同的记录，并且它们可能由不同的密钥签名

01:21:37.570 --> 01:21:44.150
具有不同的有效性算法，例如您知道名称已签名，但就像

01:21:44.150 --> 01:21:48.440
您可能想要证明内容发现的东西是您拥有的

01:21:48.440 --> 01:21:51.620
除了散列之外的内容，您实际上可能希望能够

01:21:51.620 --> 01:21:57.170
生成证明，以便您指出时有很多可能性

01:21:57.170 --> 01:22:03.320
记录中的代码，所以我们可以将记录中的代码放入代码中，然后您

01:22:03.320 --> 01:22:06.620
想要验证您想要验证的数据结构，所以您

01:22:06.620 --> 01:22:13.520
想要立即成为IPL交易，那就可以了，让我们停止吧

01:22:13.520 --> 01:22:18.290
去弄清楚这个，然后再回来做，就像在哪里

01:22:18.290 --> 01:22:25.310
这是从哪里来的，所以让我问，我应该深深地融入其中吗？

01:22:25.310 --> 01:22:30.110
就像我猜是实验室嬉皮士进口的，但我的意思是作为一个项目

01:22:30.110 --> 01:22:36.590
就像我自己制造自己的产品一样，这是否有意义

01:22:36.590 --> 01:22:45.680
好吧，不，是的，我们会说这就像是范围扩大的方式一样，是的

01:22:45.680 --> 01:22:48.110
只是尝试去感受差异，我知道这是很有意义的

01:22:48.110 --> 01:22:52.970
我的意思是，这是随着时间的推移而演变的，因为我们试图

01:22:52.970 --> 01:22:56.780
关于如何处理这些事情的越来越深入的更基本的问题

01:22:56.780 --> 01:23:09.250
工作，还不清楚对不起克莱尔，是的，我的意思是

01:23:10.480 --> 01:23:17.180
如果我们正确地获得了记录存储抽象，并且我们有能力

01:23:17.180 --> 01:23:23.180
用我们可以编写的任意函数定义新的记录类型，然后就可以

01:23:23.180 --> 01:23:29.990
像CRT团队那样直接合并成一堆，就可以完成很多工作

01:23:29.990 --> 01:23:36.830
那里有很多有趣的东西，所以这很漂亮，我不知道这很难

01:23:36.830 --> 01:23:44.180
别掉进去的兔子洞确实有意义，就像

01:23:44.180 --> 01:23:52.760
馅饼看起来真的很好，那么你就像哦，男人，你现在已经像斯蒂芬斯那样倒下了

01:23:52.760 --> 01:24:34.970
是已经落在那里，是的，更容易编写将dhts之类的内容

01:24:34.970 --> 01:24:39.830
就像HP有时具有某些条件并能够定义它们

01:24:39.830 --> 01:24:44.480
记录下来，并为您做好一切准备，现在我想

01:24:44.480 --> 01:24:49.490
困难的部分是我们正在尝试现在有一点点，我们想使用

01:24:49.490 --> 01:24:54.590
现在，所有这些IP所有这些东西都还不存在，那就是

01:24:54.590 --> 01:24:58.580
像我们是否拥有IPL DNA这样的问题很好，并且祝福并说

01:24:58.580 --> 01:25:02.840
protobuf他们会像是的，为什么不听起来很棒

01:25:02.840 --> 01:25:08.660
所以我想我们可能会做些什么，我想知道我们是否应该搬家

01:25:08.660 --> 01:25:11.720
继续在C板上定义它们，然后处理

01:25:11.720 --> 01:25:19.850
后来我很抱歉，像我们已经剥离了格式

01:25:19.850 --> 01:25:31.010
然后在C钻孔器上，这样我们就可以朝这个方向前进

01:25:31.010 --> 01:25:36.740
仍然使用该API，我的意思是，嗯，这在Stephen和我之间被阻止了，

01:25:36.740 --> 01:25:44.450
其他人想出理想语言l0然后就可以猜出什么

01:25:44.450 --> 01:25:48.920
你真正想要的是能够写这样的东西哦，天哪

01:25:48.920 --> 01:26:04.060
我在哪里，你想喜欢在哪里定义这样的东西，哦

01:26:04.060 --> 01:26:10.970
实际上，这只是一个签名的记录，就像我想的那样，考虑到

01:26:10.970 --> 01:26:16.250
签名记录，我能够进行签名检查，然后像您一样

01:26:16.250 --> 01:26:21.530
就像DHD一样，它可以实现一些功能，

01:26:21.530 --> 01:26:32.450
我说这不是一个很好的例子，也许这样，您就可以喜欢

01:26:32.450 --> 01:26:37.640
在任何记录存储的顶部实现名称系统，因此像您一样给定

01:26:37.640 --> 01:26:41.890
记录，以便您可以像

01:27:06.940 --> 01:28:04.270
如此微不足道，就像真的真的很容易，所以这就是为什么

01:28:04.270 --> 01:28:08.110
一种高阶像哦，已经摄入的液体P

01:28:08.110 --> 01:28:12.520
所有网络世界和所有

01:28:12.520 --> 01:28:16.620
对等世界还吸收了所有哈希链世界的所有复杂性

01:28:16.620 --> 01:28:23.320
像耶稣，是的，您会看到我从中看到的景象，就像我想要的一样

01:28:23.320 --> 01:28:27.880
我要对P进行规范吗？

01:28:27.880 --> 01:28:33.340
实施Lippe必须要做的事必须实现B，而C可能要实现

01:28:33.340 --> 01:28:38.230
XY和Z就是这样，我只是想知道唱片是否存储了它

01:28:38.230 --> 01:28:42.699
将大量商品归类为“必须”类别，也许应该在“必须”类别中

01:28:42.699 --> 01:28:51.010
不适用类别或是的，我只是是的，这不仅使

01:28:51.010 --> 01:28:55.870
实施比较复杂，但对于尝试学习肢体p2p的人来说

01:28:55.870 --> 01:29:01.210
这就像是他们需要绕着头包的一整套全新事物

01:29:01.210 --> 01:29:07.030
感觉他们了解EDP循环是的，所以是的，这些是

01:29:07.030 --> 01:29:10.180
我现在有想法，我不需要这个，是的，它使更多

01:29:10.180 --> 01:29:14.820
我觉得很多

01:29:16.840 --> 01:29:20.920
回到这个像类的东西

01:29:22.390 --> 01:29:31.960
让我们将其全部放在一个文件中，是的，这会很好

01:29:49.909 --> 01:30:01.679
等等，我认为这些评论是有帮助的，我几乎想摆脱

01:30:01.679 --> 01:30:07.520
这摆脱了开关好吧，是的，就像引擎盖下一样，但是我

01:30:07.520 --> 01:30:12.179
意思是我不知道如果我们揭露它就像是个顽固的家伙，那整个就是这样

01:30:12.179 --> 01:30:19.350
像拔掉胆量，所以我几乎像去掉它，是的，我的意思是

01:30:19.350 --> 01:30:23.310
试图在盖子p2p上编写应用程序的人的人只是想要

01:30:23.310 --> 01:30:28.380
实例化一个节点，我不认为他们想要，他们不想知道如何

01:30:28.380 --> 01:30:33.179
笔记工作正常，是的，我想他们想安装一个协议，并且他们想

01:30:33.179 --> 01:30:36.270
连接到笔记，这就是我的意思是他们甚至想要访问

01:30:36.270 --> 01:30:42.780
例如纯商店，他们可能需要告诉节点有关Pierce的信息

01:30:42.780 --> 01:30:48.659
好吧，有点像嘿，请确保连接到此端口，他们可能需要告诉

01:30:48.659 --> 01:30:56.850
他们关于地址，我想我想可能不是我不知道我是

01:30:56.850 --> 01:31:01.650
只是大声思考而已，也许我可以做的就是

01:31:01.650 --> 01:31:05.340
真正看我所拥有的所有联系，那是真的，那是真的

01:31:05.340 --> 01:31:15.810
这是该死的开关的所在，是这样的开关，带来了所有这些

01:31:15.810 --> 01:31:25.219
有关连接的其他信息，我想我们确实需要流，我们需要黄色流

01:31:27.469 --> 01:31:31.280
您拥有整个口译员

01:31:37.179 --> 01:31:42.030
我真的很喜欢杀人

01:31:51.949 --> 01:32:28.530
计数的不是文档数量，而是清晰度，这可能就是我们

01:32:28.530 --> 01:32:33.239
我想在围棋上工作，并在进行防锈游戏时做的也一样，我认为围棋就是这样

01:32:33.239 --> 01:32:37.500
主持人，但我认为这基本上是相同的想法，就像主持人一样

01:32:37.500 --> 01:32:50.370
需要重命名为节点，是的，我同意，是的，我想你可以传递给

01:32:50.370 --> 01:32:55.830
构造函数将覆盖此默认值的东西，我知道他们已经

01:32:55.830 --> 01:33:24.110
在构造函数上做了一些工作，例如相对的，是的，这是好的，这

01:33:28.110 --> 01:33:31.229
[音乐]

01:33:32.989 --> 01:33:42.060
你在这里没有痛苦，如果我们有这个并且喜欢

01:33:42.060 --> 01:33:47.610
一些中立的理想格式的想法，然后每种语言都必须

01:33:47.610 --> 01:33:52.440
遵守它我不知道我认为会有很多好处

01:33:52.440 --> 01:33:56.730
想要实施的人会更容易学习如何使用

01:33:56.730 --> 01:34:02.010
库，如果我们有相同类型的标准化接口来喜欢编写一个

01:34:02.010 --> 01:34:08.100
运输然后有人想要写世界上第一个你知道莫尔斯

01:34:08.100 --> 01:34:11.910
代码收发器传输器，我们每当有疯狂的事情出现，是的，你知道他们

01:34:11.910 --> 01:34:16.100
可以用Jay rust编写它，并且可以进行有病的编程，这是相同的

01:34:16.100 --> 01:35:07.020
伙计们，是的，是的，是的，我不知道秋天好，我们经过测试，我的意思是

01:35:07.020 --> 01:35:10.980
只要我们看到一种语言未能实现该标准，就可以

01:35:10.980 --> 01:35:17.969
我们只是开始用这种语言说，嘿，是的，是的，我是说

01:35:17.969 --> 01:35:23.280
那里应该有两个不同的测试通道

01:35:23.280 --> 01:35:27.210
首先，您有一个在自己的项目中断言的测试，

01:35:27.210 --> 01:35:30.420
东西在起作用，那为什么不能每次都改变，但是那你应该

01:35:30.420 --> 01:35:35.310
每次接口更改时，从接口端也有

01:35:35.310 --> 01:35:39.360
推出测试或其他项目，以便他们可以修复它们，然后

01:35:39.360 --> 01:35:43.050
像打开一个问题，是的，这是测试失败，您需要像这样解决

01:35:43.050 --> 01:35:46.389
尽快，但它们是正常的，帐单仍会编译

01:35:46.389 --> 01:35:50.889
他们正在使用的版本，但我们仍然提供该版本，以便他们可以使用

01:35:50.889 --> 01:35:55.420
那东西，但也很棘手，就像我们有许多不同的语言

01:35:55.420 --> 01:35:59.860
使用Cori实现很容易，因为我们通常是通过HTTP IPR

01:35:59.860 --> 01:36:04.360
我们不能以一种非界面的方式进行操作，否则您需要

01:36:04.360 --> 01:36:10.330
除非我们使用hacks之类的东西，否则用本国语言编写测试

01:36:10.330 --> 01:36:17.290
这样，我们可以将测试编译为JavaScript或go，我认为

01:36:17.290 --> 01:36:24.340
我们认为我们可以编写一个连接到实时运行的测试套件，因此

01:36:24.340 --> 01:36:30.130
如果您有一个正在运行的Lapita PE节点，是的，那么一个测试实现

01:36:30.130 --> 01:36:43.659
可以探测它，就像放置节点一样，您喜欢启动命令行客户端，然后

01:36:43.659 --> 01:36:49.630
然后它像finds报告告诉您绑定到哪些端口，是的，我想您是

01:36:49.630 --> 01:36:52.600
对，对，我们可以做一个CLI测试的程序

01:36:52.600 --> 01:36:56.350
确保零相同，我们可以进行HTTP测试以确保

01:36:56.350 --> 01:37:00.790
HTTP API是相同的，但是当我们像核心定义那样执行时

01:37:00.790 --> 01:37:05.590
我们要么喜欢对其进行编译的编程API

01:37:05.590 --> 01:37:10.600
语言或类似DSL上的发明人，就像Jam oh，我很聪明，或者很聪明

01:37:10.600 --> 01:37:17.080
就像测试用例生成器一样，这就是这个东西所在的位置

01:37:17.080 --> 01:37:28.780
是的，是的，所以我们必须为每个代码编写一个代码gem

01:37:28.780 --> 01:37:33.369
像嵌套这样的语言，它也可能在您的测试中，对我来说，

01:37:33.369 --> 01:37:37.449
已经存在，作为我们的上限之一，例如，您知道我

01:37:37.449 --> 01:37:40.719
不，我不知道它是否对我们有用，您认为它确实成功了吗？

01:37:40.719 --> 01:37:44.230
盖尔（Gayle）当然可以，但是使用这些较低级的语言，例如激烈的人

01:37:44.230 --> 01:37:49.469
我真的很想严密控制我，不知道你们喜欢使用很多gen代码

01:37:49.469 --> 01:37:53.980
是的，似乎你永远不会，我不知道你知道你知道我的意思是我

01:37:53.980 --> 01:38:04.980
可以看到人们想要的，是的，我不知道，是的，

01:38:04.980 --> 01:38:10.860
用一种语言测试编程接口，因为那是一种语言

01:38:10.860 --> 01:38:20.350
实现将要使用惯用约定，是的，我们

01:38:20.350 --> 01:38:26.050
可以做的就是定义这是我们可以做的，我们可以定义一个标准

01:38:26.050 --> 01:38:32.860
我们可以测试的界面在任何

01:38:32.860 --> 01:38:35.800
惯用接口就像语言实现者编写的

01:38:35.800 --> 01:38:41.170
惯用的东西，然后我们围绕它写一个小包装

01:38:41.170 --> 01:38:45.040
所有正确的方法，因此，如果他们不能满足这些要求，那就有

01:38:45.040 --> 01:38:49.210
她在基础事物上缺少一些东西，就像映射

01:38:49.210 --> 01:38:53.130
从惯用的版本到标准化的版本，我认为这可能行得通，然后

01:38:53.130 --> 01:38:57.610
高性能程序只会使用好吃的东西找到惯用的界面

01:38:57.610 --> 01:39:04.540
是的，所以您基本上会像将CLI像库一样包装成这样

01:39:04.540 --> 01:39:08.710
例如，使用多哈希，您将包装一个CLI，然后定义CLI

01:39:08.710 --> 01:39:16.150
界面，然后希望是这样的，是的，我的意思是我不知道是什么

01:39:16.150 --> 01:39:24.810
是CLI本身，但是是的，是一个强有力的帮助，我们可以称之为是

01:39:24.810 --> 01:39:31.090
那就是你在提议的权利，是的，是的，我的意思是当我提议时

01:39:31.090 --> 01:39:34.150
不完全是海洋生物，但是就像我想你知道的那样，是的，就像

01:39:34.150 --> 01:39:38.710
人们使用的自动版本以及其他版本

01:39:38.710 --> 01:39:43.180
只是一个小文件，可以映射事物，还可以对类型进行按摩

01:39:43.180 --> 01:39:46.570
一点点，但应该能够通过测试，如果通过了测试

01:39:46.570 --> 01:39:49.390
那么底层实现不太可能是错误的

01:39:49.390 --> 01:39:54.520
所以它们都是编程接口，但是其中一个是专门为

01:39:54.520 --> 01:39:57.690
通过一系列测试是

01:40:06.090 --> 01:40:13.330
是的，但是不能理解约束是一种语言

01:40:13.330 --> 01:40:17.440
实现者将要更改存根并更改接口

01:40:17.440 --> 01:40:20.950
因为这对我们来说就是那门语言

01:40:20.950 --> 01:41:09.580
尝试做是的，是的，我认为这是一个更高的水平，就像

01:41:09.580 --> 01:41:18.840
是的，这是黄瓜，就像一种语言，可以为用户描述类似的情况，因此

01:41:19.980 --> 01:41:27.160
这样可能对CLI测试之类的其他事情很有用，但是

01:41:27.160 --> 01:41:32.010
也许不是核心界面的东西

01:41:52.330 --> 01:42:06.760
是的，如果您想玩一下它，看看是否像火柴一样

01:42:06.760 --> 01:42:09.260
无论如何，这基本上是一种映射方式

01:42:09.260 --> 01:42:21.040
句子编码是的，就像

01:42:29.140 --> 01:42:37.970
是的，但我想这不是，这与我们当时的情况有些不同，是的，我

01:42:37.970 --> 01:42:41.890
不要以为这是什么，因为我们不担心

01:42:41.890 --> 01:42:48.380
描述接口的人员，我们只希望程序员就和达成共识

01:42:48.380 --> 01:42:57.380
你的脸哦，等等，我们可以有更多的IDL，更像是代码，是的，我认为

01:42:57.380 --> 01:43:05.690
没错-是的，因此Mike尚未进行HTTP和CLI测试

01:43:05.690 --> 01:43:10.970
就像推断核心实现已经具有可用

01:43:10.970 --> 01:43:18.040
正确的方法，例如为什么我们要尝试通过核心接口实现

01:43:18.040 --> 01:43:23.950
对于JavaScript而言，程序化的东西很有意义，因为API和核心

01:43:23.950 --> 01:43:30.860
协议和实际代码，但您可以调用相同的方法

01:43:30.860 --> 01:43:38.930
语言甚至没有意义，原因是如果某人是

01:43:38.930 --> 01:43:43.790
应用程序编写者，他们正在跨语言编写东西

01:43:43.790 --> 01:43:48.410
对于他们来说，拥有相同的匹配接口会很有用

01:43:48.410 --> 01:43:51.740
语言，以便能够轻松地将其应用程序从一种语言移植到

01:43:51.740 --> 01:43:56.119
另一个无需学习一套全新的说明

01:43:56.119 --> 01:44:02.929
但是对于像HTTP和CLI这样的实现，则不应该这样

01:44:02.929 --> 01:44:08.630
通过嵌入节点来添加一些东西，例如，我承认嵌入了已点燃的p2p

01:44:08.630 --> 01:44:12.710
本身就是节点，是的，它不会使用命令库

01:44:12.710 --> 01:44:21.500
或或或HTTP，它将直接嵌入功能，我当时

01:44:21.500 --> 01:44:25.909
只是会说他有一个有趣的观点，就像想象一个开发商店

01:44:25.909 --> 01:44:29.750
说我们要在他们不期望的iOS和Android上编写相同的应用程序

01:44:29.750 --> 01:44:34.400
他们知道他们有两种完全不同的职业模式，并且使用相同的API

01:44:34.400 --> 01:44:40.699
他们可以这样滑行还是可以，我认为可以，更像是处理它

01:44:40.699 --> 01:45:25.360
然后一直喜欢它，我的意思是说有多少个项目

01:45:34.350 --> 01:45:42.880
[笑声] [掌声]

01:45:42.880 --> 01:45:49.820
但是最后就像我们是否有HTTP相容性介面测试

01:45:49.820 --> 01:45:54.740
这个或任何东西，我们一旦有了CLI，为什么还要添加另一个

01:45:54.740 --> 01:46:02.030
重要的是，hvap必须符合CLI的要求，抱歉，如果我们

01:46:02.030 --> 01:46:10.760
只是添加另一个，可能不是，现在没有HTTP内容

01:46:10.760 --> 01:46:22.100
对于lepida P是的，这会让我们无法让人

01:46:22.100 --> 01:46:27.830
P的每个实现都必须写一个恶魔，但是我们可以问什么

01:46:27.830 --> 01:46:33.230
他们要做的就是写一个哇，他们最终会写像

01:46:33.230 --> 01:46:38.630
恶魔，但它可以在UNIX套接字上工作，或者最终我们可以进行类似的工作

01:46:38.630 --> 01:46:43.490
将不得不暴露测试可以正确调用的内容-不会是

01:46:43.490 --> 01:46:48.860
HTTP API权限以及多种格式下的权限都需要读取相同的权限，例如

01:46:48.860 --> 01:46:53.900
多哈希需要具有可测试和调用的I API或类似Windows的CLI

01:46:53.900 --> 01:46:58.820
简单的CLI符合跨语言的相同标准，但是如果有人

01:46:58.820 --> 01:47:03.350
想要将实时p2p供应商到他们自己的代码中，像这样会把它旋转起来

01:47:03.350 --> 01:47:08.900
不会排雷，所以我们在其中看到的恶魔将与ksi PFS所做的相同

01:47:08.900 --> 01:47:13.910
今天是CLI，是韩语排列

01:47:13.910 --> 01:47:17.720
以编程方式或您的执行看不到什么，CLI可以做什么

01:47:17.720 --> 01:47:22.280
只是像命令一样映射到核心实现，我来了

01:47:22.280 --> 01:47:36.050
您可以做的很好，CLI没什么，只能翻译，是的，我只是

01:47:36.050 --> 01:47:39.920
支付了几个月的费用，并将它们传递给绒毛膜的正确方式

01:47:39.920 --> 01:47:50.210
排列好吧，我想杰里米（Jeremy）看到了

01:47:50.210 --> 01:47:53.350
能够定义事物

01:47:53.510 --> 01:48:03.040
跨语言上帝我的上帝在哪里

01:48:05.229 --> 01:48:30.699
什么不做什么，但ER PC在哪里？那不是我们，我认为

01:48:30.699 --> 01:48:37.360
你我觉得你很酷微软我觉得你可能有个麦克风我的意思是

01:48:37.360 --> 01:48:43.959
我知道您在Google工作了一段时间，因为您做得很好，所以离开了

01:48:43.959 --> 01:48:55.150
记录发生了什么材料的材料设计，这是什么

01:48:55.150 --> 01:49:04.840
是T RPC Google或PC吗？很多人都这样称呼它，但事实并非如此

01:49:04.840 --> 01:49:12.239
是通用RPC还是什么，是的，我们很接近

01:49:13.349 --> 01:49:23.110
是的，我们在这里做到了，是的，所以这是港口的标准方式

01:49:23.110 --> 01:49:29.949
就像在说杰夫是他曾经是世界内部protobuf的一部分

01:49:29.949 --> 01:49:36.039
我认为杰里的派对与之类似，但被称为“粗短”，但这实际上是有效的

01:49:36.039 --> 01:49:40.420
以及我们正在讨论的IDL会生成什么，您可以使用它

01:49:40.420 --> 01:49:47.739
生成存根，测试和RPC之类的东西，等等，它们只是内置的

01:49:47.739 --> 01:49:53.409
舒适，所以我的意思是，这就像顶层顶层一样

01:49:53.409 --> 01:49:59.800
界面对，是有用的，所以这定义了顶层

01:49:59.800 --> 01:50:04.630
界面会为您生成存根，然后您可以使用它生成所有

01:50:04.630 --> 01:50:09.579
HTTP服务器以及类似命令行的客户端以及所有类似的东西

01:50:09.579 --> 01:50:15.670
可以让我们看看是否需要将该服务器将其映射到您的核心吗，所以我们

01:50:15.670 --> 01:50:21.130
命令库等等，就像它可以做什么的一部分

01:50:21.130 --> 01:50:27.070
是的，我认为这对我们有点像轻松的部分，但没有帮助

01:50:27.070 --> 01:50:32.440
我们遇到了一些困难的部分，例如将接口映射到每个中的核心

01:50:32.440 --> 01:50:40.240
语言是的，例如，它的语言是

01:50:40.240 --> 01:50:52.390
进行突变是的，例如，您如何在其中进行回调，就像

01:50:52.390 --> 01:50:59.200
在每一行中都实现了，是的，所以您仍然可以

01:50:59.200 --> 01:51:03.010
惯用界面，然后您仍然会有惯用语的映射

01:51:03.010 --> 01:51:12.940
界面，因为我看到GS信誉出现在如何执行方面

01:51:12.940 --> 01:51:20.050
您有不同的获胜者，而现在我们有版本10和

01:51:20.050 --> 01:51:27.340
我不知道体育场阁楼上有听赛车比赛的权利

01:51:27.340 --> 01:51:31.690
是的，您知道频道，你们是否彼此之间互相了解哦，是的，但是

01:51:31.690 --> 01:51:36.580
定义一个通用的编程接口是没有意义的

01:51:36.580 --> 01:51:41.230
因为不熟悉音符的人看起来像这样，那是什么

01:51:41.230 --> 01:51:45.640
我做得不好，是的，这很不错，也许我们

01:51:45.640 --> 01:51:50.830
错误和思考，我们需要为所有实现定义一个接口

01:51:50.830 --> 01:51:55.180
我不知道像看到我的声音一样，我的手机应该作为您的手机的接口

01:51:55.180 --> 01:51:59.790
很好，但是与测试用例不同，它们可以用

01:51:59.790 --> 01:52:04.180
JavaScript或其他任何东西，然后它们调用我们在

01:52:04.180 --> 01:52:08.590
核心实现，我认为这足以断言

01:52:08.590 --> 01:52:14.380
核心实现我不知道所有实现都应该

01:52:14.380 --> 01:52:22.210
实施一个HTTP接口，例如，为什么不为什么我们需要像多个

01:52:22.210 --> 01:52:30.160
好吧，我们要确保恶魔在

01:52:30.160 --> 01:52:32.830
与我们保持一致，所以我们现在就住在我身边，

01:52:32.830 --> 01:52:35.830
没有它，所以我们是否不打算为自由创建恶魔

01:52:35.830 --> 01:52:42.690
是的，只有图书馆才能使用这种结构，我们不得不

01:52:42.690 --> 01:52:48.790
使每个实现都将其接口映射到HTTP，而不是将其映射到HTTP

01:52:48.790 --> 01:52:52.480
他们将不得不做两件事，一是将其实现映射到

01:52:52.480 --> 01:52:56.440
标准的制作方式，然后将制作方式的中心方式映射到高清

01:52:56.440 --> 01:53:03.070
每种语言，所以这暗示着这些简单

01:53:03.070 --> 01:53:06.760
函数，然后将您惯用的东西映射到此，然后由它处理

01:53:06.760 --> 01:53:11.170
所有其余的东西，例如从此转换为具有

01:53:11.170 --> 01:53:16.750
通过HTTP或其他任何您想做的RPC事情，它完成了所有繁重的工作

01:53:16.750 --> 01:53:23.740
反正为你举重，我们将不得不骑自行车分享这件事现在可以弄清楚

01:53:23.740 --> 01:53:46.240
明天我认为映射可能会很小我认为映射可能会很小

01:53:46.240 --> 01:53:50.170
一个少于一百行的文件，所以我认为不是

01:53:50.170 --> 01:53:54.370
有很多问题要问，您发现这是所有其他部分的工作方式

01:53:54.370 --> 01:53:58.870
如果我们有该映射关系，我们能否做到这一点，就可以

01:53:58.870 --> 01:54:03.790
如果我们做不到，那么就可靠地测试所有东西，那我们就不应该探索

01:54:03.790 --> 01:54:08.920
这是非常可能的，但是想要使用盖子的程序员

01:54:08.920 --> 01:54:13.750
p2p并进入，这是一个go程序员，看到了

01:54:13.750 --> 01:54:17.800
事件，而不是像传递频道那样，就像您知道自己惯用的

01:54:17.800 --> 01:54:21.040
像这样，他们会变得像这样，我没有任何意义

01:54:21.040 --> 01:54:27.520
基本上要燃烧你说的话，是的，是的，我喜欢我看到的好处

01:54:27.520 --> 01:54:30.850
标准化测试，但我从程序员的角度

01:54:30.850 --> 01:54:35.290
想要您的意见，让我们做供应商Inlet p2p不仅将其用作守护程序，是的

01:54:35.290 --> 01:54:38.410
我不是在建议摆脱惯用界面，而是要说怎么做

01:54:38.410 --> 01:54:43.630
您确实知道先知道的事，然后为了进行测试，我们将

01:54:43.630 --> 01:54:48.800
惯用的接口，可以在测试箱中正常进行，仅用于测试

01:54:48.800 --> 01:54:56.030
好的，好的，我很好，它正在对其进行测试并测试其完整性，因为

01:54:56.030 --> 01:54:59.479
测试测试将检查它是否正确，并且还会检查您

01:54:59.479 --> 01:55:03.169
定义了所有功能，如果您缺少某些功能，就不会

01:55:03.169 --> 01:55:07.340
是的，通过了一些小测试，所以它真的可以检查并确保您拥有所有

01:55:07.340 --> 01:56:01.639
功能，因此，如果我们确实有此功能，那么我们可以编写测试

01:56:01.639 --> 01:56:08.860
理论上的

01:56:09.959 --> 01:56:33.940
听起来不错，我们回到像现在这样向我们展示了一些基本知识

01:56:33.940 --> 01:56:41.610
我认为目前需要在某个地方进行HTTP测试的地方也要提取到自己的记录中

01:56:42.630 --> 01:57:02.320
是的，但是我们是从那里来的，所以我们就像在写我拥有的这个文件

01:57:02.320 --> 01:57:07.409
我们所说的一切都是其中的大部分，再加上

01:57:07.409 --> 01:57:21.039
但是所有的网络都来自我的电脑，我只是

01:57:21.039 --> 01:57:31.389
将您的计算机设备带到某个地方是的，这不是整个事情，不是吗？

01:57:31.389 --> 01:57:38.590
只是在某个地方不，因为我不想放一些Pippy问题，因为他们不想

01:57:38.590 --> 01:57:43.119
然后立即成为像现在这样的因素，另一件事可能会引起混淆

01:57:43.119 --> 01:57:46.300
人，所以我想和超级人一起去做正确的事

01:57:46.300 --> 01:58:03.849
加载到上下文中，然后像将其推出一样，您就知道这点

01:58:03.849 --> 01:58:08.949
污染了整个录音，现在我们不得不不想表现出任何出色的表现

01:58:08.949 --> 01:58:16.499
想表明是的，我很认真

01:58:19.220 --> 01:58:30.390
很酷，我可以，让我们首先介绍一下他们除草并计算出的所有唱片之星的东西

01:58:30.390 --> 01:58:38.220
不管是否确定他们进口了我填满了这些东西，这真的很好

01:58:38.220 --> 01:58:44.940
如果它是出于多种原因，但它却集结在一个充满东西的世界中，因此

01:58:44.940 --> 01:58:52.830
关于p2p的工作原理，我还有其他问题要紧着急

01:58:52.830 --> 01:59:05.760
现在是专家，您可以给他们下一个话题吗，是的，忘记了那些界面

01:59:05.760 --> 01:59:09.240
然后就走了，就像轻松摘下蓝牙一样，真的很棒

01:59:09.240 --> 01:59:16.040
实施，然后实施诸如发现之类的所有事情

01:59:19.970 --> 01:59:23.120
知道什么

01:59:47.720 --> 02:00:03.720
新的他是什么在顶部的所有这些是的，但我认为我们需要得到

02:00:03.720 --> 02:00:17.640
这些都是我想，这就是人们发现它更容易喜欢的原因

02:00:17.640 --> 02:01:07.110
阅读JavaScript项目并理解，因为我知道我想要

02:01:07.110 --> 02:01:13.110
人们必须用骰子阅读数百行才能理解这些

02:01:13.110 --> 02:01:15.470
介面

02:01:18.530 --> 02:01:58.370
就像只要一切，并确保它打在我们身上，他们就与我们同在，但是

02:01:58.370 --> 02:02:09.110
您手动添加所有权限，我可能需要续订，我们应该继续

02:02:09.110 --> 02:02:14.000
到地方和东西，因为这种方式比城镇更容易阅读

02:02:14.000 --> 02:02:29.150
这样的标题，您会直接看到，就像我的意思是，您认为那个吗？

02:02:29.150 --> 02:02:47.630
认为这就像一个很好的摘要，缺少什么对不起，我不是说像

02:02:47.630 --> 02:02:51.080
像每一个这样的医生都会想要像评论一样的大文件

02:02:51.080 --> 02:02:54.800
解释它是如何工作的，您已经了解了go代码是如何记录的

02:02:54.800 --> 02:03:02.470
是的，但不仅如此

02:03:16.630 --> 02:03:21.470
大多数情况下，代码是不需要我们清空的

02:03:21.470 --> 02:03:26.320
同意它，并以此作为我们的规格

02:03:29.350 --> 02:03:44.270
是的，然后您可以创建教程以及各种惯用的内容

02:03:44.270 --> 02:03:50.420
在您看来这是怎么回事Matic例如要回来

02:03:50.420 --> 02:04:02.870
大概我的传递就像协同例程还是机器人一样，就像调用一样

02:04:02.870 --> 02:04:38.410
约定错误，是的，返回多个事物一个小时就可以看到

02:04:38.410 --> 02:04:42.800
我们在没有类型的语言中有一个很大的不同，那就是

02:04:42.800 --> 02:04:52.610
可以的类型的语言，我们可以做到，但我无法检查自己是否可以使用该语言

02:04:52.610 --> 02:04:58.580
再次检查一下，我们可以在缓存中更简洁地表达这一点，因为

02:04:58.580 --> 02:05:01.820
以及详细的描述，因为有两个不同的地方

02:05:01.820 --> 02:05:05.780
这里的事情，我们希望编译器检查可以正常工作的东西

02:05:05.780 --> 02:05:10.010
是的，但故事的另一面是人们

02:05:10.010 --> 02:05:15.980
想要了解为什么或为什么将其映射到JavaScript

02:05:15.980 --> 02:05:19.010
实现会有自己的习惯用法

02:05:19.010 --> 02:05:22.579
通知，并且应该将JavaScript威吓记录在案，因此您应该

02:05:22.579 --> 02:05:26.900
能够查看JavaScript权限，并且只能读取且仅

02:05:26.900 --> 02:05:42.710
现在，我认为使用Lipton的用户如果使用某种语言，就会读懂

02:05:42.710 --> 02:05:48.230
该语言的文档，在新的版本中实现了合法性

02:05:48.230 --> 02:05:54.110
语言应先读取，然后再从中读取一个文件，该文件将所有

02:05:54.110 --> 02:06:10.760
像进行映射这样编写所必需的上下文甚至都不是东西

02:06:10.760 --> 02:06:13.909
这将进入政府将要实施的实施中

02:06:13.909 --> 02:06:16.659
还有很多其他的东西

02:06:37.350 --> 02:06:40.419
[音乐]

02:06:43.920 --> 02:06:46.920
所以

02:06:46.940 --> 02:06:53.199
但我想我要问的是我们需要这些类型吗

02:06:53.199 --> 02:07:02.139
PID纯信息多加法器，所以我想让我加入

02:07:09.360 --> 02:07:15.440
[音乐]是的，这仅仅是因为我们正在使用

02:07:15.440 --> 02:07:20.630
现在，如果我们使用其他东西作为理想，我们将成为理想，

02:07:20.630 --> 02:07:35.389
不会写我们引用那个确切的东西，是的，因为如果这是

02:07:35.389 --> 02:07:47.050
JavaScript我们会说是的，所以在JavaScript中，您就像JavaScript一样

02:07:47.050 --> 02:08:18.830
回调版本，然后更深入地观察，并希望您对piotr skarga感到疼痛

02:08:18.830 --> 02:08:27.560
内容发现纯路由器内容作家我想我们需要的节点

02:08:27.560 --> 02:08:31.030
加密，我们需要钥匙

02:08:38.369 --> 02:09:08.010
是的，对，这是一种习惯用法，我们可以摆脱的想法

02:09:08.010 --> 02:09:12.449
我们现在应该使用go，就像有人反对使用go作为界面一样

02:09:12.449 --> 02:09:20.790
在这里定义语言辩论，我只想提及，还有

02:09:20.790 --> 02:09:29.190
来自Mozilla的IDL，它似乎已迁移到C ++和JavaScript，这可能

02:09:29.190 --> 02:09:42.030
成为我们所需要的，就像知道它有多好一样，但是就像他们提到它们一样

02:09:42.030 --> 02:10:06.679
有C ID的人，哦，真的，它用于Firefox OS，不，不，哦，天哪

02:10:06.679 --> 02:10:34.190
你是认真的吗，我的意思是那些应该像鼓舞人心的想法的例子应该是

02:10:34.190 --> 02:10:37.790
是的，这只是

02:10:45.570 --> 02:10:49.740
我想那是一个不止一个的转折

02:10:55.350 --> 02:11:04.980
认为这比回调更惯用

02:11:11.940 --> 02:11:16.930
基本上感谢浏览器中的C ++方面，因为它错过了API

02:11:16.930 --> 02:11:19.930
 JavaScript端，但当然浏览器需要实现另一端

02:11:19.930 --> 02:11:25.750
无论如何，在C ++中我只是想提出它，以防万一您意识到它，但是

02:11:25.750 --> 02:11:33.370
就像这是一个很好的介绍性基础，还有其他理想，所以我们

02:11:33.370 --> 02:11:42.370
还应该看看我提到的唯一原因或我们降落的唯一原因

02:11:42.370 --> 02:11:48.780
走，是因为这真的很简单不是没有其他原因

02:12:02.820 --> 02:12:22.990
不，这是不同的，这是不同的语义，我们还记得吗

02:12:22.990 --> 02:12:30.490
是显式的传出连接，我正在告诉我正在告诉

02:12:30.490 --> 02:12:35.290
我明确要打出拨出电话的接口，所以

02:12:35.290 --> 02:12:41.740
这意味着进行一些设置并执行拨号操作，侦听是对称的

02:12:41.740 --> 02:12:46.150
等效于进行一些设置，我将等待连接，

02:12:46.150 --> 02:12:53.170
然后准备接受连接在这里实际上是模棱两可的，

02:12:53.170 --> 02:13:01.060
说我不在乎您是怎么做的，无论您是拨出还是收听只是连接

02:13:01.060 --> 02:13:05.700
到此对等端（如果您已经有连接）

02:13:05.700 --> 02:13:16.950
它会立即返回，因此，如果我们拨打此拨盘，将会引起混乱

02:13:20.100 --> 02:13:34.930
是的，您拨打所连接的地址会出现，这绝对是一个

02:13:34.930 --> 02:13:44.050
自行车棚值得，就像我想公开一个不

02:13:44.050 --> 02:13:46.630
拥有所有类似的连接东西

02:13:46.630 --> 02:13:52.380
如果我们能够做到这一点，我将感到非常高兴，但我不知道我们可以

02:13:57.380 --> 02:15:02.700
我们应该特别是协议，例如，怎么办

02:15:02.700 --> 02:15:06.380
人们想写协议，而我们有一个实现

02:15:06.380 --> 02:15:15.390
这是仿照HTTP服务器建模的，特别是它不是

02:15:15.390 --> 02:15:17.850
必定是实现它的最佳方法，实际上是要服务并继续前进，

02:15:17.850 --> 02:15:22.980
 JavaScript回调，因此它不一定是面向回调的

02:15:22.980 --> 02:15:36.510
最好的一个，不是，我的意思是这个男人协议的东西起作用的方式是

02:15:36.510 --> 02:15:41.640
使用回调作为一种方式来获取我的协议并挂载它可能不会

02:15:41.640 --> 02:15:57.090
最好的东西是的，不，不，不好，要搭配高性能的东西

02:15:57.090 --> 02:16:03.470
您不希望使用渠道，因为如果它们实际上非常昂贵

02:16:03.470 --> 02:16:08.640
不幸的是去渠道是相当昂贵的脂质版本之一

02:16:08.640 --> 02:16:13.020
意见是与渠道有关，我们将带一个小包

02:16:13.020 --> 02:16:17.219
像这样，所有的一切都始于尝试使它成为一开始的数据包。

02:16:17.219 --> 02:16:22.980
然后我们拿一个小包并通过渠道发送它，依此类推

02:16:22.980 --> 02:16:29.400
然后将数据包正常传送到协议中

02:16:29.400 --> 02:16:34.380
惯用的东西，实在太慢了，太可怕了

02:16:34.380 --> 02:16:39.929
顺便说一句，又是流怪物的天皇也做了同样的事情

02:16:39.929 --> 02:16:44.670
而且那个人都是惯用的，我们大约在同一时间做了

02:16:44.670 --> 02:16:48.650
就像完全放弃了它一样，另一种是因为渠道是

02:16:48.650 --> 02:16:55.410
出奇的昂贵，但要点是使并发就像在

02:16:55.410 --> 02:17:03.630
我不知道我不知道是错的代价，但我认为

02:17:03.630 --> 02:17:10.260
他们可能不满意频道的实际价格

02:17:10.260 --> 02:17:14.250
他们本来希望它足够好，以至于我们可以

02:17:14.250 --> 02:17:18.150
用这种方式在实现时将其写成通道，但在这种情况下，

02:17:18.150 --> 02:17:24.960
太糟糕了以至于它不是真实的，所以我的意思是也许我们应该多放些

02:17:24.960 --> 02:17:29.910
努力提高我们的高性能，我他们离开了他们，但是的，我们的高水平

02:17:29.910 --> 02:17:37.800
表现拉斯，我的意思是我不知道那只是在安排时间

02:17:37.800 --> 02:17:42.389
知道我们对性能的要求超出了将来的范围

02:17:42.389 --> 02:17:49.800
因为那不是他们的目标，我的意思是我不知道他们去那

02:17:49.800 --> 02:18:00.090
没有狗窝的运行时间实际上要慢得多，这将是一个很好的问题

02:18:00.090 --> 02:18:04.580
弄清楚，就像我们跟踪基准测试一样，看看它们是如何工作的

02:18:10.400 --> 02:18:21.390
并测量之间的力量目前尚不可行，但我们应该拥有

02:18:21.390 --> 02:18:36.719
我们不，我们不是从um开始的，也许是的，

02:18:36.719 --> 02:18:40.620
在C数量级内的大多数事物，而在大多数情况下，我是

02:18:40.620 --> 02:18:49.590
也不会让大多数受IO约束的事情变得不正常

02:18:49.590 --> 02:18:57.060
我认为当您有很多函数调用并且您在

02:18:57.060 --> 02:19:00.620
像goroutine堆栈一样进行操作，并有可能从例程中切换

02:19:00.620 --> 02:19:08.640
但是，如果您要处理io，它可能会很接近，我们应该对其进行基准测试

02:19:08.640 --> 02:19:13.850
看看进展如何，是的，我想到了我们要放到哪里

02:19:13.850 --> 02:19:17.910
如果我们希望将其放置在路由器中，例如在实际的类似网络中

02:19:17.910 --> 02:19:25.850
路由器将必须生锈是的，没人会承认GC是的，我同意。

02:19:32.549 --> 02:19:39.799
 [笑声]

02:19:42.560 --> 02:19:48.240
谈论其弹出的接口不应该在这里

02:19:48.240 --> 02:19:53.120
应该在这里

02:19:53.250 --> 02:20:12.479
是他们该死的振动，谢谢你，整天困扰着我

02:20:12.479 --> 02:20:18.180
搜索是否喜欢循环运行以喜欢得到下一个单词

02:20:18.180 --> 02:20:22.640
是的，所以这显然是一种不同的方式，然后

02:20:22.640 --> 02:20:36.140
处理程序回调，因为我想看看看起来像是

02:20:44.830 --> 02:20:52.550
这是像水泥一样的坚果类零件首先是USB螺母遍历谢谢

02:20:52.550 --> 02:21:00.050
克里斯，我认为这将是一个具体的潜在因素，他们会像您一样

02:21:00.050 --> 02:21:06.850
您编写了一种自然感知的特殊传输，但是随后尝试

02:21:06.850 --> 02:21:10.819
使连接发生，因为有一堆不同的NAT遍历

02:21:10.819 --> 02:21:16.729
策略是的，但这就是潜在的巨大卖点

02:21:16.729 --> 02:21:20.239
库，然后我们拥有所有自然的通用策略

02:21:20.239 --> 02:21:22.640
我们会像这样正确地一步一步地尝试

02:21:22.640 --> 02:21:26.270
是的，我们有任何交通工具可以做到吗？您说我们有一个

02:21:26.270 --> 02:21:33.140
几个自然的事物之一就是像UPnP和NAT PMP这样的琐碎事物

02:21:33.140 --> 02:21:40.689
就像要求好的路由器打开端口一样，我们有一个

02:21:40.689 --> 02:21:50.270
在TCP最初设计的地方，您可以发送和发送邮件确实很痛苦

02:21:50.270 --> 02:21:55.640
从同一个端口接收，如果您这样做，并且您正在处理的垫子

02:21:55.640 --> 02:22:01.310
它不是完全对称的，那么当您拨出几次后，您可以

02:22:01.310 --> 02:22:06.529
接收到您可以从外面观察相同的地址，然后您知道

02:22:06.529 --> 02:22:09.859
您在垫子外面的地址是这样，这样人们就可以拨打您的电话，这就是

02:22:09.859 --> 02:22:15.979
打孔的工作原理如此，好吧，我们确实像懒人打孔那样，当您拨号时

02:22:15.979 --> 02:22:21.890
你要打孔哦，这只是这个观点的怪癖

02:22:21.890 --> 02:22:25.460
您知道的路由器就是这样工作的

02:22:25.460 --> 02:22:34.250
好吧好吧，一直以来都在努力工作，因为网络堆栈不允许

02:22:34.250 --> 02:22:40.630
您要重用同一端口，实际上它不允许您在TCP上进行绑定

02:22:40.630 --> 02:22:48.140
传出端口（如果该端口已绑定到侦听器，但内核允许您执行此操作）

02:22:48.140 --> 02:22:53.170
这样，因此您必须像在此调用标志处那样设置一个内核标志，并且

02:22:53.170 --> 02:23:00.051
目前，有一个令人讨厌的模块，

02:23:00.051 --> 02:23:04.000
存在处理语言限制哦

02:23:04.480 --> 02:23:11.240
哦，是的，总是在分叉语言和保持语言之间

02:23:11.240 --> 02:23:14.450
修补语言，就像是下载最新版本的语言

02:23:14.450 --> 02:23:21.971
应用补丁，然后运行它，并说服他们改变主意，

02:23:21.971 --> 02:23:25.820
写那个模块，所以我们写那个模块，因为那是最便宜的

02:23:25.820 --> 02:23:34.881
版本，但还没有结束，是的，是的，是的，我认为

02:23:34.881 --> 02:23:39.740
我们正在做的那种复杂的东西感觉不像是阅读语言

02:23:39.740 --> 02:23:44.240
但是我知道这非常受欢迎，我们将在下游失去很多

02:23:44.240 --> 02:23:48.440
潜在的下游开发人员（如果我们不支持的话），这是一个真正的权衡

02:23:48.440 --> 02:23:53.811
就像是的，我的意思是我真的认为您应该知道，Russ应该

02:23:53.811 --> 02:23:59.540
是的，对他们俩来说都是这样，好吧，Jess，我们需要在浏览器中使用Brett

02:23:59.540 --> 02:24:03.980
是的，是的，这很容易，我认为尽管组装得当，我们可以拥有

02:24:03.980 --> 02:24:11.061
贾斯去吧，生锈的兄弟们来了哦，你想看到一些东西

02:24:11.061 --> 02:24:18.351
总是很棒的webassembly，我们会停止开发Jess，而只是做

02:24:18.351 --> 02:24:23.421
铁锈和目标浏览器中的所有内容都是一个编译器，很好，我的意思是

02:24:23.421 --> 02:24:26.330
是疯了还是对，这完全合法

02:24:26.330 --> 02:24:34.730
我的意思是我认为我们将为浏览器提供特定的传输方式

02:24:34.730 --> 02:24:37.011
点，例如，像Web RTC

02:24:37.011 --> 02:24:40.940
只能使用密码yeah，而Mike则完成了其他一些操作

02:24:40.940 --> 02:24:45.500
所以也许我们会像基地一样使用，然后炸毁不同的东西，

02:24:45.500 --> 02:24:50.591
那些可以写的，那些可以手写的JavaScript

02:24:50.591 --> 02:25:00.189
休息或球之类的东西是在这里读不需要检查

02:25:00.189 --> 02:25:09.799
这不是很好的宝石，所以这里有一个主要的点html'

02:25:09.799 --> 02:25:18.409
在点斜线中，斜线是mange，而点斜线法师是，法师在这里定义了问候

02:25:18.409 --> 02:25:23.889
等于没有绑定年轻，然后调用它具有一个名为run app的功能

02:25:23.889 --> 02:25:31.699
这叫打招呼，然后它没有绑定仁的东西然后运行

02:25:31.699 --> 02:25:38.270
应用程序，因此它调用的不是绑定Jen，Jen是在某处导入的函数，然后

02:25:38.270 --> 02:25:47.629
之后，调用运行应用程序就可以了，所以在这里我有一个Lib点RS，所以在这里我

02:25:47.629 --> 02:25:57.109
做一些很棒的绑定Jen的东西，然后我发出一个警报函数，然后我

02:25:57.109 --> 02:26:05.689
定义greet函数，然后从greet调用alert，这样我就可以构建

02:26:05.689 --> 02:26:17.329
这和我建造的主要道奇在这里，有很多类似的东西

02:26:17.329 --> 02:26:24.439
出口打招呼等等，大概就像我运行应用程序的某个地方

02:26:24.439 --> 02:26:37.140
在这里叫希腊语，是的，也许您已经以某种方式编译了哦，我

02:26:37.140 --> 02:26:43.890
在4039哪里做些希腊文哦，是的，在这里

02:26:43.890 --> 02:26:51.660
是的，这是问候的JavaScript版本，就像是怀疑

02:26:51.660 --> 02:26:57.930
je s字符串并将其变成不是字符串，然后将其调用为

02:26:57.930 --> 02:27:05.850
然后打电话来的不是希腊人，所以这是一堆很棒的东西，是的，哦，是的

02:27:05.850 --> 02:27:11.070
您可以看到非常重要的操作，然后您就可以拥有

02:27:11.070 --> 02:27:16.890
令人惊叹的幻灯片，您知道音乐编号在哪里

02:27:16.890 --> 02:27:30.260
很长很长的时间哇，是的，我知道我在跟罗利开玩笑，

02:27:30.260 --> 02:27:38.160
然后我们运行它和我的世界，你可以休息一下，就像哦，你知道什么

02:27:38.160 --> 02:27:42.530
我想确保这是合法的

02:27:55.240 --> 02:27:59.610
保存构建

02:28:07.561 --> 02:28:19.811
谢谢，是的，所以这很甜蜜，是的，我的意思是所有对象都生锈了

02:28:19.811 --> 02:28:25.210
将在浏览器中显示的内容说我的天哪，我的意思是他们已经展示了

02:28:25.210 --> 02:28:35.500
好的，让我们向您展示从一个函数调用到另一个函数有多么容易

02:28:35.500 --> 02:28:40.420
另一个像这样的调用是用J s字符串打招呼，然后在这里

02:28:40.420 --> 02:29:24.610
为什么会因为对本机功能大喊大叫而感到沮丧

02:29:24.610 --> 02:29:35.680
为什么有人认为这很有用，这需要像外国人一样

02:29:35.680 --> 02:29:40.570
可以像调用力量一样在负鼠中调用浏览器

02:29:40.570 --> 02:29:57.510
是的，但是网络组装人员想要做的是在您创建的衬衫上

02:29:58.561 --> 02:30:05.730
是的，从环境来看，这将是一个网络功能，但是

02:30:05.730 --> 02:30:10.070
目前没有火，没有权利，这是你必须注入的

02:30:10.070 --> 02:30:21.070
这就是为什么我们可以生成它的原因，如果我们手动生成所有内容，

02:30:21.070 --> 02:30:24.160
 [音乐]

02:30:25.580 --> 02:30:30.891
我们只是没有做，因为它不统一

02:30:35.730 --> 02:30:41.311
Mozilla hack喜欢很多糖果文章

02:30:41.311 --> 02:30:47.790
是的，也不会再拖入CNC展位巴士了

02:30:47.790 --> 02:30:59.320
可能还有其他事情哦，所以这个网站就是整个网站

02:30:59.320 --> 02:31:06.101
只是演示并没有发现您一直都知道这就像呃这是一颗宝石，所以

02:31:06.101 --> 02:31:20.160
那种普通的IDE，是的，空的是什么项目，哦，我不知道

02:31:22.170 --> 02:31:33.149
哦，也许它一直都在做benjin也许，是的，也许这是好的，这是什么

02:31:33.149 --> 02:31:41.729
哦，我明白了，哦，实际的webassembly只是

02:31:41.729 --> 02:31:46.580
一些二进制格式或仅此而已

02:31:49.790 --> 02:31:54.290
好的，我们必须看

